package main

import unsafe "unsafe"

var sqlite3_version [7]int8 = [7]int8{'3', '.', '3', '8', '.', '2', '\x00'}

type sqlite3 = struct_sqlite3
type sqlite_int64 = int64
type sqlite_uint64 = uint64
type sqlite3_int64 = int64
type sqlite3_uint64 = uint64
type sqlite3_callback = func(unsafe.Pointer, int32, **int8, **int8) int32
type sqlite3_file = struct_sqlite3_file
type struct_sqlite3_file struct {
	pMethods *struct_sqlite3_io_methods
}
type sqlite3_io_methods = struct_sqlite3_io_methods
type struct_sqlite3_io_methods struct {
	iVersion               int32
	xClose                 func(*struct_sqlite3_file) int32
	xRead                  func(*struct_sqlite3_file, unsafe.Pointer, int32, int64) int32
	xWrite                 func(*struct_sqlite3_file, unsafe.Pointer, int32, int64) int32
	xTruncate              func(*struct_sqlite3_file, int64) int32
	xSync                  func(*struct_sqlite3_file, int32) int32
	xFileSize              func(*struct_sqlite3_file, *int64) int32
	xLock                  func(*struct_sqlite3_file, int32) int32
	xUnlock                func(*struct_sqlite3_file, int32) int32
	xCheckReservedLock     func(*struct_sqlite3_file, *int32) int32
	xFileControl           func(*struct_sqlite3_file, int32, unsafe.Pointer) int32
	xSectorSize            func(*struct_sqlite3_file) int32
	xDeviceCharacteristics func(*struct_sqlite3_file) int32
	xShmMap                func(*struct_sqlite3_file, int32, int32, int32, *unsafe.Pointer) int32
	xShmLock               func(*struct_sqlite3_file, int32, int32, int32) int32
	xShmBarrier            func(*struct_sqlite3_file)
	xShmUnmap              func(*struct_sqlite3_file, int32) int32
	xFetch                 func(*struct_sqlite3_file, int64, int32, *unsafe.Pointer) int32
	xUnfetch               func(*struct_sqlite3_file, int64, unsafe.Pointer) int32
}
type sqlite3_mutex = struct_sqlite3_mutex
type sqlite3_api_routines = struct_sqlite3_api_routines
type sqlite3_vfs = struct_sqlite3_vfs
type sqlite3_syscall_ptr = func()
type struct_sqlite3_vfs struct {
	iVersion          int32
	szOsFile          int32
	mxPathname        int32
	pNext             *struct_sqlite3_vfs
	zName             *int8
	pAppData          unsafe.Pointer
	xOpen             func(*struct_sqlite3_vfs, *int8, *struct_sqlite3_file, int32, *int32) int32
	xDelete           func(*struct_sqlite3_vfs, *int8, int32) int32
	xAccess           func(*struct_sqlite3_vfs, *int8, int32, *int32) int32
	xFullPathname     func(*struct_sqlite3_vfs, *int8, int32, *int8) int32
	xDlOpen           func(*struct_sqlite3_vfs, *int8) unsafe.Pointer
	xDlError          func(*struct_sqlite3_vfs, int32, *int8)
	xDlSym            func(*struct_sqlite3_vfs, unsafe.Pointer, *int8) func()
	xDlClose          func(*struct_sqlite3_vfs, unsafe.Pointer)
	xRandomness       func(*struct_sqlite3_vfs, int32, *int8) int32
	xSleep            func(*struct_sqlite3_vfs, int32) int32
	xCurrentTime      func(*struct_sqlite3_vfs, *float64) int32
	xGetLastError     func(*struct_sqlite3_vfs, int32, *int8) int32
	xCurrentTimeInt64 func(*struct_sqlite3_vfs, *int64) int32
	xSetSystemCall    func(*struct_sqlite3_vfs, *int8, func()) int32
	xGetSystemCall    func(*struct_sqlite3_vfs, *int8) func()
	xNextSystemCall   func(*struct_sqlite3_vfs, *int8) *int8
}
type sqlite3_mem_methods = struct_sqlite3_mem_methods
type struct_sqlite3_mem_methods struct {
	xMalloc   func(int32) unsafe.Pointer
	xFree     func(unsafe.Pointer)
	xRealloc  func(unsafe.Pointer, int32) unsafe.Pointer
	xSize     func(unsafe.Pointer) int32
	xRoundup  func(int32) int32
	xInit     func(unsafe.Pointer) int32
	xShutdown func(unsafe.Pointer)
	pAppData  unsafe.Pointer
}
type sqlite3_stmt = struct_sqlite3_stmt
type sqlite3_value = struct_sqlite3_value
type sqlite3_context = struct_sqlite3_context
type sqlite3_destructor_type = func(unsafe.Pointer)




type sqlite3_vtab = struct_sqlite3_vtab
type sqlite3_index_info = struct_sqlite3_index_info
type sqlite3_vtab_cursor = struct_sqlite3_vtab_cursor
type sqlite3_module = struct_sqlite3_module
type struct_sqlite3_module struct {
	iVersion      int32
	xCreate       func(*struct_sqlite3, unsafe.Pointer, int32, **int8, **struct_sqlite3_vtab, **int8) int32
	xConnect      func(*struct_sqlite3, unsafe.Pointer, int32, **int8, **struct_sqlite3_vtab, **int8) int32
	xBestIndex    func(*struct_sqlite3_vtab, *struct_sqlite3_index_info) int32
	xDisconnect   func(*struct_sqlite3_vtab) int32
	xDestroy      func(*struct_sqlite3_vtab) int32
	xOpen         func(*struct_sqlite3_vtab, **struct_sqlite3_vtab_cursor) int32
	xClose        func(*struct_sqlite3_vtab_cursor) int32
	xFilter       func(*struct_sqlite3_vtab_cursor, int32, *int8, int32, **struct_sqlite3_value) int32
	xNext         func(*struct_sqlite3_vtab_cursor) int32
	xEof          func(*struct_sqlite3_vtab_cursor) int32
	xColumn       func(*struct_sqlite3_vtab_cursor, *struct_sqlite3_context, int32) int32
	xRowid        func(*struct_sqlite3_vtab_cursor, *int64) int32
	xUpdate       func(*struct_sqlite3_vtab, int32, **struct_sqlite3_value, *int64) int32
	xBegin        func(*struct_sqlite3_vtab) int32
	xSync         func(*struct_sqlite3_vtab) int32
	xCommit       func(*struct_sqlite3_vtab) int32
	xRollback     func(*struct_sqlite3_vtab) int32
	xFindFunction func(*struct_sqlite3_vtab, int32, *int8, *func(*struct_sqlite3_context, int32, **struct_sqlite3_value), *unsafe.Pointer) int32
	xRename       func(*struct_sqlite3_vtab, *int8) int32
	xSavepoint    func(*struct_sqlite3_vtab, int32) int32
	xRelease      func(*struct_sqlite3_vtab, int32) int32
	xRollbackTo   func(*struct_sqlite3_vtab, int32) int32
	xShadowName   func(*int8) int32
}
type struct_sqlite3_index_constraint struct {
	iColumn     int32
	op          uint8
	usable      uint8
	iTermOffset int32
}
type struct_sqlite3_index_orderby struct {
	iColumn int32
	desc    uint8
}
type struct_sqlite3_index_constraint_usage struct {
	argvIndex int32
	omit      uint8
}
type struct_sqlite3_index_info struct {
	nConstraint      int32
	aConstraint      *struct_sqlite3_index_constraint
	nOrderBy         int32
	aOrderBy         *struct_sqlite3_index_orderby
	aConstraintUsage *struct_sqlite3_index_constraint_usage
	idxNum           int32
	idxStr           *int8
	needToFreeIdxStr int32
	orderByConsumed  int32
	estimatedCost    float64
	estimatedRows    int64
	idxFlags         int32
	colUsed          uint64
}
type struct_sqlite3_vtab struct {
	pModule *struct_sqlite3_module
	nRef    int32
	zErrMsg *int8
}
type struct_sqlite3_vtab_cursor struct {
	pVtab *struct_sqlite3_vtab
}
type sqlite3_blob = struct_sqlite3_blob
type sqlite3_mutex_methods = struct_sqlite3_mutex_methods
type struct_sqlite3_mutex_methods struct {
	xMutexInit    func() int32
	xMutexEnd     func() int32
	xMutexAlloc   func(int32) *struct_sqlite3_mutex
	xMutexFree    func(*struct_sqlite3_mutex)
	xMutexEnter   func(*struct_sqlite3_mutex)
	xMutexTry     func(*struct_sqlite3_mutex) int32
	xMutexLeave   func(*struct_sqlite3_mutex)
	xMutexHeld    func(*struct_sqlite3_mutex) int32
	xMutexNotheld func(*struct_sqlite3_mutex) int32
}
type sqlite3_str = struct_sqlite3_str
type sqlite3_pcache = struct_sqlite3_pcache
type sqlite3_pcache_page = struct_sqlite3_pcache_page
type struct_sqlite3_pcache_page struct {
	pBuf   unsafe.Pointer
	pExtra unsafe.Pointer
}
type sqlite3_pcache_methods2 = struct_sqlite3_pcache_methods2
type struct_sqlite3_pcache_methods2 struct {
	iVersion   int32
	pArg       unsafe.Pointer
	xInit      func(unsafe.Pointer) int32
	xShutdown  func(unsafe.Pointer)
	xCreate    func(int32, int32, int32) *struct_sqlite3_pcache
	xCachesize func(*struct_sqlite3_pcache, int32)
	xPagecount func(*struct_sqlite3_pcache) int32
	xFetch     func(*struct_sqlite3_pcache, uint32, int32) *struct_sqlite3_pcache_page
	xUnpin     func(*struct_sqlite3_pcache, *struct_sqlite3_pcache_page, int32)
	xRekey     func(*struct_sqlite3_pcache, *struct_sqlite3_pcache_page, uint32, uint32)
	xTruncate  func(*struct_sqlite3_pcache, uint32)
	xDestroy   func(*struct_sqlite3_pcache)
	xShrink    func(*struct_sqlite3_pcache)
}
type sqlite3_pcache_methods = struct_sqlite3_pcache_methods
type struct_sqlite3_pcache_methods struct {
	pArg       unsafe.Pointer
	xInit      func(unsafe.Pointer) int32
	xShutdown  func(unsafe.Pointer)
	xCreate    func(int32, int32) *struct_sqlite3_pcache
	xCachesize func(*struct_sqlite3_pcache, int32)
	xPagecount func(*struct_sqlite3_pcache) int32
	xFetch     func(*struct_sqlite3_pcache, uint32, int32) unsafe.Pointer
	xUnpin     func(*struct_sqlite3_pcache, unsafe.Pointer, int32)
	xRekey     func(*struct_sqlite3_pcache, unsafe.Pointer, uint32, uint32)
	xTruncate  func(*struct_sqlite3_pcache, uint32)
	xDestroy   func(*struct_sqlite3_pcache)
}
type sqlite3_backup = struct_sqlite3_backup
type struct_sqlite3_snapshot struct {
	hidden [48]uint8
}
type sqlite3_snapshot = struct_sqlite3_snapshot
type sqlite3_rtree_geometry = struct_sqlite3_rtree_geometry
type sqlite3_rtree_query_info = struct_sqlite3_rtree_query_info
type sqlite3_rtree_dbl = float64
type struct_sqlite3_rtree_geometry struct {
	pContext unsafe.Pointer
	nParam   int32
	aParam   *float64
	pUser    unsafe.Pointer
	xDelUser func(unsafe.Pointer)
}
type struct_sqlite3_rtree_query_info struct {
	pContext      unsafe.Pointer
	nParam        int32
	aParam        *float64
	pUser         unsafe.Pointer
	xDelUser      func(unsafe.Pointer)
	aCoord        *float64
	anQueue       *uint32
	nCoord        int32
	iLevel        int32
	mxLevel       int32
	iRowid        int64
	rParentScore  float64
	eParentWithin int32
	eWithin       int32
	rScore        float64
	apSqlParam    **struct_sqlite3_value
}
type Fts5ExtensionApi = struct_Fts5ExtensionApi
type Fts5Context = struct_Fts5Context
type Fts5PhraseIter = struct_Fts5PhraseIter
type fts5_extension_function = func(*struct_Fts5ExtensionApi, *struct_Fts5Context, *struct_sqlite3_context, int32, **struct_sqlite3_value)
type struct_Fts5PhraseIter struct {
	a *uint8
	b *uint8
}
type struct_Fts5ExtensionApi struct {
	iVersion           int32
	xUserData          func(*struct_Fts5Context) unsafe.Pointer
	xColumnCount       func(*struct_Fts5Context) int32
	xRowCount          func(*struct_Fts5Context, *int64) int32
	xColumnTotalSize   func(*struct_Fts5Context, int32, *int64) int32
	xTokenize          func(*struct_Fts5Context, *int8, int32, unsafe.Pointer, func(unsafe.Pointer, int32, *int8, int32, int32, int32) int32) int32
	xPhraseCount       func(*struct_Fts5Context) int32
	xPhraseSize        func(*struct_Fts5Context, int32) int32
	xInstCount         func(*struct_Fts5Context, *int32) int32
	xInst              func(*struct_Fts5Context, int32, *int32, *int32, *int32) int32
	xRowid             func(*struct_Fts5Context) int64
	xColumnText        func(*struct_Fts5Context, int32, **int8, *int32) int32
	xColumnSize        func(*struct_Fts5Context, int32, *int32) int32
	xQueryPhrase       func(*struct_Fts5Context, int32, unsafe.Pointer, func(*struct_Fts5ExtensionApi, *struct_Fts5Context, unsafe.Pointer) int32) int32
	xSetAuxdata        func(*struct_Fts5Context, unsafe.Pointer, func(unsafe.Pointer)) int32
	xGetAuxdata        func(*struct_Fts5Context, int32) unsafe.Pointer
	xPhraseFirst       func(*struct_Fts5Context, int32, *struct_Fts5PhraseIter, *int32, *int32) int32
	xPhraseNext        func(*struct_Fts5Context, *struct_Fts5PhraseIter, *int32, *int32)
	xPhraseFirstColumn func(*struct_Fts5Context, int32, *struct_Fts5PhraseIter, *int32) int32
	xPhraseNextColumn  func(*struct_Fts5Context, *struct_Fts5PhraseIter, *int32)
}
type Fts5Tokenizer = struct_Fts5Tokenizer
type fts5_tokenizer = struct_fts5_tokenizer
type struct_fts5_tokenizer struct {
	xCreate   func(unsafe.Pointer, **int8, int32, **struct_Fts5Tokenizer) int32
	xDelete   func(*struct_Fts5Tokenizer)
	xTokenize func(*struct_Fts5Tokenizer, unsafe.Pointer, int32, *int8, int32, func(unsafe.Pointer, int32, *int8, int32, int32, int32) int32) int32
}
type fts5_api = struct_fts5_api
type struct_fts5_api struct {
	iVersion         int32
	xCreateTokenizer func(*struct_fts5_api, *int8, unsafe.Pointer, *struct_fts5_tokenizer, func(unsafe.Pointer)) int32
	xFindTokenizer   func(*struct_fts5_api, *int8, *unsafe.Pointer, *struct_fts5_tokenizer) int32
	xCreateFunction  func(*struct_fts5_api, *int8, unsafe.Pointer, func(*struct_Fts5ExtensionApi, *struct_Fts5Context, *struct_sqlite3_context, int32, **struct_sqlite3_value), func(unsafe.Pointer)) int32
}
type Hash = struct_Hash
type HashElem = struct_HashElem
type struct__ht struct {
	count uint32
	chain *struct_HashElem
}
type struct_Hash struct {
	htsize uint32
	count  uint32
	first  *struct_HashElem
	ht     *struct__ht
}
type struct_HashElem struct {
	next *struct_HashElem
	prev *struct_HashElem
	data unsafe.Pointer
	pKey *int8
}
type __int8_t = int8
type __uint8_t = uint8
type __int16_t = int16
type __uint16_t = uint16
type __int32_t = int32
type __uint32_t = uint32
type __int64_t = int64
type __uint64_t = uint64
type __darwin_intptr_t = int
type __darwin_natural_t = uint32
type __darwin_ct_rune_t = int32
type _cgoa_1 struct {
	__mbstate8 [128]int8
}
type __darwin_mbstate_t = _cgoa_1
type __darwin_ptrdiff_t = int
type __darwin_size_t = uint
type __darwin_wchar_t = int32
type __darwin_rune_t = int32
type __darwin_wint_t = int32
type __darwin_clock_t = uint
type __darwin_socklen_t = uint32
type __darwin_ssize_t = int
type __darwin_time_t = int
type __darwin_blkcnt_t = int64
type __darwin_blksize_t = int32
type __darwin_dev_t = int32
type __darwin_fsblkcnt_t = uint32
type __darwin_fsfilcnt_t = uint32
type __darwin_gid_t = uint32
type __darwin_id_t = uint32
type __darwin_ino64_t = uint64
type __darwin_ino_t = uint64
type __darwin_mach_port_name_t = uint32
type __darwin_mach_port_t = uint32
type __darwin_mode_t = uint16
type __darwin_off_t = int64
type __darwin_pid_t = int32
type __darwin_sigset_t = uint32
type __darwin_suseconds_t = int32
type __darwin_uid_t = uint32
type __darwin_useconds_t = uint32
type __darwin_uuid_t = [16]uint8
type __darwin_uuid_string_t = [37]int8
type struct___darwin_pthread_handler_rec struct {
	__routine func(unsafe.Pointer)
	__arg     unsafe.Pointer
	__next    *struct___darwin_pthread_handler_rec
}
type struct__opaque_pthread_attr_t struct {
	__sig    int
	__opaque [56]int8
}
type struct__opaque_pthread_cond_t struct {
	__sig    int
	__opaque [40]int8
}
type struct__opaque_pthread_condattr_t struct {
	__sig    int
	__opaque [8]int8
}
type struct__opaque_pthread_mutex_t struct {
	__sig    int
	__opaque [56]int8
}
type struct__opaque_pthread_mutexattr_t struct {
	__sig    int
	__opaque [8]int8
}
type struct__opaque_pthread_once_t struct {
	__sig    int
	__opaque [8]int8
}
type struct__opaque_pthread_rwlock_t struct {
	__sig    int
	__opaque [192]int8
}
type struct__opaque_pthread_rwlockattr_t struct {
	__sig    int
	__opaque [16]int8
}
type struct__opaque_pthread_t struct {
	__sig           int
	__cleanup_stack *struct___darwin_pthread_handler_rec
	__opaque        [8176]int8
}
type __darwin_pthread_attr_t = struct__opaque_pthread_attr_t
type __darwin_pthread_cond_t = struct__opaque_pthread_cond_t
type __darwin_pthread_condattr_t = struct__opaque_pthread_condattr_t
type __darwin_pthread_key_t = uint
type __darwin_pthread_mutex_t = struct__opaque_pthread_mutex_t
type __darwin_pthread_mutexattr_t = struct__opaque_pthread_mutexattr_t
type __darwin_pthread_once_t = struct__opaque_pthread_once_t
type __darwin_pthread_rwlock_t = struct__opaque_pthread_rwlock_t
type __darwin_pthread_rwlockattr_t = struct__opaque_pthread_rwlockattr_t
type __darwin_pthread_t = *struct__opaque_pthread_t
type __darwin_nl_item = int32
type __darwin_wctrans_t = int32
type __darwin_wctype_t = uint32
type int8_t = int8
type int16_t = int16
type int32_t = int32
type int64_t = int64
type u_int8_t = uint8
type u_int16_t = uint16
type u_int32_t = uint32
type u_int64_t = uint64
type register_t = int64
type intptr_t = int
type uintptr_t = uint
type user_addr_t = uint64
type user_size_t = uint64
type user_ssize_t = int64
type user_long_t = int64
type user_ulong_t = uint64
type user_time_t = int64
type user_off_t = int64
type syscall_arg_t = uint64
type size_t = uint
type fpos_t = int64
type struct___sbuf struct {
	_base *uint8
	_size int32
}
type struct___sFILE struct {
	_p       *uint8
	_r       int32
	_w       int32
	_flags   int16
	_file    int16
	_bf      struct___sbuf
	_lbfsize int32
	_cookie  unsafe.Pointer
	_close   func(unsafe.Pointer) int32
	_read    func(unsafe.Pointer, *int8, int32) int32
	_seek    func(unsafe.Pointer, int64, int32) int64
	_write   func(unsafe.Pointer, *int8, int32) int32
	_ub      struct___sbuf
	_extra   *struct___sFILEX
	_ur      int32
	_ubuf    [3]uint8
	_nbuf    [1]uint8
	_lb      struct___sbuf
	_blksize int32
	_offset  int64
}
type FILE = struct___sFILE

func __sputc(_c int32, _p *struct___sFILE) int32 {
	if func() (_cgo_ret int32) {
		_cgo_addr := &_p._w
		*_cgo_addr--
		return *_cgo_addr
	}() >= 0 || _p._w >= _p._lbfsize && int32(int8(_c)) != '\n' {
		return int32(func() (_cgo_ret uint8) {
			_cgo_addr := &*func() (_cgo_ret *uint8) {
				_cgo_addr := &_p._p
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()
			*_cgo_addr = uint8(_c)
			return *_cgo_addr
		}())
	} else {
		return __swbuf(_c, _p)
	}
}

type off_t = int64
type ssize_t = int

const (
	P_ALL  int32 = 0
	P_PID  int32 = 1
	P_PGID int32 = 2
)

type idtype_t = int32
type pid_t = int32
type id_t = uint32
type sig_atomic_t = int32
type struct___darwin_i386_thread_state struct {
	__eax    uint32
	__ebx    uint32
	__ecx    uint32
	__edx    uint32
	__edi    uint32
	__esi    uint32
	__ebp    uint32
	__esp    uint32
	__ss     uint32
	__eflags uint32
	__eip    uint32
	__cs     uint32
	__ds     uint32
	__es     uint32
	__fs     uint32
	__gs     uint32
}
type struct___darwin_fp_control struct {
	Xbf_0 uint16
}
type __darwin_fp_control_t = struct___darwin_fp_control
type struct___darwin_fp_status struct {
	Xbf_0 uint16
}
type __darwin_fp_status_t = struct___darwin_fp_status
type struct___darwin_mmst_reg struct {
	__mmst_reg  [10]int8
	__mmst_rsrv [6]int8
}
type struct___darwin_xmm_reg struct {
	__xmm_reg [16]int8
}
type struct___darwin_ymm_reg struct {
	__ymm_reg [32]int8
}
type struct___darwin_zmm_reg struct {
	__zmm_reg [64]int8
}
type struct___darwin_opmask_reg struct {
	__opmask_reg [8]int8
}
type struct___darwin_i386_float_state struct {
	__fpu_reserved  [2]int32
	__fpu_fcw       struct___darwin_fp_control
	__fpu_fsw       struct___darwin_fp_status
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct___darwin_mmst_reg
	__fpu_stmm1     struct___darwin_mmst_reg
	__fpu_stmm2     struct___darwin_mmst_reg
	__fpu_stmm3     struct___darwin_mmst_reg
	__fpu_stmm4     struct___darwin_mmst_reg
	__fpu_stmm5     struct___darwin_mmst_reg
	__fpu_stmm6     struct___darwin_mmst_reg
	__fpu_stmm7     struct___darwin_mmst_reg
	__fpu_xmm0      struct___darwin_xmm_reg
	__fpu_xmm1      struct___darwin_xmm_reg
	__fpu_xmm2      struct___darwin_xmm_reg
	__fpu_xmm3      struct___darwin_xmm_reg
	__fpu_xmm4      struct___darwin_xmm_reg
	__fpu_xmm5      struct___darwin_xmm_reg
	__fpu_xmm6      struct___darwin_xmm_reg
	__fpu_xmm7      struct___darwin_xmm_reg
	__fpu_rsrv4     [224]int8
	__fpu_reserved1 int32
}
type struct___darwin_i386_avx_state struct {
	__fpu_reserved  [2]int32
	__fpu_fcw       struct___darwin_fp_control
	__fpu_fsw       struct___darwin_fp_status
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct___darwin_mmst_reg
	__fpu_stmm1     struct___darwin_mmst_reg
	__fpu_stmm2     struct___darwin_mmst_reg
	__fpu_stmm3     struct___darwin_mmst_reg
	__fpu_stmm4     struct___darwin_mmst_reg
	__fpu_stmm5     struct___darwin_mmst_reg
	__fpu_stmm6     struct___darwin_mmst_reg
	__fpu_stmm7     struct___darwin_mmst_reg
	__fpu_xmm0      struct___darwin_xmm_reg
	__fpu_xmm1      struct___darwin_xmm_reg
	__fpu_xmm2      struct___darwin_xmm_reg
	__fpu_xmm3      struct___darwin_xmm_reg
	__fpu_xmm4      struct___darwin_xmm_reg
	__fpu_xmm5      struct___darwin_xmm_reg
	__fpu_xmm6      struct___darwin_xmm_reg
	__fpu_xmm7      struct___darwin_xmm_reg
	__fpu_rsrv4     [224]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct___darwin_xmm_reg
	__fpu_ymmh1     struct___darwin_xmm_reg
	__fpu_ymmh2     struct___darwin_xmm_reg
	__fpu_ymmh3     struct___darwin_xmm_reg
	__fpu_ymmh4     struct___darwin_xmm_reg
	__fpu_ymmh5     struct___darwin_xmm_reg
	__fpu_ymmh6     struct___darwin_xmm_reg
	__fpu_ymmh7     struct___darwin_xmm_reg
}
type struct___darwin_i386_avx512_state struct {
	__fpu_reserved  [2]int32
	__fpu_fcw       struct___darwin_fp_control
	__fpu_fsw       struct___darwin_fp_status
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct___darwin_mmst_reg
	__fpu_stmm1     struct___darwin_mmst_reg
	__fpu_stmm2     struct___darwin_mmst_reg
	__fpu_stmm3     struct___darwin_mmst_reg
	__fpu_stmm4     struct___darwin_mmst_reg
	__fpu_stmm5     struct___darwin_mmst_reg
	__fpu_stmm6     struct___darwin_mmst_reg
	__fpu_stmm7     struct___darwin_mmst_reg
	__fpu_xmm0      struct___darwin_xmm_reg
	__fpu_xmm1      struct___darwin_xmm_reg
	__fpu_xmm2      struct___darwin_xmm_reg
	__fpu_xmm3      struct___darwin_xmm_reg
	__fpu_xmm4      struct___darwin_xmm_reg
	__fpu_xmm5      struct___darwin_xmm_reg
	__fpu_xmm6      struct___darwin_xmm_reg
	__fpu_xmm7      struct___darwin_xmm_reg
	__fpu_rsrv4     [224]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct___darwin_xmm_reg
	__fpu_ymmh1     struct___darwin_xmm_reg
	__fpu_ymmh2     struct___darwin_xmm_reg
	__fpu_ymmh3     struct___darwin_xmm_reg
	__fpu_ymmh4     struct___darwin_xmm_reg
	__fpu_ymmh5     struct___darwin_xmm_reg
	__fpu_ymmh6     struct___darwin_xmm_reg
	__fpu_ymmh7     struct___darwin_xmm_reg
	__fpu_k0        struct___darwin_opmask_reg
	__fpu_k1        struct___darwin_opmask_reg
	__fpu_k2        struct___darwin_opmask_reg
	__fpu_k3        struct___darwin_opmask_reg
	__fpu_k4        struct___darwin_opmask_reg
	__fpu_k5        struct___darwin_opmask_reg
	__fpu_k6        struct___darwin_opmask_reg
	__fpu_k7        struct___darwin_opmask_reg
	__fpu_zmmh0     struct___darwin_ymm_reg
	__fpu_zmmh1     struct___darwin_ymm_reg
	__fpu_zmmh2     struct___darwin_ymm_reg
	__fpu_zmmh3     struct___darwin_ymm_reg
	__fpu_zmmh4     struct___darwin_ymm_reg
	__fpu_zmmh5     struct___darwin_ymm_reg
	__fpu_zmmh6     struct___darwin_ymm_reg
	__fpu_zmmh7     struct___darwin_ymm_reg
}
type struct___darwin_i386_exception_state struct {
	__trapno     uint16
	__cpu        uint16
	__err        uint32
	__faultvaddr uint32
}
type struct___darwin_x86_debug_state32 struct {
	__dr0 uint32
	__dr1 uint32
	__dr2 uint32
	__dr3 uint32
	__dr4 uint32
	__dr5 uint32
	__dr6 uint32
	__dr7 uint32
}
type struct___x86_instruction_state struct {
	__insn_stream_valid_bytes int32
	__insn_offset             int32
	__out_of_synch            int32
	__insn_bytes              [2380]uint8
	__insn_cacheline          [64]uint8
}
type struct___last_branch_record struct {
	__from_ip uint64
	__to_ip   uint64
	Xbf_0     uint32
}
type struct___last_branch_state struct {
	__lbr_count int32
	Xbf_0       uint32
	__lbrs      [32]struct___last_branch_record
}
type struct___x86_pagein_state struct {
	__pagein_error int32
}
type struct___darwin_x86_thread_state64 struct {
	__rax    uint64
	__rbx    uint64
	__rcx    uint64
	__rdx    uint64
	__rdi    uint64
	__rsi    uint64
	__rbp    uint64
	__rsp    uint64
	__r8     uint64
	__r9     uint64
	__r10    uint64
	__r11    uint64
	__r12    uint64
	__r13    uint64
	__r14    uint64
	__r15    uint64
	__rip    uint64
	__rflags uint64
	__cs     uint64
	__fs     uint64
	__gs     uint64
}
type struct___darwin_x86_thread_full_state64 struct {
	__ss64   struct___darwin_x86_thread_state64
	__ds     uint64
	__es     uint64
	__ss     uint64
	__gsbase uint64
}
type struct___darwin_x86_float_state64 struct {
	__fpu_reserved  [2]int32
	__fpu_fcw       struct___darwin_fp_control
	__fpu_fsw       struct___darwin_fp_status
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct___darwin_mmst_reg
	__fpu_stmm1     struct___darwin_mmst_reg
	__fpu_stmm2     struct___darwin_mmst_reg
	__fpu_stmm3     struct___darwin_mmst_reg
	__fpu_stmm4     struct___darwin_mmst_reg
	__fpu_stmm5     struct___darwin_mmst_reg
	__fpu_stmm6     struct___darwin_mmst_reg
	__fpu_stmm7     struct___darwin_mmst_reg
	__fpu_xmm0      struct___darwin_xmm_reg
	__fpu_xmm1      struct___darwin_xmm_reg
	__fpu_xmm2      struct___darwin_xmm_reg
	__fpu_xmm3      struct___darwin_xmm_reg
	__fpu_xmm4      struct___darwin_xmm_reg
	__fpu_xmm5      struct___darwin_xmm_reg
	__fpu_xmm6      struct___darwin_xmm_reg
	__fpu_xmm7      struct___darwin_xmm_reg
	__fpu_xmm8      struct___darwin_xmm_reg
	__fpu_xmm9      struct___darwin_xmm_reg
	__fpu_xmm10     struct___darwin_xmm_reg
	__fpu_xmm11     struct___darwin_xmm_reg
	__fpu_xmm12     struct___darwin_xmm_reg
	__fpu_xmm13     struct___darwin_xmm_reg
	__fpu_xmm14     struct___darwin_xmm_reg
	__fpu_xmm15     struct___darwin_xmm_reg
	__fpu_rsrv4     [96]int8
	__fpu_reserved1 int32
}
type struct___darwin_x86_avx_state64 struct {
	__fpu_reserved  [2]int32
	__fpu_fcw       struct___darwin_fp_control
	__fpu_fsw       struct___darwin_fp_status
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct___darwin_mmst_reg
	__fpu_stmm1     struct___darwin_mmst_reg
	__fpu_stmm2     struct___darwin_mmst_reg
	__fpu_stmm3     struct___darwin_mmst_reg
	__fpu_stmm4     struct___darwin_mmst_reg
	__fpu_stmm5     struct___darwin_mmst_reg
	__fpu_stmm6     struct___darwin_mmst_reg
	__fpu_stmm7     struct___darwin_mmst_reg
	__fpu_xmm0      struct___darwin_xmm_reg
	__fpu_xmm1      struct___darwin_xmm_reg
	__fpu_xmm2      struct___darwin_xmm_reg
	__fpu_xmm3      struct___darwin_xmm_reg
	__fpu_xmm4      struct___darwin_xmm_reg
	__fpu_xmm5      struct___darwin_xmm_reg
	__fpu_xmm6      struct___darwin_xmm_reg
	__fpu_xmm7      struct___darwin_xmm_reg
	__fpu_xmm8      struct___darwin_xmm_reg
	__fpu_xmm9      struct___darwin_xmm_reg
	__fpu_xmm10     struct___darwin_xmm_reg
	__fpu_xmm11     struct___darwin_xmm_reg
	__fpu_xmm12     struct___darwin_xmm_reg
	__fpu_xmm13     struct___darwin_xmm_reg
	__fpu_xmm14     struct___darwin_xmm_reg
	__fpu_xmm15     struct___darwin_xmm_reg
	__fpu_rsrv4     [96]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct___darwin_xmm_reg
	__fpu_ymmh1     struct___darwin_xmm_reg
	__fpu_ymmh2     struct___darwin_xmm_reg
	__fpu_ymmh3     struct___darwin_xmm_reg
	__fpu_ymmh4     struct___darwin_xmm_reg
	__fpu_ymmh5     struct___darwin_xmm_reg
	__fpu_ymmh6     struct___darwin_xmm_reg
	__fpu_ymmh7     struct___darwin_xmm_reg
	__fpu_ymmh8     struct___darwin_xmm_reg
	__fpu_ymmh9     struct___darwin_xmm_reg
	__fpu_ymmh10    struct___darwin_xmm_reg
	__fpu_ymmh11    struct___darwin_xmm_reg
	__fpu_ymmh12    struct___darwin_xmm_reg
	__fpu_ymmh13    struct___darwin_xmm_reg
	__fpu_ymmh14    struct___darwin_xmm_reg
	__fpu_ymmh15    struct___darwin_xmm_reg
}
type struct___darwin_x86_avx512_state64 struct {
	__fpu_reserved  [2]int32
	__fpu_fcw       struct___darwin_fp_control
	__fpu_fsw       struct___darwin_fp_status
	__fpu_ftw       uint8
	__fpu_rsrv1     uint8
	__fpu_fop       uint16
	__fpu_ip        uint32
	__fpu_cs        uint16
	__fpu_rsrv2     uint16
	__fpu_dp        uint32
	__fpu_ds        uint16
	__fpu_rsrv3     uint16
	__fpu_mxcsr     uint32
	__fpu_mxcsrmask uint32
	__fpu_stmm0     struct___darwin_mmst_reg
	__fpu_stmm1     struct___darwin_mmst_reg
	__fpu_stmm2     struct___darwin_mmst_reg
	__fpu_stmm3     struct___darwin_mmst_reg
	__fpu_stmm4     struct___darwin_mmst_reg
	__fpu_stmm5     struct___darwin_mmst_reg
	__fpu_stmm6     struct___darwin_mmst_reg
	__fpu_stmm7     struct___darwin_mmst_reg
	__fpu_xmm0      struct___darwin_xmm_reg
	__fpu_xmm1      struct___darwin_xmm_reg
	__fpu_xmm2      struct___darwin_xmm_reg
	__fpu_xmm3      struct___darwin_xmm_reg
	__fpu_xmm4      struct___darwin_xmm_reg
	__fpu_xmm5      struct___darwin_xmm_reg
	__fpu_xmm6      struct___darwin_xmm_reg
	__fpu_xmm7      struct___darwin_xmm_reg
	__fpu_xmm8      struct___darwin_xmm_reg
	__fpu_xmm9      struct___darwin_xmm_reg
	__fpu_xmm10     struct___darwin_xmm_reg
	__fpu_xmm11     struct___darwin_xmm_reg
	__fpu_xmm12     struct___darwin_xmm_reg
	__fpu_xmm13     struct___darwin_xmm_reg
	__fpu_xmm14     struct___darwin_xmm_reg
	__fpu_xmm15     struct___darwin_xmm_reg
	__fpu_rsrv4     [96]int8
	__fpu_reserved1 int32
	__avx_reserved1 [64]int8
	__fpu_ymmh0     struct___darwin_xmm_reg
	__fpu_ymmh1     struct___darwin_xmm_reg
	__fpu_ymmh2     struct___darwin_xmm_reg
	__fpu_ymmh3     struct___darwin_xmm_reg
	__fpu_ymmh4     struct___darwin_xmm_reg
	__fpu_ymmh5     struct___darwin_xmm_reg
	__fpu_ymmh6     struct___darwin_xmm_reg
	__fpu_ymmh7     struct___darwin_xmm_reg
	__fpu_ymmh8     struct___darwin_xmm_reg
	__fpu_ymmh9     struct___darwin_xmm_reg
	__fpu_ymmh10    struct___darwin_xmm_reg
	__fpu_ymmh11    struct___darwin_xmm_reg
	__fpu_ymmh12    struct___darwin_xmm_reg
	__fpu_ymmh13    struct___darwin_xmm_reg
	__fpu_ymmh14    struct___darwin_xmm_reg
	__fpu_ymmh15    struct___darwin_xmm_reg
	__fpu_k0        struct___darwin_opmask_reg
	__fpu_k1        struct___darwin_opmask_reg
	__fpu_k2        struct___darwin_opmask_reg
	__fpu_k3        struct___darwin_opmask_reg
	__fpu_k4        struct___darwin_opmask_reg
	__fpu_k5        struct___darwin_opmask_reg
	__fpu_k6        struct___darwin_opmask_reg
	__fpu_k7        struct___darwin_opmask_reg
	__fpu_zmmh0     struct___darwin_ymm_reg
	__fpu_zmmh1     struct___darwin_ymm_reg
	__fpu_zmmh2     struct___darwin_ymm_reg
	__fpu_zmmh3     struct___darwin_ymm_reg
	__fpu_zmmh4     struct___darwin_ymm_reg
	__fpu_zmmh5     struct___darwin_ymm_reg
	__fpu_zmmh6     struct___darwin_ymm_reg
	__fpu_zmmh7     struct___darwin_ymm_reg
	__fpu_zmmh8     struct___darwin_ymm_reg
	__fpu_zmmh9     struct___darwin_ymm_reg
	__fpu_zmmh10    struct___darwin_ymm_reg
	__fpu_zmmh11    struct___darwin_ymm_reg
	__fpu_zmmh12    struct___darwin_ymm_reg
	__fpu_zmmh13    struct___darwin_ymm_reg
	__fpu_zmmh14    struct___darwin_ymm_reg
	__fpu_zmmh15    struct___darwin_ymm_reg
	__fpu_zmm16     struct___darwin_zmm_reg
	__fpu_zmm17     struct___darwin_zmm_reg
	__fpu_zmm18     struct___darwin_zmm_reg
	__fpu_zmm19     struct___darwin_zmm_reg
	__fpu_zmm20     struct___darwin_zmm_reg
	__fpu_zmm21     struct___darwin_zmm_reg
	__fpu_zmm22     struct___darwin_zmm_reg
	__fpu_zmm23     struct___darwin_zmm_reg
	__fpu_zmm24     struct___darwin_zmm_reg
	__fpu_zmm25     struct___darwin_zmm_reg
	__fpu_zmm26     struct___darwin_zmm_reg
	__fpu_zmm27     struct___darwin_zmm_reg
	__fpu_zmm28     struct___darwin_zmm_reg
	__fpu_zmm29     struct___darwin_zmm_reg
	__fpu_zmm30     struct___darwin_zmm_reg
	__fpu_zmm31     struct___darwin_zmm_reg
}
type struct___darwin_x86_exception_state64 struct {
	__trapno     uint16
	__cpu        uint16
	__err        uint32
	__faultvaddr uint64
}
type struct___darwin_x86_debug_state64 struct {
	__dr0 uint64
	__dr1 uint64
	__dr2 uint64
	__dr3 uint64
	__dr4 uint64
	__dr5 uint64
	__dr6 uint64
	__dr7 uint64
}
type struct___darwin_x86_cpmu_state64 struct {
	__ctrs [16]uint64
}
type struct___darwin_mcontext32 struct {
	__es struct___darwin_i386_exception_state
	__ss struct___darwin_i386_thread_state
	__fs struct___darwin_i386_float_state
}
type struct___darwin_mcontext_avx32 struct {
	__es struct___darwin_i386_exception_state
	__ss struct___darwin_i386_thread_state
	__fs struct___darwin_i386_avx_state
}
type struct___darwin_mcontext_avx512_32 struct {
	__es struct___darwin_i386_exception_state
	__ss struct___darwin_i386_thread_state
	__fs struct___darwin_i386_avx512_state
}
type struct___darwin_mcontext64 struct {
	__es struct___darwin_x86_exception_state64
	__ss struct___darwin_x86_thread_state64
	__fs struct___darwin_x86_float_state64
}
type struct___darwin_mcontext64_full struct {
	__es struct___darwin_x86_exception_state64
	__ss struct___darwin_x86_thread_full_state64
	__fs struct___darwin_x86_float_state64
}
type struct___darwin_mcontext_avx64 struct {
	__es struct___darwin_x86_exception_state64
	__ss struct___darwin_x86_thread_state64
	__fs struct___darwin_x86_avx_state64
}
type struct___darwin_mcontext_avx64_full struct {
	__es struct___darwin_x86_exception_state64
	__ss struct___darwin_x86_thread_full_state64
	__fs struct___darwin_x86_avx_state64
}
type struct___darwin_mcontext_avx512_64 struct {
	__es struct___darwin_x86_exception_state64
	__ss struct___darwin_x86_thread_state64
	__fs struct___darwin_x86_avx512_state64
}
type struct___darwin_mcontext_avx512_64_full struct {
	__es struct___darwin_x86_exception_state64
	__ss struct___darwin_x86_thread_full_state64
	__fs struct___darwin_x86_avx512_state64
}
type mcontext_t = *struct___darwin_mcontext64
type pthread_attr_t = struct__opaque_pthread_attr_t
type struct___darwin_sigaltstack struct {
	ss_sp    unsafe.Pointer
	ss_size  uint
	ss_flags int32
}
type stack_t = struct___darwin_sigaltstack
type struct___darwin_ucontext struct {
	uc_onstack  int32
	uc_sigmask  uint32
	uc_stack    struct___darwin_sigaltstack
	uc_link     *struct___darwin_ucontext
	uc_mcsize   uint
	uc_mcontext *struct___darwin_mcontext64
}
type ucontext_t = struct___darwin_ucontext
type sigset_t = uint32
type uid_t = uint32
type union_sigval struct {
	sival_ptr unsafe.Pointer
}
type struct_sigevent struct {
	sigev_notify            int32
	sigev_signo             int32
	sigev_value             union_sigval
	sigev_notify_function   func(union_sigval)
	sigev_notify_attributes *struct__opaque_pthread_attr_t
}
type struct___siginfo struct {
	si_signo  int32
	si_errno  int32
	si_code   int32
	si_pid    int32
	si_uid    uint32
	si_status int32
	si_addr   unsafe.Pointer
	si_value  union_sigval
	si_band   int
	__pad     [7]uint
}
type siginfo_t = struct___siginfo
type union___sigaction_u struct {
	__sa_handler func(int32)
}
type struct___sigaction struct {
	__sigaction_u union___sigaction_u
	sa_tramp      func(unsafe.Pointer, int32, int32, *struct___siginfo, unsafe.Pointer)
	sa_mask       uint32
	sa_flags      int32
}
type struct_sigaction struct {
	__sigaction_u union___sigaction_u
	sa_mask       uint32
	sa_flags      int32
}
type sig_t = func(int32)
type struct_sigvec struct {
	sv_handler func(int32)
	sv_mask    int32
	sv_flags   int32
}
type struct_sigstack struct {
	ss_sp      *int8
	ss_onstack int32
}
type uint8_t = uint8
type uint16_t = uint16
type uint32_t = uint32
type uint64_t = uint64
type int_least8_t = int8
type int_least16_t = int16
type int_least32_t = int32
type int_least64_t = int64
type uint_least8_t = uint8
type uint_least16_t = uint16
type uint_least32_t = uint32
type uint_least64_t = uint64
type int_fast8_t = int8
type int_fast16_t = int16
type int_fast32_t = int32
type int_fast64_t = int64
type uint_fast8_t = uint8
type uint_fast16_t = uint16
type uint_fast32_t = uint32
type uint_fast64_t = uint64
type intmax_t = int
type uintmax_t = uint
type struct_timeval struct {
	tv_sec  int
	tv_usec int32
}
type rlim_t = uint64
type struct_rusage struct {
	ru_utime    struct_timeval
	ru_stime    struct_timeval
	ru_maxrss   int
	ru_ixrss    int
	ru_idrss    int
	ru_isrss    int
	ru_minflt   int
	ru_majflt   int
	ru_nswap    int
	ru_inblock  int
	ru_oublock  int
	ru_msgsnd   int
	ru_msgrcv   int
	ru_nsignals int
	ru_nvcsw    int
	ru_nivcsw   int
}
type rusage_info_t = unsafe.Pointer
type struct_rusage_info_v0 struct {
	ri_uuid               [16]uint8
	ri_user_time          uint64
	ri_system_time        uint64
	ri_pkg_idle_wkups     uint64
	ri_interrupt_wkups    uint64
	ri_pageins            uint64
	ri_wired_size         uint64
	ri_resident_size      uint64
	ri_phys_footprint     uint64
	ri_proc_start_abstime uint64
	ri_proc_exit_abstime  uint64
}
type struct_rusage_info_v1 struct {
	ri_uuid                  [16]uint8
	ri_user_time             uint64
	ri_system_time           uint64
	ri_pkg_idle_wkups        uint64
	ri_interrupt_wkups       uint64
	ri_pageins               uint64
	ri_wired_size            uint64
	ri_resident_size         uint64
	ri_phys_footprint        uint64
	ri_proc_start_abstime    uint64
	ri_proc_exit_abstime     uint64
	ri_child_user_time       uint64
	ri_child_system_time     uint64
	ri_child_pkg_idle_wkups  uint64
	ri_child_interrupt_wkups uint64
	ri_child_pageins         uint64
	ri_child_elapsed_abstime uint64
}
type struct_rusage_info_v2 struct {
	ri_uuid                  [16]uint8
	ri_user_time             uint64
	ri_system_time           uint64
	ri_pkg_idle_wkups        uint64
	ri_interrupt_wkups       uint64
	ri_pageins               uint64
	ri_wired_size            uint64
	ri_resident_size         uint64
	ri_phys_footprint        uint64
	ri_proc_start_abstime    uint64
	ri_proc_exit_abstime     uint64
	ri_child_user_time       uint64
	ri_child_system_time     uint64
	ri_child_pkg_idle_wkups  uint64
	ri_child_interrupt_wkups uint64
	ri_child_pageins         uint64
	ri_child_elapsed_abstime uint64
	ri_diskio_bytesread      uint64
	ri_diskio_byteswritten   uint64
}
type struct_rusage_info_v3 struct {
	ri_uuid                          [16]uint8
	ri_user_time                     uint64
	ri_system_time                   uint64
	ri_pkg_idle_wkups                uint64
	ri_interrupt_wkups               uint64
	ri_pageins                       uint64
	ri_wired_size                    uint64
	ri_resident_size                 uint64
	ri_phys_footprint                uint64
	ri_proc_start_abstime            uint64
	ri_proc_exit_abstime             uint64
	ri_child_user_time               uint64
	ri_child_system_time             uint64
	ri_child_pkg_idle_wkups          uint64
	ri_child_interrupt_wkups         uint64
	ri_child_pageins                 uint64
	ri_child_elapsed_abstime         uint64
	ri_diskio_bytesread              uint64
	ri_diskio_byteswritten           uint64
	ri_cpu_time_qos_default          uint64
	ri_cpu_time_qos_maintenance      uint64
	ri_cpu_time_qos_background       uint64
	ri_cpu_time_qos_utility          uint64
	ri_cpu_time_qos_legacy           uint64
	ri_cpu_time_qos_user_initiated   uint64
	ri_cpu_time_qos_user_interactive uint64
	ri_billed_system_time            uint64
	ri_serviced_system_time          uint64
}
type struct_rusage_info_v4 struct {
	ri_uuid                          [16]uint8
	ri_user_time                     uint64
	ri_system_time                   uint64
	ri_pkg_idle_wkups                uint64
	ri_interrupt_wkups               uint64
	ri_pageins                       uint64
	ri_wired_size                    uint64
	ri_resident_size                 uint64
	ri_phys_footprint                uint64
	ri_proc_start_abstime            uint64
	ri_proc_exit_abstime             uint64
	ri_child_user_time               uint64
	ri_child_system_time             uint64
	ri_child_pkg_idle_wkups          uint64
	ri_child_interrupt_wkups         uint64
	ri_child_pageins                 uint64
	ri_child_elapsed_abstime         uint64
	ri_diskio_bytesread              uint64
	ri_diskio_byteswritten           uint64
	ri_cpu_time_qos_default          uint64
	ri_cpu_time_qos_maintenance      uint64
	ri_cpu_time_qos_background       uint64
	ri_cpu_time_qos_utility          uint64
	ri_cpu_time_qos_legacy           uint64
	ri_cpu_time_qos_user_initiated   uint64
	ri_cpu_time_qos_user_interactive uint64
	ri_billed_system_time            uint64
	ri_serviced_system_time          uint64
	ri_logical_writes                uint64
	ri_lifetime_max_phys_footprint   uint64
	ri_instructions                  uint64
	ri_cycles                        uint64
	ri_billed_energy                 uint64
	ri_serviced_energy               uint64
	ri_interval_max_phys_footprint   uint64
	ri_runnable_time                 uint64
}
type struct_rusage_info_v5 struct {
	ri_uuid                          [16]uint8
	ri_user_time                     uint64
	ri_system_time                   uint64
	ri_pkg_idle_wkups                uint64
	ri_interrupt_wkups               uint64
	ri_pageins                       uint64
	ri_wired_size                    uint64
	ri_resident_size                 uint64
	ri_phys_footprint                uint64
	ri_proc_start_abstime            uint64
	ri_proc_exit_abstime             uint64
	ri_child_user_time               uint64
	ri_child_system_time             uint64
	ri_child_pkg_idle_wkups          uint64
	ri_child_interrupt_wkups         uint64
	ri_child_pageins                 uint64
	ri_child_elapsed_abstime         uint64
	ri_diskio_bytesread              uint64
	ri_diskio_byteswritten           uint64
	ri_cpu_time_qos_default          uint64
	ri_cpu_time_qos_maintenance      uint64
	ri_cpu_time_qos_background       uint64
	ri_cpu_time_qos_utility          uint64
	ri_cpu_time_qos_legacy           uint64
	ri_cpu_time_qos_user_initiated   uint64
	ri_cpu_time_qos_user_interactive uint64
	ri_billed_system_time            uint64
	ri_serviced_system_time          uint64
	ri_logical_writes                uint64
	ri_lifetime_max_phys_footprint   uint64
	ri_instructions                  uint64
	ri_cycles                        uint64
	ri_billed_energy                 uint64
	ri_serviced_energy               uint64
	ri_interval_max_phys_footprint   uint64
	ri_runnable_time                 uint64
	ri_flags                         uint64
}
type rusage_info_current = struct_rusage_info_v5
type struct_rlimit struct {
	rlim_cur uint64
	rlim_max uint64
}
type struct_proc_rlimit_control_wakeupmon struct {
	wm_flags uint32
	wm_rate  int32
}

func _OSSwapInt16(_data uint16) uint16 {
	return uint16(int32(_data)<<8 | int32(_data)>>8)
}
func _OSSwapInt32(_data uint32) uint32 {
	return __builtin_bswap32(_data)
}
func _OSSwapInt64(_data uint64) uint64 {
	return __builtin_bswap64(_data)
}

type _cgoa_2 struct {
	Xbf_0 uint32
}
type _cgoa_3 struct {
	Xbf_0 uint32
}
type union_wait struct {
	w_status int32
}
type ct_rune_t = int32
type rune_t = int32
type wchar_t = int32
type _cgoa_4 struct {
	quot int32
	rem  int32
}
type _cgoa_5 struct {
	quot int
	rem  int
}
type _cgoa_6 struct {
	quot int64
	rem  int64
}
type dev_t = int32
type mode_t = uint16
type rsize_t = uint
type errno_t = int32
type ptrdiff_t = int
type max_align_t = float64
type i64 = int64
type u64 = uint64
type u32 = uint32
type u16 = uint16
type i16 = int16
type u8 = uint8
type i8 = int8
type tRowcnt = uint32
type LogEst = int16
type uptr = uint64



type BusyHandler = struct_BusyHandler
type struct_BusyHandler struct {
	xBusyHandler func(unsafe.Pointer, int32) int32
	pBusyArg     unsafe.Pointer
	nBusy        int32
}
type AggInfo = struct_AggInfo
type AuthContext = struct_AuthContext
type AutoincInfo = struct_AutoincInfo
type Bitvec = struct_Bitvec
type CollSeq = struct_CollSeq
type Column = struct_Column
type Cte = struct_Cte
type CteUse = struct_CteUse
type Db = struct_Db
type DbFixer = struct_DbFixer
type Schema = struct_Schema
type Expr = struct_Expr
type ExprList = struct_ExprList
type FKey = struct_FKey
type FuncDestructor = struct_FuncDestructor
type FuncDef = struct_FuncDef
type FuncDefHash = struct_FuncDefHash
type IdList = struct_IdList
type Index = struct_Index
type IndexSample = struct_IndexSample
type KeyClass = struct_KeyClass
type KeyInfo = struct_KeyInfo
type Lookaside = struct_Lookaside
type LookasideSlot = struct_LookasideSlot
type Module = struct_Module
type NameContext = struct_NameContext
type Parse = struct_Parse
type ParseCleanup = struct_ParseCleanup
type PreUpdate = struct_PreUpdate
type PrintfArguments = struct_PrintfArguments
type RenameToken = struct_RenameToken
type Returning = struct_Returning
type RowSet = struct_RowSet
type Savepoint = struct_Savepoint
type Select = struct_Select
type SQLiteThread = struct_SQLiteThread
type SelectDest = struct_SelectDest
type SrcItem = struct_SrcItem
type SrcList = struct_SrcList
type StrAccum = struct_sqlite3_str
type Table = struct_Table
type TableLock = struct_TableLock
type Token = struct_Token
type TreeView = struct_TreeView
type Trigger = struct_Trigger
type TriggerPrg = struct_TriggerPrg
type TriggerStep = struct_TriggerStep
type UnpackedRecord = struct_UnpackedRecord
type Upsert = struct_Upsert
type VTable = struct_VTable
type VtabCtx = struct_VtabCtx
type Walker = struct_Walker
type WhereInfo = struct_WhereInfo
type Window = struct_Window
type With = struct_With
type Bitmask = uint64
type VList = int32
type Pgno = uint32
type Pager = struct_Pager
type DbPage = struct_PgHdr
type Btree = struct_Btree
type BtCursor = struct_BtCursor
type BtShared = struct_BtShared
type BtreePayload = struct_BtreePayload
type struct_BtreePayload struct {
	pKey  unsafe.Pointer
	nKey  int64
	pData unsafe.Pointer
	aMem  *struct_sqlite3_value
	nMem  uint16
	nData int32
	nZero int32
}
type Vdbe = struct_Vdbe
type Mem = struct_sqlite3_value
type SubProgram = struct_SubProgram
type union_p4union struct {
	p unsafe.Pointer
}
type struct_VdbeOp struct {
	opcode uint8
	p4type int8
	p5     uint16
	p1     int32
	p2     int32
	p3     int32
	p4     union_p4union
}
type VdbeOp = struct_VdbeOp
type struct_SubProgram struct {
	aOp   *struct_VdbeOp
	nOp   int32
	nMem  int32
	nCsr  int32
	aOnce *uint8
	token unsafe.Pointer
	pNext *struct_SubProgram
}
type struct_VdbeOpList struct {
	opcode uint8
	p1     int8
	p2     int8
	p3     int8
}
type VdbeOpList = struct_VdbeOpList
type RecordCompare = func(int32, unsafe.Pointer, *struct_UnpackedRecord) int32
type PgHdr = struct_PgHdr
type PCache = struct_PCache
type struct_PgHdr struct {
	pPage      *struct_sqlite3_pcache_page
	pData      unsafe.Pointer
	pExtra     unsafe.Pointer
	pCache     *struct_PCache
	pDirty     *struct_PgHdr
	pPager     *struct_Pager
	pgno       uint32
	flags      uint16
	nRef       int16
	pDirtyNext *struct_PgHdr
	pDirtyPrev *struct_PgHdr
}
type struct_Db struct {
	zDbSName     *int8
	pBt          *struct_Btree
	safety_level uint8
	bSyncSet     uint8
	pSchema      *struct_Schema
}
type struct_Schema struct {
	schema_cookie int32
	iGeneration   int32
	tblHash       struct_Hash
	idxHash       struct_Hash
	trigHash      struct_Hash
	fkeyHash      struct_Hash
	pSeqTab       *struct_Table
	file_format   uint8
	enc           uint8
	schemaFlags   uint16
	cache_size    int32
}
type struct_Lookaside struct {
	bDisable   uint32
	sz         uint16
	szTrue     uint16
	bMalloced  uint8
	nSlot      uint32
	anStat     [3]uint32
	pInit      *struct_LookasideSlot
	pFree      *struct_LookasideSlot
	pSmallInit *struct_LookasideSlot
	pSmallFree *struct_LookasideSlot
	pMiddle    unsafe.Pointer
	pStart     unsafe.Pointer
	pEnd       unsafe.Pointer
}
type struct_LookasideSlot struct {
	pNext *struct_LookasideSlot
}
type struct_FuncDefHash struct {
	a [23]*struct_FuncDef
}
type sqlite3_xauth = func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32
type struct_sqlite3InitInfo struct {
	newTnum uint32
	iDb     uint8
	busy    uint8
	Xbf_0   uint32
	azInit  **int8
}
type _cgoa_7 struct {
	xLegacy func(unsafe.Pointer, *int8)
}
type _cgoa_8 struct {
	notUsed1 float64
}
type struct_sqlite3 struct {
	pVfs                   *struct_sqlite3_vfs
	pVdbe                  *struct_Vdbe
	pDfltColl              *struct_CollSeq
	mutex                  *struct_sqlite3_mutex
	aDb                    *struct_Db
	nDb                    int32
	mDbFlags               uint32
	flags                  uint64
	lastRowid              int64
	szMmap                 int64
	nSchemaLock            uint32
	openFlags              uint32
	errCode                int32
	errByteOffset          int32
	errMask                int32
	iSysErrno              int32
	dbOptFlags             uint32
	enc                    uint8
	autoCommit             uint8
	temp_store             uint8
	mallocFailed           uint8
	bBenignMalloc          uint8
	dfltLockMode           uint8
	nextAutovac            int8
	suppressErr            uint8
	vtabOnConflict         uint8
	isTransactionSavepoint uint8
	mTrace                 uint8
	noSharedCache          uint8
	nSqlExec               uint8
	eOpenState             uint8
	nextPagesize           int32
	nChange                int64
	nTotalChange           int64
	aLimit                 [12]int32
	nMaxSorterMmap         int32
	init                   struct_sqlite3InitInfo
	nVdbeActive            int32
	nVdbeRead              int32
	nVdbeWrite             int32
	nVdbeExec              int32
	nVDestroy              int32
	nExtension             int32
	aExtension             *unsafe.Pointer
	trace                  _cgoa_7
	pTraceArg              unsafe.Pointer
	xProfile               func(unsafe.Pointer, *int8, uint64)
	pProfileArg            unsafe.Pointer
	pCommitArg             unsafe.Pointer
	xCommitCallback        func(unsafe.Pointer) int32
	pRollbackArg           unsafe.Pointer
	xRollbackCallback      func(unsafe.Pointer)
	pUpdateArg             unsafe.Pointer
	xUpdateCallback        func(unsafe.Pointer, int32, *int8, *int8, int64)
	pAutovacPagesArg       unsafe.Pointer
	xAutovacDestr          func(unsafe.Pointer)
	xAutovacPages          func(unsafe.Pointer, *int8, uint32, uint32, uint32) uint32
	pParse                 *struct_Parse
	xWalCallback           func(unsafe.Pointer, *struct_sqlite3, *int8, int32) int32
	pWalArg                unsafe.Pointer
	xCollNeeded            func(unsafe.Pointer, *struct_sqlite3, int32, *int8)
	xCollNeeded16          func(unsafe.Pointer, *struct_sqlite3, int32, unsafe.Pointer)
	pCollNeededArg         unsafe.Pointer
	pErr                   *struct_sqlite3_value
	u1                     _cgoa_8
	lookaside              struct_Lookaside
	xAuth                  func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32
	pAuthArg               unsafe.Pointer
	xProgress              func(unsafe.Pointer) int32
	pProgressArg           unsafe.Pointer
	nProgressOps           uint32
	nVTrans                int32
	aModule                struct_Hash
	pVtabCtx               *struct_VtabCtx
	aVTrans                **struct_VTable
	pDisconnect            *struct_VTable
	aFunc                  struct_Hash
	aCollSeq               struct_Hash
	busyHandler            struct_BusyHandler
	aDbStatic              [2]struct_Db
	pSavepoint             *struct_Savepoint
	nAnalysisLimit         int32
	busyTimeout            int32
	nSavepoint             int32
	nStatement             int32
	nDeferredCons          int64
	nDeferredImmCons       int64
	pnBytesFreed           *int32
}
type _cgoa_9 struct {
	pHash *struct_FuncDef
}
type struct_FuncDef struct {
	nArg      int8
	funcFlags uint32
	pUserData unsafe.Pointer
	pNext     *struct_FuncDef
	xSFunc    func(*struct_sqlite3_context, int32, **struct_sqlite3_value)
	xFinalize func(*struct_sqlite3_context)
	xValue    func(*struct_sqlite3_context)
	xInverse  func(*struct_sqlite3_context, int32, **struct_sqlite3_value)
	zName     *int8
	u         _cgoa_9
}
type struct_FuncDestructor struct {
	nRef      int32
	xDestroy  func(unsafe.Pointer)
	pUserData unsafe.Pointer
}
type struct_Savepoint struct {
	zName            *int8
	nDeferredCons    int64
	nDeferredImmCons int64
	pNext            *struct_Savepoint
}
type struct_Module struct {
	pModule    *struct_sqlite3_module
	zName      *int8
	nRefModule int32
	pAux       unsafe.Pointer
	xDestroy   func(unsafe.Pointer)
	pEpoTab    *struct_Table
}
type struct_Column struct {
	zCnName  *int8
	Xbf_0    uint32
	affinity int8
	szEst    uint8
	hName    uint8
	iDflt    uint16
	colFlags uint16
}
type struct_CollSeq struct {
	zName *int8
	enc   uint8
	pUser unsafe.Pointer
	xCmp  func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32
	xDel  func(unsafe.Pointer)
}
type struct_VTable struct {
	db          *struct_sqlite3
	pMod        *struct_Module
	pVtab       *struct_sqlite3_vtab
	nRef        int32
	bConstraint uint8
	eVtabRisk   uint8
	iSavepoint  int32
	pNext       *struct_VTable
}
type _cgoa_11 struct {
	addColOffset int32
	pFKey        *struct_FKey
	pDfltList    *struct_ExprList
}
type _cgoa_12 struct {
	pSelect *struct_Select
}
type _cgoa_13 struct {
	nArg  int32
	azArg **int8
	p     *struct_VTable
}
type _cgoa_10 struct {
	tab _cgoa_11
}
type struct_Table struct {
	zName      *int8
	aCol       *struct_Column
	pIndex     *struct_Index
	zColAff    *int8
	pCheck     *struct_ExprList
	tnum       uint32
	nTabRef    uint32
	tabFlags   uint32
	iPKey      int16
	nCol       int16
	nNVCol     int16
	nRowLogEst int16
	szTabRow   int16
	keyConf    uint8
	eTabType   uint8
	u          _cgoa_10
	pTrigger   *struct_Trigger
	pSchema    *struct_Schema
}
type struct_sColMap struct {
	iFrom int32
	zCol  *int8
}
type struct_FKey struct {
	pFrom      *struct_Table
	pNextFrom  *struct_FKey
	zTo        *int8
	pNextTo    *struct_FKey
	pPrevTo    *struct_FKey
	nCol       int32
	isDeferred uint8
	aAction    [2]uint8
	apTrigger  [2]*struct_Trigger
	aCol       [1]struct_sColMap
}
type struct_KeyInfo struct {
	nRef       uint32
	enc        uint8
	nKeyField  uint16
	nAllField  uint16
	db         *struct_sqlite3
	aSortFlags *uint8
	aColl      [1]*struct_CollSeq
}
type struct_UnpackedRecord struct {
	pKeyInfo   *struct_KeyInfo
	aMem       *struct_sqlite3_value
	nField     uint16
	default_rc int8
	errCode    uint8
	r1         int8
	r2         int8
	eqSeen     uint8
}
type struct_Index struct {
	zName         *int8
	aiColumn      *int16
	aiRowLogEst   *int16
	pTable        *struct_Table
	zColAff       *int8
	pNext         *struct_Index
	pSchema       *struct_Schema
	aSortOrder    *uint8
	azColl        **int8
	pPartIdxWhere *struct_Expr
	aColExpr      *struct_ExprList
	tnum          uint32
	szIdxRow      int16
	nKeyCol       uint16
	nColumn       uint16
	onError       uint8
	Xbf_0         uint32
	colNotIdxed   uint64
}
type struct_IndexSample struct {
	p     unsafe.Pointer
	n     int32
	anEq  *uint32
	anLt  *uint32
	anDLt *uint32
}
type struct_Token struct {
	z *int8
	n uint32
}
type struct_AggInfo_col struct {
	pTab          *struct_Table
	pCExpr        *struct_Expr
	iTable        int32
	iMem          int32
	iColumn       int16
	iSorterColumn int16
}
type struct_AggInfo_func struct {
	pFExpr    *struct_Expr
	pFunc     *struct_FuncDef
	iMem      int32
	iDistinct int32
	iDistAddr int32
}
type struct_AggInfo struct {
	directMode     uint8
	useSortingIdx  uint8
	sortingIdx     int32
	sortingIdxPTab int32
	nSortingColumn int32
	mnReg          int32
	mxReg          int32
	pGroupBy       *struct_ExprList
	aCol           *struct_AggInfo_col
	nColumn        int32
	nAccumulator   int32
	aFunc          *struct_AggInfo_func
	nFunc          int32
	selId          uint32
}
type ynVar = int16
type _cgoa_14 struct {
	zToken *int8
}
type _cgoa_15 struct {
	pList *struct_ExprList
}
type _cgoa_16 struct {
	iRightJoinTable int32
}
type _cgoa_18 struct {
	iAddr     int32
	regReturn int32
}
type _cgoa_17 struct {
	pTab *struct_Table
}
type struct_Expr struct {
	op       uint8
	affExpr  int8
	op2      uint8
	flags    uint32
	u        _cgoa_14
	pLeft    *struct_Expr
	pRight   *struct_Expr
	x        _cgoa_15
	nHeight  int32
	iTable   int32
	iColumn  int16
	iAgg     int16
	w        _cgoa_16
	pAggInfo *struct_AggInfo
	y        _cgoa_17
}
type _cgoa_20 struct {
	iOrderByCol uint16
	iAlias      uint16
}
type _cgoa_19 struct {
	x _cgoa_20
}
type struct_ExprList_item struct {
	pExpr     *struct_Expr
	zEName    *int8
	sortFlags uint8
	Xbf_0     uint32
	u         _cgoa_19
}
type struct_ExprList struct {
	nExpr  int32
	nAlloc int32
	a      [1]struct_ExprList_item
}
type struct_IdList_item struct {
	zName *int8
	idx   int32
}
type struct_IdList struct {
	a   *struct_IdList_item
	nId int32
}
type _cgoa_21 struct {
	jointype uint8
	Xbf_0    uint32
}
type _cgoa_22 struct {
	zIndexedBy *int8
}
type _cgoa_23 struct {
	pIBIndex *struct_Index
}
type struct_SrcItem struct {
	pSchema     *struct_Schema
	zDatabase   *int8
	zName       *int8
	zAlias      *int8
	pTab        *struct_Table
	pSelect     *struct_Select
	addrFillSub int32
	regReturn   int32
	regResult   int32
	fg          _cgoa_21
	iCursor     int32
	pOn         *struct_Expr
	pUsing      *struct_IdList
	colUsed     uint64
	u1          _cgoa_22
	u2          _cgoa_23
}
type struct_SrcList struct {
	nSrc   int32
	nAlloc uint32
	a      [1]struct_SrcItem
}
type _cgoa_24 struct {
	pEList *struct_ExprList
}
type struct_NameContext struct {
	pParse     *struct_Parse
	pSrcList   *struct_SrcList
	uNC        _cgoa_24
	pNext      *struct_NameContext
	nRef       int32
	nNcErr     int32
	ncFlags    int32
	pWinSelect *struct_Select
}
type struct_Upsert struct {
	pUpsertTarget      *struct_ExprList
	pUpsertTargetWhere *struct_Expr
	pUpsertSet         *struct_ExprList
	pUpsertWhere       *struct_Expr
	pNextUpsert        *struct_Upsert
	isDoUpdate         uint8
	pToFree            unsafe.Pointer
	pUpsertIdx         *struct_Index
	pUpsertSrc         *struct_SrcList
	regData            int32
	iDataCur           int32
	iIdxCur            int32
}
type struct_Select struct {
	op           uint8
	nSelectRow   int16
	selFlags     uint32
	iLimit       int32
	iOffset      int32
	selId        uint32
	addrOpenEphm [2]int32
	pEList       *struct_ExprList
	pSrc         *struct_SrcList
	pWhere       *struct_Expr
	pGroupBy     *struct_ExprList
	pHaving      *struct_Expr
	pOrderBy     *struct_ExprList
	pPrior       *struct_Select
	pNext        *struct_Select
	pLimit       *struct_Expr
	pWith        *struct_With
	pWin         *struct_Window
	pWinDefn     *struct_Window
}
type struct_SelectDest struct {
	eDest    uint8
	iSDParm  int32
	iSDParm2 int32
	iSdst    int32
	nSdst    int32
	zAffSdst *int8
	pOrderBy *struct_ExprList
}
type struct_AutoincInfo struct {
	pNext  *struct_AutoincInfo
	pTab   *struct_Table
	iDb    int32
	regCtr int32
}
type struct_TriggerPrg struct {
	pTrigger *struct_Trigger
	pNext    *struct_TriggerPrg
	pProgram *struct_SubProgram
	orconf   int32
	aColmask [2]uint32
}
type yDbMask = uint32
type struct_ParseCleanup struct {
	pNext    *struct_ParseCleanup
	pPtr     unsafe.Pointer
	xCleanup func(*struct_sqlite3, unsafe.Pointer)
}
type _cgoa_25 struct {
	pReturning *struct_Returning
}
type struct_Parse struct {
	db               *struct_sqlite3
	zErrMsg          *int8
	pVdbe            *struct_Vdbe
	rc               int32
	colNamesSet      uint8
	checkSchema      uint8
	nested           uint8
	nTempReg         uint8
	isMultiWrite     uint8
	mayAbort         uint8
	hasCompound      uint8
	okConstFactor    uint8
	disableLookaside uint8
	disableVtab      uint8
	nRangeReg        int32
	iRangeReg        int32
	nErr             int32
	nTab             int32
	nMem             int32
	szOpAlloc        int32
	iSelfTab         int32
	nLabel           int32
	nLabelAlloc      int32
	aLabel           *int32
	pConstExpr       *struct_ExprList
	constraintName   struct_Token
	writeMask        uint32
	cookieMask       uint32
	regRowid         int32
	regRoot          int32
	nMaxArg          int32
	nSelect          int32
	nTableLock       int32
	aTableLock       *struct_TableLock
	pAinc            *struct_AutoincInfo
	pToplevel        *struct_Parse
	pTriggerTab      *struct_Table
	pTriggerPrg      *struct_TriggerPrg
	pCleanup         *struct_ParseCleanup
	u1               _cgoa_25
	nQueryLoop       uint32
	oldmask          uint32
	newmask          uint32
	eTriggerOp       uint8
	bReturning       uint8
	eOrconf          uint8
	disableTriggers  uint8
	aTempReg         [8]int32
	pOuterParse      *struct_Parse
	sNameToken       struct_Token
	sLastToken       struct_Token
	nVar             int16
	iPkSortOrder     uint8
	explain          uint8
	eParseMode       uint8
	nVtabLock        int32
	nHeight          int32
	addrExplain      int32
	pVList           *int32
	pReprepare       *struct_Vdbe
	zTail            *int8
	pNewTable        *struct_Table
	pNewIndex        *struct_Index
	pNewTrigger      *struct_Trigger
	zAuthContext     *int8
	sArg             struct_Token
	apVtabLock       **struct_Table
	pWith            *struct_With
	pRename          *struct_RenameToken
}
type struct_AuthContext struct {
	zAuthContext *int8
	pParse       *struct_Parse
}
type struct_Trigger struct {
	zName      *int8
	table      *int8
	op         uint8
	tr_tm      uint8
	bReturning uint8
	pWhen      *struct_Expr
	pColumns   *struct_IdList
	pSchema    *struct_Schema
	pTabSchema *struct_Schema
	step_list  *struct_TriggerStep
	pNext      *struct_Trigger
}
type struct_TriggerStep struct {
	op        uint8
	orconf    uint8
	pTrig     *struct_Trigger
	pSelect   *struct_Select
	zTarget   *int8
	pFrom     *struct_SrcList
	pWhere    *struct_Expr
	pExprList *struct_ExprList
	pIdList   *struct_IdList
	pUpsert   *struct_Upsert
	zSpan     *int8
	pNext     *struct_TriggerStep
	pLast     *struct_TriggerStep
}
type struct_Returning struct {
	pParse    *struct_Parse
	pReturnEL *struct_ExprList
	retTrig   struct_Trigger
	retTStep  struct_TriggerStep
	iRetCur   int32
	nRetCol   int32
	iRetReg   int32
}
type struct_sqlite3_str struct {
	db          *struct_sqlite3
	zText       *int8
	nAlloc      uint32
	mxAlloc     uint32
	nChar       uint32
	accError    uint8
	printfFlags uint8
}
type _cgoa_26 struct {
	db         *struct_sqlite3
	pzErrMsg   **int8
	iDb        int32
	rc         int32
	mInitFlags uint32
	nInitRow   uint32
	mxPage     uint32
}
type struct_Sqlite3Config struct {
	bMemstat            int32
	bCoreMutex          uint8
	bFullMutex          uint8
	bOpenUri            uint8
	bUseCis             uint8
	bSmallMalloc        uint8
	bExtraSchemaChecks  uint8
	mxStrlen            int32
	neverCorrupt        int32
	szLookaside         int32
	nLookaside          int32
	nStmtSpill          int32
	m                   struct_sqlite3_mem_methods
	mutex               struct_sqlite3_mutex_methods
	pcache2             struct_sqlite3_pcache_methods2
	pHeap               unsafe.Pointer
	nHeap               int32
	mnReq               int32
	mxReq               int32
	szMmap              int64
	mxMmap              int64
	pPage               unsafe.Pointer
	szPage              int32
	nPage               int32
	mxParserStack       int32
	sharedCacheEnabled  int32
	szPma               uint32
	isInit              int32
	inProgress          int32
	isMutexInit         int32
	isMallocInit        int32
	isPCacheInit        int32
	nRefInitMutex       int32
	pInitMutex          *struct_sqlite3_mutex
	xLog                func(unsafe.Pointer, int32, *int8)
	pLogArg             unsafe.Pointer
	mxMemdbSize         int64
	xTestCallback       func(int32) int32
	bLocaltimeFault     int32
	xAltLocaltime       func(unsafe.Pointer, unsafe.Pointer) int32
	iOnceResetThreshold int32
	szSorterRef         uint32
	iPrngSeed           uint32
}
type _cgoa_27 struct {
	pNC *struct_NameContext
}
type struct_Walker struct {
	pParse           *struct_Parse
	xExprCallback    func(*struct_Walker, *struct_Expr) int32
	xSelectCallback  func(*struct_Walker, *struct_Select) int32
	xSelectCallback2 func(*struct_Walker, *struct_Select)
	walkerDepth      int32
	eCode            uint16
	u                _cgoa_27
}
type struct_DbFixer struct {
	pParse  *struct_Parse
	w       struct_Walker
	pSchema *struct_Schema
	bTemp   uint8
	zDb     *int8
	zType   *int8
	pName   *struct_Token
}
type struct_Cte struct {
	zName   *int8
	pCols   *struct_ExprList
	pSelect *struct_Select
	zCteErr *int8
	pUse    *struct_CteUse
	eM10d   uint8
}
type struct_With struct {
	nCte   int32
	bView  int32
	pOuter *struct_With
	a      [1]struct_Cte
}
type struct_CteUse struct {
	nUse    int32
	addrM9e int32
	regRtn  int32
	iCur    int32
	nRowEst int16
	eM10d   uint8
}
type struct_Window struct {
	zName          *int8
	zBase          *int8
	pPartition     *struct_ExprList
	pOrderBy       *struct_ExprList
	eFrmType       uint8
	eStart         uint8
	eEnd           uint8
	bImplicitFrame uint8
	eExclude       uint8
	pStart         *struct_Expr
	pEnd           *struct_Expr
	ppThis         **struct_Window
	pNextWin       *struct_Window
	pFilter        *struct_Expr
	pFunc          *struct_FuncDef
	iEphCsr        int32
	regAccum       int32
	regResult      int32
	csrApp         int32
	regApp         int32
	regPart        int32
	pOwner         *struct_Expr
	nBufferCol     int32
	iArgCol        int32
	regOne         int32
	regStartRowid  int32
	regEndRowid    int32
	bExprArgs      uint8
}
type struct_PrintfArguments struct {
	nArg  int32
	nUsed int32
	apArg **struct_sqlite3_value
}

var sqlite3azCompileOpt [36]*int8 = [36]*int8{(*int8)(unsafe.Pointer(&[20]int8{'A', 'T', 'O', 'M', 'I', 'C', '_', 'I', 'N', 'T', 'R', 'I', 'N', 'S', 'I', 'C', 'S', '=', '1', '\x00'})), (*int8)(unsafe.Pointer(&[22]int8{'C', 'O', 'M', 'P', 'I', 'L', 'E', 'R', '=', 'c', 'l', 'a', 'n', 'g', '-', '1', '3', '.', '0', '.', '0', '\x00'})), (*int8)(unsafe.Pointer(&[19]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'A', 'U', 'T', 'O', 'V', 'A', 'C', 'U', 'U', 'M', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'C', 'A', 'C', 'H', 'E', '_', 'S', 'I', 'Z', 'E', '=', '-', '2', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[22]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'F', 'I', 'L', 'E', '_', 'F', 'O', 'R', 'M', 'A', 'T', '=', '4', '\x00'})), (*int8)(unsafe.Pointer(&[30]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'J', 'O', 'U', 'R', 'N', 'A', 'L', '_', 'S', 'I', 'Z', 'E', '_', 'L', 'I', 'M', 'I', 'T', '=', '-', '1', '\x00'})), (*int8)(unsafe.Pointer(&[20]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'M', 'M', 'A', 'P', '_', 'S', 'I', 'Z', 'E', '=', '0', '\x00'})), (*int8)(unsafe.Pointer(&[23]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'P', 'A', 'G', 'E', '_', 'S', 'I', 'Z', 'E', '=', '4', '0', '9', '6', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'P', 'C', 'A', 'C', 'H', 'E', '_', 'I', 'N', 'I', 'T', 'S', 'Z', '=', '2', '0', '\x00'})), (*int8)(unsafe.Pointer(&[27]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'R', 'E', 'C', 'U', 'R', 'S', 'I', 'V', 'E', '_', 'T', 'R', 'I', 'G', 'G', 'E', 'R', 'S', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'S', 'E', 'C', 'T', 'O', 'R', '_', 'S', 'I', 'Z', 'E', '=', '4', '0', '9', '6', '\x00'})), (*int8)(unsafe.Pointer(&[22]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'S', 'Y', 'N', 'C', 'H', 'R', 'O', 'N', 'O', 'U', 'S', '=', '2', '\x00'})), (*int8)(unsafe.Pointer(&[32]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'W', 'A', 'L', '_', 'A', 'U', 'T', 'O', 'C', 'H', 'E', 'C', 'K', 'P', 'O', 'I', 'N', 'T', '=', '1', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[26]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'W', 'A', 'L', '_', 'S', 'Y', 'N', 'C', 'H', 'R', 'O', 'N', 'O', 'U', 'S', '=', '2', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'W', 'O', 'R', 'K', 'E', 'R', '_', 'T', 'H', 'R', 'E', 'A', 'D', 'S', '=', '0', '\x00'})), (*int8)(unsafe.Pointer(&[23]int8{'M', 'A', 'L', 'L', 'O', 'C', '_', 'S', 'O', 'F', 'T', '_', 'L', 'I', 'M', 'I', 'T', '=', '1', '0', '2', '4', '\x00'})), (*int8)(unsafe.Pointer(&[16]int8{'M', 'A', 'X', '_', 'A', 'T', 'T', 'A', 'C', 'H', 'E', 'D', '=', '1', '0', '\x00'})), (*int8)(unsafe.Pointer(&[16]int8{'M', 'A', 'X', '_', 'C', 'O', 'L', 'U', 'M', 'N', '=', '2', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[24]int8{'M', 'A', 'X', '_', 'C', 'O', 'M', 'P', 'O', 'U', 'N', 'D', '_', 'S', 'E', 'L', 'E', 'C', 'T', '=', '5', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[27]int8{'M', 'A', 'X', '_', 'D', 'E', 'F', 'A', 'U', 'L', 'T', '_', 'P', 'A', 'G', 'E', '_', 'S', 'I', 'Z', 'E', '=', '8', '1', '9', '2', '\x00'})), (*int8)(unsafe.Pointer(&[20]int8{'M', 'A', 'X', '_', 'E', 'X', 'P', 'R', '_', 'D', 'E', 'P', 'T', 'H', '=', '1', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[21]int8{'M', 'A', 'X', '_', 'F', 'U', 'N', 'C', 'T', 'I', 'O', 'N', '_', 'A', 'R', 'G', '=', '1', '2', '7', '\x00'})), (*int8)(unsafe.Pointer(&[22]int8{'M', 'A', 'X', '_', 'L', 'E', 'N', 'G', 'T', 'H', '=', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[30]int8{'M', 'A', 'X', '_', 'L', 'I', 'K', 'E', '_', 'P', 'A', 'T', 'T', 'E', 'R', 'N', '_', 'L', 'E', 'N', 'G', 'T', 'H', '=', '5', '0', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'M', 'A', 'X', '_', 'M', 'M', 'A', 'P', '_', 'S', 'I', 'Z', 'E', '=', '0', 'x', '7', 'f', 'f', 'f', '0', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[26]int8{'M', 'A', 'X', '_', 'P', 'A', 'G', 'E', '_', 'C', 'O', 'U', 'N', 'T', '=', '1', '0', '7', '3', '7', '4', '1', '8', '2', '3', '\x00'})), (*int8)(unsafe.Pointer(&[20]int8{'M', 'A', 'X', '_', 'P', 'A', 'G', 'E', '_', 'S', 'I', 'Z', 'E', '=', '6', '5', '5', '3', '6', '\x00'})), (*int8)(unsafe.Pointer(&[26]int8{'M', 'A', 'X', '_', 'S', 'Q', 'L', '_', 'L', 'E', 'N', 'G', 'T', 'H', '=', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[23]int8{'M', 'A', 'X', '_', 'T', 'R', 'I', 'G', 'G', 'E', 'R', '_', 'D', 'E', 'P', 'T', 'H', '=', '1', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[26]int8{'M', 'A', 'X', '_', 'V', 'A', 'R', 'I', 'A', 'B', 'L', 'E', '_', 'N', 'U', 'M', 'B', 'E', 'R', '=', '3', '2', '7', '6', '6', '\x00'})), (*int8)(unsafe.Pointer(&[22]int8{'M', 'A', 'X', '_', 'V', 'D', 'B', 'E', '_', 'O', 'P', '=', '2', '5', '0', '0', '0', '0', '0', '0', '0', '\x00'})), (*int8)(unsafe.Pointer(&[21]int8{'M', 'A', 'X', '_', 'W', 'O', 'R', 'K', 'E', 'R', '_', 'T', 'H', 'R', 'E', 'A', 'D', 'S', '=', '8', '\x00'})), (*int8)(unsafe.Pointer(&[15]int8{'M', 'U', 'T', 'E', 'X', '_', 'P', 'T', 'H', 'R', 'E', 'A', 'D', 'S', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'S', 'Y', 'S', 'T', 'E', 'M', '_', 'M', 'A', 'L', 'L', 'O', 'C', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'T', 'E', 'M', 'P', '_', 'S', 'T', 'O', 'R', 'E', '=', '1', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'T', 'H', 'R', 'E', 'A', 'D', 'S', 'A', 'F', 'E', '=', '1', '\x00'}))}

func sqlite3CompileOptions(pnOpt *int32) **int8 {
	*pnOpt = int32(288 / 8)
	return (**int8)(unsafe.Pointer((**int8)(unsafe.Pointer(&sqlite3azCompileOpt))))
}

var sqlite3UpperToLower [274]uint8 = [274]uint8{uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35), uint8(36), uint8(37), uint8(38), uint8(39), uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47), uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53), uint8(54), uint8(55), uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63), uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103), uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121), uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95), uint8(96), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103), uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121), uint8(122), uint8(123), uint8(124), uint8(125), uint8(126), uint8(127), uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135), uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143), uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151), uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159), uint8(160), uint8(161), uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167), uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175), uint8(176), uint8(177), uint8(178), uint8(179), uint8(180), uint8(181), uint8(182), uint8(183), uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191), uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197), uint8(198), uint8(199), uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207), uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215), uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223), uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231), uint8(232), uint8(233), uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239), uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247), uint8(248), uint8(249), uint8(250), uint8(251), uint8(252), uint8(253), uint8(254), uint8(255), uint8(1), uint8(0), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0), uint8(1), uint8(0), uint8(1), uint8(0), uint8(1), uint8(1), uint8(0), uint8(1), uint8(0), uint8(0), uint8(1)}
var sqlite3aLTb *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(256-52)))
var sqlite3aEQb *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(256+6-52)))
var sqlite3aGTb *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(256+12-52)))
var sqlite3CtypeMap [256]uint8 = [256]uint8{uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(0), uint8(128), uint8(0), uint8(64), uint8(0), uint8(0), uint8(128), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(12), uint8(12), uint8(12), uint8(12), uint8(12), uint8(12), uint8(12), uint8(12), uint8(12), uint8(12), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(10), uint8(10), uint8(10), uint8(10), uint8(10), uint8(10), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(128), uint8(0), uint8(0), uint8(0), uint8(64), uint8(128), uint8(42), uint8(42), uint8(42), uint8(42), uint8(42), uint8(42), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(34), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64), uint8(64)}
var sqlite3Config struct_Sqlite3Config = struct_Sqlite3Config{1, uint8(1), func() uint8 {
	if 1 == 1 {
		return 1
	} else {
		return 0
	}
}(), uint8(0), uint8(1), uint8(0), uint8(1), 2147483646, 0, 1200, 40, 64 * 1024, struct_sqlite3_mem_methods{nil, nil, nil, nil, nil, nil, nil, nil}, struct_sqlite3_mutex_methods{nil, nil, nil, nil, nil, nil, nil, nil, nil}, struct_sqlite3_pcache_methods2{0, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil}, unsafe.Pointer(0), 0, 0, 0, int64(0), int64(2147418112), unsafe.Pointer(0), 0, 20, 0, 0, uint32(250), 0, 0, 0, 0, 0, 0, nil, nil, nil, int64(1073741824), nil, 0, nil, 2147483646, uint32(2147483647), uint32(0)}
var sqlite3BuiltinFunctions struct_FuncDefHash
var sqlite3PendingByte int32 = 1073741824
var sqlite3SelectTrace uint32 = uint32(0)
var sqlite3WhereTrace uint32 = uint32(0)
var sqlite3OpcodeProperty [185]uint8 = [185]uint8{uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(1), uint8(0), uint8(16), uint8(0), uint8(1), uint8(0), uint8(1), uint8(1), uint8(1), uint8(3), uint8(3), uint8(1), uint8(1), uint8(3), uint8(18), uint8(3), uint8(3), uint8(1), uint8(9), uint8(9), uint8(9), uint8(9), uint8(1), uint8(9), uint8(9), uint8(9), uint8(9), uint8(9), uint8(9), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(38), uint8(38), uint8(35), uint8(11), uint8(1), uint8(1), uint8(3), uint8(3), uint8(3), uint8(11), uint8(11), uint8(11), uint8(11), uint8(11), uint8(11), uint8(1), uint8(3), uint8(3), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(0), uint8(2), uint8(2), uint8(8), uint8(0), uint8(16), uint8(16), uint8(16), uint8(16), uint8(0), uint8(16), uint8(16), uint8(0), uint8(0), uint8(16), uint8(16), uint8(0), uint8(0), uint8(0), uint8(2), uint8(2), uint8(2), uint8(0), uint8(0), uint8(18), uint8(30), uint8(32), uint8(0), uint8(0), uint8(0), uint8(0), uint8(16), uint8(16), uint8(0), uint8(0), uint8(0), uint8(38), uint8(38), uint8(38), uint8(38), uint8(38), uint8(38), uint8(38), uint8(38), uint8(38), uint8(38), uint8(0), uint8(0), uint8(18), uint8(0), uint8(0), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(16), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(16), uint8(0), uint8(0), uint8(4), uint8(4), uint8(0), uint8(0), uint8(16), uint8(0), uint8(16), uint8(0), uint8(0), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(16), uint8(0), uint8(6), uint8(16), uint8(0), uint8(4), uint8(26), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(16), uint8(0), uint8(0), uint8(16), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0)}
var sqlite3StrBINARY [7]int8 = [7]int8{'B', 'I', 'N', 'A', 'R', 'Y', '\x00'}
var sqlite3StdTypeLen [6]uint8 = [6]uint8{uint8(3), uint8(4), uint8(3), uint8(7), uint8(4), uint8(4)}
var sqlite3StdTypeAffinity [6]int8 = [6]int8{int8(67), int8(65), int8(68), int8(68), int8(69), int8(66)}
var sqlite3StdTypeMap [6]int8 = [6]int8{int8(0), int8(4), int8(1), int8(1), int8(2), int8(3)}
var sqlite3StdType [6]*int8 = [6]*int8{(*int8)(unsafe.Pointer(&[4]int8{'A', 'N', 'Y', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'B', 'L', 'O', 'B', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'I', 'N', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'I', 'N', 'T', 'E', 'G', 'E', 'R', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'R', 'E', 'A', 'L', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'T', 'E', 'X', 'T', '\x00'}))}

type Op = struct_VdbeOp
type Bool = uint32
type VdbeSorter = struct_VdbeSorter
type AuxData = struct_AuxData
type VdbeCursor = struct_VdbeCursor
type _cgoa_28 struct {
	pBtx *struct_Btree
}
type _cgoa_29 struct {
	pCursor *struct_BtCursor
}
type struct_VdbeCursor struct {
	eCurType       uint8
	iDb            int8
	nullRow        uint8
	deferredMoveto uint8
	isTable        uint8
	Xbf_0          uint32
	seekHit        uint16
	ub             _cgoa_28
	seqCount       int64
	cacheStatus    uint32
	seekResult     int32
	pAltCursor     *struct_VdbeCursor
	uc             _cgoa_29
	pKeyInfo       *struct_KeyInfo
	iHdrOffset     uint32
	pgnoRoot       uint32
	nField         int16
	nHdrParsed     uint16
	movetoTarget   int64
	aOffset        *uint32
	aRow           *uint8
	payloadSize    uint32
	szRow          uint32
	aType          [1]uint32
}
type VdbeFrame = struct_VdbeFrame
type struct_VdbeFrame struct {
	v         *struct_Vdbe
	pParent   *struct_VdbeFrame
	aOp       *struct_VdbeOp
	anExec    *int64
	aMem      *struct_sqlite3_value
	apCsr     **struct_VdbeCursor
	aOnce     *uint8
	token     unsafe.Pointer
	lastRowid int64
	pAuxData  *struct_AuxData
	nCursor   int32
	pc        int32
	nOp       int32
	nMem      int32
	nChildMem int32
	nChildCsr int32
	nChange   int64
	nDbChange int64
}
type union_MemValue struct {
	r float64
}
type struct_sqlite3_value struct {
	u        union_MemValue
	flags    uint16
	enc      uint8
	eSubtype uint8
	n        int32
	z        *int8
	zMalloc  *int8
	szMalloc int32
	uTemp    uint32
	db       *struct_sqlite3
	xDel     func(unsafe.Pointer)
}
type struct_AuxData struct {
	iAuxOp     int32
	iAuxArg    int32
	pAux       unsafe.Pointer
	xDeleteAux func(unsafe.Pointer)
	pNextAux   *struct_AuxData
}
type struct_sqlite3_context struct {
	pOut     *struct_sqlite3_value
	pFunc    *struct_FuncDef
	pMem     *struct_sqlite3_value
	pVdbe    *struct_Vdbe
	iOp      int32
	isError  int32
	skipFlag uint8
	argc     uint8
	argv     [1]*struct_sqlite3_value
}
type bft = uint32
type ScanStatus = struct_ScanStatus
type struct_ScanStatus struct {
	addrExplain int32
	addrLoop    int32
	addrVisit   int32
	iSelectID   int32
	nEst        int16
	zName       *int8
}
type DblquoteStr = struct_DblquoteStr
type struct_DblquoteStr struct {
	pNextStr *struct_DblquoteStr
	z        [8]int8
}
type struct_Vdbe struct {
	db                 *struct_sqlite3
	pPrev              *struct_Vdbe
	pNext              *struct_Vdbe
	pParse             *struct_Parse
	nVar               int16
	iVdbeMagic         uint32
	nMem               int32
	nCursor            int32
	cacheCtr           uint32
	pc                 int32
	rc                 int32
	nChange            int64
	iStatement         int32
	iCurrentTime       int64
	nFkConstraint      int64
	nStmtDefCons       int64
	nStmtDefImmCons    int64
	aMem               *struct_sqlite3_value
	apArg              **struct_sqlite3_value
	apCsr              **struct_VdbeCursor
	aVar               *struct_sqlite3_value
	aOp                *struct_VdbeOp
	nOp                int32
	nOpAlloc           int32
	aColName           *struct_sqlite3_value
	pResultSet         *struct_sqlite3_value
	zErrMsg            *int8
	pVList             *int32
	startTime          int64
	nResColumn         uint16
	errorAction        uint8
	minWriteFileFormat uint8
	prepFlags          uint8
	doingRerun         uint8
	Xbf_0              uint32
	btreeMask          uint32
	lockMask           uint32
	aCounter           [9]uint32
	zSql               *int8
	pFree              unsafe.Pointer
	pFrame             *struct_VdbeFrame
	pDelFrame          *struct_VdbeFrame
	nFrame             int32
	expmask            uint32
	pProgram           *struct_SubProgram
	pAuxData           *struct_AuxData
}
type struct_PreUpdate struct {
	v            *struct_Vdbe
	pCsr         *struct_VdbeCursor
	op           int32
	aRecord      *uint8
	keyinfo      struct_KeyInfo
	pUnpacked    *struct_UnpackedRecord
	pNewUnpacked *struct_UnpackedRecord
	iNewReg      int32
	iBlobWrite   int32
	iKey1        int64
	iKey2        int64
	aNew         *struct_sqlite3_value
	pTab         *struct_Table
	pPk          *struct_Index
}
type ValueList = struct_ValueList
type struct_ValueList struct {
	pCsr *struct_BtCursor
	pOut *struct_sqlite3_value
}
type sqlite3StatValueType = int64
type sqlite3StatType = struct_sqlite3StatType
type struct_sqlite3StatType struct {
	nowValue [10]int64
	mxValue  [10]int64
}

var sqlite3Stat struct_sqlite3StatType = struct_sqlite3StatType{[10]int64{int64(0)}, [10]int64{int64(0)}}
var statMutex [10]int8 = [10]int8{int8(0), int8(1), int8(1), int8(0), int8(0), int8(0), int8(0), int8(1), int8(0), int8(0)}

func sqlite3StatusValue(op int32) int64 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8))
}
func sqlite3StatusUp(op int32, N int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8)) += int64(N)
	if *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8)) > *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.mxValue)))) + uintptr(op)*8)) {
		*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.mxValue)))) + uintptr(op)*8)) = *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8))
	}
}
func sqlite3StatusDown(op int32, N int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8)) -= int64(N)
}
func sqlite3StatusHighwater(op int32, X int32) {
	var newValue int64
	func() int {
		_ = 0
		return 0
	}()
	newValue = int64(X)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if newValue > *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.mxValue)))) + uintptr(op)*8)) {
		*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.mxValue)))) + uintptr(op)*8)) = newValue
	}
}
func sqlite3_status64(op int32, pCurrent *int64, pHighwater *int64, resetFlag int32) int32 {
	var pMutex *struct_sqlite3_mutex
	if op < 0 || op >= int32(80/8) {
		return sqlite3MisuseError(22808)
	}
	pMutex = func() *struct_sqlite3_mutex {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&statMutex)))) + uintptr(op)))) != 0 {
			return sqlite3Pcache1Mutex()
		} else {
			return sqlite3MallocMutex()
		}
	}()
	sqlite3_mutex_enter(pMutex)
	*pCurrent = *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8))
	*pHighwater = *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.mxValue)))) + uintptr(op)*8))
	if resetFlag != 0 {
		*(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.mxValue)))) + uintptr(op)*8)) = *(*int64)(unsafe.Pointer(uintptr(unsafe.Pointer((*int64)(unsafe.Pointer(&sqlite3Stat.nowValue)))) + uintptr(op)*8))
	}
	sqlite3_mutex_leave(pMutex)
	func() int {
		_ = pMutex
		return 0
	}()
	return int32(0)
}
func sqlite3_status(op int32, pCurrent *int32, pHighwater *int32, resetFlag int32) int32 {
	var iCur int64 = int64(0)
	var iHwtr int64 = int64(0)
	var rc int32
	rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag)
	if rc == 0 {
		*pCurrent = int32(iCur)
		*pHighwater = int32(iHwtr)
	}
	return rc
}
func countLookasideSlots(p *struct_LookasideSlot) uint32 {
	var cnt uint32 = uint32(0)
	for p != nil {
		p = p.pNext
		cnt++
	}
	return cnt
}
func sqlite3LookasideUsed(db *struct_sqlite3, pHighwater *int32) int32 {
	var nInit uint32 = countLookasideSlots(db.lookaside.pInit)
	var nFree uint32 = countLookasideSlots(db.lookaside.pFree)
	nInit += countLookasideSlots(db.lookaside.pSmallInit)
	nFree += countLookasideSlots(db.lookaside.pSmallFree)
	if pHighwater != nil {
		*pHighwater = int32(db.lookaside.nSlot - nInit)
	}
	return int32(db.lookaside.nSlot - (nInit + nFree))
}
func sqlite3_db_status(db *struct_sqlite3, op int32, pCurrent *int32, pHighwater *int32, resetFlag int32) int32 {
	var rc int32 = 0
	sqlite3_mutex_enter(db.mutex)
	switch op {
	case 0:
		{
			*pCurrent = sqlite3LookasideUsed(db, pHighwater)
			if resetFlag != 0 {
				var p *struct_LookasideSlot = db.lookaside.pFree
				if p != nil {
					for p.pNext != nil {
						p = p.pNext
					}
					p.pNext = db.lookaside.pInit
					db.lookaside.pInit = db.lookaside.pFree
					db.lookaside.pFree = (*struct_LookasideSlot)(nil)
				}
				p = db.lookaside.pSmallFree
				if p != nil {
					for p.pNext != nil {
						p = p.pNext
					}
					p.pNext = db.lookaside.pSmallInit
					db.lookaside.pSmallInit = db.lookaside.pSmallFree
					db.lookaside.pSmallFree = (*struct_LookasideSlot)(nil)
				}
			}
			break
		}
	case 4:
		fallthrough
	case 5:
		fallthrough
	case 6:
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			*pCurrent = int32(0)
			*pHighwater = int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(op-4)*4)))
			if resetFlag != 0 {
				*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(op-4)*4)) = uint32(0)
			}
			break
		}
	case 11:
		fallthrough
	case 1:
		{
			var totalUsed int32 = 0
			var i int32
			sqlite3BtreeEnterAll(db)
			for i = int32(0); i < db.nDb; i++ {
				var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
				if pBt != nil {
					var pPager *struct_Pager = sqlite3BtreePager(pBt)
					var nByte int32 = sqlite3PagerMemUsed(pPager)
					if op == 11 {
						nByte = nByte / sqlite3BtreeConnectionCount(pBt)
					}
					totalUsed += nByte
				}
			}
			sqlite3BtreeLeaveAll(db)
			*pCurrent = totalUsed
			*pHighwater = int32(0)
			break
		}
	case 2:
		{
			var i int32
			var nByte int32 = 0
			sqlite3BtreeEnterAll(db)
			db.pnBytesFreed = &nByte
			for i = int32(0); i < db.nDb; i++ {
				var pSchema *struct_Schema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema
				if uintptr(unsafe.Pointer(pSchema)) != uintptr(unsafe.Pointer(nil)) {
					var p *struct_HashElem
					nByte += int32(uint32(sqlite3Config.m.xRoundup(int32(32))) * (pSchema.tblHash.count + pSchema.trigHash.count + pSchema.idxHash.count + pSchema.fkeyHash.count))
					nByte += int32(sqlite3_msize(unsafe.Pointer(pSchema.tblHash.ht)))
					nByte += int32(sqlite3_msize(unsafe.Pointer(pSchema.trigHash.ht)))
					nByte += int32(sqlite3_msize(unsafe.Pointer(pSchema.idxHash.ht)))
					nByte += int32(sqlite3_msize(unsafe.Pointer(pSchema.fkeyHash.ht)))
					for p = (&pSchema.trigHash).first; p != nil; p = p.next {
						sqlite3DeleteTrigger(db, (*struct_Trigger)(p.data))
					}
					for p = (&pSchema.tblHash).first; p != nil; p = p.next {
						sqlite3DeleteTable(db, (*struct_Table)(p.data))
					}
				}
			}
			db.pnBytesFreed = (*int32)(nil)
			sqlite3BtreeLeaveAll(db)
			*pHighwater = int32(0)
			*pCurrent = nByte
			break
		}
	case 3:
		{
			var pVdbe *struct_Vdbe
			var nByte int32 = 0
			db.pnBytesFreed = &nByte
			for pVdbe = db.pVdbe; pVdbe != nil; pVdbe = pVdbe.pNext {
				sqlite3VdbeClearObject(db, pVdbe)
				sqlite3DbFree(db, unsafe.Pointer(pVdbe))
			}
			db.pnBytesFreed = (*int32)(nil)
			*pHighwater = int32(0)
			*pCurrent = nByte
			break
		}
	case 12:
		op = int32(9 + 1)
	case 7:
		fallthrough
	case 8:
		fallthrough
	case 9:
		{
			var i int32
			var nRet int32 = 0
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < db.nDb; i++ {
				if (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt != nil {
					var pPager *struct_Pager = sqlite3BtreePager((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt)
					sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet)
				}
			}
			*pHighwater = int32(0)
			*pCurrent = nRet
			break
		}
	case 10:
		{
			*pHighwater = int32(0)
			*pCurrent = func() int32 {
				if db.nDeferredImmCons > int64(0) || db.nDeferredCons > int64(0) {
					return 1
				} else {
					return 0
				}
			}()
			break
		}
	default:
		{
			rc = int32(1)
		}
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}

type clock_t = uint
type time_t = int
type struct_timespec struct {
	tv_sec  int
	tv_nsec int
}
type struct_tm struct {
	tm_sec    int32
	tm_min    int32
	tm_hour   int32
	tm_mday   int32
	tm_mon    int32
	tm_year   int32
	tm_wday   int32
	tm_yday   int32
	tm_isdst  int32
	tm_gmtoff int
	tm_zone   *int8
}

const (
	_CLOCK_REALTIME             int32 = 0
	_CLOCK_MONOTONIC            int32 = 6
	_CLOCK_MONOTONIC_RAW        int32 = 4
	_CLOCK_MONOTONIC_RAW_APPROX int32 = 5
	_CLOCK_UPTIME_RAW           int32 = 8
	_CLOCK_UPTIME_RAW_APPROX    int32 = 9
	_CLOCK_PROCESS_CPUTIME_ID   int32 = 12
	_CLOCK_THREAD_CPUTIME_ID    int32 = 16
)

type clockid_t = int32
type DateTime = struct_DateTime
type struct_DateTime struct {
	iJD      int64
	Y        int32
	M        int32
	D        int32
	h        int32
	m        int32
	tz       int32
	s        float64
	validJD  int8
	rawS     int8
	validYMD int8
	validHMS int8
	validTZ  int8
	tzSet    int8
	isError  int8
}

func getDigits(zDate *int8, zFormat *int8, __cgo_args ...interface {
}) int32 {
	var aMx [6]uint16 = [6]uint16{uint16(12), uint16(14), uint16(24), uint16(31), uint16(59), uint16(9999)}
	var cnt int32 = 0
	var nextC int8
	for {
		var N int8 = int8(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFormat)) + uintptr(0)))) - '0')
		var min int8 = int8(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFormat)) + uintptr(1)))) - '0')
		var val int32 = 0
		var max uint16
		func() int {
			_ = 0
			return 0
		}()
		max = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aMx)))) + uintptr(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFormat)) + uintptr(2))))-'a')*2))
		nextC = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFormat)) + uintptr(3)))
		val = int32(0)
		for func() (_cgo_ret int8) {
			_cgo_addr := &N
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}() != 0 {
			if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zDate)))))&4 != 0) {
				goto end_getDigits
			}
			val = val*10 + int32(*zDate) - '0'
			*(*uintptr)(unsafe.Pointer(&zDate))++
		}
		if val < int32(min) || val > int32(max) || int32(nextC) != 0 && int32(nextC) != int32(*zDate) {
			goto end_getDigits
		}
		*func() (_cgo_ret *int32) {
			_cgo_ret = __cgo_args[0].(*int32)
			__cgo_args = __cgo_args[1:]
			return
		}() = val
		*(*uintptr)(unsafe.Pointer(&zDate))++
		cnt++
		*(*uintptr)(unsafe.Pointer(&zFormat)) += uintptr(4)
		if !(nextC != 0) {
			break
		}
	}
end_getDigits:
	return cnt
}
func parseTimezone(zDate *int8, p *struct_DateTime) int32 {
	var sgn int32 = 0
	var nHr int32
	var nMn int32
	var c int32
	for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zDate)))))&1 != 0 {
		*(*uintptr)(unsafe.Pointer(&zDate))++
	}
	p.tz = int32(0)
	c = int32(*zDate)
	if c == '-' {
		sgn = int32(-1)
	} else if c == '+' {
		sgn = int32(1)
	} else if c == 'Z' || c == 'z' {
		*(*uintptr)(unsafe.Pointer(&zDate))++
		goto zulu_time
	} else {
		return func() int32 {
			if c != 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	*(*uintptr)(unsafe.Pointer(&zDate))++
	if getDigits(zDate, (*int8)(unsafe.Pointer(&[8]int8{'2', '0', 'b', ':', '2', '0', 'e', '\x00'})), &nHr, &nMn) != 2 {
		return int32(1)
	}
	*(*uintptr)(unsafe.Pointer(&zDate)) += uintptr(5)
	p.tz = sgn * (nMn + nHr*60)
zulu_time:
	for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zDate)))))&1 != 0 {
		*(*uintptr)(unsafe.Pointer(&zDate))++
	}
	p.tzSet = int8(1)
	return func() int32 {
		if int32(*zDate) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func parseHhMmSs(zDate *int8, p *struct_DateTime) int32 {
	var h int32
	var m int32
	var s int32
	var ms float64 = 0
	if getDigits(zDate, (*int8)(unsafe.Pointer(&[8]int8{'2', '0', 'c', ':', '2', '0', 'e', '\x00'})), &h, &m) != 2 {
		return int32(1)
	}
	*(*uintptr)(unsafe.Pointer(&zDate)) += uintptr(5)
	if int32(*zDate) == ':' {
		*(*uintptr)(unsafe.Pointer(&zDate))++
		if getDigits(zDate, (*int8)(unsafe.Pointer(&[4]int8{'2', '0', 'e', '\x00'})), &s) != 1 {
			return int32(1)
		}
		*(*uintptr)(unsafe.Pointer(&zDate)) += uintptr(2)
		if int32(*zDate) == '.' && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDate)) + uintptr(1))))))))&4 != 0 {
			var rScale float64 = 1
			*(*uintptr)(unsafe.Pointer(&zDate))++
			for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zDate)))))&4 != 0 {
				ms = ms*10 + float64(int32(*zDate)) - float64('0')
				rScale *= float64(10)
				*(*uintptr)(unsafe.Pointer(&zDate))++
			}
			ms /= rScale
		}
	} else {
		s = int32(0)
	}
	p.validJD = int8(0)
	p.rawS = int8(0)
	p.validHMS = int8(1)
	p.h = h
	p.m = m
	p.s = float64(s) + ms
	if parseTimezone(zDate, p) != 0 {
		return int32(1)
	}
	p.validTZ = int8(func() int32 {
		if p.tz != 0 {
			return 1
		} else {
			return 0
		}
	}())
	return int32(0)
}
func datetimeError(p *struct_DateTime) {
	__builtin___memset_chk(unsafe.Pointer(p), 0, 47, __builtin_object_size(unsafe.Pointer(p), 0))
	p.isError = int8(1)
}
func computeJD(p *struct_DateTime) {
	var Y int32
	var M int32
	var D int32
	var A int32
	var B int32
	var X1 int32
	var X2 int32
	if p.validJD != 0 {
		return
	}
	if p.validYMD != 0 {
		Y = p.Y
		M = p.M
		D = p.D
	} else {
		Y = int32(2000)
		M = int32(1)
		D = int32(1)
	}
	if Y < -4713 || Y > 9999 || int32(p.rawS) != 0 {
		datetimeError(p)
		return
	}
	if M <= 2 {
		Y--
		M += int32(12)
	}
	A = Y / 100
	B = 2 - A + A/4
	X1 = 36525 * (Y + 4716) / 100
	X2 = 306001 * (M + 1) / 10000
	p.iJD = int64((float64(X1+X2+D+B) - 1524.5) * float64(86400000))
	p.validJD = int8(1)
	if p.validHMS != 0 {
		p.iJD += int64(p.h*3600000+p.m*60000) + int64(p.s*float64(1000))
		if p.validTZ != 0 {
			p.iJD -= int64(p.tz * 60000)
			p.validYMD = int8(0)
			p.validHMS = int8(0)
			p.validTZ = int8(0)
		}
	}
}
func parseYyyyMmDd(zDate *int8, p *struct_DateTime) int32 {
	var Y int32
	var M int32
	var D int32
	var neg int32
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDate)) + uintptr(0)))) == '-' {
		*(*uintptr)(unsafe.Pointer(&zDate))++
		neg = int32(1)
	} else {
		neg = int32(0)
	}
	if getDigits(zDate, (*int8)(unsafe.Pointer(&[12]int8{'4', '0', 'f', '-', '2', '1', 'a', '-', '2', '1', 'd', '\x00'})), &Y, &M, &D) != 3 {
		return int32(1)
	}
	*(*uintptr)(unsafe.Pointer(&zDate)) += uintptr(10)
	for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zDate)))))&1 != 0 || 'T' == int32(*(*uint8)(unsafe.Pointer(zDate))) {
		*(*uintptr)(unsafe.Pointer(&zDate))++
	}
	if parseHhMmSs(zDate, p) == 0 {
	} else if int32(*zDate) == 0 {
		p.validHMS = int8(0)
	} else {
		return int32(1)
	}
	p.validJD = int8(0)
	p.validYMD = int8(1)
	p.Y = func() int32 {
		if neg != 0 {
			return -Y
		} else {
			return Y
		}
	}()
	p.M = M
	p.D = D
	if p.validTZ != 0 {
		computeJD(p)
	}
	return int32(0)
}
func setDateTimeToCurrent(context *struct_sqlite3_context, p *struct_DateTime) int32 {
	p.iJD = sqlite3StmtCurrentTime(context)
	if p.iJD > int64(0) {
		p.validJD = int8(1)
		return int32(0)
	} else {
		return int32(1)
	}
}
func setRawDateNumber(p *struct_DateTime, r float64) {
	p.s = r
	p.rawS = int8(1)
	if r >= 0 && r < 5373484.5 {
		p.iJD = int64(r*8.64e+7 + 0.5)
		p.validJD = int8(1)
	}
}
func parseDateOrTime(context *struct_sqlite3_context, zDate *int8, p *struct_DateTime) int32 {
	var r float64
	if parseYyyyMmDd(zDate, p) == 0 {
		return int32(0)
	} else if parseHhMmSs(zDate, p) == 0 {
		return int32(0)
	} else if sqlite3StrICmp(zDate, (*int8)(unsafe.Pointer(&[4]int8{'n', 'o', 'w', '\x00'}))) == 0 && sqlite3NotPureFunc(context) != 0 {
		return setDateTimeToCurrent(context, p)
	} else if sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), uint8(1)) > 0 {
		setRawDateNumber(p, r)
		return int32(0)
	}
	return int32(1)
}
func validJulianDay(iJD int64) int32 {
	return func() int32 {
		if iJD >= int64(0) && iJD <= int64(108096)<<32|int64(275971583) {
			return 1
		} else {
			return 0
		}
	}()
}
func computeYMD(p *struct_DateTime) {
	var Z int32
	var A int32
	var B int32
	var C int32
	var D int32
	var E int32
	var X1 int32
	if p.validYMD != 0 {
		return
	}
	if !(p.validJD != 0) {
		p.Y = int32(2000)
		p.M = int32(1)
		p.D = int32(1)
	} else if !(validJulianDay(p.iJD) != 0) {
		datetimeError(p)
		return
	} else {
		Z = int32((p.iJD + int64(43200000)) / int64(86400000))
		A = int32((float64(Z) - 1867216.25) / 36524.25)
		A = Z + 1 + A - A/4
		B = A + 1524
		C = int32((float64(B) - 122.09999999999999) / 365.25)
		D = 36525 * (C & 32767) / 100
		E = int32(float64(B-D) / 30.600100000000001)
		X1 = int32(30.600100000000001 * float64(E))
		p.D = B - D - X1
		p.M = func() int32 {
			if E < 14 {
				return E - 1
			} else {
				return E - 13
			}
		}()
		p.Y = func() int32 {
			if p.M > 2 {
				return C - 4716
			} else {
				return C - 4715
			}
		}()
	}
	p.validYMD = int8(1)
}
func computeHMS(p *struct_DateTime) {
	var s int32
	if p.validHMS != 0 {
		return
	}
	computeJD(p)
	s = int32((p.iJD + int64(43200000)) % int64(86400000))
	p.s = float64(s) / 1000
	s = int32(p.s)
	p.s -= float64(s)
	p.h = s / 3600
	s -= p.h * 3600
	p.m = s / 60
	p.s += float64(s - p.m*60)
	p.rawS = int8(0)
	p.validHMS = int8(1)
}
func computeYMD_HMS(p *struct_DateTime) {
	computeYMD(p)
	computeHMS(p)
}
func clearYMD_HMS_TZ(p *struct_DateTime) {
	p.validYMD = int8(0)
	p.validHMS = int8(0)
	p.validTZ = int8(0)
}
func osLocaltime(t *int, pTm *struct_tm) int32 {
	var rc int32
	var pX *struct_tm
	var mutex *struct_sqlite3_mutex = sqlite3MutexAlloc(2)
	sqlite3_mutex_enter(mutex)
	pX = localtime(t)
	if sqlite3Config.bLocaltimeFault != 0 {
		if uintptr(unsafe.Pointer(sqlite3Config.xAltLocaltime)) != uintptr(unsafe.Pointer(nil)) && 0 == sqlite3Config.xAltLocaltime(unsafe.Pointer(t), unsafe.Pointer(pTm)) {
			pX = pTm
		} else {
			pX = (*struct_tm)(nil)
		}
	}
	if pX != nil {
		*pTm = *pX
	}
	sqlite3_mutex_leave(mutex)
	rc = func() int32 {
		if uintptr(unsafe.Pointer(pX)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	return rc
}
func toLocaltime(p *struct_DateTime, pCtx *struct_sqlite3_context) int32 {
	var t int
	var sLocal struct_tm
	var iYearDiff int32
	__builtin___memset_chk(unsafe.Pointer(&sLocal), 0, 56, __builtin_object_size(unsafe.Pointer(&sLocal), 0))
	computeJD(p)
	if p.iJD < int64(2108667600)*int64(100000) || p.iJD > int64(2130141456)*int64(100000) {
		var x struct_DateTime = *p
		computeYMD_HMS(&x)
		iYearDiff = 2000 + x.Y%4 - x.Y
		x.Y += iYearDiff
		x.validJD = int8(0)
		computeJD(&x)
		t = int(x.iJD/int64(1000) - int64(21086676)*int64(10000))
	} else {
		iYearDiff = int32(0)
		t = int(p.iJD/int64(1000) - int64(21086676)*int64(10000))
	}
	if osLocaltime(&t, &sLocal) != 0 {
		sqlite3_result_error(pCtx, (*int8)(unsafe.Pointer(&[23]int8{'l', 'o', 'c', 'a', 'l', ' ', 't', 'i', 'm', 'e', ' ', 'u', 'n', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', '\x00'})), -1)
		return int32(1)
	}
	p.Y = sLocal.tm_year + 1900 - iYearDiff
	p.M = sLocal.tm_mon + 1
	p.D = sLocal.tm_mday
	p.h = sLocal.tm_hour
	p.m = sLocal.tm_min
	p.s = float64(sLocal.tm_sec) + float64(p.iJD%int64(1000))*0.001
	p.validYMD = int8(1)
	p.validHMS = int8(1)
	p.validJD = int8(0)
	p.rawS = int8(0)
	p.validTZ = int8(0)
	p.isError = int8(0)
	return int32(0)
}

type _cgoa_30 struct {
	nName  uint8
	zName  [7]int8
	rLimit float32
	rXform float32
}

var aXformType [6]_cgoa_30 = [6]_cgoa_30{_cgoa_30{uint8(6), [7]int8{'s', 'e', 'c', 'o', 'n', 'd', '\x00'}, float32(4.6427e+14), float32(1)}, _cgoa_30{uint8(6), [7]int8{'m', 'i', 'n', 'u', 't', 'e', '\x00'}, float32(7.7379e+12), float32(60)}, _cgoa_30{uint8(4), [7]int8{'h', 'o', 'u', 'r', '\x00'}, float32(1.2897e+11), float32(3600)}, _cgoa_30{uint8(3), [7]int8{'d', 'a', 'y', '\x00'}, float32(5373485), float32(86400)}, _cgoa_30{uint8(5), [7]int8{'m', 'o', 'n', 't', 'h', '\x00'}, float32(176546), float32(2592000)}, _cgoa_30{uint8(4), [7]int8{'y', 'e', 'a', 'r', '\x00'}, float32(14713), float32(31536000)}}

func parseModifier(pCtx *struct_sqlite3_context, z *int8, n int32, p *struct_DateTime, idx int32) int32 {
	var rc int32 = 1
	var r float64
	switch int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))))))) {
	case 'a':
		{
			if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[5]int8{'a', 'u', 't', 'o', '\x00'}))) == 0 {
				if idx > 1 {
					return int32(1)
				}
				if !(p.rawS != 0) || int32(p.validJD) != 0 {
					rc = int32(0)
					p.rawS = int8(0)
				} else if p.s >= float64(int64(-21086676)*int64(10000)) && p.s <= float64(int64(25340230)*int64(10000)+int64(799)) {
					r = p.s*1000 + 2.1086676e+14
					clearYMD_HMS_TZ(p)
					p.iJD = int64(r + 0.5)
					p.validJD = int8(1)
					p.rawS = int8(0)
					rc = int32(0)
				}
			}
			break
		}
	case 'j':
		{
			if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[10]int8{'j', 'u', 'l', 'i', 'a', 'n', 'd', 'a', 'y', '\x00'}))) == 0 {
				if idx > 1 {
					return int32(1)
				}
				if int32(p.validJD) != 0 && int32(p.rawS) != 0 {
					rc = int32(0)
					p.rawS = int8(0)
				}
			}
			break
		}
	case 'l':
		{
			if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[10]int8{'l', 'o', 'c', 'a', 'l', 't', 'i', 'm', 'e', '\x00'}))) == 0 && sqlite3NotPureFunc(pCtx) != 0 {
				rc = toLocaltime(p, pCtx)
			}
			break
		}
	case 'u':
		{
			if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[10]int8{'u', 'n', 'i', 'x', 'e', 'p', 'o', 'c', 'h', '\x00'}))) == 0 && int32(p.rawS) != 0 {
				if idx > 1 {
					return int32(1)
				}
				r = p.s*1000 + 2.1086676e+14
				if r >= 0 && r < 4.642690608e+14 {
					clearYMD_HMS_TZ(p)
					p.iJD = int64(r + 0.5)
					p.validJD = int8(1)
					p.rawS = int8(0)
					rc = int32(0)
				}
			} else if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[4]int8{'u', 't', 'c', '\x00'}))) == 0 && sqlite3NotPureFunc(pCtx) != 0 {
				if int32(p.tzSet) == 0 {
					var iOrigJD int64
					var iGuess int64
					var cnt int32 = 0
					var iErr int32
					computeJD(p)
					iGuess = func() (_cgo_ret int64) {
						_cgo_addr := &iOrigJD
						*_cgo_addr = p.iJD
						return *_cgo_addr
					}()
					iErr = int32(0)
					for {
						var new struct_DateTime
						__builtin___memset_chk(unsafe.Pointer(&new), 0, 47, __builtin_object_size(unsafe.Pointer(&new), 0))
						iGuess -= int64(iErr)
						new.iJD = iGuess
						new.validJD = int8(1)
						rc = toLocaltime(&new, pCtx)
						if rc != 0 {
							return rc
						}
						computeJD(&new)
						iErr = int32(new.iJD - iOrigJD)
						if !(iErr != 0 && func() (_cgo_ret int32) {
							_cgo_addr := &cnt
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}() < 3) {
							break
						}
					}
					__builtin___memset_chk(unsafe.Pointer(p), 0, 47, __builtin_object_size(unsafe.Pointer(p), 0))
					p.iJD = iGuess
					p.validJD = int8(1)
					p.tzSet = int8(1)
				}
				rc = int32(0)
			}
			break
		}
	case 'w':
		{
			if sqlite3_strnicmp(z, (*int8)(unsafe.Pointer(&[9]int8{'w', 'e', 'e', 'k', 'd', 'a', 'y', ' ', '\x00'})), 8) == 0 && sqlite3AtoF(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(8))), &r, sqlite3Strlen30(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(8)))), uint8(1)) > 0 && float64(func() (_cgo_ret int32) {
				_cgo_addr := &n
				*_cgo_addr = int32(r)
				return *_cgo_addr
			}()) == r && n >= 0 && r < float64(7) {
				var Z int64
				computeYMD_HMS(p)
				p.validTZ = int8(0)
				p.validJD = int8(0)
				computeJD(p)
				Z = (p.iJD + int64(129600000)) / int64(86400000) % int64(7)
				if Z > int64(n) {
					Z -= int64(7)
				}
				p.iJD += (int64(n) - Z) * int64(86400000)
				clearYMD_HMS_TZ(p)
				rc = int32(0)
			}
			break
		}
	case 's':
		{
			if sqlite3_strnicmp(z, (*int8)(unsafe.Pointer(&[10]int8{'s', 't', 'a', 'r', 't', ' ', 'o', 'f', ' ', '\x00'})), 9) != 0 {
				break
			}
			if !(p.validJD != 0) && !(p.validYMD != 0) && !(p.validHMS != 0) {
				break
			}
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(9)
			computeYMD(p)
			p.validHMS = int8(1)
			p.h = func() (_cgo_ret int32) {
				_cgo_addr := &p.m
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
			p.s = float64(0)
			p.rawS = int8(0)
			p.validTZ = int8(0)
			p.validJD = int8(0)
			if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[6]int8{'m', 'o', 'n', 't', 'h', '\x00'}))) == 0 {
				p.D = int32(1)
				rc = int32(0)
			} else if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[5]int8{'y', 'e', 'a', 'r', '\x00'}))) == 0 {
				p.M = int32(1)
				p.D = int32(1)
				rc = int32(0)
			} else if sqlite3_stricmp(z, (*int8)(unsafe.Pointer(&[4]int8{'d', 'a', 'y', '\x00'}))) == 0 {
				rc = int32(0)
			}
			break
		}
	case '+':
		fallthrough
	case '-':
		fallthrough
	case '0':
		fallthrough
	case '1':
		fallthrough
	case '2':
		fallthrough
	case '3':
		fallthrough
	case '4':
		fallthrough
	case '5':
		fallthrough
	case '6':
		fallthrough
	case '7':
		fallthrough
	case '8':
		fallthrough
	case '9':
		{
			var rRounder float64
			var i int32
			for n = int32(1); int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n)))) != ':' && !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n))))))))&1 != 0); n++ {
			}
			if sqlite3AtoF(z, &r, n, uint8(1)) <= 0 {
				rc = int32(1)
				break
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n)))) == ':' {
				var z2 *int8 = z
				var tx struct_DateTime
				var day int64
				if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z2)))))&4 != 0) {
					*(*uintptr)(unsafe.Pointer(&z2))++
				}
				__builtin___memset_chk(unsafe.Pointer(&tx), 0, 47, __builtin_object_size(unsafe.Pointer(&tx), 0))
				if parseHhMmSs(z2, &tx) != 0 {
					break
				}
				computeJD(&tx)
				tx.iJD -= int64(43200000)
				day = tx.iJD / int64(86400000)
				tx.iJD -= day * int64(86400000)
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) == '-' {
					tx.iJD = -tx.iJD
				}
				computeJD(p)
				clearYMD_HMS_TZ(p)
				p.iJD += tx.iJD
				rc = int32(0)
				break
			}
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(n)
			for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&1 != 0 {
				*(*uintptr)(unsafe.Pointer(&z))++
			}
			n = sqlite3Strlen30(z)
			if n > 10 || n < 3 {
				break
			}
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n-1)))))))) == 's' {
				n--
			}
			computeJD(p)
			rc = int32(1)
			rRounder = func() float64 {
				if r < float64(0) {
					return -0.5
				} else {
					return 0.5
				}
			}()
			for i = int32(0); i < int32(96/16); i++ {
				if int32((*(*_cgoa_30)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_30)(unsafe.Pointer(&aXformType)))) + uintptr(i)*16))).nName) == n && sqlite3_strnicmp((*int8)(unsafe.Pointer(&(*(*_cgoa_30)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_30)(unsafe.Pointer(&aXformType)))) + uintptr(i)*16))).zName)), z, n) == 0 && r > float64(-(*(*_cgoa_30)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_30)(unsafe.Pointer(&aXformType)))) + uintptr(i)*16))).rLimit) && r < float64((*(*_cgoa_30)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_30)(unsafe.Pointer(&aXformType)))) + uintptr(i)*16))).rLimit) {
					switch i {
					case 4:
						{
							var x int32
							func() int {
								_ = 0
								return 0
							}()
							computeYMD_HMS(p)
							p.M += int32(r)
							x = func() int32 {
								if p.M > 0 {
									return (p.M - 1) / 12
								} else {
									return (p.M - 12) / 12
								}
							}()
							p.Y += x
							p.M -= x * 12
							p.validJD = int8(0)
							r -= float64(int32(r))
							break
						}
					case 5:
						{
							var y int32 = int32(r)
							func() int {
								_ = 0
								return 0
							}()
							computeYMD_HMS(p)
							p.Y += y
							p.validJD = int8(0)
							r -= float64(int32(r))
							break
						}
					}
					computeJD(p)
					p.iJD += int64(r*1000*float64((*(*_cgoa_30)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_30)(unsafe.Pointer(&aXformType)))) + uintptr(i)*16))).rXform) + rRounder)
					rc = int32(0)
					break
				}
			}
			clearYMD_HMS_TZ(p)
			break
		}
	default:
		{
			break
		}
	}
	return rc
}
func isDate(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value, p *struct_DateTime) int32 {
	var i int32
	var n int32
	var z *uint8
	var eType int32
	__builtin___memset_chk(unsafe.Pointer(p), 0, 47, __builtin_object_size(unsafe.Pointer(p), 0))
	if argc == 0 {
		if !(sqlite3NotPureFunc(context) != 0) {
			return int32(1)
		}
		return setDateTimeToCurrent(context, p)
	}
	if func() (_cgo_ret int32) {
		_cgo_addr := &eType
		*_cgo_addr = sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		return *_cgo_addr
	}() == 2 || eType == 1 {
		setRawDateNumber(p, sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	} else {
		z = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		if !(z != nil) || parseDateOrTime(context, (*int8)(unsafe.Pointer(z)), p) != 0 {
			return int32(1)
		}
	}
	for i = int32(1); i < argc; i++ {
		z = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))
		n = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))
		if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) || parseModifier(context, (*int8)(unsafe.Pointer(z)), n, p, i) != 0 {
			return int32(1)
		}
	}
	computeJD(p)
	if int32(p.isError) != 0 || !(validJulianDay(p.iJD) != 0) {
		return int32(1)
	}
	return int32(0)
}
func juliandayFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_DateTime
	if isDate(context, argc, argv, &x) == 0 {
		computeJD(&x)
		sqlite3_result_double(context, float64(x.iJD)/8.64e+7)
	}
}
func unixepochFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_DateTime
	if isDate(context, argc, argv, &x) == 0 {
		computeJD(&x)
		sqlite3_result_int64(context, x.iJD/int64(1000)-int64(21086676)*int64(10000))
	}
}
func datetimeFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_DateTime
	if isDate(context, argc, argv, &x) == 0 {
		var Y int32
		var s int32
		var zBuf [24]int8
		computeYMD_HMS(&x)
		Y = x.Y
		if Y < 0 {
			Y = -Y
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(1))) = int8('0' + Y/1000%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(2))) = int8('0' + Y/100%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(3))) = int8('0' + Y/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(4))) = int8('0' + Y%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(5))) = int8('-')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(6))) = int8('0' + x.M/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(7))) = int8('0' + x.M%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(8))) = int8('-')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(9))) = int8('0' + x.D/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(10))) = int8('0' + x.D%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(11))) = int8(' ')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(12))) = int8('0' + x.h/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(13))) = int8('0' + x.h%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(14))) = int8(':')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(15))) = int8('0' + x.m/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(16))) = int8('0' + x.m%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(17))) = int8(':')
		s = int32(x.s)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(18))) = int8('0' + s/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(19))) = int8('0' + s%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(20))) = int8(0)
		if x.Y < 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(0))) = int8('-')
			sqlite3_result_text(context, (*int8)(unsafe.Pointer(&zBuf)), 20, (func(unsafe.Pointer))(-1))
		} else {
			sqlite3_result_text(context, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(1))), 19, (func(unsafe.Pointer))(-1))
		}
	}
}
func timeFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_DateTime
	if isDate(context, argc, argv, &x) == 0 {
		var s int32
		var zBuf [16]int8
		computeHMS(&x)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(0))) = int8('0' + x.h/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(1))) = int8('0' + x.h%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(2))) = int8(':')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(3))) = int8('0' + x.m/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(4))) = int8('0' + x.m%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(5))) = int8(':')
		s = int32(x.s)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(6))) = int8('0' + s/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(7))) = int8('0' + s%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(8))) = int8(0)
		sqlite3_result_text(context, (*int8)(unsafe.Pointer(&zBuf)), 8, (func(unsafe.Pointer))(-1))
	}
}
func dateFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_DateTime
	if isDate(context, argc, argv, &x) == 0 {
		var Y int32
		var zBuf [16]int8
		computeYMD(&x)
		Y = x.Y
		if Y < 0 {
			Y = -Y
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(1))) = int8('0' + Y/1000%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(2))) = int8('0' + Y/100%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(3))) = int8('0' + Y/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(4))) = int8('0' + Y%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(5))) = int8('-')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(6))) = int8('0' + x.M/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(7))) = int8('0' + x.M%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(8))) = int8('-')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(9))) = int8('0' + x.D/10%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(10))) = int8('0' + x.D%10)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(11))) = int8(0)
		if x.Y < 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(0))) = int8('-')
			sqlite3_result_text(context, (*int8)(unsafe.Pointer(&zBuf)), 11, (func(unsafe.Pointer))(-1))
		} else {
			sqlite3_result_text(context, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zBuf)))) + uintptr(1))), 10, (func(unsafe.Pointer))(-1))
		}
	}
}
func strftimeFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_DateTime
	var i uint
	var j uint
	var db *struct_sqlite3
	var zFmt *int8
	var sRes struct_sqlite3_str
	if argc == 0 {
		return
	}
	zFmt = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	if uintptr(unsafe.Pointer(zFmt)) == uintptr(unsafe.Pointer(nil)) || isDate(context, argc-1, (**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv))+uintptr(1)*8)), &x) != 0 {
		return
	}
	db = sqlite3_context_db_handle(context)
	sqlite3StrAccumInit(&sRes, nil, nil, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)))
	computeJD(&x)
	computeYMD_HMS(&x)
	for i = func() (_cgo_ret uint) {
		_cgo_addr := &j
		*_cgo_addr = uint(0)
		return *_cgo_addr
	}(); *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFmt)) + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFmt)) + uintptr(i)))) != '%' {
			continue
		}
		if j < i {
			sqlite3_str_append(&sRes, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFmt))+uintptr(j))), int32(i-j))
		}
		i++
		j = i + uint(1)
		switch int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFmt)) + uintptr(i)))) {
		case 'd':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'd', '\x00'})), x.D)
				break
			}
		case 'f':
			{
				var s float64 = x.s
				if s > 59.999000000000002 {
					s = float64(59.999000000000002)
				}
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[7]int8{'%', '0', '6', '.', '3', 'f', '\x00'})), s)
				break
			}
		case 'H':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'd', '\x00'})), x.h)
				break
			}
		case 'W':
			fallthrough
		case 'j':
			{
				var nDay int32
				var y struct_DateTime = x
				y.validJD = int8(0)
				y.M = int32(1)
				y.D = int32(1)
				computeJD(&y)
				nDay = int32((x.iJD - y.iJD + int64(43200000)) / int64(86400000))
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFmt)) + uintptr(i)))) == 'W' {
					var wd int32
					wd = int32((x.iJD + int64(43200000)) / int64(86400000) % int64(7))
					sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'd', '\x00'})), (nDay+7-wd)/7)
				} else {
					sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '3', 'd', '\x00'})), nDay+1)
				}
				break
			}
		case 'J':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[6]int8{'%', '.', '1', '6', 'g', '\x00'})), float64(x.iJD)/8.64e+7)
				break
			}
		case 'm':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'd', '\x00'})), x.M)
				break
			}
		case 'M':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'd', '\x00'})), x.m)
				break
			}
		case 's':
			{
				var iS int64 = int64(x.iJD/int64(1000) - int64(21086676)*int64(10000))
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', 'l', 'l', 'd', '\x00'})), iS)
				break
			}
		case 'S':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'd', '\x00'})), int32(x.s))
				break
			}
		case 'w':
			{
				sqlite3_str_appendchar(&sRes, 1, int8(int32(int8((x.iJD+int64(129600000))/int64(86400000)%int64(7)))+'0'))
				break
			}
		case 'Y':
			{
				sqlite3_str_appendf(&sRes, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '4', 'd', '\x00'})), x.Y)
				break
			}
		case '%':
			{
				sqlite3_str_appendchar(&sRes, 1, int8('%'))
				break
			}
		default:
			{
				sqlite3_str_reset(&sRes)
				return
			}
		}
	}
	if j < i {
		sqlite3_str_append(&sRes, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFmt))+uintptr(j))), int32(i-j))
	}
	sqlite3ResultStrAccum(context, &sRes)
}
func ctimeFunc(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	timeFunc(context, 0, nil)
}
func cdateFunc(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	dateFunc(context, 0, nil)
}
func ctimestampFunc(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	datetimeFunc(context, 0, nil)
}
func sqlite3RegisterDateTimeFunctions() {
	var aDateTimeFuncs [9]struct_FuncDef = [9]struct_FuncDef{struct_FuncDef{int8(-1), uint32(8388608 | 8192 | 1 | 2048), unsafe.Pointer(&sqlite3Config), nil, juliandayFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'j', 'u', 'l', 'i', 'a', 'n', 'd', 'a', 'y', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 8192 | 1 | 2048), unsafe.Pointer(&sqlite3Config), nil, unixepochFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'u', 'n', 'i', 'x', 'e', 'p', 'o', 'c', 'h', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 8192 | 1 | 2048), unsafe.Pointer(&sqlite3Config), nil, dateFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'d', 'a', 't', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 8192 | 1 | 2048), unsafe.Pointer(&sqlite3Config), nil, timeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'t', 'i', 'm', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 8192 | 1 | 2048), unsafe.Pointer(&sqlite3Config), nil, datetimeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'d', 'a', 't', 'e', 't', 'i', 'm', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 8192 | 1 | 2048), unsafe.Pointer(&sqlite3Config), nil, strftimeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'s', 't', 'r', 'f', 't', 'i', 'm', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 8192 | 1), nil, nil, ctimeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[13]int8{'c', 'u', 'r', 'r', 'e', 'n', 't', '_', 't', 'i', 'm', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 8192 | 1), nil, nil, ctimestampFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[18]int8{'c', 'u', 'r', 'r', 'e', 'n', 't', '_', 't', 'i', 'm', 'e', 's', 't', 'a', 'm', 'p', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 8192 | 1), nil, nil, cdateFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[13]int8{'c', 'u', 'r', 'r', 'e', 'n', 't', '_', 'd', 'a', 't', 'e', '\x00'})), _cgoa_9{nil}}}
	sqlite3InsertBuiltinFuncs((*struct_FuncDef)(unsafe.Pointer(&aDateTimeFuncs)), int32(648/72))
}
func sqlite3OsClose(pId *struct_sqlite3_file) {
	if pId.pMethods != nil {
		pId.pMethods.xClose(pId)
		pId.pMethods = (*struct_sqlite3_io_methods)(nil)
	}
}
func sqlite3OsRead(id *struct_sqlite3_file, pBuf unsafe.Pointer, amt int32, offset int64) int32 {
	return id.pMethods.xRead(id, pBuf, amt, offset)
}
func sqlite3OsWrite(id *struct_sqlite3_file, pBuf unsafe.Pointer, amt int32, offset int64) int32 {
	return id.pMethods.xWrite(id, pBuf, amt, offset)
}
func sqlite3OsTruncate(id *struct_sqlite3_file, size int64) int32 {
	return id.pMethods.xTruncate(id, size)
}
func sqlite3OsSync(id *struct_sqlite3_file, flags int32) int32 {
	return func() int32 {
		if flags != 0 {
			return id.pMethods.xSync(id, flags)
		} else {
			return 0
		}
	}()
}
func sqlite3OsFileSize(id *struct_sqlite3_file, pSize *int64) int32 {
	return id.pMethods.xFileSize(id, pSize)
}
func sqlite3OsLock(id *struct_sqlite3_file, lockType int32) int32 {
	return id.pMethods.xLock(id, lockType)
}
func sqlite3OsUnlock(id *struct_sqlite3_file, lockType int32) int32 {
	return id.pMethods.xUnlock(id, lockType)
}
func sqlite3OsCheckReservedLock(id *struct_sqlite3_file, pResOut *int32) int32 {
	return id.pMethods.xCheckReservedLock(id, pResOut)
}
func sqlite3OsFileControl(id *struct_sqlite3_file, op int32, pArg unsafe.Pointer) int32 {
	if uintptr(unsafe.Pointer(id.pMethods)) == uintptr(unsafe.Pointer(nil)) {
		return int32(12)
	}
	return id.pMethods.xFileControl(id, op, pArg)
}
func sqlite3OsFileControlHint(id *struct_sqlite3_file, op int32, pArg unsafe.Pointer) {
	if id.pMethods != nil {
		func() int {
			_ = id.pMethods.xFileControl(id, op, pArg)
			return 0
		}()
	}
}
func sqlite3OsSectorSize(id *struct_sqlite3_file) int32 {
	var xSectorSize func(*struct_sqlite3_file) int32 = id.pMethods.xSectorSize
	return func() int32 {
		if xSectorSize != nil {
			return xSectorSize(id)
		} else {
			return 4096
		}
	}()
}
func sqlite3OsDeviceCharacteristics(id *struct_sqlite3_file) int32 {
	if uintptr(unsafe.Pointer(id.pMethods)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	return id.pMethods.xDeviceCharacteristics(id)
}
func sqlite3OsShmLock(id *struct_sqlite3_file, offset int32, n int32, flags int32) int32 {
	return id.pMethods.xShmLock(id, offset, n, flags)
}
func sqlite3OsShmBarrier(id *struct_sqlite3_file) {
	id.pMethods.xShmBarrier(id)
}
func sqlite3OsShmUnmap(id *struct_sqlite3_file, deleteFlag int32) int32 {
	return id.pMethods.xShmUnmap(id, deleteFlag)
}
func sqlite3OsShmMap(id *struct_sqlite3_file, iPage int32, pgsz int32, bExtend int32, pp *unsafe.Pointer) int32 {
	return id.pMethods.xShmMap(id, iPage, pgsz, bExtend, pp)
}
func sqlite3OsFetch(id *struct_sqlite3_file, iOff int64, iAmt int32, pp *unsafe.Pointer) int32 {
	return id.pMethods.xFetch(id, iOff, iAmt, pp)
}
func sqlite3OsUnfetch(id *struct_sqlite3_file, iOff int64, p unsafe.Pointer) int32 {
	return id.pMethods.xUnfetch(id, iOff, p)
}
func sqlite3OsOpen(pVfs *struct_sqlite3_vfs, zPath *int8, pFile *struct_sqlite3_file, flags int32, pFlagsOut *int32) int32 {
	var rc int32
	rc = pVfs.xOpen(pVfs, zPath, pFile, flags&17334143, pFlagsOut)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3OsDelete(pVfs *struct_sqlite3_vfs, zPath *int8, dirSync int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if uintptr(unsafe.Pointer(pVfs.xDelete)) != uintptr(unsafe.Pointer(nil)) {
			return pVfs.xDelete(pVfs, zPath, dirSync)
		} else {
			return 0
		}
	}()
}
func sqlite3OsAccess(pVfs *struct_sqlite3_vfs, zPath *int8, flags int32, pResOut *int32) int32 {
	return pVfs.xAccess(pVfs, zPath, flags, pResOut)
}
func sqlite3OsFullPathname(pVfs *struct_sqlite3_vfs, zPath *int8, nPathOut int32, zPathOut *int8) int32 {
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPathOut)) + uintptr(0))) = int8(0)
	return pVfs.xFullPathname(pVfs, zPath, nPathOut, zPathOut)
}
func sqlite3OsDlOpen(pVfs *struct_sqlite3_vfs, zPath *int8) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return pVfs.xDlOpen(pVfs, zPath)
}
func sqlite3OsDlError(pVfs *struct_sqlite3_vfs, nByte int32, zBufOut *int8) {
	pVfs.xDlError(pVfs, nByte, zBufOut)
}
func sqlite3OsDlSym(pVfs *struct_sqlite3_vfs, pHdle unsafe.Pointer, zSym *int8) func() {
	return pVfs.xDlSym(pVfs, pHdle, zSym)
}
func sqlite3OsDlClose(pVfs *struct_sqlite3_vfs, pHandle unsafe.Pointer) {
	pVfs.xDlClose(pVfs, pHandle)
}
func sqlite3OsRandomness(pVfs *struct_sqlite3_vfs, nByte int32, zBufOut *int8) int32 {
	if sqlite3Config.iPrngSeed != 0 {
		__builtin___memset_chk(unsafe.Pointer(zBufOut), 0, uint(nByte), __builtin_object_size(unsafe.Pointer(zBufOut), 0))
		if nByte > int32(4) {
			nByte = int32(4)
		}
		__builtin___memcpy_chk(unsafe.Pointer(zBufOut), unsafe.Pointer(&sqlite3Config.iPrngSeed), uint(nByte), __builtin_object_size(unsafe.Pointer(zBufOut), 0))
		return int32(0)
	} else {
		return pVfs.xRandomness(pVfs, nByte, zBufOut)
	}
}
func sqlite3OsSleep(pVfs *struct_sqlite3_vfs, nMicro int32) int32 {
	return pVfs.xSleep(pVfs, nMicro)
}
func sqlite3OsGetLastError(pVfs *struct_sqlite3_vfs) int32 {
	return func() int32 {
		if pVfs.xGetLastError != nil {
			return pVfs.xGetLastError(pVfs, 0, nil)
		} else {
			return 0
		}
	}()
}
func sqlite3OsCurrentTimeInt64(pVfs *struct_sqlite3_vfs, pTimeOut *int64) int32 {
	var rc int32
	if pVfs.iVersion >= 2 && pVfs.xCurrentTimeInt64 != nil {
		rc = pVfs.xCurrentTimeInt64(pVfs, pTimeOut)
	} else {
		var r float64
		rc = pVfs.xCurrentTime(pVfs, &r)
		*pTimeOut = int64(r * 8.64e+7)
	}
	return rc
}
func sqlite3OsOpenMalloc(pVfs *struct_sqlite3_vfs, zFile *int8, ppFile **struct_sqlite3_file, flags int32, pOutFlags *int32) int32 {
	var rc int32
	var pFile *struct_sqlite3_file
	pFile = (*struct_sqlite3_file)(sqlite3MallocZero(uint64(pVfs.szOsFile)))
	if pFile != nil {
		rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags)
		if rc != 0 {
			sqlite3_free(unsafe.Pointer(pFile))
			*ppFile = (*struct_sqlite3_file)(nil)
		} else {
			*ppFile = pFile
		}
	} else {
		*ppFile = (*struct_sqlite3_file)(nil)
		rc = int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3OsCloseFree(pFile *struct_sqlite3_file) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3OsClose(pFile)
	sqlite3_free(unsafe.Pointer(pFile))
}
func sqlite3OsInit() int32 {
	var p unsafe.Pointer = sqlite3_malloc(10)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	sqlite3_free(p)
	return sqlite3_os_init()
}

var vfsList *struct_sqlite3_vfs = nil

func sqlite3_vfs_find(zVfs *int8) *struct_sqlite3_vfs {
	var pVfs *struct_sqlite3_vfs = nil
	var mutex *struct_sqlite3_mutex
	var rc int32 = sqlite3_initialize()
	if rc != 0 {
		return (*struct_sqlite3_vfs)(nil)
	}
	mutex = sqlite3MutexAlloc(2)
	sqlite3_mutex_enter(mutex)
	for pVfs = vfsList; pVfs != nil; pVfs = pVfs.pNext {
		if uintptr(unsafe.Pointer(zVfs)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		if strcmp(zVfs, pVfs.zName) == 0 {
			break
		}
	}
	sqlite3_mutex_leave(mutex)
	return pVfs
}
func vfsUnlink(pVfs *struct_sqlite3_vfs) {
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pVfs)) == uintptr(unsafe.Pointer(nil)) {
	} else if uintptr(unsafe.Pointer(vfsList)) == uintptr(unsafe.Pointer(pVfs)) {
		vfsList = pVfs.pNext
	} else if vfsList != nil {
		var p *struct_sqlite3_vfs = vfsList
		for p.pNext != nil && uintptr(unsafe.Pointer(p.pNext)) != uintptr(unsafe.Pointer(pVfs)) {
			p = p.pNext
		}
		if uintptr(unsafe.Pointer(p.pNext)) == uintptr(unsafe.Pointer(pVfs)) {
			p.pNext = pVfs.pNext
		}
	}
}
func sqlite3_vfs_register(pVfs *struct_sqlite3_vfs, makeDflt int32) int32 {
	var mutex *struct_sqlite3_mutex
	var rc int32 = sqlite3_initialize()
	if rc != 0 {
		return rc
	}
	mutex = sqlite3MutexAlloc(2)
	sqlite3_mutex_enter(mutex)
	vfsUnlink(pVfs)
	if makeDflt != 0 || uintptr(unsafe.Pointer(vfsList)) == uintptr(unsafe.Pointer(nil)) {
		pVfs.pNext = vfsList
		vfsList = pVfs
	} else {
		pVfs.pNext = vfsList.pNext
		vfsList.pNext = pVfs
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_leave(mutex)
	return int32(0)
}
func sqlite3_vfs_unregister(pVfs *struct_sqlite3_vfs) int32 {
	var mutex *struct_sqlite3_mutex
	var rc int32 = sqlite3_initialize()
	if rc != 0 {
		return rc
	}
	mutex = sqlite3MutexAlloc(2)
	sqlite3_mutex_enter(mutex)
	vfsUnlink(pVfs)
	sqlite3_mutex_leave(mutex)
	return int32(0)
}

type BenignMallocHooks = struct_BenignMallocHooks
type struct_BenignMallocHooks struct {
	xBenignBegin func()
	xBenignEnd   func()
}

var sqlite3Hooks struct_BenignMallocHooks = struct_BenignMallocHooks{nil, nil}

func sqlite3BenignMallocHooks(xBenignBegin func(), xBenignEnd func()) {
	sqlite3Hooks.xBenignBegin = xBenignBegin
	sqlite3Hooks.xBenignEnd = xBenignEnd
}
func sqlite3BeginBenignMalloc() {
	if sqlite3Hooks.xBenignBegin != nil {
		sqlite3Hooks.xBenignBegin()
	}
}
func sqlite3EndBenignMalloc() {
	if sqlite3Hooks.xBenignEnd != nil {
		sqlite3Hooks.xBenignEnd()
	}
}

type struct_fd_set struct {
	fds_bits [32]int32
}
type fd_set = struct_fd_set

func __darwin_check_fd_set(_a int32, _b unsafe.Pointer) int32 {
	if uint(uintptr(unsafe.Pointer(&__darwin_check_fd_set_overflow))) != uint(0) {
		return __darwin_check_fd_set_overflow(_a, _b, 0)
	} else {
		return int32(1)
	}
}
func __darwin_fd_isset(_fd int32, _p *struct_fd_set) int32 {
	if __darwin_check_fd_set(_fd, unsafe.Pointer(_p)) != 0 {
		return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&_p.fds_bits)))) + uintptr(uint(_fd)/(4*uint(8)))*4)) & int32(uint(1)<<(uint(_fd)%(4*uint(8))))
	}
	return int32(0)
}
func __darwin_fd_set(_fd int32, _p *struct_fd_set) {
	if __darwin_check_fd_set(_fd, unsafe.Pointer(_p)) != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&_p.fds_bits)))) + uintptr(uint(_fd)/(4*uint(8)))*4)) |= int32(uint(1) << (uint(_fd) % (4 * uint(8))))
	}
}
func __darwin_fd_clr(_fd int32, _p *struct_fd_set) {
	if __darwin_check_fd_set(_fd, unsafe.Pointer(_p)) != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&_p.fds_bits)))) + uintptr(uint(_fd)/(4*uint(8)))*4)) &= ^int32(uint(1) << (uint(_fd) % (4 * uint(8))))
	}
}

type struct_timeval64 struct {
	tv_sec  int64
	tv_usec int64
}
type suseconds_t = int32
type struct_itimerval struct {
	it_interval struct_timeval
	it_value    struct_timeval
}
type struct_timezone struct {
	tz_minuteswest int32
	tz_dsttime     int32
}
type struct_clockinfo struct {
	hz      int32
	tick    int32
	tickadj int32
	stathz  int32
	profhz  int32
}
type u_char = uint8
type u_short = uint16
type u_int = uint32
type u_long = uint
type ushort = uint16
type uint = uint32
type u_quad_t = uint64
type quad_t = int64
type qaddr_t = *int64
type caddr_t = *int8
type daddr_t = int32
type fixpt_t = uint32
type blkcnt_t = int64
type blksize_t = int32
type gid_t = uint32
type in_addr_t = uint32
type in_port_t = uint16
type ino_t = uint64
type ino64_t = uint64
type key_t = int32
type nlink_t = uint16
type segsz_t = int32
type swblk_t = int32
type useconds_t = uint32
type fd_mask = int32
type pthread_cond_t = struct__opaque_pthread_cond_t
type pthread_condattr_t = struct__opaque_pthread_condattr_t
type pthread_mutex_t = struct__opaque_pthread_mutex_t
type pthread_mutexattr_t = struct__opaque_pthread_mutexattr_t
type pthread_once_t = struct__opaque_pthread_once_t
type pthread_rwlock_t = struct__opaque_pthread_rwlock_t
type pthread_rwlockattr_t = struct__opaque_pthread_rwlockattr_t
type pthread_t = *struct__opaque_pthread_t
type pthread_key_t = uint
type fsblkcnt_t = uint32
type fsfilcnt_t = uint32
type au_id_t = uint32
type au_asid_t = int32
type au_event_t = uint16
type au_emod_t = uint16
type au_class_t = uint32
type au_asflgs_t = uint64
type au_ctlmode_t = uint8
type struct_au_tid struct {
	port    int32
	machine uint32
}
type au_tid_t = struct_au_tid
type struct_au_tid_addr struct {
	at_port int32
	at_type uint32
	at_addr [4]uint32
}
type au_tid_addr_t = struct_au_tid_addr
type struct_au_mask struct {
	am_success uint32
	am_failure uint32
}
type au_mask_t = struct_au_mask
type struct_auditinfo struct {
	ai_auid   uint32
	ai_mask   struct_au_mask
	ai_termid struct_au_tid
	ai_asid   int32
}
type auditinfo_t = struct_auditinfo
type struct_auditinfo_addr struct {
	ai_auid   uint32
	ai_mask   struct_au_mask
	ai_termid struct_au_tid_addr
	ai_asid   int32
	ai_flags  uint64
}
type auditinfo_addr_t = struct_auditinfo_addr
type struct_auditpinfo struct {
	ap_pid    int32
	ap_auid   uint32
	ap_mask   struct_au_mask
	ap_termid struct_au_tid
	ap_asid   int32
}
type auditpinfo_t = struct_auditpinfo
type struct_auditpinfo_addr struct {
	ap_pid    int32
	ap_auid   uint32
	ap_mask   struct_au_mask
	ap_termid struct_au_tid_addr
	ap_asid   int32
	ap_flags  uint64
}
type auditpinfo_addr_t = struct_auditpinfo_addr
type struct_au_session struct {
	as_aia_p *struct_auditinfo_addr
	as_mask  struct_au_mask
}
type au_session_t = struct_au_session
type struct_au_expire_after struct {
	age     int
	size    uint
	op_type uint8
}
type au_expire_after_t = struct_au_expire_after
type token_t = struct_au_token
type struct_au_qctrl struct {
	aq_hiwater int32
	aq_lowater int32
	aq_bufsz   int32
	aq_delay   int32
	aq_minfree int32
}
type au_qctrl_t = struct_au_qctrl
type struct_audit_stat struct {
	as_version   uint32
	as_numevent  uint32
	as_generated int32
	as_nonattrib int32
	as_kernel    int32
	as_audit     int32
	as_auditctl  int32
	as_enqueue   int32
	as_written   int32
	as_wblocked  int32
	as_rblocked  int32
	as_dropped   int32
	as_totalsize int32
	as_memused   uint32
}
type au_stat_t = struct_audit_stat
type struct_audit_fstat struct {
	af_filesz uint64
	af_currsz uint64
}
type au_fstat_t = struct_audit_fstat
type struct_au_evclass_map struct {
	ec_number uint16
	ec_class  uint32
}
type au_evclass_map_t = struct_au_evclass_map
type boolean_t = uint32
type natural_t = uint32
type integer_t = int32
type vm_offset_t = uint
type vm_size_t = uint
type mach_vm_address_t = uint64
type mach_vm_offset_t = uint64
type mach_vm_size_t = uint64
type vm_map_offset_t = uint64
type vm_map_address_t = uint64
type vm_map_size_t = uint64
type mach_port_context_t = uint64
type mach_port_name_t = uint32
type mach_port_name_array_t = *uint32
type mach_port_t = uint32
type mach_port_array_t = *uint32
type mach_port_right_t = uint32
type mach_port_type_t = uint32
type mach_port_type_array_t = *uint32
type mach_port_urefs_t = uint32
type mach_port_delta_t = int32
type mach_port_seqno_t = uint32
type mach_port_mscount_t = uint32
type mach_port_msgcount_t = uint32
type mach_port_rights_t = uint32
type mach_port_srights_t = uint32
type struct_mach_port_status struct {
	mps_pset      uint32
	mps_seqno     uint32
	mps_mscount   uint32
	mps_qlimit    uint32
	mps_msgcount  uint32
	mps_sorights  uint32
	mps_srights   uint32
	mps_pdrequest uint32
	mps_nsrequest uint32
	mps_flags     uint32
}
type mach_port_status_t = struct_mach_port_status
type struct_mach_port_limits struct {
	mpl_qlimit uint32
}
type mach_port_limits_t = struct_mach_port_limits
type struct_mach_port_info_ext struct {
	mpie_status    struct_mach_port_status
	mpie_boost_cnt uint32
	reserved       [6]uint32
}
type mach_port_info_ext_t = struct_mach_port_info_ext
type mach_port_info_t = *int32
type mach_port_flavor_t = int32
type struct_mach_port_qos struct {
	Xbf_0 uint32
	len   uint32
}
type mach_port_qos_t = struct_mach_port_qos
type _cgoa_31 struct {
	reserved [2]uint64
}
type struct_mach_port_options struct {
	flags uint32
	mpl   struct_mach_port_limits
	_cgoa_31
}
type mach_port_options_t = struct_mach_port_options
type mach_port_options_ptr_t = *struct_mach_port_options

const (
	kGUARD_EXC_DESTROY              int32 = int32(1 << 0)
	kGUARD_EXC_MOD_REFS             int32 = int32(1 << 1)
	kGUARD_EXC_SET_CONTEXT          int32 = int32(1 << 2)
	kGUARD_EXC_UNGUARDED            int32 = int32(1 << 3)
	kGUARD_EXC_INCORRECT_GUARD      int32 = int32(1 << 4)
	kGUARD_EXC_IMMOVABLE            int32 = int32(1 << 5)
	kGUARD_EXC_STRICT_REPLY         int32 = int32(1 << 6)
	kGUARD_EXC_MSG_FILTERED         int32 = int32(1 << 7)
	kGUARD_EXC_INVALID_RIGHT        int32 = int32(1 << 8)
	kGUARD_EXC_INVALID_NAME         int32 = int32(1 << 9)
	kGUARD_EXC_INVALID_VALUE        int32 = int32(1 << 10)
	kGUARD_EXC_INVALID_ARGUMENT     int32 = int32(1 << 11)
	kGUARD_EXC_RIGHT_EXISTS         int32 = int32(1 << 12)
	kGUARD_EXC_KERN_NO_SPACE        int32 = int32(1 << 13)
	kGUARD_EXC_KERN_FAILURE         int32 = int32(1 << 14)
	kGUARD_EXC_KERN_RESOURCE        int32 = int32(1 << 15)
	kGUARD_EXC_SEND_INVALID_REPLY   int32 = int32(1 << 16)
	kGUARD_EXC_SEND_INVALID_VOUCHER int32 = int32(1 << 17)
	kGUARD_EXC_SEND_INVALID_RIGHT   int32 = int32(1 << 18)
	kGUARD_EXC_RCV_INVALID_NAME     int32 = int32(1 << 19)
	kGUARD_EXC_RCV_GUARDED_DESC     int32 = int32(1 << 20)
	kGUARD_EXC_MOD_REFS_NON_FATAL   int32 = int32(1 << 21)
	kGUARD_EXC_IMMOVABLE_NON_FATAL  int32 = int32(1 << 22)
)

type kauth_cred_t = *struct_ucred
type posix_cred_t = *struct_posix_cred
type struct_xucred struct {
	cr_version uint32
	cr_uid     uint32
	cr_ngroups int16
	cr_groups  [16]uint32
}
type struct_kevent struct {
	ident  uint
	filter int16
	flags  uint16
	fflags uint32
	data   int
	udata  unsafe.Pointer
}
type struct_kevent64_s struct {
	ident  uint64
	filter int16
	flags  uint16
	fflags uint32
	data   int64
	udata  uint64
	ext    [2]uint64
}

const eNoteReapDeprecated int32 = 268435456
const eNoteExitReparentedDeprecated int32 = 524288

type struct_klist struct {
	slh_first *struct_knote
}
type _cgoa_33 struct {
	__p_forw *struct_proc
	__p_back *struct_proc
}
type _cgoa_32 struct {
	p_st1 _cgoa_33
}
type struct_extern_proc struct {
	p_un        _cgoa_32
	p_vmspace   *struct_vmspace
	p_sigacts   *struct_sigacts
	p_flag      int32
	p_stat      int8
	p_pid       int32
	p_oppid     int32
	p_dupfd     int32
	user_stack  *int8
	exit_thread unsafe.Pointer
	p_debugger  int32
	sigwait     uint32
	p_estcpu    uint32
	p_cpticks   int32
	p_pctcpu    uint32
	p_wchan     unsafe.Pointer
	p_wmesg     *int8
	p_swtime    uint32
	p_slptime   uint32
	p_realtimer struct_itimerval
	p_rtime     struct_timeval
	p_uticks    uint64
	p_sticks    uint64
	p_iticks    uint64
	p_traceflag int32
	p_tracep    *struct_vnode
	p_siglist   int32
	p_textvp    *struct_vnode
	p_holdcnt   int32
	p_sigmask   uint32
	p_sigignore uint32
	p_sigcatch  uint32
	p_priority  uint8
	p_usrpri    uint8
	p_nice      int8
	p_comm      [17]int8
	p_pgrp      *struct_pgrp
	p_addr      *struct_user
	p_xstat     uint16
	p_acflag    uint16
	p_ru        *struct_rusage
}
type struct_vmspace struct {
	dummy  int32
	dummy2 *int8
	dummy3 [5]int32
	dummy4 [3]*int8
}
type struct_ctlname struct {
	ctl_name *int8
	ctl_type int32
}
type struct__pcred struct {
	pc_lock  [72]int8
	pc_ucred *struct_ucred
	p_ruid   uint32
	p_svuid  uint32
	p_rgid   uint32
	p_svgid  uint32
	p_refcnt int32
}
type struct__ucred struct {
	cr_ref     int32
	cr_uid     uint32
	cr_ngroups int16
	cr_groups  [16]uint32
}
type struct_eproc struct {
	e_paddr   *struct_proc
	e_sess    *struct_session
	e_pcred   struct__pcred
	e_ucred   struct__ucred
	e_vm      struct_vmspace
	e_ppid    int32
	e_pgid    int32
	e_jobc    int16
	e_tdev    int32
	e_tpgid   int32
	e_tsess   *struct_session
	e_wmesg   [8]int8
	e_xsize   int32
	e_xrssize int16
	e_xccount int16
	e_xswrss  int16
	e_flag    int32
	e_login   [12]int8
	e_spare   [4]int32
}
type struct_kinfo_proc struct {
	kp_proc  struct_extern_proc
	kp_eproc struct_eproc
}
type struct_xsw_usage struct {
	xsu_total     uint64
	xsu_avail     uint64
	xsu_used      uint64
	xsu_pagesize  uint32
	xsu_encrypted uint32
}
type struct_loadavg struct {
	ldavg  [3]uint32
	fscale int
}
type kern_return_t = int32
type mach_msg_timeout_t = uint32
type mach_msg_bits_t = uint32
type mach_msg_size_t = uint32
type mach_msg_id_t = int32
type mach_msg_priority_t = uint32
type mach_msg_type_name_t = uint32
type mach_msg_copy_options_t = uint32
type mach_msg_guard_flags_t = uint32
type mach_msg_descriptor_type_t = uint32
type _cgoa_34 struct {
	pad1  uint32
	pad2  uint32
	Xbf_0 uint32
}
type _cgoa_35 struct {
	name  uint32
	pad1  uint32
	Xbf_0 uint32
}
type _cgoa_36 struct {
	address uint32
	size    uint32
	Xbf_0   uint32
}
type _cgoa_37 struct {
	address uint64
	Xbf_0   uint32
	size    uint32
}
type _cgoa_38 struct {
	address unsafe.Pointer
	Xbf_0   uint32
	size    uint32
}
type _cgoa_39 struct {
	address uint32
	count   uint32
	Xbf_0   uint32
}
type _cgoa_40 struct {
	address uint64
	Xbf_0   uint32
	count   uint32
}
type _cgoa_41 struct {
	address unsafe.Pointer
	Xbf_0   uint32
	count   uint32
}
type _cgoa_42 struct {
	context uint32
	name    uint32
	Xbf_0   uint32
}
type _cgoa_43 struct {
	context uint64
	Xbf_0   uint32
	name    uint32
}
type _cgoa_44 struct {
	context uint64
	Xbf_0   uint32
	name    uint32
}
type _cgoa_45 struct {
	out_of_line _cgoa_38
}
type _cgoa_46 struct {
	msgh_descriptor_count uint32
}
type _cgoa_47 struct {
	msgh_bits         uint32
	msgh_size         uint32
	msgh_remote_port  uint32
	msgh_local_port   uint32
	msgh_voucher_port uint32
	msgh_id           int32
}
type _cgoa_48 struct {
	header _cgoa_47
	body   _cgoa_46
}
type mach_msg_trailer_type_t = uint32
type mach_msg_trailer_size_t = uint32
type mach_msg_trailer_info_t = *int8
type _cgoa_49 struct {
	msgh_trailer_type uint32
	msgh_trailer_size uint32
}
type _cgoa_50 struct {
	msgh_trailer_type uint32
	msgh_trailer_size uint32
	msgh_seqno        uint32
}
type _cgoa_51 struct {
	val [2]uint32
}
type _cgoa_52 struct {
	msgh_trailer_type uint32
	msgh_trailer_size uint32
	msgh_seqno        uint32
	msgh_sender       _cgoa_51
}
type _cgoa_53 struct {
	val [8]uint32
}
type _cgoa_54 struct {
	msgh_trailer_type uint32
	msgh_trailer_size uint32
	msgh_seqno        uint32
	msgh_sender       _cgoa_51
	msgh_audit        _cgoa_53
}
type _cgoa_55 struct {
	msgh_trailer_type uint32
	msgh_trailer_size uint32
	msgh_seqno        uint32
	msgh_sender       _cgoa_51
	msgh_audit        _cgoa_53
	msgh_context      uint64
}
type _cgoa_56 struct {
	sender uint32
}
type mach_msg_filter_id = int32
type _cgoa_57 struct {
	msgh_trailer_type uint32
	msgh_trailer_size uint32
	msgh_seqno        uint32
	msgh_sender       _cgoa_51
	msgh_audit        _cgoa_53
	msgh_context      uint64
	msgh_ad           int32
	msgh_labels       _cgoa_56
}
type mach_msg_max_trailer_t = _cgoa_57
type mach_msg_format_0_trailer_t = _cgoa_52
type mach_msg_options_t = int32
type _cgoa_58 struct {
	header _cgoa_47
}
type _cgoa_59 struct {
	header  _cgoa_47
	trailer _cgoa_49
}
type _cgoa_60 struct {
	rcv _cgoa_59
}
type mach_msg_type_size_t = uint32
type mach_msg_type_number_t = uint32
type mach_msg_option_t = int32
type mach_msg_return_t = int32
type struct_vm_statistics struct {
	free_count        uint32
	active_count      uint32
	inactive_count    uint32
	wire_count        uint32
	zero_fill_count   uint32
	reactivations     uint32
	pageins           uint32
	pageouts          uint32
	faults            uint32
	cow_faults        uint32
	lookups           uint32
	hits              uint32
	purgeable_count   uint32
	purges            uint32
	speculative_count uint32
}
type vm_statistics_t = *struct_vm_statistics
type vm_statistics_data_t = struct_vm_statistics
type struct_vm_statistics64 struct {
	free_count                             uint32
	active_count                           uint32
	inactive_count                         uint32
	wire_count                             uint32
	zero_fill_count                        uint64
	reactivations                          uint64
	pageins                                uint64
	pageouts                               uint64
	faults                                 uint64
	cow_faults                             uint64
	lookups                                uint64
	hits                                   uint64
	purges                                 uint64
	purgeable_count                        uint32
	speculative_count                      uint32
	decompressions                         uint64
	compressions                           uint64
	swapins                                uint64
	swapouts                               uint64
	compressor_page_count                  uint32
	throttled_count                        uint32
	external_page_count                    uint32
	internal_page_count                    uint32
	total_uncompressed_pages_in_compressor uint64
}
type vm_statistics64_t = *struct_vm_statistics64
type vm_statistics64_data_t = struct_vm_statistics64
type struct_vm_extmod_statistics struct {
	task_for_pid_count            int64
	task_for_pid_caller_count     int64
	thread_creation_count         int64
	thread_creation_caller_count  int64
	thread_set_state_count        int64
	thread_set_state_caller_count int64
}
type vm_extmod_statistics_t = *struct_vm_extmod_statistics
type vm_extmod_statistics_data_t = struct_vm_extmod_statistics
type struct_vm_purgeable_stat struct {
	count uint64
	size  uint64
}
type vm_purgeable_stat_t = struct_vm_purgeable_stat
type struct_vm_purgeable_info struct {
	fifo_data     [8]struct_vm_purgeable_stat
	obsolete_data struct_vm_purgeable_stat
	lifo_data     [8]struct_vm_purgeable_stat
}
type vm_purgeable_info_t = *struct_vm_purgeable_info

const kGUARD_EXC_DEALLOC_GAP int32 = int32(1 << 0)

type cpu_type_t = int32
type cpu_subtype_t = int32
type cpu_threadtype_t = int32
type struct_time_value struct {
	seconds      int32
	microseconds int32
}
type time_value_t = struct_time_value
type host_info_t = *int32
type host_info64_t = *int32
type host_info_data_t = [1024]int32
type kernel_version_t = [512]int8
type kernel_boot_info_t = [4096]int8
type host_flavor_t = int32
type struct_host_can_has_debugger_info struct {
	can_has_debugger uint32
}
type host_can_has_debugger_info_data_t = struct_host_can_has_debugger_info
type host_can_has_debugger_info_t = *struct_host_can_has_debugger_info
type struct_host_basic_info struct {
	max_cpus         int32
	avail_cpus       int32
	memory_size      uint32
	cpu_type         int32
	cpu_subtype      int32
	cpu_threadtype   int32
	physical_cpu     int32
	physical_cpu_max int32
	logical_cpu      int32
	logical_cpu_max  int32
	max_mem          uint64
}
type host_basic_info_data_t = struct_host_basic_info
type host_basic_info_t = *struct_host_basic_info
type struct_host_sched_info struct {
	min_timeout int32
	min_quantum int32
}
type host_sched_info_data_t = struct_host_sched_info
type host_sched_info_t = *struct_host_sched_info
type struct_kernel_resource_sizes struct {
	task          uint32
	thread        uint32
	port          uint32
	memory_region uint32
	memory_object uint32
}
type kernel_resource_sizes_data_t = struct_kernel_resource_sizes
type kernel_resource_sizes_t = *struct_kernel_resource_sizes
type struct_host_priority_info struct {
	kernel_priority  int32
	system_priority  int32
	server_priority  int32
	user_priority    int32
	depress_priority int32
	idle_priority    int32
	minimum_priority int32
	maximum_priority int32
}
type host_priority_info_data_t = struct_host_priority_info
type host_priority_info_t = *struct_host_priority_info
type struct_host_load_info struct {
	avenrun     [3]int32
	mach_factor [3]int32
}
type host_load_info_data_t = struct_host_load_info
type host_load_info_t = *struct_host_load_info
type host_purgable_info_data_t = struct_vm_purgeable_info
type host_purgable_info_t = *struct_vm_purgeable_info
type struct_host_cpu_load_info struct {
	cpu_ticks [4]uint32
}
type host_cpu_load_info_data_t = struct_host_cpu_load_info
type host_cpu_load_info_t = *struct_host_cpu_load_info
type struct_host_preferred_user_arch struct {
	cpu_type    int32
	cpu_subtype int32
}
type host_preferred_user_arch_data_t = struct_host_preferred_user_arch
type host_preferred_user_arch_t = *struct_host_preferred_user_arch
type vm_prot_t = int32
type vm_sync_t = uint32
type pointer_t = uint
type vm_address_t = uint
type addr64_t = uint64
type reg64_t = uint32
type ppnum_t = uint32
type vm_map_t = uint32
type vm_map_read_t = uint32
type vm_map_inspect_t = uint32
type vm_object_offset_t = uint64
type vm_object_size_t = uint64
type upl_t = uint32
type vm_named_entry_t = uint32
type memory_object_offset_t = uint64
type memory_object_size_t = uint64
type memory_object_cluster_size_t = uint32
type memory_object_fault_info_t = *uint32
type vm_object_id_t = uint64
type memory_object_t = uint32
type memory_object_control_t = uint32
type memory_object_array_t = *uint32
type memory_object_name_t = uint32
type memory_object_default_t = uint32
type memory_object_copy_strategy_t = int32
type memory_object_return_t = int32
type memory_object_info_t = *int32
type memory_object_flavor_t = int32
type memory_object_info_data_t = [1024]int32
type struct_memory_object_perf_info struct {
	cluster_size uint32
	may_cache    uint32
}
type struct_memory_object_attr_info struct {
	copy_strategy    int32
	cluster_size     uint32
	may_cache_object uint32
	temporary        uint32
}
type struct_memory_object_behave_info struct {
	copy_strategy    int32
	temporary        uint32
	invalidate       uint32
	silent_overwrite uint32
	advisory_pageout uint32
}
type memory_object_behave_info_t = *struct_memory_object_behave_info
type memory_object_behave_info_data_t = struct_memory_object_behave_info
type memory_object_perf_info_t = *struct_memory_object_perf_info
type memory_object_perf_info_data_t = struct_memory_object_perf_info
type memory_object_attr_info_t = *struct_memory_object_attr_info
type memory_object_attr_info_data_t = struct_memory_object_attr_info
type struct_x86_state_hdr struct {
	flavor uint32
	count  uint32
}
type x86_state_hdr_t = struct_x86_state_hdr
type i386_thread_state_t = struct___darwin_i386_thread_state
type x86_thread_state32_t = struct___darwin_i386_thread_state
type i386_float_state_t = struct___darwin_i386_float_state
type x86_float_state32_t = struct___darwin_i386_float_state
type x86_avx_state32_t = struct___darwin_i386_avx_state
type x86_avx512_state32_t = struct___darwin_i386_avx512_state
type i386_exception_state_t = struct___darwin_i386_exception_state
type x86_exception_state32_t = struct___darwin_i386_exception_state
type x86_debug_state32_t = struct___darwin_x86_debug_state32
type x86_thread_state64_t = struct___darwin_x86_thread_state64
type x86_thread_full_state64_t = struct___darwin_x86_thread_full_state64
type x86_float_state64_t = struct___darwin_x86_float_state64
type x86_avx_state64_t = struct___darwin_x86_avx_state64
type x86_avx512_state64_t = struct___darwin_x86_avx512_state64
type x86_exception_state64_t = struct___darwin_x86_exception_state64
type x86_debug_state64_t = struct___darwin_x86_debug_state64
type x86_pagein_state_t = struct___x86_pagein_state
type x86_instruction_state_t = struct___x86_instruction_state
type last_branch_state_t = struct___last_branch_state
type _cgoa_61 struct {
	ts64 struct___darwin_x86_thread_state64
}
type struct_x86_thread_state struct {
	tsh struct_x86_state_hdr
	uts _cgoa_61
}
type _cgoa_62 struct {
	fs32 struct___darwin_i386_float_state
}
type struct_x86_float_state struct {
	fsh struct_x86_state_hdr
	ufs _cgoa_62
}
type _cgoa_63 struct {
	es64 struct___darwin_x86_exception_state64
}
type struct_x86_exception_state struct {
	esh struct_x86_state_hdr
	ues _cgoa_63
}
type _cgoa_64 struct {
	ds64 struct___darwin_x86_debug_state64
}
type struct_x86_debug_state struct {
	dsh struct_x86_state_hdr
	uds _cgoa_64
}
type _cgoa_65 struct {
	as64 struct___darwin_x86_avx_state64
}
type struct_x86_avx_state struct {
	ash struct_x86_state_hdr
	ufs _cgoa_65
}
type _cgoa_66 struct {
	as64 struct___darwin_x86_avx512_state64
}
type struct_x86_avx512_state struct {
	ash struct_x86_state_hdr
	ufs _cgoa_66
}
type x86_thread_state_t = struct_x86_thread_state
type x86_float_state_t = struct_x86_float_state
type x86_exception_state_t = struct_x86_exception_state
type x86_debug_state_t = struct_x86_debug_state
type x86_avx_state_t = struct_x86_avx_state
type x86_avx512_state_t = struct_x86_avx512_state
type thread_state_t = *uint32
type thread_state_data_t = [614]uint32
type thread_state_flavor_t = int32
type thread_state_flavor_array_t = *int32
type struct_ipc_info_space struct {
	iis_genno_mask uint32
	iis_table_size uint32
	iis_table_next uint32
	iis_tree_size  uint32
	iis_tree_small uint32
	iis_tree_hash  uint32
}
type ipc_info_space_t = struct_ipc_info_space
type struct_ipc_info_space_basic struct {
	iisb_genno_mask  uint32
	iisb_table_size  uint32
	iisb_table_next  uint32
	iisb_table_inuse uint32
	iisb_reserved    [2]uint32
}
type ipc_info_space_basic_t = struct_ipc_info_space_basic
type struct_ipc_info_name struct {
	iin_name      uint32
	iin_collision int32
	iin_type      uint32
	iin_urefs     uint32
	iin_object    uint32
	iin_next      uint32
	iin_hash      uint32
}
type ipc_info_name_t = struct_ipc_info_name
type ipc_info_name_array_t = *struct_ipc_info_name
type struct_ipc_info_tree_name struct {
	iitn_name   struct_ipc_info_name
	iitn_lchild uint32
	iitn_rchild uint32
}
type ipc_info_tree_name_t = struct_ipc_info_tree_name
type ipc_info_tree_name_array_t = *struct_ipc_info_tree_name
type struct_ipc_info_port struct {
	iip_port_object     uint32
	iip_receiver_object uint32
}
type ipc_info_port_t = struct_ipc_info_port
type exception_handler_info_array_t = *struct_ipc_info_port
type exception_type_t = int32
type exception_data_type_t = int32
type mach_exception_data_type_t = int64
type exception_behavior_t = int32
type exception_data_t = *int32
type mach_exception_data_t = *int64
type exception_mask_t = uint32
type exception_mask_array_t = *uint32
type exception_behavior_array_t = *int32
type exception_flavor_array_t = *int32
type exception_port_array_t = *uint32
type exception_port_info_array_t = *struct_ipc_info_port
type mach_exception_code_t = int64
type mach_exception_subcode_t = int64
type uuid_t = [16]uint8
type mach_voucher_t = uint32
type mach_voucher_name_t = uint32
type mach_voucher_name_array_t = *uint32
type ipc_voucher_t = uint32
type mach_voucher_selector_t = uint32
type mach_voucher_attr_key_t = uint32
type mach_voucher_attr_key_array_t = *uint32
type mach_voucher_attr_content_t = *uint8
type mach_voucher_attr_content_size_t = uint32
type mach_voucher_attr_command_t = uint32
type mach_voucher_attr_recipe_command_t = uint32
type mach_voucher_attr_recipe_command_array_t = *uint32
type struct_mach_voucher_attr_recipe_data struct {
	key              uint32
	command          uint32
	previous_voucher uint32
	content_size     uint32
	content          [0]uint8
}
type mach_voucher_attr_recipe_data_t = struct_mach_voucher_attr_recipe_data
type mach_voucher_attr_recipe_t = *struct_mach_voucher_attr_recipe_data
type mach_voucher_attr_recipe_size_t = uint32
type mach_voucher_attr_raw_recipe_t = *uint8
type mach_voucher_attr_raw_recipe_array_t = *uint8
type mach_voucher_attr_raw_recipe_size_t = uint32
type mach_voucher_attr_raw_recipe_array_size_t = uint32
type mach_voucher_attr_manager_t = uint32
type mach_voucher_attr_control_t = uint32
type ipc_voucher_attr_manager_t = uint32
type ipc_voucher_attr_control_t = uint32
type mach_voucher_attr_value_handle_t = uint64
type mach_voucher_attr_value_handle_array_t = *uint64
type mach_voucher_attr_value_handle_array_size_t = uint32
type mach_voucher_attr_value_reference_t = uint32
type mach_voucher_attr_value_flags_t = uint32
type mach_voucher_attr_control_flags_t = uint32
type mach_voucher_attr_importance_refs = uint32
type processor_info_t = *int32
type processor_info_array_t = *int32
type processor_info_data_t = [1024]int32
type processor_set_info_t = *int32
type processor_set_info_data_t = [1024]int32
type processor_flavor_t = int32
type struct_processor_basic_info struct {
	cpu_type    int32
	cpu_subtype int32
	running     uint32
	slot_num    int32
	is_master   uint32
}
type processor_basic_info_data_t = struct_processor_basic_info
type processor_basic_info_t = *struct_processor_basic_info
type struct_processor_cpu_load_info struct {
	cpu_ticks [4]uint32
}
type processor_cpu_load_info_data_t = struct_processor_cpu_load_info
type processor_cpu_load_info_t = *struct_processor_cpu_load_info
type processor_set_flavor_t = int32
type struct_processor_set_basic_info struct {
	processor_count int32
	default_policy  int32
}
type processor_set_basic_info_data_t = struct_processor_set_basic_info
type processor_set_basic_info_t = *struct_processor_set_basic_info
type struct_processor_set_load_info struct {
	task_count   int32
	thread_count int32
	load_average int32
	mach_factor  int32
}
type processor_set_load_info_data_t = struct_processor_set_load_info
type processor_set_load_info_t = *struct_processor_set_load_info
type policy_t = int32
type policy_info_t = *int32
type policy_base_t = *int32
type policy_limit_t = *int32
type struct_policy_timeshare_base struct {
	base_priority int32
}
type struct_policy_timeshare_limit struct {
	max_priority int32
}
type struct_policy_timeshare_info struct {
	max_priority     int32
	base_priority    int32
	cur_priority     int32
	depressed        uint32
	depress_priority int32
}
type policy_timeshare_base_t = *struct_policy_timeshare_base
type policy_timeshare_limit_t = *struct_policy_timeshare_limit
type policy_timeshare_info_t = *struct_policy_timeshare_info
type policy_timeshare_base_data_t = struct_policy_timeshare_base
type policy_timeshare_limit_data_t = struct_policy_timeshare_limit
type policy_timeshare_info_data_t = struct_policy_timeshare_info
type struct_policy_rr_base struct {
	base_priority int32
	quantum       int32
}
type struct_policy_rr_limit struct {
	max_priority int32
}
type struct_policy_rr_info struct {
	max_priority     int32
	base_priority    int32
	quantum          int32
	depressed        uint32
	depress_priority int32
}
type policy_rr_base_t = *struct_policy_rr_base
type policy_rr_limit_t = *struct_policy_rr_limit
type policy_rr_info_t = *struct_policy_rr_info
type policy_rr_base_data_t = struct_policy_rr_base
type policy_rr_limit_data_t = struct_policy_rr_limit
type policy_rr_info_data_t = struct_policy_rr_info
type struct_policy_fifo_base struct {
	base_priority int32
}
type struct_policy_fifo_limit struct {
	max_priority int32
}
type struct_policy_fifo_info struct {
	max_priority     int32
	base_priority    int32
	depressed        uint32
	depress_priority int32
}
type policy_fifo_base_t = *struct_policy_fifo_base
type policy_fifo_limit_t = *struct_policy_fifo_limit
type policy_fifo_info_t = *struct_policy_fifo_info
type policy_fifo_base_data_t = struct_policy_fifo_base
type policy_fifo_limit_data_t = struct_policy_fifo_limit
type policy_fifo_info_data_t = struct_policy_fifo_info
type struct_policy_bases struct {
	ts   struct_policy_timeshare_base
	rr   struct_policy_rr_base
	fifo struct_policy_fifo_base
}
type struct_policy_limits struct {
	ts   struct_policy_timeshare_limit
	rr   struct_policy_rr_limit
	fifo struct_policy_fifo_limit
}
type struct_policy_infos struct {
	ts   struct_policy_timeshare_info
	rr   struct_policy_rr_info
	fifo struct_policy_fifo_info
}
type policy_base_data_t = struct_policy_bases
type policy_limit_data_t = struct_policy_limits
type policy_info_data_t = struct_policy_infos
type task_flavor_t = uint32
type task_info_t = *int32
type task_info_data_t = [1024]int32
type struct_task_basic_info_32 struct {
	suspend_count int32
	virtual_size  uint32
	resident_size uint32
	user_time     struct_time_value
	system_time   struct_time_value
	policy        int32
}
type task_basic_info_32_data_t = struct_task_basic_info_32
type task_basic_info_32_t = *struct_task_basic_info_32
type struct_task_basic_info_64 struct {
	suspend_count int32
	virtual_size  uint64
	resident_size uint64
	user_time     struct_time_value
	system_time   struct_time_value
	policy        int32
}
type task_basic_info_64_data_t = struct_task_basic_info_64
type task_basic_info_64_t = *struct_task_basic_info_64
type struct_task_basic_info struct {
	suspend_count int32
	virtual_size  uint
	resident_size uint
	user_time     struct_time_value
	system_time   struct_time_value
	policy        int32
}
type task_basic_info_data_t = struct_task_basic_info
type task_basic_info_t = *struct_task_basic_info
type struct_task_events_info struct {
	faults            int32
	pageins           int32
	cow_faults        int32
	messages_sent     int32
	messages_received int32
	syscalls_mach     int32
	syscalls_unix     int32
	csw               int32
}
type task_events_info_data_t = struct_task_events_info
type task_events_info_t = *struct_task_events_info
type struct_task_thread_times_info struct {
	user_time   struct_time_value
	system_time struct_time_value
}
type task_thread_times_info_data_t = struct_task_thread_times_info
type task_thread_times_info_t = *struct_task_thread_times_info
type struct_task_absolutetime_info struct {
	total_user     uint64
	total_system   uint64
	threads_user   uint64
	threads_system uint64
}
type task_absolutetime_info_data_t = struct_task_absolutetime_info
type task_absolutetime_info_t = *struct_task_absolutetime_info
type struct_task_kernelmemory_info struct {
	total_palloc uint64
	total_pfree  uint64
	total_salloc uint64
	total_sfree  uint64
}
type task_kernelmemory_info_data_t = struct_task_kernelmemory_info
type task_kernelmemory_info_t = *struct_task_kernelmemory_info
type struct_task_affinity_tag_info struct {
	set_count  int32
	min        int32
	max        int32
	task_count int32
}
type task_affinity_tag_info_data_t = struct_task_affinity_tag_info
type task_affinity_tag_info_t = *struct_task_affinity_tag_info
type struct_task_dyld_info struct {
	all_image_info_addr   uint64
	all_image_info_size   uint64
	all_image_info_format int32
}
type task_dyld_info_data_t = struct_task_dyld_info
type task_dyld_info_t = *struct_task_dyld_info
type struct_task_extmod_info struct {
	task_uuid         [16]uint8
	extmod_statistics struct_vm_extmod_statistics
}
type task_extmod_info_data_t = struct_task_extmod_info
type task_extmod_info_t = *struct_task_extmod_info
type struct_mach_task_basic_info struct {
	virtual_size      uint64
	resident_size     uint64
	resident_size_max uint64
	user_time         struct_time_value
	system_time       struct_time_value
	policy            int32
	suspend_count     int32
}
type mach_task_basic_info_data_t = struct_mach_task_basic_info
type mach_task_basic_info_t = *struct_mach_task_basic_info
type struct_task_power_info struct {
	total_user                 uint64
	total_system               uint64
	task_interrupt_wakeups     uint64
	task_platform_idle_wakeups uint64
	task_timer_wakeups_bin_1   uint64
	task_timer_wakeups_bin_2   uint64
}
type task_power_info_data_t = struct_task_power_info
type task_power_info_t = *struct_task_power_info
type struct_task_vm_info struct {
	virtual_size                               uint64
	region_count                               int32
	page_size                                  int32
	resident_size                              uint64
	resident_size_peak                         uint64
	device                                     uint64
	device_peak                                uint64
	internal                                   uint64
	internal_peak                              uint64
	external                                   uint64
	external_peak                              uint64
	reusable                                   uint64
	reusable_peak                              uint64
	purgeable_volatile_pmap                    uint64
	purgeable_volatile_resident                uint64
	purgeable_volatile_virtual                 uint64
	compressed                                 uint64
	compressed_peak                            uint64
	compressed_lifetime                        uint64
	phys_footprint                             uint64
	min_address                                uint64
	max_address                                uint64
	ledger_phys_footprint_peak                 int64
	ledger_purgeable_nonvolatile               int64
	ledger_purgeable_novolatile_compressed     int64
	ledger_purgeable_volatile                  int64
	ledger_purgeable_volatile_compressed       int64
	ledger_tag_network_nonvolatile             int64
	ledger_tag_network_nonvolatile_compressed  int64
	ledger_tag_network_volatile                int64
	ledger_tag_network_volatile_compressed     int64
	ledger_tag_media_footprint                 int64
	ledger_tag_media_footprint_compressed      int64
	ledger_tag_media_nofootprint               int64
	ledger_tag_media_nofootprint_compressed    int64
	ledger_tag_graphics_footprint              int64
	ledger_tag_graphics_footprint_compressed   int64
	ledger_tag_graphics_nofootprint            int64
	ledger_tag_graphics_nofootprint_compressed int64
	ledger_tag_neural_footprint                int64
	ledger_tag_neural_footprint_compressed     int64
	ledger_tag_neural_nofootprint              int64
	ledger_tag_neural_nofootprint_compressed   int64
	limit_bytes_remaining                      uint64
	decompressions                             int32
}
type task_vm_info_data_t = struct_task_vm_info
type task_vm_info_t = *struct_task_vm_info
type task_purgable_info_t = struct_vm_purgeable_info
type struct_task_trace_memory_info struct {
	user_memory_address uint64
	buffer_size         uint64
	mailbox_array_size  uint64
}
type task_trace_memory_info_data_t = struct_task_trace_memory_info
type task_trace_memory_info_t = *struct_task_trace_memory_info
type struct_task_wait_state_info struct {
	total_wait_state_time     uint64
	total_wait_sfi_state_time uint64
	_reserved                 [4]uint32
}
type task_wait_state_info_data_t = struct_task_wait_state_info
type task_wait_state_info_t = *struct_task_wait_state_info
type _cgoa_67 struct {
	task_gpu_utilisation    uint64
	task_gpu_stat_reserved0 uint64
	task_gpu_stat_reserved1 uint64
	task_gpu_stat_reserved2 uint64
}
type gpu_energy_data_t = *_cgoa_67
type struct_task_power_info_v2 struct {
	cpu_energy         struct_task_power_info
	gpu_energy         _cgoa_67
	task_ptime         uint64
	task_pset_switches uint64
}
type task_power_info_v2_data_t = struct_task_power_info_v2
type task_power_info_v2_t = *struct_task_power_info_v2
type struct_task_flags_info struct {
	flags uint32
}
type task_flags_info_data_t = struct_task_flags_info
type task_flags_info_t = *struct_task_flags_info
type task_exc_guard_behavior_t = uint32
type task_inspect_flavor_t = uint32

const TASK_INSPECT_BASIC_COUNTS int32 = 1

type struct_task_inspect_basic_counts struct {
	instructions uint64
	cycles       uint64
}
type task_inspect_basic_counts_data_t = struct_task_inspect_basic_counts
type task_inspect_basic_counts_t = *struct_task_inspect_basic_counts
type task_inspect_info_t = *int32
type task_policy_flavor_t = uint32
type task_policy_t = *int32

const (
	TASK_RENICED                int32 = -1
	TASK_UNSPECIFIED            int32 = 0
	TASK_FOREGROUND_APPLICATION int32 = 1
	TASK_BACKGROUND_APPLICATION int32 = 2
	TASK_CONTROL_APPLICATION    int32 = 3
	TASK_GRAPHICS_SERVER        int32 = 4
	TASK_THROTTLE_APPLICATION   int32 = 5
	TASK_NONUI_APPLICATION      int32 = 6
	TASK_DEFAULT_APPLICATION    int32 = 7
	TASK_DARWINBG_APPLICATION   int32 = 8
)

type task_role_t = int32
type struct_task_category_policy struct {
	role int32
}
type task_category_policy_data_t = struct_task_category_policy
type task_category_policy_t = *struct_task_category_policy

const (
	LATENCY_QOS_TIER_UNSPECIFIED int32 = 0
	LATENCY_QOS_TIER_0           int32 = 255<<16 | 1
	LATENCY_QOS_TIER_1           int32 = 255<<16 | 2
	LATENCY_QOS_TIER_2           int32 = 255<<16 | 3
	LATENCY_QOS_TIER_3           int32 = 255<<16 | 4
	LATENCY_QOS_TIER_4           int32 = 255<<16 | 5
	LATENCY_QOS_TIER_5           int32 = 255<<16 | 6
)

type task_latency_qos_t = int32

const (
	THROUGHPUT_QOS_TIER_UNSPECIFIED int32 = 0
	THROUGHPUT_QOS_TIER_0           int32 = 254<<16 | 1
	THROUGHPUT_QOS_TIER_1           int32 = 254<<16 | 2
	THROUGHPUT_QOS_TIER_2           int32 = 254<<16 | 3
	THROUGHPUT_QOS_TIER_3           int32 = 254<<16 | 4
	THROUGHPUT_QOS_TIER_4           int32 = 254<<16 | 5
	THROUGHPUT_QOS_TIER_5           int32 = 254<<16 | 6
)

type task_throughput_qos_t = int32
type struct_task_qos_policy struct {
	task_latency_qos_tier    int32
	task_throughput_qos_tier int32
}
type task_qos_policy_t = *struct_task_qos_policy
type task_special_port_t = int32
type thread_flavor_t = uint32
type thread_info_t = *int32
type thread_info_data_t = [32]int32
type struct_thread_basic_info struct {
	user_time     struct_time_value
	system_time   struct_time_value
	cpu_usage     int32
	policy        int32
	run_state     int32
	flags         int32
	suspend_count int32
	sleep_time    int32
}
type thread_basic_info_data_t = struct_thread_basic_info
type thread_basic_info_t = *struct_thread_basic_info
type struct_thread_identifier_info struct {
	thread_id      uint64
	thread_handle  uint64
	dispatch_qaddr uint64
}
type thread_identifier_info_data_t = struct_thread_identifier_info
type thread_identifier_info_t = *struct_thread_identifier_info
type struct_thread_extended_info struct {
	pth_user_time   uint64
	pth_system_time uint64
	pth_cpu_usage   int32
	pth_policy      int32
	pth_run_state   int32
	pth_flags       int32
	pth_sleep_time  int32
	pth_curpri      int32
	pth_priority    int32
	pth_maxpriority int32
	pth_name        [64]int8
}
type thread_extended_info_data_t = struct_thread_extended_info
type thread_extended_info_t = *struct_thread_extended_info
type struct_io_stat_entry struct {
	count uint64
	size  uint64
}
type struct_io_stat_info struct {
	disk_reads  struct_io_stat_entry
	io_priority [4]struct_io_stat_entry
	paging      struct_io_stat_entry
	metadata    struct_io_stat_entry
	total_io    struct_io_stat_entry
}
type io_stat_info_t = *struct_io_stat_info
type thread_policy_flavor_t = uint32
type thread_policy_t = *int32
type struct_thread_standard_policy struct {
	no_data uint32
}
type thread_standard_policy_data_t = struct_thread_standard_policy
type thread_standard_policy_t = *struct_thread_standard_policy
type struct_thread_extended_policy struct {
	timeshare uint32
}
type thread_extended_policy_data_t = struct_thread_extended_policy
type thread_extended_policy_t = *struct_thread_extended_policy
type struct_thread_time_constraint_policy struct {
	period      uint32
	computation uint32
	constraint  uint32
	preemptible uint32
}
type thread_time_constraint_policy_data_t = struct_thread_time_constraint_policy
type thread_time_constraint_policy_t = *struct_thread_time_constraint_policy
type struct_thread_precedence_policy struct {
	importance int32
}
type thread_precedence_policy_data_t = struct_thread_precedence_policy
type thread_precedence_policy_t = *struct_thread_precedence_policy
type struct_thread_affinity_policy struct {
	affinity_tag int32
}
type thread_affinity_policy_data_t = struct_thread_affinity_policy
type thread_affinity_policy_t = *struct_thread_affinity_policy
type struct_thread_background_policy struct {
	priority int32
}
type thread_background_policy_data_t = struct_thread_background_policy
type thread_background_policy_t = *struct_thread_background_policy
type thread_latency_qos_t = int32
type struct_thread_latency_qos_policy struct {
	thread_latency_qos_tier int32
}
type thread_latency_qos_policy_data_t = struct_thread_latency_qos_policy
type thread_latency_qos_policy_t = *struct_thread_latency_qos_policy
type thread_throughput_qos_t = int32
type struct_thread_throughput_qos_policy struct {
	thread_throughput_qos_tier int32
}
type thread_throughput_qos_policy_data_t = struct_thread_throughput_qos_policy
type thread_throughput_qos_policy_t = *struct_thread_throughput_qos_policy
type alarm_type_t = int32
type sleep_type_t = int32
type clock_id_t = int32
type clock_flavor_t = int32
type clock_attr_t = *int32
type clock_res_t = int32
type struct_mach_timespec struct {
	tv_sec  uint32
	tv_nsec int32
}
type mach_timespec_t = struct_mach_timespec
type vm_machine_attribute_t = uint32
type vm_machine_attribute_val_t = int32
type vm_inherit_t = uint32
type vm_purgable_t = int32
type vm_behavior_t = int32
type vm32_object_id_t = uint32
type vm_region_info_t = *int32
type vm_region_info_64_t = *int32
type vm_region_recurse_info_t = *int32
type vm_region_recurse_info_64_t = *int32
type vm_region_flavor_t = int32
type vm_region_info_data_t = [1024]int32
type struct_vm_region_basic_info_64 struct {
	protection       int32
	max_protection   int32
	inheritance      uint32
	shared           uint32
	reserved         uint32
	offset           uint64
	behavior         int32
	user_wired_count uint16
}
type vm_region_basic_info_64_t = *struct_vm_region_basic_info_64
type vm_region_basic_info_data_64_t = struct_vm_region_basic_info_64
type struct_vm_region_basic_info struct {
	protection       int32
	max_protection   int32
	inheritance      uint32
	shared           uint32
	reserved         uint32
	offset           uint32
	behavior         int32
	user_wired_count uint16
}
type vm_region_basic_info_t = *struct_vm_region_basic_info
type vm_region_basic_info_data_t = struct_vm_region_basic_info
type struct_vm_region_extended_info struct {
	protection               int32
	user_tag                 uint32
	pages_resident           uint32
	pages_shared_now_private uint32
	pages_swapped_out        uint32
	pages_dirtied            uint32
	ref_count                uint32
	shadow_depth             uint16
	external_pager           uint8
	share_mode               uint8
	pages_reusable           uint32
}
type vm_region_extended_info_t = *struct_vm_region_extended_info
type vm_region_extended_info_data_t = struct_vm_region_extended_info
type struct_vm_region_top_info struct {
	obj_id                 uint32
	ref_count              uint32
	private_pages_resident uint32
	shared_pages_resident  uint32
	share_mode             uint8
}
type vm_region_top_info_t = *struct_vm_region_top_info
type vm_region_top_info_data_t = struct_vm_region_top_info
type struct_vm_region_submap_info struct {
	protection               int32
	max_protection           int32
	inheritance              uint32
	offset                   uint32
	user_tag                 uint32
	pages_resident           uint32
	pages_shared_now_private uint32
	pages_swapped_out        uint32
	pages_dirtied            uint32
	ref_count                uint32
	shadow_depth             uint16
	external_pager           uint8
	share_mode               uint8
	is_submap                uint32
	behavior                 int32
	object_id                uint32
	user_wired_count         uint16
}
type vm_region_submap_info_t = *struct_vm_region_submap_info
type vm_region_submap_info_data_t = struct_vm_region_submap_info
type struct_vm_region_submap_info_64 struct {
	protection               int32
	max_protection           int32
	inheritance              uint32
	offset                   uint64
	user_tag                 uint32
	pages_resident           uint32
	pages_shared_now_private uint32
	pages_swapped_out        uint32
	pages_dirtied            uint32
	ref_count                uint32
	shadow_depth             uint16
	external_pager           uint8
	share_mode               uint8
	is_submap                uint32
	behavior                 int32
	object_id                uint32
	user_wired_count         uint16
	pages_reusable           uint32
	object_id_full           uint64
}
type vm_region_submap_info_64_t = *struct_vm_region_submap_info_64
type vm_region_submap_info_data_64_t = struct_vm_region_submap_info_64
type struct_vm_region_submap_short_info_64 struct {
	protection       int32
	max_protection   int32
	inheritance      uint32
	offset           uint64
	user_tag         uint32
	ref_count        uint32
	shadow_depth     uint16
	external_pager   uint8
	share_mode       uint8
	is_submap        uint32
	behavior         int32
	object_id        uint32
	user_wired_count uint16
}
type vm_region_submap_short_info_64_t = *struct_vm_region_submap_short_info_64
type vm_region_submap_short_info_data_64_t = struct_vm_region_submap_short_info_64
type struct_mach_vm_read_entry struct {
	address uint64
	size    uint64
}
type struct_vm_read_entry struct {
	address uint
	size    uint
}
type mach_vm_read_entry_t = [256]struct_mach_vm_read_entry
type vm_read_entry_t = [256]struct_vm_read_entry
type vm_page_info_t = *int32
type vm_page_info_flavor_t = int32
type struct_vm_page_info_basic struct {
	disposition int32
	ref_count   int32
	object_id   uint64
	offset      uint64
	depth       int32
	__pad       int32
}
type vm_page_info_basic_t = *struct_vm_page_info_basic
type vm_page_info_basic_data_t = struct_vm_page_info_basic
type kmod_t = int32
type kmod_start_func_t = func(*struct_kmod_info, unsafe.Pointer) int32
type kmod_stop_func_t = func(*struct_kmod_info, unsafe.Pointer) int32
type struct_kmod_reference struct {
	next *struct_kmod_reference
	info *struct_kmod_info
}
type kmod_reference_t = struct_kmod_reference
type struct_kmod_info struct {
	next            *struct_kmod_info
	info_version    int32
	id              uint32
	name            [64]int8
	version         [64]int8
	reference_count int32
	reference_list  *struct_kmod_reference
	address         uint
	size            uint
	hdr_size        uint
	start           func(*struct_kmod_info, unsafe.Pointer) int32
	stop            func(*struct_kmod_info, unsafe.Pointer) int32
}
type kmod_info_t = struct_kmod_info
type struct_kmod_info_32_v1 struct {
	next_addr           uint32
	info_version        int32
	id                  uint32
	name                [64]uint8
	version             [64]uint8
	reference_count     int32
	reference_list_addr uint32
	address             uint32
	size                uint32
	hdr_size            uint32
	start_addr          uint32
	stop_addr           uint32
}
type kmod_info_32_v1_t = struct_kmod_info_32_v1
type struct_kmod_info_64_v1 struct {
	next_addr           uint64
	info_version        int32
	id                  uint32
	name                [64]uint8
	version             [64]uint8
	reference_count     int32
	reference_list_addr uint64
	address             uint64
	size                uint64
	hdr_size            uint64
	start_addr          uint64
	stop_addr           uint64
}
type kmod_info_64_v1_t = struct_kmod_info_64_v1
type kmod_args_t = unsafe.Pointer
type kmod_control_flavor_t = int32
type kmod_info_array_t = *struct_kmod_info
type struct_fsid struct {
	val [2]int32
}
type fsid_t = struct_fsid
type struct_fsobj_id struct {
	fid_objno      uint32
	fid_generation uint32
}
type fsobj_id_t = struct_fsobj_id
type struct_dyld_kernel_image_info struct {
	uuid      [16]uint8
	fsobjid   struct_fsobj_id
	fsid      struct_fsid
	load_addr uint64
}
type struct_dyld_kernel_process_info struct {
	cache_image_info  struct_dyld_kernel_image_info
	timestamp         uint64
	imageCount        uint32
	initialImageCount uint32
	dyldState         uint8
	no_cache          uint32
	private_cache     uint32
}
type dyld_kernel_image_info_t = struct_dyld_kernel_image_info
type dyld_kernel_process_info_t = struct_dyld_kernel_process_info
type dyld_kernel_image_info_array_t = *struct_dyld_kernel_image_info
type task_t = uint32
type task_name_t = uint32
type task_policy_set_t = uint32
type task_policy_get_t = uint32
type task_inspect_t = uint32
type task_read_t = uint32
type task_suspension_token_t = uint32
type thread_t = uint32
type thread_act_t = uint32
type thread_inspect_t = uint32
type thread_read_t = uint32
type ipc_space_t = uint32
type ipc_space_read_t = uint32
type ipc_space_inspect_t = uint32
type coalition_t = uint32
type host_t = uint32
type host_priv_t = uint32
type host_security_t = uint32
type processor_t = uint32
type processor_set_t = uint32
type processor_set_control_t = uint32
type semaphore_t = uint32
type lock_set_t = uint32
type ledger_t = uint32
type alarm_t = uint32
type clock_serv_t = uint32
type clock_ctrl_t = uint32
type arcade_register_t = uint32
type ipc_eventlink_t = uint32
type eventlink_port_pair_t = [2]uint32
type suid_cred_t = uint32
type task_id_token_t = uint32
type processor_set_name_t = uint32
type clock_reply_t = uint32
type bootstrap_t = uint32
type mem_entry_name_port_t = uint32
type exception_handler_t = uint32
type exception_handler_array_t = *uint32
type vm_task_entry_t = uint32
type io_master_t = uint32
type UNDServerRef = uint32
type mach_eventlink_t = uint32
type exception_handler_info_t = struct_ipc_info_port
type task_array_t = *uint32
type thread_array_t = *uint32
type processor_set_array_t = *uint32
type processor_set_name_array_t = *uint32
type processor_array_t = *uint32
type thread_act_array_t = *uint32
type ledger_array_t = *uint32
type task_port_t = uint32
type task_port_array_t = *uint32
type thread_port_t = uint32
type thread_port_array_t = *uint32
type ipc_space_port_t = uint32
type host_name_t = uint32
type host_name_port_t = uint32
type processor_set_port_t = uint32
type processor_set_name_port_t = uint32
type processor_set_name_port_array_t = *uint32
type processor_set_control_port_t = uint32
type processor_port_t = uint32
type processor_port_array_t = *uint32
type thread_act_port_t = uint32
type thread_act_port_array_t = *uint32
type semaphore_port_t = uint32
type lock_set_port_t = uint32
type ledger_port_t = uint32
type ledger_port_array_t = *uint32
type alarm_port_t = uint32
type clock_serv_port_t = uint32
type clock_ctrl_port_t = uint32
type exception_port_t = uint32
type exception_port_arrary_t = *uint32
type vfs_path_t = [4096]int8
type nspace_path_t = [1024]int8
type suid_cred_path_t = [1024]int8
type suid_cred_uid_t = uint32
type mach_task_flavor_t = uint32
type mach_thread_flavor_t = uint32
type ledger_item_t = uint32
type ledger_amount_t = int64
type emulation_vector_t = *uint64
type user_subsystem_t = *int8
type labelstr_t = *int8
type struct__malloc_zone_t struct {
	reserved1          unsafe.Pointer
	reserved2          unsafe.Pointer
	size               func(*struct__malloc_zone_t, unsafe.Pointer) uint
	malloc             func(*struct__malloc_zone_t, uint) unsafe.Pointer
	calloc             func(*struct__malloc_zone_t, uint, uint) unsafe.Pointer
	valloc             func(*struct__malloc_zone_t, uint) unsafe.Pointer
	free               func(*struct__malloc_zone_t, unsafe.Pointer)
	realloc            func(*struct__malloc_zone_t, unsafe.Pointer, uint) unsafe.Pointer
	destroy            func(*struct__malloc_zone_t)
	zone_name          *int8
	batch_malloc       func(*struct__malloc_zone_t, uint, *unsafe.Pointer, uint32) uint32
	batch_free         func(*struct__malloc_zone_t, *unsafe.Pointer, uint32)
	introspect         *struct_malloc_introspection_t
	version            uint32
	memalign           func(*struct__malloc_zone_t, uint, uint) unsafe.Pointer
	free_definite_size func(*struct__malloc_zone_t, unsafe.Pointer, uint)
	pressure_relief    func(*struct__malloc_zone_t, uint) uint
	claimed_address    func(*struct__malloc_zone_t, unsafe.Pointer) uint32
}
type malloc_zone_t = struct__malloc_zone_t
type _cgoa_68 struct {
	address uint
	size    uint
}
type struct_malloc_statistics_t struct {
	blocks_in_use   uint32
	size_in_use     uint
	max_size_in_use uint
	size_allocated  uint
}
type malloc_statistics_t = struct_malloc_statistics_t
type memory_reader_t = func(uint32, uint, uint, *unsafe.Pointer) int32
type vm_range_recorder_t = func(uint32, unsafe.Pointer, uint32, *_cgoa_68, uint32)
type print_task_printer_t = func(*int8, ...interface {
})
type struct_malloc_introspection_t struct {
	enumerator                    func(uint32, unsafe.Pointer, uint32, uint, func(uint32, uint, uint, *unsafe.Pointer) int32, func(uint32, unsafe.Pointer, uint32, *_cgoa_68, uint32)) int32
	good_size                     func(*struct__malloc_zone_t, uint) uint
	check                         func(*struct__malloc_zone_t) uint32
	print                         func(*struct__malloc_zone_t, uint32)
	log                           func(*struct__malloc_zone_t, unsafe.Pointer)
	force_lock                    func(*struct__malloc_zone_t)
	force_unlock                  func(*struct__malloc_zone_t)
	statistics                    func(*struct__malloc_zone_t, *struct_malloc_statistics_t)
	zone_locked                   func(*struct__malloc_zone_t) uint32
	enable_discharge_checking     func(*struct__malloc_zone_t) uint32
	disable_discharge_checking    func(*struct__malloc_zone_t)
	discharge                     func(*struct__malloc_zone_t, unsafe.Pointer)
	enumerate_discharged_pointers func(*struct__malloc_zone_t, func(unsafe.Pointer, unsafe.Pointer))
	reinit_lock                   func(*struct__malloc_zone_t)
	print_task                    func(uint32, uint32, uint, func(uint32, uint, uint, *unsafe.Pointer) int32, func(*int8, ...interface {
	}))
	task_statistics func(uint32, uint, func(uint32, uint, uint, *unsafe.Pointer) int32, *struct_malloc_statistics_t)
}
type malloc_introspection_t = struct_malloc_introspection_t
type struct_mstats struct {
	bytes_total uint
	chunks_used uint
	bytes_used  uint
	chunks_free uint
	bytes_free  uint
}

var _sqliteZone_ *struct__malloc_zone_t

func sqlite3MemMalloc(nByte int32) unsafe.Pointer {
	var p unsafe.Pointer
	p = malloc_zone_malloc(_sqliteZone_, uint(nByte))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_log(7, (*int8)(unsafe.Pointer(&[38]int8{'f', 'a', 'i', 'l', 'e', 'd', ' ', 't', 'o', ' ', 'a', 'l', 'l', 'o', 'c', 'a', 't', 'e', ' ', '%', 'u', ' ', 'b', 'y', 't', 'e', 's', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})), nByte)
	}
	return p
}
func sqlite3MemFree(pPrior unsafe.Pointer) {
	malloc_zone_free(_sqliteZone_, pPrior)
}
func sqlite3MemSize(pPrior unsafe.Pointer) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return int32(func() uint {
		if _sqliteZone_ != nil {
			return _sqliteZone_.size(_sqliteZone_, pPrior)
		} else {
			return malloc_size(pPrior)
		}
	}())
}
func sqlite3MemRealloc(pPrior unsafe.Pointer, nByte int32) unsafe.Pointer {
	var p unsafe.Pointer = malloc_zone_realloc(_sqliteZone_, pPrior, uint(nByte))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_log(7, (*int8)(unsafe.Pointer(&[36]int8{'f', 'a', 'i', 'l', 'e', 'd', ' ', 'm', 'e', 'm', 'o', 'r', 'y', ' ', 'r', 'e', 's', 'i', 'z', 'e', ' ', '%', 'u', ' ', 't', 'o', ' ', '%', 'u', ' ', 'b', 'y', 't', 'e', 's', '\x00'})), func() uint {
			if _sqliteZone_ != nil {
				return _sqliteZone_.size(_sqliteZone_, pPrior)
			} else {
				return malloc_size(pPrior)
			}
		}(), nByte)
	}
	return p
}
func sqlite3MemRoundup(n int32) int32 {
	return (n + 7) & ^7
}
func sqlite3MemInit(NotUsed unsafe.Pointer) int32 {
	var cpuCount int32
	var len uint
	if _sqliteZone_ != nil {
		return int32(0)
	}
	len = uint(4)
	sysctlbyname((*int8)(unsafe.Pointer(&[8]int8{'h', 'w', '.', 'n', 'c', 'p', 'u', '\x00'})), unsafe.Pointer(&cpuCount), &len, unsafe.Pointer(0), uint(0))
	if cpuCount > 1 {
		_sqliteZone_ = malloc_default_zone()
	} else {
		_sqliteZone_ = malloc_create_zone(uint(4096), uint32(0))
		malloc_set_zone_name(_sqliteZone_, (*int8)(unsafe.Pointer(&[12]int8{'S', 'q', 'l', 'i', 't', 'e', '_', 'H', 'e', 'a', 'p', '\x00'})))
	}
	func() int {
		_ = NotUsed
		return 0
	}()
	return int32(0)
}
func sqlite3MemShutdown(NotUsed unsafe.Pointer) {
	func() int {
		_ = NotUsed
		return 0
	}()
	return
}
func sqlite3MemSetDefault() {
	var defaultMethods struct_sqlite3_mem_methods = struct_sqlite3_mem_methods{sqlite3MemMalloc, sqlite3MemFree, sqlite3MemRealloc, sqlite3MemSize, sqlite3MemRoundup, sqlite3MemInit, sqlite3MemShutdown, nil}
	sqlite3_config(4, &defaultMethods)
}
func sqlite3MutexInit() int32 {
	var rc int32 = 0
	if !(sqlite3Config.mutex.xMutexAlloc != nil) {
		var pFrom *struct_sqlite3_mutex_methods
		var pTo *struct_sqlite3_mutex_methods = &sqlite3Config.mutex
		if sqlite3Config.bCoreMutex != 0 {
			pFrom = sqlite3DefaultMutex()
		} else {
			pFrom = sqlite3NoopMutex()
		}
		pTo.xMutexInit = pFrom.xMutexInit
		pTo.xMutexEnd = pFrom.xMutexEnd
		pTo.xMutexFree = pFrom.xMutexFree
		pTo.xMutexEnter = pFrom.xMutexEnter
		pTo.xMutexTry = pFrom.xMutexTry
		pTo.xMutexLeave = pFrom.xMutexLeave
		pTo.xMutexHeld = pFrom.xMutexHeld
		pTo.xMutexNotheld = pFrom.xMutexNotheld
		sqlite3MemoryBarrier()
		pTo.xMutexAlloc = pFrom.xMutexAlloc
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3Config.mutex.xMutexInit()
	sqlite3MemoryBarrier()
	return rc
}
func sqlite3MutexEnd() int32 {
	var rc int32 = 0
	if sqlite3Config.mutex.xMutexEnd != nil {
		rc = sqlite3Config.mutex.xMutexEnd()
	}
	return rc
}
func sqlite3_mutex_alloc(id int32) *struct_sqlite3_mutex {
	if id <= 1 && sqlite3_initialize() != 0 {
		return (*struct_sqlite3_mutex)(nil)
	}
	if id > 1 && sqlite3MutexInit() != 0 {
		return (*struct_sqlite3_mutex)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3Config.mutex.xMutexAlloc(id)
}
func sqlite3MutexAlloc(id int32) *struct_sqlite3_mutex {
	if !(sqlite3Config.bCoreMutex != 0) {
		return (*struct_sqlite3_mutex)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3Config.mutex.xMutexAlloc(id)
}
func sqlite3_mutex_free(p *struct_sqlite3_mutex) {
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3Config.mutex.xMutexFree(p)
	}
}
func sqlite3_mutex_enter(p *struct_sqlite3_mutex) {
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3Config.mutex.xMutexEnter(p)
	}
}
func sqlite3_mutex_try(p *struct_sqlite3_mutex) int32 {
	var rc int32 = 0
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		return sqlite3Config.mutex.xMutexTry(p)
	}
	return rc
}
func sqlite3_mutex_leave(p *struct_sqlite3_mutex) {
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3Config.mutex.xMutexLeave(p)
	}
}
func noopMutexInit() int32 {
	return int32(0)
}
func noopMutexEnd() int32 {
	return int32(0)
}
func noopMutexAlloc(id int32) *struct_sqlite3_mutex {
	func() int {
		_ = id
		return 0
	}()
	return (*struct_sqlite3_mutex)(unsafe.Pointer(uintptr(8)))
}
func noopMutexFree(p *struct_sqlite3_mutex) {
	func() int {
		_ = p
		return 0
	}()
	return
}
func noopMutexEnter(p *struct_sqlite3_mutex) {
	func() int {
		_ = p
		return 0
	}()
	return
}
func noopMutexTry(p *struct_sqlite3_mutex) int32 {
	func() int {
		_ = p
		return 0
	}()
	return int32(0)
}
func noopMutexLeave(p *struct_sqlite3_mutex) {
	func() int {
		_ = p
		return 0
	}()
	return
}
func sqlite3NoopMutex() *struct_sqlite3_mutex_methods {
	var sMutex struct_sqlite3_mutex_methods = struct_sqlite3_mutex_methods{noopMutexInit, noopMutexEnd, noopMutexAlloc, noopMutexFree, noopMutexEnter, noopMutexTry, noopMutexLeave, nil, nil}
	return &sMutex
}

type struct_sched_param struct {
	sched_priority int32
	__opaque       [4]int8
}

const (
	QOS_CLASS_USER_INTERACTIVE int32 = 33
	QOS_CLASS_USER_INITIATED   int32 = 25
	QOS_CLASS_DEFAULT          int32 = 21
	QOS_CLASS_UTILITY          int32 = 17
	QOS_CLASS_BACKGROUND       int32 = 9
	QOS_CLASS_UNSPECIFIED      int32 = 0
)

type qos_class_t = uint32
type pthread_override_t = *struct_pthread_override_s
type struct_sqlite3_mutex struct {
	mutex struct__opaque_pthread_mutex_t
}

func sqlite3MemoryBarrier() {
	__sync_synchronize()
}
func pthreadMutexInit() int32 {
	return int32(0)
}
func pthreadMutexEnd() int32 {
	return int32(0)
}
func pthreadMutexAlloc(iType int32) *struct_sqlite3_mutex {
	var staticMutexes [12]struct_sqlite3_mutex = [12]struct_sqlite3_mutex{struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}, struct_sqlite3_mutex{struct__opaque_pthread_mutex_t{int(850045863), [56]int8{int8(0)}}}}
	var p *struct_sqlite3_mutex
	switch iType {
	case 1:
		{
			p = (*struct_sqlite3_mutex)(sqlite3MallocZero(uint64(64)))
			if p != nil {
				var recursiveAttr struct__opaque_pthread_mutexattr_t
				pthread_mutexattr_init(&recursiveAttr)
				pthread_mutexattr_settype(&recursiveAttr, 2)
				pthread_mutex_init(&p.mutex, &recursiveAttr)
				pthread_mutexattr_destroy(&recursiveAttr)
			}
			break
		}
	case 0:
		{
			p = (*struct_sqlite3_mutex)(sqlite3MallocZero(uint64(64)))
			if p != nil {
				pthread_mutex_init(&p.mutex, nil)
			}
			break
		}
	default:
		{
			p = &*(*struct_sqlite3_mutex)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sqlite3_mutex)(unsafe.Pointer(&staticMutexes)))) + uintptr(iType-2)*64))
			break
		}
	}
	return p
}
func pthreadMutexFree(p *struct_sqlite3_mutex) {
	func() int {
		_ = 0
		return 0
	}()
	{
		pthread_mutex_destroy(&p.mutex)
		sqlite3_free(unsafe.Pointer(p))
	}
}
func pthreadMutexEnter(p *struct_sqlite3_mutex) {
	func() int {
		_ = 0
		return 0
	}()
	pthread_mutex_lock(&p.mutex)
}
func pthreadMutexTry(p *struct_sqlite3_mutex) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if pthread_mutex_trylock(&p.mutex) == 0 {
		rc = int32(0)
	} else {
		rc = int32(5)
	}
	return rc
}
func pthreadMutexLeave(p *struct_sqlite3_mutex) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pthread_mutex_unlock(&p.mutex)
}
func sqlite3DefaultMutex() *struct_sqlite3_mutex_methods {
	var sMutex struct_sqlite3_mutex_methods = struct_sqlite3_mutex_methods{pthreadMutexInit, pthreadMutexEnd, pthreadMutexAlloc, pthreadMutexFree, pthreadMutexEnter, pthreadMutexTry, pthreadMutexLeave, nil, nil}
	return &sMutex
}
func sqlite3_release_memory(n int32) int32 {
	func() int {
		_ = n
		return 0
	}()
	return int32(0)
}

type struct_Mem0Global struct {
	mutex          *struct_sqlite3_mutex
	alarmThreshold int64
	hardLimit      int64
	nearlyFull     int32
}

var mem0 struct_Mem0Global = struct_Mem0Global{nil, int64(0), int64(0), 0}

func sqlite3MallocMutex() *struct_sqlite3_mutex {
	return mem0.mutex
}
func sqlite3_memory_alarm(xCallback func(unsafe.Pointer, int64, int32), pArg unsafe.Pointer, iThreshold int64) int32 {
	func() int {
		_ = xCallback
		return 0
	}()
	func() int {
		_ = pArg
		return 0
	}()
	func() int {
		_ = iThreshold
		return 0
	}()
	return int32(0)
}
func sqlite3_soft_heap_limit64(n int64) int64 {
	var priorLimit int64
	var excess int64
	var nUsed int64
	var rc int32 = sqlite3_initialize()
	if rc != 0 {
		return int64(-1)
	}
	sqlite3_mutex_enter(mem0.mutex)
	priorLimit = mem0.alarmThreshold
	if n < int64(0) {
		sqlite3_mutex_leave(mem0.mutex)
		return priorLimit
	}
	if mem0.hardLimit > int64(0) && (n > mem0.hardLimit || n == int64(0)) {
		n = mem0.hardLimit
	}
	mem0.alarmThreshold = n
	nUsed = sqlite3StatusValue(0)
	__atomic_store_n_i32(&mem0.nearlyFull, 0, func() int32 {
		if n > int64(0) && n <= nUsed {
			return 1
		} else {
			return 0
		}
	}())
	sqlite3_mutex_leave(mem0.mutex)
	excess = sqlite3_memory_used() - n
	if excess > int64(0) {
		sqlite3_release_memory(int32(excess & int64(2147483647)))
	}
	return priorLimit
}
func sqlite3_soft_heap_limit(n int32) {
	if n < 0 {
		n = int32(0)
	}
	sqlite3_soft_heap_limit64(int64(n))
}
func sqlite3_hard_heap_limit64(n int64) int64 {
	var priorLimit int64
	var rc int32 = sqlite3_initialize()
	if rc != 0 {
		return int64(-1)
	}
	sqlite3_mutex_enter(mem0.mutex)
	priorLimit = mem0.hardLimit
	if n >= int64(0) {
		mem0.hardLimit = n
		if n < mem0.alarmThreshold || mem0.alarmThreshold == int64(0) {
			mem0.alarmThreshold = n
		}
	}
	sqlite3_mutex_leave(mem0.mutex)
	return priorLimit
}
func sqlite3MallocInit() int32 {
	var rc int32
	if uintptr(unsafe.Pointer(sqlite3Config.m.xMalloc)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3MemSetDefault()
	}
	mem0.mutex = sqlite3MutexAlloc(3)
	if uintptr(unsafe.Pointer(sqlite3Config.pPage)) == uintptr(unsafe.Pointer(nil)) || sqlite3Config.szPage < 512 || sqlite3Config.nPage <= 0 {
		sqlite3Config.pPage = unsafe.Pointer(nil)
		sqlite3Config.szPage = int32(0)
	}
	rc = sqlite3Config.m.xInit(sqlite3Config.m.pAppData)
	if rc != 0 {
		__builtin___memset_chk(unsafe.Pointer(&mem0), 0, 28, __builtin_object_size(unsafe.Pointer(&mem0), 0))
	}
	return rc
}
func sqlite3HeapNearlyFull() int32 {
	return __atomic_load_n_i32(&mem0.nearlyFull, 0)
}
func sqlite3MallocEnd() {
	if sqlite3Config.m.xShutdown != nil {
		sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData)
	}
	__builtin___memset_chk(unsafe.Pointer(&mem0), 0, 28, __builtin_object_size(unsafe.Pointer(&mem0), 0))
}
func sqlite3_memory_used() int64 {
	var res int64
	var mx int64
	sqlite3_status64(0, &res, &mx, 0)
	return res
}
func sqlite3_memory_highwater(resetFlag int32) int64 {
	var res int64
	var mx int64
	sqlite3_status64(0, &res, &mx, resetFlag)
	return mx
}
func sqlite3MallocAlarm(nByte int32) {
	if mem0.alarmThreshold <= int64(0) {
		return
	}
	sqlite3_mutex_leave(mem0.mutex)
	sqlite3_release_memory(nByte)
	sqlite3_mutex_enter(mem0.mutex)
}
func mallocWithAlarm(n int32, pp *unsafe.Pointer) {
	var p unsafe.Pointer
	var nFull int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nFull = sqlite3Config.m.xRoundup(n)
	sqlite3StatusHighwater(5, n)
	if mem0.alarmThreshold > int64(0) {
		var nUsed int64 = sqlite3StatusValue(0)
		if nUsed >= mem0.alarmThreshold-int64(nFull) {
			__atomic_store_n_i32(&mem0.nearlyFull, 0, 1)
			sqlite3MallocAlarm(nFull)
			if mem0.hardLimit != 0 {
				nUsed = sqlite3StatusValue(0)
				if nUsed >= mem0.hardLimit-int64(nFull) {
					*pp = unsafe.Pointer(nil)
					return
				}
			}
		} else {
			__atomic_store_n_i32(&mem0.nearlyFull, 0, 0)
		}
	}
	p = sqlite3Config.m.xMalloc(nFull)
	if p != nil {
		nFull = sqlite3MallocSize(p)
		sqlite3StatusUp(0, nFull)
		sqlite3StatusUp(9, 1)
	}
	*pp = p
}
func sqlite3Malloc(n uint64) unsafe.Pointer {
	var p unsafe.Pointer
	if n == uint64(0) || n >= uint64(2147483392) {
		p = unsafe.Pointer(nil)
	} else if sqlite3Config.bMemstat != 0 {
		sqlite3_mutex_enter(mem0.mutex)
		mallocWithAlarm(int32(n), &p)
		sqlite3_mutex_leave(mem0.mutex)
	} else {
		p = sqlite3Config.m.xMalloc(int32(n))
	}
	func() int {
		_ = 0
		return 0
	}()
	return p
}
func sqlite3_malloc(n int32) unsafe.Pointer {
	if sqlite3_initialize() != 0 {
		return unsafe.Pointer(nil)
	}
	return func() unsafe.Pointer {
		if n <= 0 {
			return nil
		} else {
			return sqlite3Malloc(uint64(n))
		}
	}()
}
func sqlite3_malloc64(n uint64) unsafe.Pointer {
	if sqlite3_initialize() != 0 {
		return unsafe.Pointer(nil)
	}
	return sqlite3Malloc(n)
}
func isLookaside(db *struct_sqlite3, p unsafe.Pointer) int32 {
	return func() int32 {
		if uint64(p) >= uint64(db.lookaside.pStart) && uint64(p) < uint64(db.lookaside.pEnd) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3MallocSize(p unsafe.Pointer) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3Config.m.xSize(unsafe.Pointer(p))
}
func lookasideMallocSize(db *struct_sqlite3, p unsafe.Pointer) int32 {
	return func() int32 {
		if uintptr(unsafe.Pointer(p)) < uintptr(unsafe.Pointer(unsafe.Pointer(db.lookaside.pMiddle))) {
			return int32(db.lookaside.szTrue)
		} else {
			return 128
		}
	}()
}
func sqlite3DbMallocSize(db *struct_sqlite3, p unsafe.Pointer) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if db != nil {
		if uint64(p) < uint64(db.lookaside.pEnd) {
			if uint64(p) >= uint64(db.lookaside.pMiddle) {
				func() int {
					_ = 0
					return 0
				}()
				return int32(128)
			}
			if uint64(p) >= uint64(db.lookaside.pStart) {
				func() int {
					_ = 0
					return 0
				}()
				return int32(db.lookaside.szTrue)
			}
		}
	}
	return sqlite3Config.m.xSize(unsafe.Pointer(p))
}
func sqlite3_msize(p unsafe.Pointer) uint64 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return uint64(func() int32 {
		if p != nil {
			return sqlite3Config.m.xSize(p)
		} else {
			return 0
		}
	}())
}
func sqlite3_free(p unsafe.Pointer) {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3Config.bMemstat != 0 {
		sqlite3_mutex_enter(mem0.mutex)
		sqlite3StatusDown(0, sqlite3MallocSize(p))
		sqlite3StatusDown(9, 1)
		sqlite3Config.m.xFree(p)
		sqlite3_mutex_leave(mem0.mutex)
	} else {
		sqlite3Config.m.xFree(p)
	}
}
func measureAllocationSize(db *struct_sqlite3, p unsafe.Pointer) {
	*db.pnBytesFreed += sqlite3DbMallocSize(db, p)
}
func sqlite3DbFreeNN(db *struct_sqlite3, p unsafe.Pointer) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db != nil {
		if db.pnBytesFreed != nil {
			measureAllocationSize(db, p)
			return
		}
		if uint64(p) < uint64(db.lookaside.pEnd) {
			if uint64(p) >= uint64(db.lookaside.pMiddle) {
				var pBuf *struct_LookasideSlot = (*struct_LookasideSlot)(p)
				pBuf.pNext = db.lookaside.pSmallFree
				db.lookaside.pSmallFree = pBuf
				return
			}
			if uint64(p) >= uint64(db.lookaside.pStart) {
				var pBuf *struct_LookasideSlot = (*struct_LookasideSlot)(p)
				pBuf.pNext = db.lookaside.pFree
				db.lookaside.pFree = pBuf
				return
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_free(p)
}
func sqlite3DbFree(db *struct_sqlite3, p unsafe.Pointer) {
	func() int {
		_ = 0
		return 0
	}()
	if p != nil {
		sqlite3DbFreeNN(db, p)
	}
}
func sqlite3Realloc(pOld unsafe.Pointer, nBytes uint64) unsafe.Pointer {
	var nOld int32
	var nNew int32
	var nDiff int32
	var pNew unsafe.Pointer
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pOld)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3Malloc(nBytes)
	}
	if nBytes == uint64(0) {
		sqlite3_free(pOld)
		return unsafe.Pointer(nil)
	}
	if nBytes >= uint64(2147483392) {
		return unsafe.Pointer(nil)
	}
	nOld = sqlite3MallocSize(pOld)
	nNew = sqlite3Config.m.xRoundup(int32(nBytes))
	if nOld == nNew {
		pNew = pOld
	} else if sqlite3Config.bMemstat != 0 {
		var nUsed int64
		sqlite3_mutex_enter(mem0.mutex)
		sqlite3StatusHighwater(5, int32(nBytes))
		nDiff = nNew - nOld
		if nDiff > 0 && func() (_cgo_ret int64) {
			_cgo_addr := &nUsed
			*_cgo_addr = sqlite3StatusValue(0)
			return *_cgo_addr
		}() >= mem0.alarmThreshold-int64(nDiff) {
			sqlite3MallocAlarm(nDiff)
			if mem0.hardLimit > int64(0) && nUsed >= mem0.hardLimit-int64(nDiff) {
				sqlite3_mutex_leave(mem0.mutex)
				return unsafe.Pointer(nil)
			}
		}
		pNew = sqlite3Config.m.xRealloc(pOld, nNew)
		if pNew != nil {
			nNew = sqlite3MallocSize(pNew)
			sqlite3StatusUp(0, nNew-nOld)
		}
		sqlite3_mutex_leave(mem0.mutex)
	} else {
		pNew = sqlite3Config.m.xRealloc(pOld, nNew)
	}
	func() int {
		_ = 0
		return 0
	}()
	return pNew
}
func sqlite3_realloc(pOld unsafe.Pointer, n int32) unsafe.Pointer {
	if sqlite3_initialize() != 0 {
		return unsafe.Pointer(nil)
	}
	if n < 0 {
		n = int32(0)
	}
	return sqlite3Realloc(pOld, uint64(n))
}
func sqlite3_realloc64(pOld unsafe.Pointer, n uint64) unsafe.Pointer {
	if sqlite3_initialize() != 0 {
		return unsafe.Pointer(nil)
	}
	return sqlite3Realloc(pOld, n)
}
func sqlite3MallocZero(n uint64) unsafe.Pointer {
	var p unsafe.Pointer = sqlite3Malloc(n)
	if p != nil {
		__builtin___memset_chk(p, 0, uint(n), __builtin_object_size(p, 0))
	}
	return p
}
func sqlite3DbMallocZero(db *struct_sqlite3, n uint64) unsafe.Pointer {
	var p unsafe.Pointer
	p = sqlite3DbMallocRaw(db, n)
	if p != nil {
		__builtin___memset_chk(p, 0, uint(n), __builtin_object_size(p, 0))
	}
	return p
}
func dbMallocRawFinish(db *struct_sqlite3, n uint64) unsafe.Pointer {
	var p unsafe.Pointer
	func() int {
		_ = 0
		return 0
	}()
	p = sqlite3Malloc(n)
	if !(p != nil) {
		sqlite3OomFault(db)
	}
	return p
}
func sqlite3DbMallocRaw(db *struct_sqlite3, n uint64) unsafe.Pointer {
	var p unsafe.Pointer
	if db != nil {
		return sqlite3DbMallocRawNN(db, n)
	}
	p = sqlite3Malloc(n)
	return p
}
func sqlite3DbMallocRawNN(db *struct_sqlite3, n uint64) unsafe.Pointer {
	var pBuf *struct_LookasideSlot
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if n > uint64(db.lookaside.sz) {
		if !(db.lookaside.bDisable != 0) {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(1)*4))++
		} else if db.mallocFailed != 0 {
			return unsafe.Pointer(nil)
		}
		return dbMallocRawFinish(db, n)
	}
	if n <= uint64(128) {
		if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_LookasideSlot) {
			_cgo_addr := &pBuf
			*_cgo_addr = db.lookaside.pSmallFree
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			db.lookaside.pSmallFree = pBuf.pNext
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(0)*4))++
			return unsafe.Pointer(pBuf)
		} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_LookasideSlot) {
			_cgo_addr := &pBuf
			*_cgo_addr = db.lookaside.pSmallInit
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			db.lookaside.pSmallInit = pBuf.pNext
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(0)*4))++
			return unsafe.Pointer(pBuf)
		}
	}
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_LookasideSlot) {
		_cgo_addr := &pBuf
		*_cgo_addr = db.lookaside.pFree
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		db.lookaside.pFree = pBuf.pNext
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(0)*4))++
		return unsafe.Pointer(pBuf)
	} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_LookasideSlot) {
		_cgo_addr := &pBuf
		*_cgo_addr = db.lookaside.pInit
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		db.lookaside.pInit = pBuf.pNext
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(0)*4))++
		return unsafe.Pointer(pBuf)
	} else {
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&db.lookaside.anStat)))) + uintptr(2)*4))++
	}
	return dbMallocRawFinish(db, n)
}
func sqlite3DbRealloc(db *struct_sqlite3, p unsafe.Pointer, n uint64) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3DbMallocRawNN(db, n)
	}
	func() int {
		_ = 0
		return 0
	}()
	if uint64(p) < uint64(db.lookaside.pEnd) {
		if uint64(p) >= uint64(db.lookaside.pMiddle) {
			if n <= uint64(128) {
				return p
			}
		} else if uint64(p) >= uint64(db.lookaside.pStart) {
			if n <= uint64(db.lookaside.szTrue) {
				return p
			}
		}
	}
	return dbReallocFinish(db, p, n)
}
func dbReallocFinish(db *struct_sqlite3, p unsafe.Pointer, n uint64) unsafe.Pointer {
	var pNew unsafe.Pointer = nil
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(db.mallocFailed) == 0 {
		if isLookaside(db, p) != 0 {
			pNew = sqlite3DbMallocRawNN(db, n)
			if pNew != nil {
				__builtin___memcpy_chk(pNew, p, uint(lookasideMallocSize(db, p)), __builtin_object_size(pNew, 0))
				sqlite3DbFree(db, p)
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pNew = sqlite3Realloc(p, n)
			if !(pNew != nil) {
				sqlite3OomFault(db)
			}
		}
	}
	return pNew
}
func sqlite3DbReallocOrFree(db *struct_sqlite3, p unsafe.Pointer, n uint64) unsafe.Pointer {
	var pNew unsafe.Pointer
	pNew = sqlite3DbRealloc(db, p, n)
	if !(pNew != nil) {
		sqlite3DbFree(db, p)
	}
	return pNew
}
func sqlite3DbStrDup(db *struct_sqlite3, z *int8) *int8 {
	var zNew *int8
	var n uint
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	n = strlen(z) + uint(1)
	zNew = (*int8)(sqlite3DbMallocRaw(db, uint64(n)))
	if zNew != nil {
		__builtin___memcpy_chk(unsafe.Pointer(zNew), unsafe.Pointer(z), n, __builtin_object_size(unsafe.Pointer(zNew), 0))
	}
	return zNew
}
func sqlite3DbStrNDup(db *struct_sqlite3, z *int8, n uint64) *int8 {
	var zNew *int8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	zNew = (*int8)(func() unsafe.Pointer {
		if z != nil {
			return sqlite3DbMallocRawNN(db, n+uint64(1))
		} else {
			return nil
		}
	}())
	if zNew != nil {
		__builtin___memcpy_chk(unsafe.Pointer(zNew), unsafe.Pointer(z), uint(n), __builtin_object_size(unsafe.Pointer(zNew), 0))
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(n))) = int8(0)
	}
	return zNew
}
func sqlite3DbSpanDup(db *struct_sqlite3, zStart *int8, zEnd *int8) *int8 {
	var n int32
	for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStart)) + uintptr(0))))))))&1 != 0 {
		*(*uintptr)(unsafe.Pointer(&zStart))++
	}
	n = int32(uintptr(unsafe.Pointer(zEnd)) - uintptr(unsafe.Pointer(zStart)))
	for n > 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStart)) + uintptr(n-1))))))))&1 != 0 {
		n--
	}
	return sqlite3DbStrNDup(db, zStart, uint64(n))
}
func sqlite3SetString(pz **int8, db *struct_sqlite3, zNew *int8) {
	sqlite3DbFree(db, unsafe.Pointer(*pz))
	*pz = sqlite3DbStrDup(db, zNew)
}
func sqlite3OomFault(db *struct_sqlite3) unsafe.Pointer {
	if int32(db.mallocFailed) == 0 && int32(db.bBenignMalloc) == 0 {
		db.mallocFailed = uint8(1)
		if db.nVdbeExec > 0 {
			__atomic_store_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0, 1)
		}
		db.lookaside.bDisable++
		db.lookaside.sz = uint16(0)
		if db.pParse != nil {
			sqlite3ErrorMsg(db.pParse, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
			db.pParse.rc = int32(7)
		}
	}
	return unsafe.Pointer(nil)
}
func sqlite3OomClear(db *struct_sqlite3) {
	if int32(db.mallocFailed) != 0 && db.nVdbeExec == 0 {
		db.mallocFailed = uint8(0)
		__atomic_store_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0, 0)
		func() int {
			_ = 0
			return 0
		}()
		db.lookaside.bDisable--
		db.lookaside.sz = uint16(func() int32 {
			if db.lookaside.bDisable != 0 {
				return 0
			} else {
				return int32(db.lookaside.szTrue)
			}
		}())
	}
}
func apiHandleError(db *struct_sqlite3, rc int32) int32 {
	if int32(db.mallocFailed) != 0 || rc == 10|12<<8 {
		sqlite3OomClear(db)
		sqlite3Error(db, 7)
		return int32(7)
	}
	return rc & db.errMask
}
func sqlite3ApiExit(db *struct_sqlite3, rc int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(db.mallocFailed) != 0 || rc != 0 {
		return apiHandleError(db, rc)
	}
	return rc & db.errMask
}

type etByte = uint8
type struct_et_info struct {
	fmttype int8
	base    uint8
	flags   uint8
	type_   uint8
	charset uint8
	prefix  uint8
}
type et_info = struct_et_info

var aDigits [33]int8 = [33]int8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', '\x00'}
var aPrefix [7]int8 = [7]int8{'-', 'x', '0', '\x00', 'X', '0', '\x00'}
var fmtinfo [23]struct_et_info = [23]struct_et_info{struct_et_info{int8('d'), uint8(10), uint8(1), uint8(16), uint8(0), uint8(0)}, struct_et_info{int8('s'), uint8(0), uint8(4), uint8(5), uint8(0), uint8(0)}, struct_et_info{int8('g'), uint8(0), uint8(1), uint8(3), uint8(30), uint8(0)}, struct_et_info{int8('z'), uint8(0), uint8(4), uint8(6), uint8(0), uint8(0)}, struct_et_info{int8('q'), uint8(0), uint8(4), uint8(9), uint8(0), uint8(0)}, struct_et_info{int8('Q'), uint8(0), uint8(4), uint8(10), uint8(0), uint8(0)}, struct_et_info{int8('w'), uint8(0), uint8(4), uint8(14), uint8(0), uint8(0)}, struct_et_info{int8('c'), uint8(0), uint8(0), uint8(8), uint8(0), uint8(0)}, struct_et_info{int8('o'), uint8(8), uint8(0), uint8(0), uint8(0), uint8(2)}, struct_et_info{int8('u'), uint8(10), uint8(0), uint8(16), uint8(0), uint8(0)}, struct_et_info{int8('x'), uint8(16), uint8(0), uint8(0), uint8(16), uint8(1)}, struct_et_info{int8('X'), uint8(16), uint8(0), uint8(0), uint8(0), uint8(4)}, struct_et_info{int8('f'), uint8(0), uint8(1), uint8(1), uint8(0), uint8(0)}, struct_et_info{int8('e'), uint8(0), uint8(1), uint8(2), uint8(30), uint8(0)}, struct_et_info{int8('E'), uint8(0), uint8(1), uint8(2), uint8(14), uint8(0)}, struct_et_info{int8('G'), uint8(0), uint8(1), uint8(3), uint8(14), uint8(0)}, struct_et_info{int8('i'), uint8(10), uint8(1), uint8(16), uint8(0), uint8(0)}, struct_et_info{int8('n'), uint8(0), uint8(0), uint8(4), uint8(0), uint8(0)}, struct_et_info{int8('%'), uint8(0), uint8(0), uint8(7), uint8(0), uint8(0)}, struct_et_info{int8('p'), uint8(16), uint8(0), uint8(13), uint8(0), uint8(1)}, struct_et_info{int8('T'), uint8(0), uint8(0), uint8(11), uint8(0), uint8(0)}, struct_et_info{int8('S'), uint8(0), uint8(0), uint8(12), uint8(0), uint8(0)}, struct_et_info{int8('r'), uint8(10), uint8(1), uint8(15), uint8(0), uint8(0)}}
var arRound [10]float64 = [10]float64{0.5, 0.050000000000000003, 0.0050000000000000001, 5.0000000000000001e-4, 5.0000000000000002e-5, 5.0000000000000004e-6, 4.9999999999999998e-7, 4.9999999999999998e-8, 5.0000000000000001e-9, 5.0000000000000003e-10}

func et_getdigit(val *float64, cnt *int32) int8 {
	var digit int32
	var d float64
	if *cnt <= 0 {
		return int8('0')
	}
	*cnt--
	digit = int32(*val)
	d = float64(digit)
	digit += int32('0')
	*val = (*val - d) * float64(10)
	return int8(digit)
}
func sqlite3StrAccumSetError(p *struct_sqlite3_str, eError uint8) {
	func() int {
		_ = 0
		return 0
	}()
	p.accError = eError
	if p.mxAlloc != 0 {
		sqlite3_str_reset(p)
	}
	if int32(eError) == 18 {
		sqlite3ErrorToParser(p.db, int32(eError))
	}
}
func getIntArg(p *struct_PrintfArguments) int64 {
	if p.nArg <= p.nUsed {
		return int64(0)
	}
	return sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apArg)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &p.nUsed
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*8)))
}
func getDoubleArg(p *struct_PrintfArguments) float64 {
	if p.nArg <= p.nUsed {
		return float64(0)
	}
	return sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apArg)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &p.nUsed
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*8)))
}
func getTextArg(p *struct_PrintfArguments) *int8 {
	if p.nArg <= p.nUsed {
		return (*int8)(nil)
	}
	return (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apArg)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &p.nUsed
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*8)))))
}
func printfTempBuf(pAccum *struct_sqlite3_str, n int64) *int8 {
	var z *int8
	if pAccum.accError != 0 {
		return (*int8)(nil)
	}
	if n > int64(pAccum.nAlloc) && n > int64(pAccum.mxAlloc) {
		sqlite3StrAccumSetError(pAccum, uint8(18))
		return (*int8)(nil)
	}
	z = (*int8)(sqlite3DbMallocRaw(pAccum.db, uint64(n)))
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3StrAccumSetError(pAccum, uint8(7))
	}
	return z
}
func sqlite3_str_vappendf(pAccum *struct_sqlite3_str, fmt *int8, __cgo_args ...interface {
}) {
	var (
		i_cgo17         int32
		j_cgo18         int32
		k_cgo19         int32
		n_cgo20         int32
		isnull_cgo21    int32
		needQuote_cgo22 int32
		ch_cgo23        int8
		q_cgo24         int8
		escarg_cgo25    *int8
	)
	var c int32
	var bufpt *int8
	var precision int32
	var length int32
	var idx int32
	var width int32
	var flag_leftjustify uint8
	var flag_prefix uint8
	var flag_alternateform uint8
	var flag_altform2 uint8
	var flag_zeropad uint8
	var flag_long uint8
	var done uint8
	var cThousand uint8
	var xtype uint8 = uint8(17)
	var bArgList uint8
	var prefix int8
	var longvalue uint64
	var realvalue float64
	var infop *struct_et_info
	var zOut *int8
	var nOut int32
	var zExtra *int8 = nil
	var exp int32
	var e2 int32
	var nsd int32
	var rounder float64
	var flag_dp uint8
	var flag_rtz uint8
	var pArgList *struct_PrintfArguments = nil
	var buf [70]int8
	func() int {
		_ = 0
		return 0
	}()
	bufpt = (*int8)(nil)
	if int32(pAccum.printfFlags)&2 != 0 {
		pArgList = func() (_cgo_ret *struct_PrintfArguments) {
			_cgo_ret = __cgo_args[0].(*struct_PrintfArguments)
			__cgo_args = __cgo_args[1:]
			return
		}()
		bArgList = uint8(1)
	} else {
		bArgList = uint8(0)
	}
	for ; func() (_cgo_ret int32) {
		_cgo_addr := &c
		*_cgo_addr = int32(*fmt)
		return *_cgo_addr
	}() != 0; *(*uintptr)(unsafe.Pointer(&fmt))++ {
		if c != '%' {
			bufpt = (*int8)(unsafe.Pointer(fmt))
			for {
				*(*uintptr)(unsafe.Pointer(&fmt))++
				if !(int32(*fmt) != 0 && int32(*fmt) != '%') {
					break
				}
			}
			sqlite3_str_append(pAccum, bufpt, int32(uintptr(unsafe.Pointer(fmt))-uintptr(unsafe.Pointer(bufpt))))
			if int32(*fmt) == 0 {
				break
			}
		}
		if func() (_cgo_ret int32) {
			_cgo_addr := &c
			*_cgo_addr = int32(*func() (_cgo_ret *int8) {
				_cgo_addr := &fmt
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return *_cgo_addr
			}())
			return *_cgo_addr
		}() == 0 {
			sqlite3_str_append(pAccum, (*int8)(unsafe.Pointer(&[2]int8{'%', '\x00'})), 1)
			break
		}
		flag_leftjustify = func() (_cgo_ret uint8) {
			_cgo_addr := &flag_prefix
			*_cgo_addr = func() (_cgo_ret uint8) {
				_cgo_addr := &cThousand
				*_cgo_addr = func() (_cgo_ret uint8) {
					_cgo_addr := &flag_alternateform
					*_cgo_addr = func() (_cgo_ret uint8) {
						_cgo_addr := &flag_altform2
						*_cgo_addr = func() (_cgo_ret uint8) {
							_cgo_addr := &flag_zeropad
							*_cgo_addr = uint8(0)
							return *_cgo_addr
						}()
						return *_cgo_addr
					}()
					return *_cgo_addr
				}()
				return *_cgo_addr
			}()
			return *_cgo_addr
		}()
		done = uint8(0)
		width = int32(0)
		flag_long = uint8(0)
		precision = int32(-1)
		for {
			switch c {
			case '-':
				flag_leftjustify = uint8(1)
				break
			case '+':
				flag_prefix = uint8('+')
				break
			case ' ':
				flag_prefix = uint8(' ')
				break
			case '#':
				flag_alternateform = uint8(1)
				break
			case '!':
				flag_altform2 = uint8(1)
				break
			case '0':
				flag_zeropad = uint8(1)
				break
			case ',':
				cThousand = uint8(',')
				break
			default:
				done = uint8(1)
				break
			case 'l':
				{
					flag_long = uint8(1)
					c = int32(*func() (_cgo_ret *int8) {
						_cgo_addr := &fmt
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return *_cgo_addr
					}())
					if c == 'l' {
						c = int32(*func() (_cgo_ret *int8) {
							_cgo_addr := &fmt
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return *_cgo_addr
						}())
						flag_long = uint8(2)
					}
					done = uint8(1)
					break
				}
			case '1':
				fallthrough
			case '2':
				fallthrough
			case '3':
				fallthrough
			case '4':
				fallthrough
			case '5':
				fallthrough
			case '6':
				fallthrough
			case '7':
				fallthrough
			case '8':
				fallthrough
			case '9':
				{
					var wx uint32 = uint32(c - '0')
					for func() (_cgo_ret int32) {
						_cgo_addr := &c
						*_cgo_addr = int32(*func() (_cgo_ret *int8) {
							_cgo_addr := &fmt
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return *_cgo_addr
						}())
						return *_cgo_addr
					}() >= '0' && c <= '9' {
						wx = wx*uint32(10) + uint32(c) - uint32('0')
					}
					width = int32(wx & uint32(2147483647))
					if c != '.' && c != 'l' {
						done = uint8(1)
					} else {
						*(*uintptr)(unsafe.Pointer(&fmt))--
					}
					break
				}
			case '*':
				{
					if bArgList != 0 {
						width = int32(getIntArg(pArgList))
					} else {
						width = func() (_cgo_ret int32) {
							_cgo_ret = __cgo_args[0].(int32)
							__cgo_args = __cgo_args[1:]
							return
						}()
					}
					if width < 0 {
						flag_leftjustify = uint8(1)
						width = func() int32 {
							if width >= -2147483647 {
								return -width
							} else {
								return 0
							}
						}()
					}
					if func() (_cgo_ret int32) {
						_cgo_addr := &c
						*_cgo_addr = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(fmt)) + uintptr(1))))
						return *_cgo_addr
					}() != '.' && c != 'l' {
						c = int32(*func() (_cgo_ret *int8) {
							_cgo_addr := &fmt
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return *_cgo_addr
						}())
						done = uint8(1)
					}
					break
				}
			case '.':
				{
					c = int32(*func() (_cgo_ret *int8) {
						_cgo_addr := &fmt
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return *_cgo_addr
					}())
					if c == '*' {
						if bArgList != 0 {
							precision = int32(getIntArg(pArgList))
						} else {
							precision = func() (_cgo_ret int32) {
								_cgo_ret = __cgo_args[0].(int32)
								__cgo_args = __cgo_args[1:]
								return
							}()
						}
						if precision < 0 {
							precision = func() int32 {
								if precision >= -2147483647 {
									return -precision
								} else {
									return -1
								}
							}()
						}
						c = int32(*func() (_cgo_ret *int8) {
							_cgo_addr := &fmt
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return *_cgo_addr
						}())
					} else {
						var px uint32 = uint32(0)
						for c >= '0' && c <= '9' {
							px = px*uint32(10) + uint32(c) - uint32('0')
							c = int32(*func() (_cgo_ret *int8) {
								_cgo_addr := &fmt
								*(*uintptr)(unsafe.Pointer(_cgo_addr))++
								return *_cgo_addr
							}())
						}
						precision = int32(px & uint32(2147483647))
					}
					if c == 'l' {
						*(*uintptr)(unsafe.Pointer(&fmt))--
					} else {
						done = uint8(1)
					}
					break
				}
			}
			if !(!(done != 0) && func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*func() (_cgo_ret *int8) {
					_cgo_addr := &fmt
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return *_cgo_addr
				}())
				return *_cgo_addr
			}() != 0) {
				break
			}
		}
		infop = &*(*struct_et_info)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_et_info)(unsafe.Pointer(&fmtinfo)))) + uintptr(0)*6))
		xtype = uint8(17)
		for idx = int32(0); idx < int32(138/6); idx++ {
			if c == int32((*(*struct_et_info)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_et_info)(unsafe.Pointer(&fmtinfo)))) + uintptr(idx)*6))).fmttype) {
				infop = &*(*struct_et_info)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_et_info)(unsafe.Pointer(&fmtinfo)))) + uintptr(idx)*6))
				xtype = infop.type_
				break
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		_cgo_nm, _cgo_tag := true, int32(xtype)
		if _cgo_nm && _cgo_tag != 13 {
			goto _cgol_1
		}
		_cgo_nm = false
		flag_long = uint8(func() int32 {
			if 8 == 8 {
				return 2
			} else {
				return func() int32 {
					if 8 == 8 {
						return 1
					} else {
						return 0
					}
				}()
			}
		}())
	_cgol_1:
		if _cgo_nm && _cgo_tag != 15 {
			goto _cgol_2
		}
		_cgo_nm = false
	_cgol_2:
		if _cgo_nm && _cgo_tag != 0 {
			goto _cgol_3
		}
		_cgo_nm = false
		cThousand = uint8(0)
	_cgol_3:
		if _cgo_nm && _cgo_tag != 16 {
			goto _cgol_4
		}
		_cgo_nm = false
		if int32(infop.flags)&1 != 0 {
			var v int64
			if bArgList != 0 {
				v = getIntArg(pArgList)
			} else if flag_long != 0 {
				if int32(flag_long) == 2 {
					v = func() (_cgo_ret int64) {
						_cgo_ret = __cgo_args[0].(int64)
						__cgo_args = __cgo_args[1:]
						return
					}()
				} else {
					v = int64(func() (_cgo_ret int) {
						_cgo_ret = __cgo_args[0].(int)
						__cgo_args = __cgo_args[1:]
						return
					}())
				}
			} else {
				v = int64(func() (_cgo_ret int32) {
					_cgo_ret = __cgo_args[0].(int32)
					__cgo_args = __cgo_args[1:]
					return
				}())
			}
			if v < int64(0) {
				longvalue = uint64(^v)
				longvalue++
				prefix = int8('-')
			} else {
				longvalue = uint64(v)
				prefix = int8(flag_prefix)
			}
		} else {
			if bArgList != 0 {
				longvalue = uint64(getIntArg(pArgList))
			} else if flag_long != 0 {
				if int32(flag_long) == 2 {
					longvalue = func() (_cgo_ret uint64) {
						_cgo_ret = __cgo_args[0].(uint64)
						__cgo_args = __cgo_args[1:]
						return
					}()
				} else {
					longvalue = uint64(func() (_cgo_ret uint) {
						_cgo_ret = __cgo_args[0].(uint)
						__cgo_args = __cgo_args[1:]
						return
					}())
				}
			} else {
				longvalue = uint64(func() (_cgo_ret uint32) {
					_cgo_ret = __cgo_args[0].(uint32)
					__cgo_args = __cgo_args[1:]
					return
				}())
			}
			prefix = int8(0)
		}
		if longvalue == uint64(0) {
			flag_alternateform = uint8(0)
		}
		if int32(flag_zeropad) != 0 && precision < width-func() int32 {
			if int32(prefix) != 0 {
				return 1
			} else {
				return 0
			}
		}() {
			precision = width - func() int32 {
				if int32(prefix) != 0 {
					return 1
				} else {
					return 0
				}
			}()
		}
		if precision < 70-10-70/3 {
			nOut = int32(70)
			zOut = (*int8)(unsafe.Pointer(&buf))
		} else {
			var n uint64
			n = uint64(precision) + uint64(10)
			if cThousand != 0 {
				n += uint64(precision / 3)
			}
			zOut = func() (_cgo_ret *int8) {
				_cgo_addr := &zExtra
				*_cgo_addr = printfTempBuf(pAccum, int64(n))
				return *_cgo_addr
			}()
			if uintptr(unsafe.Pointer(zOut)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
			nOut = int32(n)
		}
		bufpt = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(nOut-1)))
		if int32(xtype) == 15 {
			var zOrd [9]int8 = [9]int8{'t', 'h', 's', 't', 'n', 'd', 'r', 'd', '\x00'}
			var x int32 = int32(longvalue % uint64(10))
			if x >= 4 || longvalue/uint64(10)%uint64(10) == uint64(1) {
				x = int32(0)
			}
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				*(*uintptr)(unsafe.Pointer(_cgo_addr))--
				return *_cgo_addr
			}() = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zOrd)))) + uintptr(x*2+1)))
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				*(*uintptr)(unsafe.Pointer(_cgo_addr))--
				return *_cgo_addr
			}() = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zOrd)))) + uintptr(x*2)))
		}
		{
			var cset *int8 = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&aDigits)))) + uintptr(infop.charset)))
			var base uint8 = infop.base
			for {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					*(*uintptr)(unsafe.Pointer(_cgo_addr))--
					return *_cgo_addr
				}() = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(cset)) + uintptr(longvalue%uint64(base))))
				longvalue = longvalue / uint64(base)
				if !(longvalue > uint64(0)) {
					break
				}
			}
		}
		length = int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(nOut-1))))) - uintptr(unsafe.Pointer(bufpt)))
		for precision > length {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				*(*uintptr)(unsafe.Pointer(_cgo_addr))--
				return *_cgo_addr
			}() = int8('0')
			length++
		}
		if cThousand != 0 {
			var nn int32 = (length - 1) / 3
			var ix int32 = (length-1)%3 + 1
			*(*uintptr)(unsafe.Pointer(&bufpt)) -= uintptr(nn)
			for idx = int32(0); nn > 0; idx++ {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(idx))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(idx+nn)))
				ix--
				if ix == 0 {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &idx
						*_cgo_addr++
						return *_cgo_addr
					}()))) = int8(cThousand)
					nn--
					ix = int32(3)
				}
			}
		}
		if prefix != 0 {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				*(*uintptr)(unsafe.Pointer(_cgo_addr))--
				return *_cgo_addr
			}() = prefix
		}
		if int32(flag_alternateform) != 0 && int32(infop.prefix) != 0 {
			var pre *int8
			var x int8
			pre = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&aPrefix)))) + uintptr(infop.prefix)))
			for ; int32(func() (_cgo_ret int8) {
				_cgo_addr := &x
				*_cgo_addr = *pre
				return *_cgo_addr
			}()) != 0; *(*uintptr)(unsafe.Pointer(&pre))++ {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					*(*uintptr)(unsafe.Pointer(_cgo_addr))--
					return *_cgo_addr
				}() = x
			}
		}
		length = int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(nOut-1))))) - uintptr(unsafe.Pointer(bufpt)))
		goto _cgol_5
	_cgol_4:
		if _cgo_nm && _cgo_tag != 1 {
			goto _cgol_6
		}
		_cgo_nm = false
	_cgol_6:
		if _cgo_nm && _cgo_tag != 2 {
			goto _cgol_7
		}
		_cgo_nm = false
	_cgol_7:
		if _cgo_nm && _cgo_tag != 3 {
			goto _cgol_8
		}
		_cgo_nm = false
		if bArgList != 0 {
			realvalue = float64(getDoubleArg(pArgList))
		} else {
			realvalue = float64(func() (_cgo_ret float64) {
				_cgo_ret = __cgo_args[0].(float64)
				__cgo_args = __cgo_args[1:]
				return
			}())
		}
		if precision < 0 {
			precision = int32(6)
		}
		if precision > 100000000 {
			precision = int32(100000000)
		}
		if realvalue < float64(0) {
			realvalue = -realvalue
			prefix = int8('-')
		} else {
			prefix = int8(flag_prefix)
		}
		if int32(xtype) == 3 && precision > 0 {
			precision--
		}
		idx = precision & 4095
		rounder = *(*float64)(unsafe.Pointer(uintptr(unsafe.Pointer((*float64)(unsafe.Pointer(&arRound)))) + uintptr(idx%10)*8))
		for idx >= 10 {
			rounder *= float64(1.0e-10)
			idx -= int32(10)
		}
		if int32(xtype) == 1 {
			var rx float64 = float64(realvalue)
			var u uint64
			var ex int32
			__builtin___memcpy_chk(unsafe.Pointer(&u), unsafe.Pointer(&rx), 8, __builtin_object_size(unsafe.Pointer(&u), 0))
			ex = -1023 + int32(u>>52&uint64(2047))
			if precision+ex/3 < 15 {
				rounder += realvalue * float64(2.9999999999999999e-16)
			}
			realvalue += float64(rounder)
		}
		exp = int32(0)
		if sqlite3IsNaN(float64(realvalue)) != 0 {
			bufpt = (*int8)(unsafe.Pointer(&[4]int8{'N', 'a', 'N', '\x00'}))
			length = int32(3)
			goto _cgol_5
		}
		if realvalue > float64(0) {
			var scale float64 = float64(1)
			for realvalue >= float64(1.0e+100)*scale && exp <= 350 {
				scale *= float64(1.0e+100)
				exp += int32(100)
			}
			for realvalue >= float64(1.0e+10)*scale && exp <= 350 {
				scale *= float64(1.0e+10)
				exp += int32(10)
			}
			for realvalue >= float64(10)*scale && exp <= 350 {
				scale *= float64(10)
				exp++
			}
			realvalue /= scale
			for realvalue < float64(1.0e-8) {
				realvalue *= float64(1.0e+8)
				exp -= int32(8)
			}
			for realvalue < float64(1) {
				realvalue *= float64(10)
				exp--
			}
			if exp > 350 {
				bufpt = (*int8)(unsafe.Pointer(&buf))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = prefix
				__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf))))+func() uintptr {
					if int32(prefix) != 0 {
						return 1
					} else {
						return 0
					}
				}()))), unsafe.Pointer((*int8)(unsafe.Pointer(&[4]int8{'I', 'n', 'f', '\x00'}))), uint(4), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf))))+func() uintptr {
					if int32(prefix) != 0 {
						return 1
					} else {
						return 0
					}
				}()))), 0))
				length = 3 + func() int32 {
					if int32(prefix) != 0 {
						return 1
					} else {
						return 0
					}
				}()
				goto _cgol_5
			}
		}
		bufpt = (*int8)(unsafe.Pointer(&buf))
		if int32(xtype) != 1 {
			realvalue += float64(rounder)
			if realvalue >= float64(10) {
				realvalue *= float64(0.10000000000000001)
				exp++
			}
		}
		if int32(xtype) == 3 {
			flag_rtz = func() uint8 {
				if !(flag_alternateform != 0) {
					return 1
				} else {
					return 0
				}
			}()
			if exp < -4 || exp > precision {
				xtype = uint8(2)
			} else {
				precision = precision - exp
				xtype = uint8(1)
			}
		} else {
			flag_rtz = flag_altform2
		}
		if int32(xtype) == 2 {
			e2 = int32(0)
		} else {
			e2 = exp
		}
		{
			var szBufNeeded int64
			szBufNeeded = int64(func() int32 {
				if e2 > 0 {
					return e2
				} else {
					return 0
				}
			}()) + int64(precision) + int64(width) + int64(15)
			if szBufNeeded > int64(70) {
				bufpt = func() (_cgo_ret *int8) {
					_cgo_addr := &zExtra
					*_cgo_addr = printfTempBuf(pAccum, szBufNeeded)
					return *_cgo_addr
				}()
				if uintptr(unsafe.Pointer(bufpt)) == uintptr(unsafe.Pointer(nil)) {
					return
				}
			}
		}
		zOut = bufpt
		nsd = 16 + int32(flag_altform2)*10
		flag_dp = uint8(func() int32 {
			if precision > 0 {
				return 1
			} else {
				return 0
			}
		}() | int32(flag_alternateform) | int32(flag_altform2))
		if prefix != 0 {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = prefix
		}
		if e2 < 0 {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = int8('0')
		} else {
			for ; e2 >= 0; e2-- {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}() = et_getdigit(&realvalue, &nsd)
			}
		}
		if flag_dp != 0 {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = int8('.')
		}
		for e2++; e2 < 0; func() int32 {
			precision--
			return func() (_cgo_ret int32) {
				_cgo_addr := &e2
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
		}() {
			func() int {
				_ = 0
				return 0
			}()
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = int8('0')
		}
		for func() (_cgo_ret int32) {
			_cgo_addr := &precision
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}() > 0 {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = et_getdigit(&realvalue, &nsd)
		}
		if int32(flag_rtz) != 0 && int32(flag_dp) != 0 {
			for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) - uintptr(- -1)))) == '0' {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					*(*uintptr)(unsafe.Pointer(_cgo_addr))--
					return *_cgo_addr
				}() = int8(0)
			}
			func() int {
				_ = 0
				return 0
			}()
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) - uintptr(- -1)))) == '.' {
				if flag_altform2 != 0 {
					*func() (_cgo_ret *int8) {
						_cgo_addr := &bufpt
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return
					}() = int8('0')
				} else {
					*func() (_cgo_ret *int8) {
						_cgo_addr := &bufpt
						*(*uintptr)(unsafe.Pointer(_cgo_addr))--
						return *_cgo_addr
					}() = int8(0)
				}
			}
		}
		if int32(xtype) == 2 {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&aDigits)))) + uintptr(infop.charset)))
			if exp < 0 {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}() = int8('-')
				exp = -exp
			} else {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}() = int8('+')
			}
			if exp >= 100 {
				*func() (_cgo_ret *int8) {
					_cgo_addr := &bufpt
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}() = int8(exp/100 + '0')
				exp %= int32(100)
			}
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = int8(exp/10 + '0')
			*func() (_cgo_ret *int8) {
				_cgo_addr := &bufpt
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = int8(exp%10 + '0')
		}
		*bufpt = int8(0)
		length = int32(uintptr(unsafe.Pointer(bufpt)) - uintptr(unsafe.Pointer(zOut)))
		bufpt = zOut
		if int32(flag_zeropad) != 0 && !(flag_leftjustify != 0) && length < width {
			var i int32
			var nPad int32 = width - length
			for i = width; i >= nPad; i-- {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(i))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(i-nPad)))
			}
			i = func() int32 {
				if int32(prefix) != 0 {
					return 1
				} else {
					return 0
				}
			}()
			for func() (_cgo_ret int32) {
				_cgo_addr := &nPad
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}() != 0 {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &i
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()))) = int8('0')
			}
			length = width
		}
		goto _cgol_5
	_cgol_8:
		if _cgo_nm && _cgo_tag != 4 {
			goto _cgol_9
		}
		_cgo_nm = false
		if !(bArgList != 0) {
			*func() (_cgo_ret *int32) {
				_cgo_ret = __cgo_args[0].(*int32)
				__cgo_args = __cgo_args[1:]
				return
			}() = int32(pAccum.nChar)
		}
		length = func() (_cgo_ret int32) {
			_cgo_addr := &width
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
		goto _cgol_5
	_cgol_9:
		if _cgo_nm && _cgo_tag != 7 {
			goto _cgol_10
		}
		_cgo_nm = false
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8('%')
		bufpt = (*int8)(unsafe.Pointer(&buf))
		length = int32(1)
		goto _cgol_5
	_cgol_10:
		if _cgo_nm && _cgo_tag != 8 {
			goto _cgol_11
		}
		_cgo_nm = false
		if bArgList != 0 {
			bufpt = getTextArg(pArgList)
			length = int32(1)
			if bufpt != nil {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8(func() (_cgo_ret int32) {
					_cgo_addr := &c
					*_cgo_addr = int32(*func() (_cgo_ret *int8) {
						_cgo_addr := &bufpt
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return
					}())
					return *_cgo_addr
				}())
				if c&192 == 192 {
					for length < 4 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(0))))&192 == 128 {
						*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(func() (_cgo_ret int32) {
							_cgo_addr := &length
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}()))) = *func() (_cgo_ret *int8) {
							_cgo_addr := &bufpt
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}()
					}
				}
			} else {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8(0)
			}
		} else {
			var ch uint32 = func() (_cgo_ret uint32) {
				_cgo_ret = __cgo_args[0].(uint32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			if ch < uint32(128) {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8(ch & uint32(255))
				length = int32(1)
			} else if ch < uint32(2048) {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8(192 + int32(uint8(ch>>6&uint32(31))))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(1))) = int8(128 + int32(uint8(ch&uint32(63))))
				length = int32(2)
			} else if ch < uint32(65536) {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8(224 + int32(uint8(ch>>12&uint32(15))))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(1))) = int8(128 + int32(uint8(ch>>6&uint32(63))))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(2))) = int8(128 + int32(uint8(ch&uint32(63))))
				length = int32(3)
			} else {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = int8(240 + int32(uint8(ch>>18&uint32(7))))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(1))) = int8(128 + int32(uint8(ch>>12&uint32(63))))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(2))) = int8(128 + int32(uint8(ch>>6&uint32(63))))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(3))) = int8(128 + int32(uint8(ch&uint32(63))))
				length = int32(4)
			}
		}
		if precision > 1 {
			width -= precision - 1
			if width > 1 && !(flag_leftjustify != 0) {
				sqlite3_str_appendchar(pAccum, width-1, int8(' '))
				width = int32(0)
			}
			for func() (_cgo_ret int32) {
				_cgo_addr := &precision
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}() > 1 {
				sqlite3_str_append(pAccum, (*int8)(unsafe.Pointer(&buf)), length)
			}
		}
		bufpt = (*int8)(unsafe.Pointer(&buf))
		flag_altform2 = uint8(1)
		goto adjust_width_for_utf8
	_cgol_11:
		if _cgo_nm && _cgo_tag != 5 {
			goto _cgol_12
		}
		_cgo_nm = false
	_cgol_12:
		if _cgo_nm && _cgo_tag != 6 {
			goto _cgol_13
		}
		_cgo_nm = false
		if bArgList != 0 {
			bufpt = getTextArg(pArgList)
			xtype = uint8(5)
		} else {
			bufpt = func() (_cgo_ret *int8) {
				_cgo_ret = __cgo_args[0].(*int8)
				__cgo_args = __cgo_args[1:]
				return
			}()
		}
		if uintptr(unsafe.Pointer(bufpt)) == uintptr(unsafe.Pointer(nil)) {
			bufpt = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
		} else if int32(xtype) == 6 {
			if pAccum.nChar == uint32(0) && pAccum.mxAlloc != 0 && width == 0 && precision < 0 && int32(pAccum.accError) == 0 {
				func() int {
					_ = 0
					return 0
				}()
				pAccum.zText = bufpt
				pAccum.nAlloc = uint32(sqlite3DbMallocSize(pAccum.db, unsafe.Pointer(bufpt)))
				pAccum.nChar = uint32(2147483647 & int32(strlen(bufpt)))
				pAccum.printfFlags |= uint8(4)
				length = int32(0)
				goto _cgol_5
			}
			zExtra = bufpt
		}
		if precision >= 0 {
			if flag_altform2 != 0 {
				var z *uint8 = (*uint8)(unsafe.Pointer(bufpt))
				for func() (_cgo_ret int32) {
					_cgo_addr := &precision
					_cgo_ret = *_cgo_addr
					*_cgo_addr--
					return
				}() > 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) != 0 {
					{
						if int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}()) >= 192 {
							for int32(*z)&192 == 128 {
								*(*uintptr)(unsafe.Pointer(&z))++
							}
						}
					}
				}
				length = int32(uintptr(unsafe.Pointer(z)) - uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(bufpt)))))
			} else {
				for length = int32(0); length < precision && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(length)))) != 0; length++ {
				}
			}
		} else {
			length = 2147483647 & int32(strlen(bufpt))
		}
	adjust_width_for_utf8:
		if int32(flag_altform2) != 0 && width > 0 {
			var ii int32 = length - 1
			for ii >= 0 {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &ii
					_cgo_ret = *_cgo_addr
					*_cgo_addr--
					return
				}()))))&192 == 128 {
					width++
				}
			}
		}
		goto _cgol_5
	_cgol_13:
		if _cgo_nm && _cgo_tag != 9 {
			goto _cgol_14
		}
		_cgo_nm = false
	_cgol_14:
		if _cgo_nm && _cgo_tag != 10 {
			goto _cgol_15
		}
		_cgo_nm = false
	_cgol_15:
		if _cgo_nm && _cgo_tag != 14 {
			goto _cgol_16
		}
		_cgo_nm = false
		i_cgo17 = 0
		j_cgo18 = 0
		k_cgo19 = 0
		n_cgo20 = 0
		isnull_cgo21 = 0
		needQuote_cgo22 = 0
		ch_cgo23 = 0
		q_cgo24 = int8(func() int32 {
			if int32(xtype) == 14 {
				return '"'
			} else {
				return '\''
			}
		}())
		escarg_cgo25 = nil
		if bArgList != 0 {
			escarg_cgo25 = getTextArg(pArgList)
		} else {
			escarg_cgo25 = func() (_cgo_ret *int8) {
				_cgo_ret = __cgo_args[0].(*int8)
				__cgo_args = __cgo_args[1:]
				return
			}()
		}
		isnull_cgo21 = func() int32 {
			if uintptr(unsafe.Pointer(escarg_cgo25)) == uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}()
		if isnull_cgo21 != 0 {
			escarg_cgo25 = func() *int8 {
				if int32(xtype) == 10 {
					return (*int8)(unsafe.Pointer(&[5]int8{'N', 'U', 'L', 'L', '\x00'}))
				} else {
					return (*int8)(unsafe.Pointer(&[7]int8{'(', 'N', 'U', 'L', 'L', ')', '\x00'}))
				}
			}()
		}
		k_cgo19 = precision
		for i_cgo17 = func() (_cgo_ret int32) {
			_cgo_addr := &n_cgo20
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}(); k_cgo19 != 0 && int32(func() (_cgo_ret int8) {
			_cgo_addr := &ch_cgo23
			*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(escarg_cgo25)) + uintptr(i_cgo17)))
			return *_cgo_addr
		}()) != 0; func() int32 {
			i_cgo17++
			return func() (_cgo_ret int32) {
				_cgo_addr := &k_cgo19
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}()
		}() {
			if int32(ch_cgo23) == int32(q_cgo24) {
				n_cgo20++
			}
			if int32(flag_altform2) != 0 && int32(ch_cgo23)&192 == 192 {
				for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(escarg_cgo25)) + uintptr(i_cgo17+1))))&192 == 128 {
					i_cgo17++
				}
			}
		}
		needQuote_cgo22 = func() int32 {
			if !(isnull_cgo21 != 0) && int32(xtype) == 10 {
				return 1
			} else {
				return 0
			}
		}()
		n_cgo20 += i_cgo17 + 3
		if n_cgo20 > 70 {
			bufpt = func() (_cgo_ret *int8) {
				_cgo_addr := &zExtra
				*_cgo_addr = printfTempBuf(pAccum, int64(n_cgo20))
				return *_cgo_addr
			}()
			if uintptr(unsafe.Pointer(bufpt)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
		} else {
			bufpt = (*int8)(unsafe.Pointer(&buf))
		}
		j_cgo18 = int32(0)
		if needQuote_cgo22 != 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j_cgo18
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = q_cgo24
		}
		k_cgo19 = i_cgo17
		for i_cgo17 = int32(0); i_cgo17 < k_cgo19; i_cgo17++ {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j_cgo18
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = func() (_cgo_ret int8) {
				_cgo_addr := &ch_cgo23
				*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(escarg_cgo25)) + uintptr(i_cgo17)))
				return *_cgo_addr
			}()
			if int32(ch_cgo23) == int32(q_cgo24) {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &j_cgo18
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()))) = ch_cgo23
			}
		}
		if needQuote_cgo22 != 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j_cgo18
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = q_cgo24
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(bufpt)) + uintptr(j_cgo18))) = int8(0)
		length = j_cgo18
		goto adjust_width_for_utf8
	_cgol_16:
		if _cgo_nm && _cgo_tag != 11 {
			goto _cgol_26
		}
		_cgo_nm = false
		{
			if int32(pAccum.printfFlags)&1 == 0 {
				return
			}
			if flag_alternateform != 0 {
				var pExpr *struct_Expr = func() (_cgo_ret *struct_Expr) {
					_cgo_ret = __cgo_args[0].(*struct_Expr)
					__cgo_args = __cgo_args[1:]
					return
				}()
				if pExpr != nil && !(pExpr.flags&uint32(1024) != uint32(0)) {
					sqlite3_str_appendall(pAccum, (*int8)(unsafe.Pointer(pExpr.u.zToken)))
					sqlite3RecordErrorOffsetOfExpr(pAccum.db, pExpr)
				}
			} else {
				var pToken *struct_Token = func() (_cgo_ret *struct_Token) {
					_cgo_ret = __cgo_args[0].(*struct_Token)
					__cgo_args = __cgo_args[1:]
					return
				}()
				func() int {
					_ = 0
					return 0
				}()
				if pToken != nil && pToken.n != 0 {
					sqlite3_str_append(pAccum, (*int8)(unsafe.Pointer(pToken.z)), int32(pToken.n))
					sqlite3RecordErrorByteOffset(pAccum.db, pToken.z)
				}
			}
			length = func() (_cgo_ret int32) {
				_cgo_addr := &width
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
			goto _cgol_5
		}
	_cgol_26:
		if _cgo_nm && _cgo_tag != 12 {
			goto _cgol_27
		}
		_cgo_nm = false
		{
			var pItem *struct_SrcItem
			if int32(pAccum.printfFlags)&1 == 0 {
				return
			}
			pItem = func() (_cgo_ret *struct_SrcItem) {
				_cgo_ret = __cgo_args[0].(*struct_SrcItem)
				__cgo_args = __cgo_args[1:]
				return
			}()
			func() int {
				_ = 0
				return 0
			}()
			if pItem.zAlias != nil && !(flag_altform2 != 0) {
				sqlite3_str_appendall(pAccum, pItem.zAlias)
			} else if pItem.zName != nil {
				if pItem.zDatabase != nil {
					sqlite3_str_appendall(pAccum, pItem.zDatabase)
					sqlite3_str_append(pAccum, (*int8)(unsafe.Pointer(&[2]int8{'.', '\x00'})), 1)
				}
				sqlite3_str_appendall(pAccum, pItem.zName)
			} else if pItem.zAlias != nil {
				sqlite3_str_appendall(pAccum, pItem.zAlias)
			} else if pItem.pSelect != nil {
				sqlite3_str_appendf(pAccum, (*int8)(unsafe.Pointer(&[12]int8{'S', 'U', 'B', 'Q', 'U', 'E', 'R', 'Y', ' ', '%', 'u', '\x00'})), pItem.pSelect.selId)
			}
			length = func() (_cgo_ret int32) {
				_cgo_addr := &width
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
			goto _cgol_5
		}
	_cgol_28:
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			return
		}
		goto _cgol_5
	_cgol_27:
		goto _cgol_28
	_cgol_5:
		width -= length
		if width > 0 {
			if !(flag_leftjustify != 0) {
				sqlite3_str_appendchar(pAccum, width, int8(' '))
			}
			sqlite3_str_append(pAccum, bufpt, length)
			if flag_leftjustify != 0 {
				sqlite3_str_appendchar(pAccum, width, int8(' '))
			}
		} else {
			sqlite3_str_append(pAccum, bufpt, length)
		}
		if zExtra != nil {
			sqlite3DbFree(pAccum.db, unsafe.Pointer(zExtra))
			zExtra = (*int8)(nil)
		}
	}
}
func sqlite3RecordErrorByteOffset(db *struct_sqlite3, z *int8) {
	var pParse *struct_Parse
	var zText *int8
	var zEnd *int8
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(db)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if db.errByteOffset != -2 {
		return
	}
	pParse = db.pParse
	if uintptr(unsafe.Pointer(pParse)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	zText = pParse.zTail
	if uintptr(unsafe.Pointer(zText)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	zEnd = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(strlen(zText))))
	if uint64(uintptr(unsafe.Pointer(z))) >= uint64(uintptr(unsafe.Pointer(zText))) && uint64(uintptr(unsafe.Pointer(z))) < uint64(uintptr(unsafe.Pointer(zEnd))) {
		db.errByteOffset = int32(uintptr(unsafe.Pointer(z)) - uintptr(unsafe.Pointer(zText)))
	}
}
func sqlite3RecordErrorOffsetOfExpr(db *struct_sqlite3, pExpr *struct_Expr) {
	for pExpr != nil && (pExpr.flags&uint32(1) != uint32(0) || *(*int32)(unsafe.Pointer(&pExpr.w)) <= 0) {
		pExpr = pExpr.pLeft
	}
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	db.errByteOffset = *(*int32)(unsafe.Pointer(&pExpr.w))
}
func sqlite3StrAccumEnlarge(p *struct_sqlite3_str, N int32) int32 {
	var zNew *int8
	func() int {
		_ = 0
		return 0
	}()
	if p.accError != 0 {
		return int32(0)
	}
	if p.mxAlloc == uint32(0) {
		sqlite3StrAccumSetError(p, uint8(18))
		return int32(p.nAlloc - p.nChar - uint32(1))
	} else {
		var zOld *int8 = func() *int8 {
			if int32(p.printfFlags)&4 != 0 {
				return p.zText
			} else {
				return nil
			}
		}()
		var szNew int64 = int64(p.nChar)
		szNew += int64(N) + int64(1)
		if szNew+int64(p.nChar) <= int64(p.mxAlloc) {
			szNew += int64(p.nChar)
		}
		if szNew > int64(p.mxAlloc) {
			sqlite3_str_reset(p)
			sqlite3StrAccumSetError(p, uint8(18))
			return int32(0)
		} else {
			p.nAlloc = uint32(int32(szNew))
		}
		if p.db != nil {
			zNew = (*int8)(sqlite3DbRealloc(p.db, unsafe.Pointer(zOld), uint64(p.nAlloc)))
		} else {
			zNew = (*int8)(sqlite3Realloc(unsafe.Pointer(zOld), uint64(p.nAlloc)))
		}
		if zNew != nil {
			func() int {
				_ = 0
				return 0
			}()
			if !(int32(p.printfFlags)&4 != 0) && p.nChar > uint32(0) {
				__builtin___memcpy_chk(unsafe.Pointer(zNew), unsafe.Pointer(p.zText), uint(p.nChar), __builtin_object_size(unsafe.Pointer(zNew), 0))
			}
			p.zText = zNew
			p.nAlloc = uint32(sqlite3DbMallocSize(p.db, unsafe.Pointer(zNew)))
			p.printfFlags |= uint8(4)
		} else {
			sqlite3_str_reset(p)
			sqlite3StrAccumSetError(p, uint8(7))
			return int32(0)
		}
	}
	return N
}
func sqlite3_str_appendchar(p *struct_sqlite3_str, N int32, c int8) {
	if int64(p.nChar)+int64(N) >= int64(p.nAlloc) && func() (_cgo_ret int32) {
		_cgo_addr := &N
		*_cgo_addr = sqlite3StrAccumEnlarge(p, N)
		return *_cgo_addr
	}() <= 0 {
		return
	}
	for func() (_cgo_ret int32) {
		_cgo_addr := &N
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() > 0 {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(func() (_cgo_ret uint32) {
			_cgo_addr := &p.nChar
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = c
	}
}
func enlargeAndAppend(p *struct_sqlite3_str, z *int8, N int32) {
	N = sqlite3StrAccumEnlarge(p, N)
	if N > 0 {
		__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(p.nChar)))), unsafe.Pointer(z), uint(N), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(p.nChar)))), 0))
		p.nChar += uint32(N)
	}
}
func sqlite3_str_append(p *struct_sqlite3_str, z *int8, N int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.nChar+uint32(N) >= p.nAlloc {
		enlargeAndAppend(p, z, N)
	} else if N != 0 {
		func() int {
			_ = 0
			return 0
		}()
		p.nChar += uint32(N)
		__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(p.nChar-uint32(N))))), unsafe.Pointer(z), uint(N), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(p.nChar-uint32(N))))), 0))
	}
}
func sqlite3_str_appendall(p *struct_sqlite3_str, z *int8) {
	sqlite3_str_append(p, z, sqlite3Strlen30(z))
}
func strAccumFinishRealloc(p *struct_sqlite3_str) *int8 {
	var zText *int8
	func() int {
		_ = 0
		return 0
	}()
	zText = (*int8)(sqlite3DbMallocRaw(p.db, uint64(p.nChar+uint32(1))))
	if zText != nil {
		__builtin___memcpy_chk(unsafe.Pointer(zText), unsafe.Pointer(p.zText), uint(p.nChar+uint32(1)), __builtin_object_size(unsafe.Pointer(zText), 0))
		p.printfFlags |= uint8(4)
	} else {
		sqlite3StrAccumSetError(p, uint8(7))
	}
	p.zText = zText
	return zText
}
func sqlite3StrAccumFinish(p *struct_sqlite3_str) *int8 {
	if p.zText != nil {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(p.nChar))) = int8(0)
		if p.mxAlloc > uint32(0) && !(int32(p.printfFlags)&4 != 0) {
			return strAccumFinishRealloc(p)
		}
	}
	return p.zText
}
func sqlite3ResultStrAccum(pCtx *struct_sqlite3_context, p *struct_sqlite3_str) {
	if p.accError != 0 {
		sqlite3_result_error_code(pCtx, int32(p.accError))
		sqlite3_str_reset(p)
	} else if int32(p.printfFlags)&4 != 0 {
		sqlite3_result_text(pCtx, p.zText, int32(p.nChar), (func(unsafe.Pointer))(sqlite3OomFault))
	} else {
		sqlite3_result_text(pCtx, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), 0, (func(unsafe.Pointer))(0))
		sqlite3_str_reset(p)
	}
}

var sqlite3OomStr struct_sqlite3_str = struct_sqlite3_str{nil, nil, uint32(0), uint32(0), uint32(0), uint8(7), uint8(0)}

func sqlite3_str_finish(p *struct_sqlite3_str) *int8 {
	var z *int8
	if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(&sqlite3OomStr)) {
		z = sqlite3StrAccumFinish(p)
		sqlite3_free(unsafe.Pointer(p))
	} else {
		z = (*int8)(nil)
	}
	return z
}
func sqlite3_str_errcode(p *struct_sqlite3_str) int32 {
	return func() int32 {
		if p != nil {
			return int32(p.accError)
		} else {
			return 7
		}
	}()
}
func sqlite3_str_length(p *struct_sqlite3_str) int32 {
	return int32(func() uint32 {
		if p != nil {
			return p.nChar
		} else {
			return uint32(0)
		}
	}())
}
func sqlite3_str_value(p *struct_sqlite3_str) *int8 {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || p.nChar == uint32(0) {
		return (*int8)(nil)
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zText)) + uintptr(p.nChar))) = int8(0)
	return p.zText
}
func sqlite3_str_reset(p *struct_sqlite3_str) {
	if int32(p.printfFlags)&4 != 0 {
		sqlite3DbFree(p.db, unsafe.Pointer(p.zText))
		p.printfFlags &= uint8(^4)
	}
	p.nAlloc = uint32(0)
	p.nChar = uint32(0)
	p.zText = (*int8)(nil)
}
func sqlite3StrAccumInit(p *struct_sqlite3_str, db *struct_sqlite3, zBase *int8, n int32, mx int32) {
	p.zText = zBase
	p.db = db
	p.nAlloc = uint32(n)
	p.mxAlloc = uint32(mx)
	p.nChar = uint32(0)
	p.accError = uint8(0)
	p.printfFlags = uint8(0)
}
func sqlite3_str_new(db *struct_sqlite3) *struct_sqlite3_str {
	var p *struct_sqlite3_str = (*struct_sqlite3_str)(sqlite3_malloc64(uint64(30)))
	if p != nil {
		sqlite3StrAccumInit(p, nil, nil, 0, func() int32 {
			if db != nil {
				return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))
			} else {
				return 1000000000
			}
		}())
	} else {
		p = &sqlite3OomStr
	}
	return p
}
func sqlite3VMPrintf(db *struct_sqlite3, zFormat *int8, __cgo_args ...interface {
}) *int8 {
	var z *int8
	var zBase [70]int8
	var acc struct_sqlite3_str
	func() int {
		_ = 0
		return 0
	}()
	sqlite3StrAccumInit(&acc, db, (*int8)(unsafe.Pointer(&zBase)), int32(70), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)))
	acc.printfFlags = uint8(1)
	sqlite3_str_vappendf(&acc, zFormat, __cgo_args...)
	z = sqlite3StrAccumFinish(&acc)
	if int32(acc.accError) == 7 {
		sqlite3OomFault(db)
	}
	return z
}
func sqlite3MPrintf(db *struct_sqlite3, zFormat *int8, __cgo_args ...interface {
}) *int8 {
	var z *int8
	z = sqlite3VMPrintf(db, zFormat, __cgo_args...)
	return z
}
func sqlite3_vmprintf(zFormat *int8, __cgo_args ...interface {
}) *int8 {
	var z *int8
	var zBase [70]int8
	var acc struct_sqlite3_str
	if sqlite3_initialize() != 0 {
		return (*int8)(nil)
	}
	sqlite3StrAccumInit(&acc, nil, (*int8)(unsafe.Pointer(&zBase)), int32(70), 1000000000)
	sqlite3_str_vappendf(&acc, zFormat, __cgo_args...)
	z = sqlite3StrAccumFinish(&acc)
	return z
}
func sqlite3_mprintf(zFormat *int8, __cgo_args ...interface {
}) *int8 {
	var z *int8
	if sqlite3_initialize() != 0 {
		return (*int8)(nil)
	}
	z = sqlite3_vmprintf(zFormat, __cgo_args...)
	return z
}
func sqlite3_vsnprintf(n int32, zBuf *int8, zFormat *int8, __cgo_args ...interface {
}) *int8 {
	var acc struct_sqlite3_str
	if n <= 0 {
		return zBuf
	}
	sqlite3StrAccumInit(&acc, nil, zBuf, n, 0)
	sqlite3_str_vappendf(&acc, zFormat, __cgo_args...)
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(acc.nChar))) = int8(0)
	return zBuf
}
func sqlite3_snprintf(n int32, zBuf *int8, zFormat *int8, __cgo_args ...interface {
}) *int8 {
	var z *int8
	z = sqlite3_vsnprintf(n, zBuf, zFormat, __cgo_args...)
	return z
}
func renderLogMsg(iErrCode int32, zFormat *int8, __cgo_args ...interface {
}) {
	var acc struct_sqlite3_str
	var zMsg [210]int8
	sqlite3StrAccumInit(&acc, nil, (*int8)(unsafe.Pointer(&zMsg)), int32(210), 0)
	sqlite3_str_vappendf(&acc, zFormat, __cgo_args...)
	sqlite3Config.xLog(sqlite3Config.pLogArg, iErrCode, sqlite3StrAccumFinish(&acc))
}
func sqlite3_log(iErrCode int32, zFormat *int8, __cgo_args ...interface {
}) {
	if sqlite3Config.xLog != nil {
		renderLogMsg(iErrCode, zFormat, __cgo_args...)
	}
}
func sqlite3_str_appendf(p *struct_sqlite3_str, zFormat *int8, __cgo_args ...interface {
}) {
	sqlite3_str_vappendf(p, zFormat, __cgo_args...)
}

type struct_sqlite3PrngType struct {
	isInit uint8
	i      uint8
	j      uint8
	s      [256]uint8
}

var sqlite3Prng struct_sqlite3PrngType

func sqlite3_randomness(N int32, pBuf unsafe.Pointer) {
	var t uint8
	var zBuf *uint8 = (*uint8)(pBuf)
	var mutex *struct_sqlite3_mutex
	if sqlite3_initialize() != 0 {
		return
	}
	mutex = sqlite3MutexAlloc(5)
	sqlite3_mutex_enter(mutex)
	if N <= 0 || uintptr(unsafe.Pointer(pBuf)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3Prng.isInit = uint8(0)
		sqlite3_mutex_leave(mutex)
		return
	}
	if !(sqlite3Prng.isInit != 0) {
		var pVfs *struct_sqlite3_vfs = sqlite3_vfs_find(nil)
		var i int32
		var k [256]int8
		sqlite3Prng.j = uint8(0)
		sqlite3Prng.i = uint8(0)
		if uintptr(unsafe.Pointer(pVfs)) == uintptr(unsafe.Pointer(nil)) {
			__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&k))), 0, 256, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&k))), 0))
		} else {
			sqlite3OsRandomness(pVfs, 256, (*int8)(unsafe.Pointer(&k)))
		}
		for i = int32(0); i < 256; i++ {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(i))) = uint8(i)
		}
		for i = int32(0); i < 256; i++ {
			sqlite3Prng.j += uint8(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(i)))) + int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&k)))) + uintptr(i)))))
			t = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.j)))
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.j))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(i)))
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(i))) = t
		}
		sqlite3Prng.isInit = uint8(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	for {
		sqlite3Prng.i++
		t = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.i)))
		sqlite3Prng.j += uint8(int32(t))
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.i))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.j)))
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.j))) = t
		t += uint8(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(sqlite3Prng.i)))))
		*func() (_cgo_ret *uint8) {
			_cgo_addr := &zBuf
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr))++
			return
		}() = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Prng.s)))) + uintptr(t)))
		if !(func() (_cgo_ret int32) {
			_cgo_addr := &N
			*_cgo_addr--
			return *_cgo_addr
		}() != 0) {
			break
		}
	}
	sqlite3_mutex_leave(mutex)
}

var sqlite3SavedPrng struct_sqlite3PrngType

func sqlite3PrngSaveState() {
	__builtin___memcpy_chk(unsafe.Pointer(&sqlite3SavedPrng), unsafe.Pointer(&sqlite3Prng), 259, __builtin_object_size(unsafe.Pointer(&sqlite3SavedPrng), 0))
}
func sqlite3PrngRestoreState() {
	__builtin___memcpy_chk(unsafe.Pointer(&sqlite3Prng), unsafe.Pointer(&sqlite3SavedPrng), 259, __builtin_object_size(unsafe.Pointer(&sqlite3Prng), 0))
}

type struct_SQLiteThread struct {
	tid   *struct__opaque_pthread_t
	done  int32
	pOut  unsafe.Pointer
	xTask func(unsafe.Pointer) unsafe.Pointer
	pIn   unsafe.Pointer
}

func sqlite3ThreadCreate(ppThread **struct_SQLiteThread, xTask func(unsafe.Pointer) unsafe.Pointer, pIn unsafe.Pointer) int32 {
	var p *struct_SQLiteThread
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*ppThread = (*struct_SQLiteThread)(nil)
	p = (*struct_SQLiteThread)(sqlite3Malloc(uint64(40)))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(p), 0, 40, __builtin_object_size(unsafe.Pointer(p), 0))
	p.xTask = xTask
	p.pIn = pIn
	if sqlite3FaultSim(200) != 0 {
		rc = int32(1)
	} else {
		rc = pthread_create(&p.tid, nil, xTask, pIn)
	}
	if rc != 0 {
		p.done = int32(1)
		p.pOut = xTask(pIn)
	}
	*ppThread = p
	return int32(0)
}
func sqlite3ThreadJoin(p *struct_SQLiteThread, ppOut *unsafe.Pointer) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	if p.done != 0 {
		*ppOut = p.pOut
		rc = int32(0)
	} else {
		rc = func() int32 {
			if pthread_join(p.tid, ppOut) != 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	sqlite3_free(unsafe.Pointer(p))
	return rc
}

var sqlite3Utf8Trans1 [64]uint8 = [64]uint8{uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17), uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(0), uint8(1), uint8(2), uint8(3), uint8(0), uint8(1), uint8(0), uint8(0)}

func sqlite3Utf8Read(pz **uint8) uint32 {
	var c uint32
	c = uint32(*func() (_cgo_ret *uint8) {
		_cgo_addr := &*pz
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr))++
		return
	}())
	if c >= uint32(192) {
		c = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Utf8Trans1)))) + uintptr(c-uint32(192)))))
		for int32(**pz)&192 == 128 {
			c = c<<6 + uint32(63&int32(*func() (_cgo_ret *uint8) {
				_cgo_addr := &*pz
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()))
		}
		if c < uint32(128) || c&4294965248 == uint32(55296) || c&4294967294 == uint32(65534) {
			c = uint32(65533)
		}
	}
	return c
}
func sqlite3VdbeMemTranslate(pMem *struct_sqlite3_value, desiredEnc uint8) int32 {
	var len int64
	var zOut *uint8
	var zIn *uint8
	var zTerm *uint8
	var z *uint8
	var c uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pMem.enc) != 1 && int32(desiredEnc) != 1 {
		var temp uint8
		var rc int32
		rc = sqlite3VdbeMemMakeWriteable(pMem)
		if rc != 0 {
			func() int {
				_ = 0
				return 0
			}()
			return int32(7)
		}
		zIn = (*uint8)(unsafe.Pointer(pMem.z))
		zTerm = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(pMem.n & ^1)))
		for uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
			temp = *zIn
			*zIn = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(1)))
			*(*uintptr)(unsafe.Pointer(&zIn))++
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zIn
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = temp
		}
		pMem.enc = desiredEnc
		goto translate_out
	}
	if int32(desiredEnc) == 1 {
		pMem.n &= int32(^1)
		len = int64(2)*int64(pMem.n) + int64(1)
	} else {
		len = int64(2)*int64(pMem.n) + int64(2)
	}
	zIn = (*uint8)(unsafe.Pointer(pMem.z))
	zTerm = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(pMem.n)))
	zOut = (*uint8)(sqlite3DbMallocRaw(pMem.db, uint64(len)))
	if !(zOut != nil) {
		return int32(7)
	}
	z = zOut
	if int32(pMem.enc) == 1 {
		if int32(desiredEnc) == 2 {
			for uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
				c = uint32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}())
				if c >= uint32(192) {
					c = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Utf8Trans1)))) + uintptr(c-uint32(192)))))
					for uintptr(unsafe.Pointer(zIn)) != uintptr(unsafe.Pointer(zTerm)) && int32(*zIn)&192 == 128 {
						c = c<<6 + uint32(63&int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zIn
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}()))
					}
					if c < uint32(128) || c&4294965248 == uint32(55296) || c&4294967294 == uint32(65534) {
						c = uint32(65533)
					}
				}
				{
					if c <= uint32(65535) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c & uint32(255))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c >> 8 & uint32(255))
					} else {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c>>10&uint32(63) + (c-uint32(65536))>>10&uint32(192))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(uint32(216) + (c-uint32(65536))>>18&uint32(3))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c & uint32(255))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(uint32(220) + c>>8&uint32(3))
					}
				}
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			for uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
				c = uint32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}())
				if c >= uint32(192) {
					c = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3Utf8Trans1)))) + uintptr(c-uint32(192)))))
					for uintptr(unsafe.Pointer(zIn)) != uintptr(unsafe.Pointer(zTerm)) && int32(*zIn)&192 == 128 {
						c = c<<6 + uint32(63&int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zIn
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}()))
					}
					if c < uint32(128) || c&4294965248 == uint32(55296) || c&4294967294 == uint32(65534) {
						c = uint32(65533)
					}
				}
				{
					if c <= uint32(65535) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c >> 8 & uint32(255))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c & uint32(255))
					} else {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(uint32(216) + (c-uint32(65536))>>18&uint32(3))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c>>10&uint32(63) + (c-uint32(65536))>>10&uint32(192))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(uint32(220) + c>>8&uint32(3))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c & uint32(255))
					}
				}
			}
		}
		pMem.n = int32(uintptr(unsafe.Pointer(z)) - uintptr(unsafe.Pointer(zOut)))
		*func() (_cgo_ret *uint8) {
			_cgo_addr := &z
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr))++
			return
		}() = uint8(0)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pMem.enc) == 2 {
			for uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
				c = uint32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}())
				c += uint32(int32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) << 8)
				if c >= uint32(55296) && c < uint32(57344) {
					if uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
						var c2 int32 = int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zIn
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}())
						c2 += int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zIn
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}()) << 8
						c = uint32(c2&1023) + c&uint32(63)<<10 + (c&uint32(960)+uint32(64))<<10
					}
				}
				{
					if c < uint32(128) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c & uint32(255))
					} else if c < uint32(2048) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(192 + int32(uint8(c>>6&uint32(31))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c&uint32(63))))
					} else if c < uint32(65536) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(224 + int32(uint8(c>>12&uint32(15))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c>>6&uint32(63))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c&uint32(63))))
					} else {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(240 + int32(uint8(c>>18&uint32(7))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c>>12&uint32(63))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c>>6&uint32(63))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c&uint32(63))))
					}
				}
			}
		} else {
			for uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
				c = uint32(int32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) << 8)
				c += uint32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}())
				if c >= uint32(55296) && c < uint32(57344) {
					if uintptr(unsafe.Pointer(zIn)) < uintptr(unsafe.Pointer(zTerm)) {
						var c2 int32 = int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zIn
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}()) << 8
						c2 += int32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zIn
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}())
						c = uint32(c2&1023) + c&uint32(63)<<10 + (c&uint32(960)+uint32(64))<<10
					}
				}
				{
					if c < uint32(128) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(c & uint32(255))
					} else if c < uint32(2048) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(192 + int32(uint8(c>>6&uint32(31))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c&uint32(63))))
					} else if c < uint32(65536) {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(224 + int32(uint8(c>>12&uint32(15))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c>>6&uint32(63))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c&uint32(63))))
					} else {
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(240 + int32(uint8(c>>18&uint32(7))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c>>12&uint32(63))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c>>6&uint32(63))))
						*func() (_cgo_ret *uint8) {
							_cgo_addr := &z
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}() = uint8(128 + int32(uint8(c&uint32(63))))
					}
				}
			}
		}
		pMem.n = int32(uintptr(unsafe.Pointer(z)) - uintptr(unsafe.Pointer(zOut)))
	}
	*z = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	c = uint32(2 | 512 | int32(pMem.flags)&(63|32768))
	sqlite3VdbeMemRelease(pMem)
	pMem.flags = uint16(c)
	pMem.enc = desiredEnc
	pMem.z = (*int8)(unsafe.Pointer(zOut))
	pMem.zMalloc = pMem.z
	pMem.szMalloc = sqlite3DbMallocSize(pMem.db, unsafe.Pointer(pMem.z))
translate_out:
	return int32(0)
}
func sqlite3VdbeMemHandleBom(pMem *struct_sqlite3_value) int32 {
	var rc int32 = 0
	var bom uint8 = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	if pMem.n > 1 {
		var b1 uint8 = *(*uint8)(unsafe.Pointer(pMem.z))
		var b2 uint8 = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pMem.z)))) + uintptr(1)))
		if int32(b1) == 254 && int32(b2) == 255 {
			bom = uint8(3)
		}
		if int32(b1) == 255 && int32(b2) == 254 {
			bom = uint8(2)
		}
	}
	if bom != 0 {
		rc = sqlite3VdbeMemMakeWriteable(pMem)
		if rc == 0 {
			pMem.n -= int32(2)
			__builtin___memmove_chk(unsafe.Pointer(pMem.z), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(2)))), uint(pMem.n), __builtin_object_size(unsafe.Pointer(pMem.z), 0))
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n))) = int8('\x00')
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n+1))) = int8('\x00')
			pMem.flags |= uint16(512)
			pMem.enc = bom
		}
	}
	return rc
}
func sqlite3Utf8CharLen(zIn *int8, nByte int32) int32 {
	var r int32 = 0
	var z *uint8 = (*uint8)(unsafe.Pointer(zIn))
	var zTerm *uint8
	if nByte >= 0 {
		zTerm = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(nByte)))
	} else {
		zTerm = (*uint8)(unsafe.Pointer(uintptr(18446744073709551615)))
	}
	func() int {
		_ = 0
		return 0
	}()
	for int32(*z) != 0 && uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zTerm)) {
		{
			if int32(*func() (_cgo_ret *uint8) {
				_cgo_addr := &z
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()) >= 192 {
				for int32(*z)&192 == 128 {
					*(*uintptr)(unsafe.Pointer(&z))++
				}
			}
		}
		r++
	}
	return r
}
func sqlite3Utf16to8(db *struct_sqlite3, z unsafe.Pointer, nByte int32, enc uint8) *int8 {
	var m struct_sqlite3_value
	__builtin___memset_chk(unsafe.Pointer(&m), 0, 56, __builtin_object_size(unsafe.Pointer(&m), 0))
	m.db = db
	sqlite3VdbeMemSetStr(&m, (*int8)(z), int64(nByte), enc, (func(unsafe.Pointer))(0))
	sqlite3VdbeChangeEncoding(&m, 1)
	if db.mallocFailed != 0 {
		sqlite3VdbeMemRelease(&m)
		m.z = (*int8)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return m.z
}
func sqlite3Utf16ByteLen(zIn unsafe.Pointer, nChar int32) int32 {
	var c int32
	var z *uint8 = (*uint8)(zIn)
	var n int32 = 0
	if 2 == 2 {
		*(*uintptr)(unsafe.Pointer(&z))++
	}
	for n < nChar {
		c = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))))
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(2)
		if c >= 216 && c < 220 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) >= 220 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) < 224 {
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(2)
		}
		n++
	}
	return int32(uintptr(unsafe.Pointer(z))-uintptr(unsafe.Pointer((*uint8)(zIn)))) - func() int32 {
		if 2 == 2 {
			return 1
		} else {
			return 0
		}
	}()
}

type float_t = float32
type double_t = float64

func __inline_isfinitef(__x float32) int32 {
	return func() int32 {
		if __x == __x && __builtin_fabsf(__x) != __builtin_inff() {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isfinited(__x float64) int32 {
	return func() int32 {
		if __x == __x && __builtin_fabs(__x) != __builtin_inf() {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isfinitel(__x float64) int32 {
	return func() int32 {
		if __x == __x && __builtin_fabsl(__x) != __builtin_infl() {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isinff(__x float32) int32 {
	return func() int32 {
		if __builtin_fabsf(__x) == __builtin_inff() {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isinfd(__x float64) int32 {
	return func() int32 {
		if __builtin_fabs(__x) == __builtin_inf() {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isinfl(__x float64) int32 {
	return func() int32 {
		if __builtin_fabsl(__x) == __builtin_infl() {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isnanf(__x float32) int32 {
	return func() int32 {
		if __x != __x {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isnand(__x float64) int32 {
	return func() int32 {
		if __x != __x {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isnanl(__x float64) int32 {
	return func() int32 {
		if __x != __x {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_signbitf(__x float32) int32 {
	type _cgoa_69 struct {
		__f float32
	}
	var __u _cgoa_69
	__u.__f = __x
	return int32(*(*uint32)(unsafe.Pointer(&__u)) >> 31)
}
func __inline_signbitd(__x float64) int32 {
	type _cgoa_70 struct {
		__f float64
	}
	var __u _cgoa_70
	__u.__f = __x
	return int32(*(*uint64)(unsafe.Pointer(&__u)) >> 63)
}
func __inline_signbitl(__x float64) int32 {
	type _cgoa_72 struct {
		__m    uint64
		__sexp uint16
	}
	type _cgoa_71 struct {
		__p _cgoa_72
	}
	var __u _cgoa_71
	*(*float64)(unsafe.Pointer(&__u)) = __x
	return int32(int32(__u.__p.__sexp) >> 15)
}
func __inline_isnormalf(__x float32) int32 {
	return func() int32 {
		if __inline_isfinitef(__x) != 0 && __builtin_fabsf(__x) >= 1.17549435e-38 {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isnormald(__x float64) int32 {
	return func() int32 {
		if __inline_isfinited(__x) != 0 && __builtin_fabs(__x) >= 2.2250738585072014e-308 {
			return 1
		} else {
			return 0
		}
	}()
}
func __inline_isnormall(__x float64) int32 {
	return func() int32 {
		if __inline_isfinitel(__x) != 0 && __builtin_fabsl(__x) >= 3.36210314311209350626e-4932 {
			return 1
		} else {
			return 0
		}
	}()
}

type struct___float2 struct {
	__sinval float32
	__cosval float32
}
type struct___double2 struct {
	__sinval float64
	__cosval float64
}

func __sincosf(__x float32, __sinp *float32, __cosp *float32) {
	var __stret struct___float2 = __sincosf_stret(__x)
	*__sinp = __stret.__sinval
	*__cosp = __stret.__cosval
}
func __sincos(__x float64, __sinp *float64, __cosp *float64) {
	var __stret struct___double2 = __sincos_stret(__x)
	*__sinp = __stret.__sinval
	*__cosp = __stret.__cosval
}
func __sincospif(__x float32, __sinp *float32, __cosp *float32) {
	var __stret struct___float2 = __sincospif_stret(__x)
	*__sinp = __stret.__sinval
	*__cosp = __stret.__cosval
}
func __sincospi(__x float64, __sinp *float64, __cosp *float64) {
	var __stret struct___double2 = __sincospi_stret(__x)
	*__sinp = __stret.__sinval
	*__cosp = __stret.__cosval
}

type struct_exception struct {
	type_  int32
	name   *int8
	arg1   float64
	arg2   float64
	retval float64
}

func sqlite3FaultSim(iTest int32) int32 {
	var xCallback func(int32) int32 = sqlite3Config.xTestCallback
	return func() int32 {
		if xCallback != nil {
			return xCallback(iTest)
		} else {
			return 0
		}
	}()
}
func sqlite3IsNaN(x float64) int32 {
	var rc int32
	var y uint64
	__builtin___memcpy_chk(unsafe.Pointer(&y), unsafe.Pointer(&x), 8, __builtin_object_size(unsafe.Pointer(&y), 0))
	rc = func() int32 {
		if y&(uint64(2047)<<52) == uint64(2047)<<52 && y&(uint64(1)<<52-uint64(1)) != uint64(0) {
			return 1
		} else {
			return 0
		}
	}()
	return rc
}
func sqlite3Strlen30(z *int8) int32 {
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	return 1073741823 & int32(strlen(z))
}
func sqlite3ColumnType(pCol *struct_Column, zDflt *int8) *int8 {
	if int32(pCol.colFlags)&4 != 0 {
		return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.zCnName))+uintptr(strlen(pCol.zCnName)))))) + uintptr(1)))
	} else if pCol.Xbf_0>>4&15 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		return (*int8)(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&sqlite3StdType)))) + uintptr(int32(pCol.Xbf_0>>4&15)-1)*8))))
	} else {
		return zDflt
	}
}
func sqlite3ErrorFinish(db *struct_sqlite3, err_code int32) {
	if db.pErr != nil {
		sqlite3ValueSetNull(db.pErr)
	}
	sqlite3SystemError(db, err_code)
}
func sqlite3Error(db *struct_sqlite3, err_code int32) {
	func() int {
		_ = 0
		return 0
	}()
	db.errCode = err_code
	if err_code != 0 || db.pErr != nil {
		sqlite3ErrorFinish(db, err_code)
	} else {
		db.errByteOffset = int32(-1)
	}
}
func sqlite3ErrorClear(db *struct_sqlite3) {
	func() int {
		_ = 0
		return 0
	}()
	db.errCode = int32(0)
	db.errByteOffset = int32(-1)
	if db.pErr != nil {
		sqlite3ValueSetNull(db.pErr)
	}
}
func sqlite3SystemError(db *struct_sqlite3, rc int32) {
	if rc == 10|12<<8 {
		return
	}
	rc &= int32(255)
	if rc == 14 || rc == 10 {
		db.iSysErrno = sqlite3OsGetLastError(db.pVfs)
	}
}
func sqlite3ErrorWithMsg(db *struct_sqlite3, err_code int32, zFormat *int8, __cgo_args ...interface {
}) {
	func() int {
		_ = 0
		return 0
	}()
	db.errCode = err_code
	sqlite3SystemError(db, err_code)
	if uintptr(unsafe.Pointer(zFormat)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3Error(db, err_code)
	} else if db.pErr != nil || uintptr(unsafe.Pointer(func() (_cgo_ret *struct_sqlite3_value) {
		_cgo_addr := &db.pErr
		*_cgo_addr = sqlite3ValueNew(db)
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		var z *int8
		z = sqlite3VMPrintf(db, zFormat, __cgo_args...)
		sqlite3ValueSetStr(db.pErr, -1, unsafe.Pointer(z), uint8(1), (func(unsafe.Pointer))(sqlite3OomFault))
	}
}
func sqlite3ErrorMsg(pParse *struct_Parse, zFormat *int8, __cgo_args ...interface {
}) {
	var zMsg *int8
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db.errByteOffset = int32(-2)
	zMsg = sqlite3VMPrintf(db, zFormat, __cgo_args...)
	if db.errByteOffset < -1 {
		db.errByteOffset = int32(-1)
	}
	if db.suppressErr != 0 {
		sqlite3DbFree(db, unsafe.Pointer(zMsg))
		if db.mallocFailed != 0 {
			pParse.nErr++
			pParse.rc = int32(7)
		}
	} else {
		pParse.nErr++
		sqlite3DbFree(db, unsafe.Pointer(pParse.zErrMsg))
		pParse.zErrMsg = zMsg
		pParse.rc = int32(1)
		pParse.pWith = (*struct_With)(nil)
	}
}
func sqlite3ErrorToParser(db *struct_sqlite3, errCode int32) int32 {
	var pParse *struct_Parse
	if uintptr(unsafe.Pointer(db)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Parse) {
		_cgo_addr := &pParse
		*_cgo_addr = db.pParse
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return errCode
	}
	pParse.rc = errCode
	pParse.nErr++
	return errCode
}
func sqlite3Dequote(z *int8) {
	var quote int8
	var i int32
	var j int32
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	quote = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))
	if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(quote)))))&128 != 0) {
		return
	}
	if int32(quote) == '[' {
		quote = int8(']')
	}
	for func() int32 {
		i = int32(1)
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); ; i++ {
		func() int {
			_ = 0
			return 0
		}()
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == int32(quote) {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))) == int32(quote) {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &j
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()))) = quote
				i++
			} else {
				break
			}
		} else {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))
		}
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j))) = int8(0)
}
func sqlite3DequoteExpr(p *struct_Expr) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	p.flags |= uint32(func() int32 {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.u.zToken)) + uintptr(0)))) == '"' {
			return 67108864 | 64
		} else {
			return 67108864
		}
	}())
	sqlite3Dequote(p.u.zToken)
}
func sqlite3DequoteToken(p *struct_Token) {
	var i uint32
	if p.n < uint32(2) {
		return
	}
	if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.z)) + uintptr(0))))))))&128 != 0) {
		return
	}
	for i = uint32(1); i < p.n-uint32(1); i++ {
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.z)) + uintptr(i))))))))&128 != 0 {
			return
		}
	}
	p.n -= uint32(2)
	*(*uintptr)(unsafe.Pointer(&p.z))++
}
func sqlite3TokenInit(p *struct_Token, z *int8) {
	p.z = z
	p.n = uint32(sqlite3Strlen30(z))
}
func sqlite3_stricmp(zLeft *int8, zRight *int8) int32 {
	if uintptr(unsafe.Pointer(zLeft)) == uintptr(unsafe.Pointer(nil)) {
		return func() int32 {
			if zRight != nil {
				return -1
			} else {
				return 0
			}
		}()
	} else if uintptr(unsafe.Pointer(zRight)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	return sqlite3StrICmp(zLeft, zRight)
}
func sqlite3StrICmp(zLeft *int8, zRight *int8) int32 {
	var a *uint8
	var b *uint8
	var c int32
	var x int32
	a = (*uint8)(unsafe.Pointer(zLeft))
	b = (*uint8)(unsafe.Pointer(zRight))
	for {
		c = int32(*a)
		x = int32(*b)
		if c == x {
			if c == 0 {
				break
			}
		} else {
			c = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(c)))) - int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(x))))
			if c != 0 {
				break
			}
		}
		*(*uintptr)(unsafe.Pointer(&a))++
		*(*uintptr)(unsafe.Pointer(&b))++
	}
	return c
}
func sqlite3_strnicmp(zLeft *int8, zRight *int8, N int32) int32 {
	var a *uint8
	var b *uint8
	if uintptr(unsafe.Pointer(zLeft)) == uintptr(unsafe.Pointer(nil)) {
		return func() int32 {
			if zRight != nil {
				return -1
			} else {
				return 0
			}
		}()
	} else if uintptr(unsafe.Pointer(zRight)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	a = (*uint8)(unsafe.Pointer(zLeft))
	b = (*uint8)(unsafe.Pointer(zRight))
	for func() (_cgo_ret int32) {
		_cgo_addr := &N
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() > 0 && int32(*a) != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(*a)))) == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(*b)))) {
		*(*uintptr)(unsafe.Pointer(&a))++
		*(*uintptr)(unsafe.Pointer(&b))++
	}
	return func() int32 {
		if N < 0 {
			return 0
		} else {
			return int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(*a)))) - int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(*b))))
		}
	}()
}
func sqlite3StrIHash(z *int8) uint8 {
	var h uint8 = uint8(0)
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return uint8(0)
	}
	for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))) != 0 {
		h += uint8(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))))))))
		*(*uintptr)(unsafe.Pointer(&z))++
	}
	return h
}
func sqlite3Pow10(E int32) float64 {
	var x float64 = float64(10)
	var r float64 = float64(1)
	for 1 != 0 {
		if E&1 != 0 {
			r *= x
		}
		E >>= 1
		if E == 0 {
			break
		}
		x *= x
	}
	return r
}
func sqlite3AtoF(z *int8, pResult *float64, length int32, enc uint8) int32 {
	var incr int32
	var zEnd *int8
	var sign int32 = 1
	var s int64 = int64(0)
	var d int32 = 0
	var esign int32 = 1
	var e int32 = 0
	var eValid int32 = 1
	var result float64
	var nDigit int32 = 0
	var eType int32 = 1
	func() int {
		_ = 0
		return 0
	}()
	*pResult = float64(0)
	if length == 0 {
		return int32(0)
	}
	if int32(enc) == 1 {
		incr = int32(1)
		zEnd = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(length)))
	} else {
		var i int32
		incr = int32(2)
		length &= int32(^1)
		func() int {
			_ = 0
			return 0
		}()
		for i = 3 - int32(enc); i < length && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == 0; i += int32(2) {
		}
		if i < length {
			eType = int32(-100)
		}
		zEnd = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i^1)))
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(int32(enc) & 1)
	}
	for uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&1 != 0 {
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
	}
	if uintptr(unsafe.Pointer(z)) >= uintptr(unsafe.Pointer(zEnd)) {
		return int32(0)
	}
	if int32(*z) == '-' {
		sign = int32(-1)
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
	} else if int32(*z) == '+' {
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
	}
	for uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&4 != 0 {
		s = s*int64(10) + int64(int32(*z)-'0')
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
		nDigit++
		if s >= (int64(4294967295)|int64(2147483647)<<32-int64(9))/int64(10) {
			for uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&4 != 0 {
				*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
				d++
			}
		}
	}
	if uintptr(unsafe.Pointer(z)) >= uintptr(unsafe.Pointer(zEnd)) {
		goto do_atof_calc
	}
	if int32(*z) == '.' {
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
		eType++
		for uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&4 != 0 {
			if s < (int64(4294967295)|int64(2147483647)<<32-int64(9))/int64(10) {
				s = s*int64(10) + int64(int32(*z)-'0')
				d--
				nDigit++
			}
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
		}
	}
	if uintptr(unsafe.Pointer(z)) >= uintptr(unsafe.Pointer(zEnd)) {
		goto do_atof_calc
	}
	if int32(*z) == 'e' || int32(*z) == 'E' {
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
		eValid = int32(0)
		eType++
		if uintptr(unsafe.Pointer(z)) >= uintptr(unsafe.Pointer(zEnd)) {
			goto do_atof_calc
		}
		if int32(*z) == '-' {
			esign = int32(-1)
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
		} else if int32(*z) == '+' {
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
		}
		for uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&4 != 0 {
			e = func() int32 {
				if e < 10000 {
					return e*10 + (int32(*z) - '0')
				} else {
					return 10000
				}
			}()
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
			eValid = int32(1)
		}
	}
	for uintptr(unsafe.Pointer(z)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&1 != 0 {
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(incr)
	}
do_atof_calc:
	e = e*esign + d
	if e < 0 {
		esign = int32(-1)
		e *= int32(-1)
	} else {
		esign = int32(1)
	}
	if s == int64(0) {
		result = func() float64 {
			if sign < 0 {
				return -float64(0)
			} else {
				return float64(0)
			}
		}()
	} else {
		for e > 0 {
			if esign > 0 {
				if s >= (int64(4294967295)|int64(2147483647)<<32)/int64(10) {
					break
				}
				s *= int64(10)
			} else {
				if s%int64(10) != int64(0) {
					break
				}
				s /= int64(10)
			}
			e--
		}
		s = func() int64 {
			if sign < 0 {
				return -s
			} else {
				return s
			}
		}()
		if e == 0 {
			result = float64(s)
		} else if e > 307 {
			if e < 342 {
				var scale float64 = sqlite3Pow10(e - 308)
				if esign < 0 {
					result = float64(float64(s) / scale)
					result /= float64(1.0e+308)
				} else {
					result = float64(float64(s) * scale)
					result *= float64(1.0e+308)
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				if esign < 0 {
					result = 0 * float64(s)
				} else {
					result = float64(__builtin_huge_valf() * float32(s))
				}
			}
		} else {
			var scale float64 = sqlite3Pow10(e)
			if esign < 0 {
				result = float64(float64(s) / scale)
			} else {
				result = float64(float64(s) * scale)
			}
		}
	}
	*pResult = result
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(zEnd)) && nDigit > 0 && eValid != 0 && eType > 0 {
		return eType
	} else if eType >= 2 && (eType == 3 || eValid != 0) && nDigit > 0 {
		return int32(-1)
	} else {
		return int32(0)
	}
}
func sqlite3Int64ToText(v int64, zOut *int8) {
	var i int32
	var x uint64
	var zTemp [22]int8
	if v < int64(0) {
		x = func() uint64 {
			if v == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
				return uint64(1) << 63
			} else {
				return uint64(-v)
			}
		}()
	} else {
		x = uint64(v)
	}
	i = int32(22 - uint(2))
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zTemp)))) + uintptr(22-uint(1)))) = int8(0)
	for {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zTemp)))) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}()))) = int8(x%uint64(10) + uint64('0'))
		x = x / uint64(10)
		if !(x != 0) {
			break
		}
	}
	if v < int64(0) {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zTemp)))) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}()))) = int8('-')
	}
	__builtin___memcpy_chk(unsafe.Pointer(zOut), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zTemp)))) + uintptr(i+1)))), 22-uint(1)-uint(i), __builtin_object_size(unsafe.Pointer(zOut), 0))
}
func compare2pow63(zNum *int8, incr int32) int32 {
	var c int32 = 0
	var i int32
	var pow63 *int8 = (*int8)(unsafe.Pointer(&[19]int8{'9', '2', '2', '3', '3', '7', '2', '0', '3', '6', '8', '5', '4', '7', '7', '5', '8', '0', '\x00'}))
	for i = int32(0); c == 0 && i < 18; i++ {
		c = (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i*incr)))) - int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pow63)) + uintptr(i))))) * 10
	}
	if c == 0 {
		c = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(18*incr)))) - '8'
	}
	return c
}
func sqlite3Atoi64(zNum *int8, pNum *int64, length int32, enc uint8) int32 {
	var incr int32
	var u uint64 = uint64(0)
	var neg int32 = 0
	var i int32
	var c int32 = 0
	var nonNum int32 = 0
	var rc int32
	var zStart *int8
	var zEnd *int8 = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(length)))
	func() int {
		_ = 0
		return 0
	}()
	if int32(enc) == 1 {
		incr = int32(1)
	} else {
		incr = int32(2)
		length &= int32(^1)
		func() int {
			_ = 0
			return 0
		}()
		for i = 3 - int32(enc); i < length && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i)))) == 0; i += int32(2) {
		}
		nonNum = func() int32 {
			if i < length {
				return 1
			} else {
				return 0
			}
		}()
		zEnd = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i^1)))
		*(*uintptr)(unsafe.Pointer(&zNum)) += uintptr(int32(enc) & 1)
	}
	for uintptr(unsafe.Pointer(zNum)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zNum)))))&1 != 0 {
		*(*uintptr)(unsafe.Pointer(&zNum)) += uintptr(incr)
	}
	if uintptr(unsafe.Pointer(zNum)) < uintptr(unsafe.Pointer(zEnd)) {
		if int32(*zNum) == '-' {
			neg = int32(1)
			*(*uintptr)(unsafe.Pointer(&zNum)) += uintptr(incr)
		} else if int32(*zNum) == '+' {
			*(*uintptr)(unsafe.Pointer(&zNum)) += uintptr(incr)
		}
	}
	zStart = zNum
	for uintptr(unsafe.Pointer(zNum)) < uintptr(unsafe.Pointer(zEnd)) && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0)))) == '0' {
		*(*uintptr)(unsafe.Pointer(&zNum)) += uintptr(incr)
	}
	for i = int32(0); uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i))))) < uintptr(unsafe.Pointer(zEnd)) && func() (_cgo_ret int32) {
		_cgo_addr := &c
		*_cgo_addr = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i))))
		return *_cgo_addr
	}() >= '0' && c <= '9'; i += incr {
		u = u*uint64(10) + uint64(c) - uint64('0')
	}
	if u > uint64(int64(4294967295)|int64(2147483647)<<32) {
		*pNum = func() int64 {
			if neg != 0 {
				return int64(-1) - (int64(4294967295) | int64(2147483647)<<32)
			} else {
				return int64(4294967295) | int64(2147483647)<<32
			}
		}()
	} else if neg != 0 {
		*pNum = -int64(u)
	} else {
		*pNum = int64(u)
	}
	rc = int32(0)
	if i == 0 && uintptr(unsafe.Pointer(zStart)) == uintptr(unsafe.Pointer(zNum)) {
		rc = int32(-1)
	} else if nonNum != 0 {
		rc = int32(1)
	} else if uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i))))) < uintptr(unsafe.Pointer(zEnd)) {
		var jj int32 = i
		for {
			if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(jj))))))))&1 != 0) {
				rc = int32(1)
				break
			}
			jj += incr
			if !(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(jj))))) < uintptr(unsafe.Pointer(zEnd))) {
				break
			}
		}
	}
	if i < 19*incr {
		func() int {
			_ = 0
			return 0
		}()
		return rc
	} else {
		c = func() int32 {
			if i > 19*incr {
				return 1
			} else {
				return compare2pow63(zNum, incr)
			}
		}()
		if c < 0 {
			func() int {
				_ = 0
				return 0
			}()
			return rc
		} else {
			*pNum = func() int64 {
				if neg != 0 {
					return int64(-1) - (int64(4294967295) | int64(2147483647)<<32)
				} else {
					return int64(4294967295) | int64(2147483647)<<32
				}
			}()
			if c > 0 {
				return int32(2)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				return func() int32 {
					if neg != 0 {
						return rc
					} else {
						return 3
					}
				}()
			}
		}
	}
}
func sqlite3DecOrHexToI64(z *int8, pOut *int64) int32 {
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) == '0' && (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == 'x' || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == 'X') {
		var u uint64 = uint64(0)
		var i int32
		var k int32
		for i = int32(2); int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == '0'; i++ {
		}
		for k = i; int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(k))))))))&8 != 0; k++ {
			u = u*uint64(16) + uint64(sqlite3HexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(k))))))
		}
		__builtin___memcpy_chk(unsafe.Pointer(pOut), unsafe.Pointer(&u), uint(8), __builtin_object_size(unsafe.Pointer(pOut), 0))
		return func() int32 {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(k)))) == 0 && k-i <= 16 {
				return 0
			} else {
				return 2
			}
		}()
	} else {
		return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), uint8(1))
	}
}
func sqlite3GetInt32(zNum *int8, pValue *int32) int32 {
	var v int64 = int64(0)
	var i int32
	var c int32
	var neg int32 = 0
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0)))) == '-' {
		neg = int32(1)
		*(*uintptr)(unsafe.Pointer(&zNum))++
	} else if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0)))) == '+' {
		*(*uintptr)(unsafe.Pointer(&zNum))++
	} else if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0)))) == '0' && (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(1)))) == 'x' || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(1)))) == 'X') && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(2))))))))&8 != 0 {
		var u uint32 = uint32(0)
		*(*uintptr)(unsafe.Pointer(&zNum)) += uintptr(2)
		for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0)))) == '0' {
			*(*uintptr)(unsafe.Pointer(&zNum))++
		}
		for i = int32(0); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i))))))))&8 != 0 && i < 8; i++ {
			u = u*uint32(16) + uint32(sqlite3HexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i))))))
		}
		if u&2147483648 == uint32(0) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i))))))))&8 == 0 {
			__builtin___memcpy_chk(unsafe.Pointer(pValue), unsafe.Pointer(&u), uint(4), __builtin_object_size(unsafe.Pointer(pValue), 0))
			return int32(1)
		} else {
			return int32(0)
		}
	}
	if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0))))))))&4 != 0) {
		return int32(0)
	}
	for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(0)))) == '0' {
		*(*uintptr)(unsafe.Pointer(&zNum))++
	}
	for i = int32(0); i < 11 && func() (_cgo_ret int32) {
		_cgo_addr := &c
		*_cgo_addr = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNum)) + uintptr(i)))) - '0'
		return *_cgo_addr
	}() >= 0 && c <= 9; i++ {
		v = v*int64(10) + int64(c)
	}
	if i > 10 {
		return int32(0)
	}
	if v-int64(neg) > int64(2147483647) {
		return int32(0)
	}
	if neg != 0 {
		v = -v
	}
	*pValue = int32(v)
	return int32(1)
}
func sqlite3Atoi(z *int8) int32 {
	var x int32 = 0
	sqlite3GetInt32(z, &x)
	return x
}
func sqlite3GetUInt32(z *int8, pI *uint32) int32 {
	var v uint64 = uint64(0)
	var i int32
	for i = int32(0); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&4 != 0; i++ {
		v = v*uint64(10) + uint64(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) - uint64('0')
		if v > uint64(4294967296) {
			*pI = uint32(0)
			return int32(0)
		}
	}
	if i == 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) != 0 {
		*pI = uint32(0)
		return int32(0)
	}
	*pI = uint32(v)
	return int32(1)
}
func putVarint64(p *uint8, v uint64) int32 {
	var i int32
	var j int32
	var n int32
	var buf [10]uint8
	if v&(uint64(4278190080)<<32) != 0 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(8))) = uint8(v)
		v >>= 8
		for i = int32(7); i >= 0; i-- {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(i))) = uint8(v&uint64(127) | uint64(128))
			v >>= 7
		}
		return int32(9)
	}
	n = int32(0)
	for {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&buf)))) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &n
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = uint8(v&uint64(127) | uint64(128))
		v >>= 7
		if !(v != uint64(0)) {
			break
		}
	}
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&buf)))) + uintptr(0))) &= uint8(127)
	func() int {
		_ = 0
		return 0
	}()
	for func() int32 {
		i = int32(0)
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = n - 1
			return *_cgo_addr
		}()
	}(); j >= 0; func() int32 {
		j--
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(i))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&buf)))) + uintptr(j)))
	}
	return n
}
func sqlite3PutVarint(p *uint8, v uint64) int32 {
	if v <= uint64(127) {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(0))) = uint8(v & uint64(127))
		return int32(1)
	}
	if v <= uint64(16383) {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(0))) = uint8(v>>7&uint64(127) | uint64(128))
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1))) = uint8(v & uint64(127))
		return int32(2)
	}
	return putVarint64(p, v)
}
func sqlite3GetVarint(p *uint8, v *uint64) uint8 {
	var a uint32
	var b uint32
	var s uint32
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p)))) + uintptr(0)))) >= 0 {
		*v = uint64(*p)
		return uint8(1)
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p)))) + uintptr(1)))) >= 0 {
		*v = uint64(uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(0))))&127)<<7 | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)))))
		return uint8(2)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	a = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(0)))) << 14
	b = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1))))
	*(*uintptr)(unsafe.Pointer(&p)) += uintptr(2)
	a |= uint32(*p)
	if !(a&uint32(128) != 0) {
		a &= uint32(2080895)
		b &= uint32(127)
		b = b << 7
		a |= b
		*v = uint64(a)
		return uint8(3)
	}
	a &= uint32(2080895)
	*(*uintptr)(unsafe.Pointer(&p))++
	b = b << 14
	b |= uint32(*p)
	if !(b&uint32(128) != 0) {
		b &= uint32(2080895)
		a = a << 7
		a |= b
		*v = uint64(a)
		return uint8(4)
	}
	b &= uint32(2080895)
	s = a
	*(*uintptr)(unsafe.Pointer(&p))++
	a = a << 14
	a |= uint32(*p)
	if !(a&uint32(128) != 0) {
		b = b << 7
		a |= b
		s = s >> 18
		*v = uint64(s)<<32 | uint64(a)
		return uint8(5)
	}
	s = s << 7
	s |= b
	*(*uintptr)(unsafe.Pointer(&p))++
	b = b << 14
	b |= uint32(*p)
	if !(b&uint32(128) != 0) {
		a &= uint32(2080895)
		a = a << 7
		a |= b
		s = s >> 18
		*v = uint64(s)<<32 | uint64(a)
		return uint8(6)
	}
	*(*uintptr)(unsafe.Pointer(&p))++
	a = a << 14
	a |= uint32(*p)
	if !(a&uint32(128) != 0) {
		a &= uint32(4028612735)
		b &= uint32(2080895)
		b = b << 7
		a |= b
		s = s >> 11
		*v = uint64(s)<<32 | uint64(a)
		return uint8(7)
	}
	a &= uint32(2080895)
	*(*uintptr)(unsafe.Pointer(&p))++
	b = b << 14
	b |= uint32(*p)
	if !(b&uint32(128) != 0) {
		b &= uint32(4028612735)
		a = a << 7
		a |= b
		s = s >> 4
		*v = uint64(s)<<32 | uint64(a)
		return uint8(8)
	}
	*(*uintptr)(unsafe.Pointer(&p))++
	a = a << 15
	a |= uint32(*p)
	b &= uint32(2080895)
	b = b << 8
	a |= b
	s = s << 4
	b = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - uintptr(- -4))))
	b &= uint32(127)
	b = b >> 3
	s |= b
	*v = uint64(s)<<32 | uint64(a)
	return uint8(9)
}
func sqlite3GetVarint32(p *uint8, v *uint32) uint8 {
	var a uint32
	var b uint32
	a = uint32(*p)
	*(*uintptr)(unsafe.Pointer(&p))++
	b = uint32(*p)
	if !(b&uint32(128) != 0) {
		a &= uint32(127)
		a = a << 7
		*v = a | b
		return uint8(2)
	}
	*(*uintptr)(unsafe.Pointer(&p))++
	a = a << 14
	a |= uint32(*p)
	if !(a&uint32(128) != 0) {
		a &= uint32(127<<14 | 127)
		b &= uint32(127)
		b = b << 7
		*v = a | b
		return uint8(3)
	}
	{
		var v64 uint64
		var n uint8
		n = sqlite3GetVarint((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p))-uintptr(2))), &v64)
		func() int {
			_ = 0
			return 0
		}()
		if v64&(uint64(1)<<32-uint64(1)) != v64 {
			*v = uint32(4294967295)
		} else {
			*v = uint32(v64)
		}
		return n
	}
}
func sqlite3VarintLen(v uint64) int32 {
	var i int32
	for i = int32(1); func() (_cgo_ret uint64) {
		_cgo_addr := &v
		*_cgo_addr >>= 7
		return *_cgo_addr
	}() != uint64(0); i++ {
		func() int {
			_ = 0
			return 0
		}()
	}
	return i
}
func sqlite3Get4byte(p *uint8) uint32 {
	return uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(3))))
}
func sqlite3Put4byte(p *uint8, v uint32) {
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(0))) = uint8(v >> 24)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1))) = uint8(v >> 16)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(2))) = uint8(v >> 8)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(3))) = uint8(v)
}
func sqlite3HexToInt(h int32) uint8 {
	func() int {
		_ = 0
		return 0
	}()
	h += 9 * (1 & (h >> 6))
	return uint8(h & 15)
}
func sqlite3HexToBlob(db *struct_sqlite3, z *int8, n int32) unsafe.Pointer {
	var zBlob *int8
	var i int32
	zBlob = (*int8)(sqlite3DbMallocRawNN(db, uint64(n/2+1)))
	n--
	if zBlob != nil {
		for i = int32(0); i < n; i += int32(2) {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBlob)) + uintptr(i/2))) = int8(int32(sqlite3HexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))<<4 | int32(sqlite3HexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))))))
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBlob)) + uintptr(i/2))) = int8(0)
	}
	return unsafe.Pointer(zBlob)
}
func logBadConnection(zType *int8) {
	sqlite3_log(21, (*int8)(unsafe.Pointer(&[45]int8{'A', 'P', 'I', ' ', 'c', 'a', 'l', 'l', ' ', 'w', 'i', 't', 'h', ' ', '%', 's', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'c', 'o', 'n', 'n', 'e', 'c', 't', 'i', 'o', 'n', ' ', 'p', 'o', 'i', 'n', 't', 'e', 'r', '\x00'})), zType)
}
func sqlite3SafetyCheckOk(db *struct_sqlite3) int32 {
	var eOpenState uint8
	if uintptr(unsafe.Pointer(db)) == uintptr(unsafe.Pointer(nil)) {
		logBadConnection((*int8)(unsafe.Pointer(&[5]int8{'N', 'U', 'L', 'L', '\x00'})))
		return int32(0)
	}
	eOpenState = db.eOpenState
	if int32(eOpenState) != 118 {
		if sqlite3SafetyCheckSickOrOk(db) != 0 {
			logBadConnection((*int8)(unsafe.Pointer(&[9]int8{'u', 'n', 'o', 'p', 'e', 'n', 'e', 'd', '\x00'})))
		}
		return int32(0)
	} else {
		return int32(1)
	}
}
func sqlite3SafetyCheckSickOrOk(db *struct_sqlite3) int32 {
	var eOpenState uint8
	eOpenState = db.eOpenState
	if int32(eOpenState) != 186 && int32(eOpenState) != 118 && int32(eOpenState) != 109 {
		logBadConnection((*int8)(unsafe.Pointer(&[8]int8{'i', 'n', 'v', 'a', 'l', 'i', 'd', '\x00'})))
		return int32(0)
	} else {
		return int32(1)
	}
}
func sqlite3AddInt64(pA *int64, iB int64) int32 {
	var iA int64 = *pA
	if iB >= int64(0) {
		if iA > int64(0) && int64(4294967295)|int64(2147483647)<<32-iA < iB {
			return int32(1)
		}
	} else if iA < int64(0) && -(iA+(int64(4294967295)|int64(2147483647)<<32)) > iB+int64(1) {
		return int32(1)
	}
	*pA += iB
	return int32(0)
}
func sqlite3SubInt64(pA *int64, iB int64) int32 {
	if iB == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
		if *pA >= int64(0) {
			return int32(1)
		}
		*pA -= iB
		return int32(0)
	} else {
		return sqlite3AddInt64(pA, -iB)
	}
}
func sqlite3MulInt64(pA *int64, iB int64) int32 {
	var iA int64 = *pA
	if iB > int64(0) {
		if iA > (int64(4294967295)|int64(2147483647)<<32)/iB {
			return int32(1)
		}
		if iA < (int64(-1)-(int64(4294967295)|int64(2147483647)<<32))/iB {
			return int32(1)
		}
	} else if iB < int64(0) {
		if iA > int64(0) {
			if iB < (int64(-1)-(int64(4294967295)|int64(2147483647)<<32))/iA {
				return int32(1)
			}
		} else if iA < int64(0) {
			if iB == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
				return int32(1)
			}
			if iA == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
				return int32(1)
			}
			if -iA > (int64(4294967295)|int64(2147483647)<<32)/-iB {
				return int32(1)
			}
		}
	}
	*pA = iA * iB
	return int32(0)
}
func sqlite3AbsInt32(x int32) int32 {
	if x >= 0 {
		return x
	}
	if x == int32(2147483648) {
		return int32(2147483647)
	}
	return -x
}
func sqlite3LogEstAdd(a int16, b int16) int16 {
	var x [32]uint8 = [32]uint8{uint8(10), uint8(10), uint8(9), uint8(9), uint8(8), uint8(8), uint8(7), uint8(7), uint8(7), uint8(6), uint8(6), uint8(6), uint8(5), uint8(5), uint8(5), uint8(4), uint8(4), uint8(4), uint8(4), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2)}
	if int32(a) >= int32(b) {
		if int32(a) > int32(b)+49 {
			return a
		}
		if int32(a) > int32(b)+31 {
			return int16(int32(a) + 1)
		}
		return int16(int32(a) + int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&x)))) + uintptr(int32(a)-int32(b))))))
	} else {
		if int32(b) > int32(a)+49 {
			return b
		}
		if int32(b) > int32(a)+31 {
			return int16(int32(b) + 1)
		}
		return int16(int32(b) + int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&x)))) + uintptr(int32(b)-int32(a))))))
	}
}
func sqlite3LogEst(x uint64) int16 {
	var a [8]int16 = [8]int16{int16(0), int16(2), int16(3), int16(5), int16(6), int16(7), int16(8), int16(9)}
	var y int16 = int16(40)
	if x < uint64(8) {
		if x < uint64(2) {
			return int16(0)
		}
		for x < uint64(8) {
			y -= int16(10)
			x <<= 1
		}
	} else {
		for x > uint64(255) {
			y += int16(40)
			x >>= 4
		}
		for x > uint64(15) {
			y += int16(10)
			x >>= 1
		}
	}
	return int16(int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&a)))) + uintptr(x&uint64(7))*2))) + int32(y) - 10)
}
func sqlite3LogEstFromDouble(x float64) int16 {
	var a uint64
	var e int16
	func() int {
		_ = 0
		return 0
	}()
	if x <= float64(1) {
		return int16(0)
	}
	if x <= float64(2000000000) {
		return sqlite3LogEst(uint64(x))
	}
	__builtin___memcpy_chk(unsafe.Pointer(&a), unsafe.Pointer(&x), uint(8), __builtin_object_size(unsafe.Pointer(&a), 0))
	e = int16(a>>52 - uint64(1022))
	return int16(int32(e) * 10)
}
func sqlite3LogEstToInt(x int16) uint64 {
	var n uint64
	n = uint64(int32(x) % 10)
	x /= int16(10)
	if n >= uint64(5) {
		n -= uint64(2)
	} else if n >= uint64(1) {
		n -= uint64(1)
	}
	if int32(x) > 60 {
		return uint64(int64(4294967295) | int64(2147483647)<<32)
	}
	return func() uint64 {
		if int32(x) >= 3 {
			return (n + uint64(8)) << (int32(x) - 3)
		} else {
			return (n + uint64(8)) >> (3 - int32(x))
		}
	}()
}
func sqlite3VListAdd(db *struct_sqlite3, pIn *int32, zName *int8, nName int32, iVal int32) *int32 {
	var nInt int32
	var z *int8
	var i int32
	nInt = nName/4 + 3
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pIn)) == uintptr(unsafe.Pointer(nil)) || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(1)*4))+nInt > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(0)*4)) {
		var nAlloc int64 = func() int64 {
			if pIn != nil {
				return int64(2) * int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(0)*4)))
			} else {
				return int64(10)
			}
		}() + int64(nInt)
		var pOut *int32 = (*int32)(sqlite3DbRealloc(db, unsafe.Pointer(pIn), uint64(nAlloc)*uint64(4)))
		if uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(nil)) {
			return pIn
		}
		if uintptr(unsafe.Pointer(pIn)) == uintptr(unsafe.Pointer(nil)) {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut)) + uintptr(1)*4)) = int32(2)
		}
		pIn = pOut
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(0)*4)) = int32(nAlloc)
	}
	i = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(1)*4))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i)*4)) = iVal
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i+1)*4)) = nInt
	z = (*int8)(unsafe.Pointer(&*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i+2)*4))))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(1)*4)) = i + nInt
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memcpy_chk(unsafe.Pointer(z), unsafe.Pointer(zName), uint(nName), __builtin_object_size(unsafe.Pointer(z), 0))
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(nName))) = int8(0)
	return pIn
}
func sqlite3VListNumToName(pIn *int32, iVal int32) *int8 {
	var i int32
	var mx int32
	if uintptr(unsafe.Pointer(pIn)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	mx = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(1)*4))
	i = int32(2)
	for {
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i)*4)) == iVal {
			return (*int8)(unsafe.Pointer(&*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i+2)*4))))
		}
		i += *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i+1)*4))
		if !(i < mx) {
			break
		}
	}
	return (*int8)(nil)
}
func sqlite3VListNameToNum(pIn *int32, zName *int8, nName int32) int32 {
	var i int32
	var mx int32
	if uintptr(unsafe.Pointer(pIn)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	mx = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(1)*4))
	i = int32(2)
	for {
		var z *int8 = (*int8)(unsafe.Pointer(&*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i+2)*4))))
		if strncmp(z, zName, uint(nName)) == 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(nName)))) == 0 {
			return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i)*4))
		}
		i += *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn)) + uintptr(i+1)*4))
		if !(i < mx) {
			break
		}
	}
	return int32(0)
}
func sqlite3HashInit(pNew *struct_Hash) {
	func() int {
		_ = 0
		return 0
	}()
	pNew.first = (*struct_HashElem)(nil)
	pNew.count = uint32(0)
	pNew.htsize = uint32(0)
	pNew.ht = (*struct__ht)(nil)
}
func sqlite3HashClear(pH *struct_Hash) {
	var elem *struct_HashElem
	func() int {
		_ = 0
		return 0
	}()
	elem = pH.first
	pH.first = (*struct_HashElem)(nil)
	sqlite3_free(unsafe.Pointer(pH.ht))
	pH.ht = (*struct__ht)(nil)
	pH.htsize = uint32(0)
	for elem != nil {
		var next_elem *struct_HashElem = elem.next
		sqlite3_free(unsafe.Pointer(elem))
		elem = next_elem
	}
	pH.count = uint32(0)
}
func strHash(z *int8) uint32 {
	var h uint32 = uint32(0)
	var c uint8
	for int32(func() (_cgo_ret uint8) {
		_cgo_addr := &c
		*_cgo_addr = uint8(*func() (_cgo_ret *int8) {
			_cgo_addr := &z
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr))++
			return
		}())
		return *_cgo_addr
	}()) != 0 {
		h += uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(c))))
		h *= uint32(2654435761)
	}
	return h
}
func insertElement(pH *struct_Hash, pEntry *struct__ht, pNew *struct_HashElem) {
	var pHead *struct_HashElem
	if pEntry != nil {
		pHead = func() *struct_HashElem {
			if pEntry.count != 0 {
				return pEntry.chain
			} else {
				return nil
			}
		}()
		pEntry.count++
		pEntry.chain = pNew
	} else {
		pHead = (*struct_HashElem)(nil)
	}
	if pHead != nil {
		pNew.next = pHead
		pNew.prev = pHead.prev
		if pHead.prev != nil {
			pHead.prev.next = pNew
		} else {
			pH.first = pNew
		}
		pHead.prev = pNew
	} else {
		pNew.next = pH.first
		if pH.first != nil {
			pH.first.prev = pNew
		}
		pNew.prev = (*struct_HashElem)(nil)
		pH.first = pNew
	}
}
func rehash(pH *struct_Hash, new_size uint32) int32 {
	var new_ht *struct__ht
	var elem *struct_HashElem
	var next_elem *struct_HashElem
	if uint(new_size)*16 > uint(1024) {
		new_size = uint32(uint(1024) / 16)
	}
	if new_size == pH.htsize {
		return int32(0)
	}
	sqlite3BeginBenignMalloc()
	new_ht = (*struct__ht)(sqlite3Malloc(uint64(uint(new_size) * 16)))
	sqlite3EndBenignMalloc()
	if uintptr(unsafe.Pointer(new_ht)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	sqlite3_free(unsafe.Pointer(pH.ht))
	pH.ht = new_ht
	pH.htsize = func() (_cgo_ret uint32) {
		_cgo_addr := &new_size
		*_cgo_addr = uint32(uint(sqlite3MallocSize(unsafe.Pointer(new_ht))) / 16)
		return *_cgo_addr
	}()
	__builtin___memset_chk(unsafe.Pointer(new_ht), 0, uint(new_size)*16, __builtin_object_size(unsafe.Pointer(new_ht), 0))
	for func() *struct_HashElem {
		elem = pH.first
		return func() (_cgo_ret *struct_HashElem) {
			_cgo_addr := &pH.first
			*_cgo_addr = (*struct_HashElem)(nil)
			return *_cgo_addr
		}()
	}(); elem != nil; elem = next_elem {
		var h uint32 = strHash(elem.pKey) % new_size
		next_elem = elem.next
		insertElement(pH, &*(*struct__ht)(unsafe.Pointer(uintptr(unsafe.Pointer(new_ht)) + uintptr(h)*16)), elem)
	}
	return int32(1)
}
func findElementWithHash(pH *struct_Hash, pKey *int8, pHash *uint32) *struct_HashElem {
	var elem *struct_HashElem
	var count uint32
	var h uint32
	var nullElement struct_HashElem = struct_HashElem{nil, nil, nil, nil}
	if pH.ht != nil {
		var pEntry *struct__ht
		h = strHash(pKey) % pH.htsize
		pEntry = &*(*struct__ht)(unsafe.Pointer(uintptr(unsafe.Pointer(pH.ht)) + uintptr(h)*16))
		elem = pEntry.chain
		count = pEntry.count
	} else {
		h = uint32(0)
		elem = pH.first
		count = pH.count
	}
	if pHash != nil {
		*pHash = h
	}
	for func() (_cgo_ret uint32) {
		_cgo_addr := &count
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if sqlite3StrICmp(elem.pKey, pKey) == 0 {
			return elem
		}
		elem = elem.next
	}
	return &nullElement
}
func removeElementGivenHash(pH *struct_Hash, elem *struct_HashElem, h uint32) {
	var pEntry *struct__ht
	if elem.prev != nil {
		elem.prev.next = elem.next
	} else {
		pH.first = elem.next
	}
	if elem.next != nil {
		elem.next.prev = elem.prev
	}
	if pH.ht != nil {
		pEntry = &*(*struct__ht)(unsafe.Pointer(uintptr(unsafe.Pointer(pH.ht)) + uintptr(h)*16))
		if uintptr(unsafe.Pointer(pEntry.chain)) == uintptr(unsafe.Pointer(elem)) {
			pEntry.chain = elem.next
		}
		func() int {
			_ = 0
			return 0
		}()
		pEntry.count--
	}
	sqlite3_free(unsafe.Pointer(elem))
	pH.count--
	if pH.count == uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3HashClear(pH)
	}
}
func sqlite3HashFind(pH *struct_Hash, pKey *int8) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return findElementWithHash(pH, pKey, nil).data
}
func sqlite3HashInsert(pH *struct_Hash, pKey *int8, data unsafe.Pointer) unsafe.Pointer {
	var h uint32
	var elem *struct_HashElem
	var new_elem *struct_HashElem
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	elem = findElementWithHash(pH, pKey, &h)
	if elem.data != nil {
		var old_data unsafe.Pointer = elem.data
		if uintptr(unsafe.Pointer(data)) == uintptr(unsafe.Pointer(nil)) {
			removeElementGivenHash(pH, elem, h)
		} else {
			elem.data = data
			elem.pKey = pKey
		}
		return old_data
	}
	if uintptr(unsafe.Pointer(data)) == uintptr(unsafe.Pointer(nil)) {
		return unsafe.Pointer(nil)
	}
	new_elem = (*struct_HashElem)(sqlite3Malloc(uint64(32)))
	if uintptr(unsafe.Pointer(new_elem)) == uintptr(unsafe.Pointer(nil)) {
		return data
	}
	new_elem.pKey = pKey
	new_elem.data = data
	pH.count++
	if pH.count >= uint32(10) && pH.count > uint32(2)*pH.htsize {
		if rehash(pH, pH.count*uint32(2)) != 0 {
			func() int {
				_ = 0
				return 0
			}()
			h = strHash(pKey) % pH.htsize
		}
	}
	insertElement(pH, func() *struct__ht {
		if pH.ht != nil {
			return &*(*struct__ht)(unsafe.Pointer(uintptr(unsafe.Pointer(pH.ht)) + uintptr(h)*16))
		} else {
			return nil
		}
	}(), new_elem)
	return unsafe.Pointer(nil)
}
func sqlite3OpcodeName(i int32) *int8 {
	var azName [185]*int8 = [185]*int8{(*int8)(unsafe.Pointer(&[10]int8{'S', 'a', 'v', 'e', 'p', 'o', 'i', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'A', 'u', 't', 'o', 'C', 'o', 'm', 'm', 'i', 't', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'T', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'S', 'o', 'r', 't', 'e', 'r', 'N', 'e', 'x', 't', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'P', 'r', 'e', 'v', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'N', 'e', 'x', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'C', 'h', 'e', 'c', 'k', 'p', 'o', 'i', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'J', 'o', 'u', 'r', 'n', 'a', 'l', 'M', 'o', 'd', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'V', 'a', 'c', 'u', 'u', 'm', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'V', 'F', 'i', 'l', 't', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'V', 'U', 'p', 'd', 'a', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'G', 'o', 't', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'G', 'o', 's', 'u', 'b', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'I', 'n', 'i', 't', 'C', 'o', 'r', 'o', 'u', 't', 'i', 'n', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'Y', 'i', 'e', 'l', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'M', 'u', 's', 't', 'B', 'e', 'I', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'J', 'u', 'm', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'O', 'n', 'c', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'I', 'f', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'N', 'o', 't', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'f', 'N', 'o', 't', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'I', 's', 'N', 'u', 'l', 'l', 'O', 'r', 'T', 'y', 'p', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'I', 'f', 'N', 'u', 'l', 'l', 'R', 'o', 'w', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'S', 'e', 'e', 'k', 'L', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'S', 'e', 'e', 'k', 'L', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'S', 'e', 'e', 'k', 'G', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'S', 'e', 'e', 'k', 'G', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'I', 'f', 'N', 'o', 't', 'O', 'p', 'e', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'I', 'f', 'N', 'o', 'H', 'o', 'p', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'N', 'o', 'C', 'o', 'n', 'f', 'l', 'i', 'c', 't', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'N', 'o', 't', 'F', 'o', 'u', 'n', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'F', 'o', 'u', 'n', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'S', 'e', 'e', 'k', 'R', 'o', 'w', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'N', 'o', 't', 'E', 'x', 'i', 's', 't', 's', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'L', 'a', 's', 't', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'I', 'f', 'S', 'm', 'a', 'l', 'l', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'S', 'o', 'r', 't', 'e', 'r', 'S', 'o', 'r', 't', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'S', 'o', 'r', 't', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'R', 'e', 'w', 'i', 'n', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'd', 'x', 'L', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'd', 'x', 'G', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'd', 'x', 'L', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'd', 'x', 'G', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'O', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'A', 'n', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'R', 'o', 'w', 'S', 'e', 't', 'R', 'e', 'a', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'R', 'o', 'w', 'S', 'e', 't', 'T', 'e', 's', 't', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'P', 'r', 'o', 'g', 'r', 'a', 'm', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'F', 'k', 'I', 'f', 'Z', 'e', 'r', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'f', 'P', 'o', 's', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'I', 's', 'N', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'N', 'o', 't', 'N', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'N', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'E', 'q', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'G', 't', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'L', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'L', 't', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'G', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'E', 'l', 's', 'e', 'E', 'q', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'I', 'f', 'N', 'o', 't', 'Z', 'e', 'r', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'D', 'e', 'c', 'r', 'J', 'u', 'm', 'p', 'Z', 'e', 'r', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'I', 'n', 'c', 'r', 'V', 'a', 'c', 'u', 'u', 'm', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'V', 'N', 'e', 'x', 't', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'F', 'i', 'l', 't', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'I', 'n', 'i', 't', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'P', 'u', 'r', 'e', 'F', 'u', 'n', 'c', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'F', 'u', 'n', 'c', 't', 'i', 'o', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'R', 'e', 't', 'u', 'r', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'E', 'n', 'd', 'C', 'o', 'r', 'o', 'u', 't', 'i', 'n', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'H', 'a', 'l', 't', 'I', 'f', 'N', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'H', 'a', 'l', 't', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'I', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'I', 'n', 't', '6', '4', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'S', 't', 'r', 'i', 'n', 'g', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'N', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'S', 'o', 'f', 't', 'N', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'B', 'l', 'o', 'b', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'V', 'a', 'r', 'i', 'a', 'b', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'M', 'o', 'v', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'C', 'o', 'p', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'S', 'C', 'o', 'p', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'I', 'n', 't', 'C', 'o', 'p', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'F', 'k', 'C', 'h', 'e', 'c', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'R', 'e', 's', 'u', 'l', 't', 'R', 'o', 'w', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'C', 'o', 'l', 'l', 'S', 'e', 'q', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'A', 'd', 'd', 'I', 'm', 'm', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'R', 'e', 'a', 'l', 'A', 'f', 'f', 'i', 'n', 'i', 't', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'C', 'a', 's', 't', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'P', 'e', 'r', 'm', 'u', 't', 'a', 't', 'i', 'o', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'C', 'o', 'm', 'p', 'a', 'r', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'I', 's', 'T', 'r', 'u', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'Z', 'e', 'r', 'o', 'O', 'r', 'N', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'O', 'f', 'f', 's', 'e', 't', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'C', 'o', 'l', 'u', 'm', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'T', 'y', 'p', 'e', 'C', 'h', 'e', 'c', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'A', 'f', 'f', 'i', 'n', 'i', 't', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'M', 'a', 'k', 'e', 'R', 'e', 'c', 'o', 'r', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'C', 'o', 'u', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'R', 'e', 'a', 'd', 'C', 'o', 'o', 'k', 'i', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'S', 'e', 't', 'C', 'o', 'o', 'k', 'i', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'R', 'e', 'o', 'p', 'e', 'n', 'I', 'd', 'x', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'O', 'p', 'e', 'n', 'R', 'e', 'a', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'B', 'i', 't', 'A', 'n', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'B', 'i', 't', 'O', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'S', 'h', 'i', 'f', 't', 'L', 'e', 'f', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'S', 'h', 'i', 'f', 't', 'R', 'i', 'g', 'h', 't', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'A', 'd', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'S', 'u', 'b', 't', 'r', 'a', 'c', 't', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'D', 'i', 'v', 'i', 'd', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'R', 'e', 'm', 'a', 'i', 'n', 'd', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'C', 'o', 'n', 'c', 'a', 't', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'O', 'p', 'e', 'n', 'W', 'r', 'i', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'O', 'p', 'e', 'n', 'D', 'u', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'B', 'i', 't', 'N', 'o', 't', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'O', 'p', 'e', 'n', 'A', 'u', 't', 'o', 'i', 'n', 'd', 'e', 'x', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'O', 'p', 'e', 'n', 'E', 'p', 'h', 'e', 'm', 'e', 'r', 'a', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'S', 't', 'r', 'i', 'n', 'g', '8', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'S', 'o', 'r', 't', 'e', 'r', 'O', 'p', 'e', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 'T', 'e', 's', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'O', 'p', 'e', 'n', 'P', 's', 'e', 'u', 'd', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'C', 'l', 'o', 's', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'C', 'o', 'l', 'u', 'm', 'n', 's', 'U', 's', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'S', 'e', 'e', 'k', 'S', 'c', 'a', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'S', 'e', 'e', 'k', 'H', 'i', 't', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'S', 'e', 'q', 'u', 'e', 'n', 'c', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'N', 'e', 'w', 'R', 'o', 'w', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'I', 'n', 's', 'e', 'r', 't', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'R', 'o', 'w', 'C', 'e', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'D', 'e', 'l', 'e', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'R', 'e', 's', 'e', 't', 'C', 'o', 'u', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'S', 'o', 'r', 't', 'e', 'r', 'C', 'o', 'm', 'p', 'a', 'r', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'S', 'o', 'r', 't', 'e', 'r', 'D', 'a', 't', 'a', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'R', 'o', 'w', 'D', 'a', 't', 'a', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'R', 'o', 'w', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'N', 'u', 'l', 'l', 'R', 'o', 'w', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'S', 'e', 'e', 'k', 'E', 'n', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'I', 'd', 'x', 'I', 'n', 's', 'e', 'r', 't', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'S', 'o', 'r', 't', 'e', 'r', 'I', 'n', 's', 'e', 'r', 't', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'I', 'd', 'x', 'D', 'e', 'l', 'e', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'D', 'e', 'f', 'e', 'r', 'r', 'e', 'd', 'S', 'e', 'e', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'I', 'd', 'x', 'R', 'o', 'w', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'F', 'i', 'n', 'i', 's', 'h', 'S', 'e', 'e', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'D', 'e', 's', 't', 'r', 'o', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'C', 'l', 'e', 'a', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'R', 'e', 's', 'e', 't', 'S', 'o', 'r', 't', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'C', 'r', 'e', 'a', 't', 'e', 'B', 't', 'r', 'e', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'S', 'q', 'l', 'E', 'x', 'e', 'c', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'P', 'a', 'r', 's', 'e', 'S', 'c', 'h', 'e', 'm', 'a', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'L', 'o', 'a', 'd', 'A', 'n', 'a', 'l', 'y', 's', 'i', 's', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'D', 'r', 'o', 'p', 'T', 'a', 'b', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'D', 'r', 'o', 'p', 'I', 'n', 'd', 'e', 'x', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'D', 'r', 'o', 'p', 'T', 'r', 'i', 'g', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'R', 'e', 'a', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'I', 'n', 't', 'e', 'g', 'r', 'i', 't', 'y', 'C', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'R', 'o', 'w', 'S', 'e', 't', 'A', 'd', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'P', 'a', 'r', 'a', 'm', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'F', 'k', 'C', 'o', 'u', 'n', 't', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'M', 'e', 'm', 'M', 'a', 'x', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'O', 'f', 'f', 's', 'e', 't', 'L', 'i', 'm', 'i', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'A', 'g', 'g', 'I', 'n', 'v', 'e', 'r', 's', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'A', 'g', 'g', 'S', 't', 'e', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'A', 'g', 'g', 'S', 't', 'e', 'p', '1', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'A', 'g', 'g', 'V', 'a', 'l', 'u', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'A', 'g', 'g', 'F', 'i', 'n', 'a', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'E', 'x', 'p', 'i', 'r', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'C', 'u', 'r', 's', 'o', 'r', 'L', 'o', 'c', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'C', 'u', 'r', 's', 'o', 'r', 'U', 'n', 'l', 'o', 'c', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'T', 'a', 'b', 'l', 'e', 'L', 'o', 'c', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'V', 'B', 'e', 'g', 'i', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'V', 'C', 'r', 'e', 'a', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'V', 'D', 'e', 's', 't', 'r', 'o', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'V', 'O', 'p', 'e', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'V', 'I', 'n', 'i', 't', 'I', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'V', 'C', 'o', 'l', 'u', 'm', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'V', 'R', 'e', 'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'P', 'a', 'g', 'e', 'c', 'o', 'u', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'M', 'a', 'x', 'P', 'g', 'c', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'F', 'i', 'l', 't', 'e', 'r', 'A', 'd', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'T', 'r', 'a', 'c', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'C', 'u', 'r', 's', 'o', 'r', 'H', 'i', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'R', 'e', 'l', 'e', 'a', 's', 'e', 'R', 'e', 'g', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'N', 'o', 'o', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'E', 'x', 'p', 'l', 'a', 'i', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'A', 'b', 'o', 'r', 't', 'a', 'b', 'l', 'e', '\x00'}))}
	return *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azName)))) + uintptr(i)*8))
}

type struct_ostat struct {
	st_dev       uint16
	st_ino       uint64
	st_mode      uint16
	st_nlink     uint16
	st_uid       uint16
	st_gid       uint16
	st_rdev      uint16
	st_size      int32
	st_atimespec struct_timespec
	st_mtimespec struct_timespec
	st_ctimespec struct_timespec
	st_blksize   int32
	st_blocks    int32
	st_flags     uint32
	st_gen       uint32
}
type struct_stat struct {
	st_dev           int32
	st_mode          uint16
	st_nlink         uint16
	st_ino           uint64
	st_uid           uint32
	st_gid           uint32
	st_rdev          int32
	st_atimespec     struct_timespec
	st_mtimespec     struct_timespec
	st_ctimespec     struct_timespec
	st_birthtimespec struct_timespec
	st_size          int64
	st_blocks        int64
	st_blksize       int32
	st_flags         uint32
	st_gen           uint32
	st_lspare        int32
	st_qspare        [2]int64
}
type struct_stat64 struct {
	st_dev           int32
	st_mode          uint16
	st_nlink         uint16
	st_ino           uint64
	st_uid           uint32
	st_gid           uint32
	st_rdev          int32
	st_atimespec     struct_timespec
	st_mtimespec     struct_timespec
	st_ctimespec     struct_timespec
	st_birthtimespec struct_timespec
	st_size          int64
	st_blocks        int64
	st_blksize       int32
	st_flags         uint32
	st_gen           uint32
	st_lspare        int32
	st_qspare        [2]int64
}
type filesec_t = *struct__filesec
type struct_flock struct {
	l_start  int64
	l_len    int64
	l_pid    int32
	l_type   int16
	l_whence int16
}
type struct_flocktimeout struct {
	fl      struct_flock
	timeout struct_timespec
}
type struct_radvisory struct {
	ra_offset int64
	ra_count  int32
}
type struct_fsignatures struct {
	fs_file_start       int64
	fs_blob_start       unsafe.Pointer
	fs_blob_size        uint
	fs_fsignatures_size uint
	fs_cdhash           [20]int8
	fs_hash_type        int32
}
type fsignatures_t = struct_fsignatures
type struct_fsupplement struct {
	fs_file_start int64
	fs_blob_start int64
	fs_blob_size  uint
	fs_orig_fd    int32
}
type fsupplement_t = struct_fsupplement
type struct_fchecklv struct {
	lv_file_start         int64
	lv_error_message_size uint
	lv_error_message      unsafe.Pointer
}
type fchecklv_t = struct_fchecklv
type struct_fgetsigsinfo struct {
	fg_file_start      int64
	fg_info_request    int32
	fg_sig_is_platform int32
}
type fgetsigsinfo_t = struct_fgetsigsinfo
type struct_fstore struct {
	fst_flags      uint32
	fst_posmode    int32
	fst_offset     int64
	fst_length     int64
	fst_bytesalloc int64
}
type fstore_t = struct_fstore
type struct_fpunchhole struct {
	fp_flags  uint32
	reserved  uint32
	fp_offset int64
	fp_length int64
}
type fpunchhole_t = struct_fpunchhole
type struct_ftrimactivefile struct {
	fta_offset int64
	fta_length int64
}
type ftrimactivefile_t = struct_ftrimactivefile
type struct_fspecread struct {
	fsr_flags  uint32
	reserved   uint32
	fsr_offset int64
	fsr_length int64
}
type fspecread_t = struct_fspecread
type struct_fbootstraptransfer struct {
	fbt_offset int64
	fbt_length uint
	fbt_buffer unsafe.Pointer
}
type fbootstraptransfer_t = struct_fbootstraptransfer
type struct_log2phys struct {
	l2p_flags       uint32
	l2p_contigbytes int64
	l2p_devoffset   int64
}

const (
	FILESEC_OWNER         int32 = 1
	FILESEC_GROUP         int32 = 2
	FILESEC_UUID          int32 = 3
	FILESEC_MODE          int32 = 4
	FILESEC_ACL           int32 = 5
	FILESEC_GRPUUID       int32 = 6
	FILESEC_ACL_RAW       int32 = 100
	FILESEC_ACL_ALLOCSIZE int32 = 101
)

type filesec_property_t = int32
type struct_winsize struct {
	ws_row    uint16
	ws_col    uint16
	ws_xpixel uint16
	ws_ypixel uint16
}
type struct_ttysize struct {
	ts_lines uint16
	ts_cols  uint16
	ts_xxx   uint16
	ts_yyy   uint16
}
type struct_accessx_descriptor struct {
	ad_name_offset uint32
	ad_flags       int32
	ad_pad         [2]int32
}
type text_encoding_t = uint32
type fsobj_type_t = uint32
type fsobj_tag_t = uint32
type fsfile_type_t = uint32
type fsvolid_t = uint32
type attrgroup_t = uint32
type struct_attrlist struct {
	bitmapcount uint16
	reserved    uint16
	commonattr  uint32
	volattr     uint32
	dirattr     uint32
	fileattr    uint32
	forkattr    uint32
}
type struct_attribute_set struct {
	commonattr uint32
	volattr    uint32
	dirattr    uint32
	fileattr   uint32
	forkattr   uint32
}
type attribute_set_t = struct_attribute_set
type struct_attrreference struct {
	attr_dataoffset int32
	attr_length     uint32
}
type attrreference_t = struct_attrreference
type struct_diskextent struct {
	startblock uint32
	blockcount uint32
}
type extentrecord = [8]struct_diskextent
type vol_capabilities_set_t = [4]uint32
type struct_vol_capabilities_attr struct {
	capabilities [4]uint32
	valid        [4]uint32
}
type vol_capabilities_attr_t = struct_vol_capabilities_attr
type struct_vol_attributes_attr struct {
	validattr  struct_attribute_set
	nativeattr struct_attribute_set
}
type vol_attributes_attr_t = struct_vol_attributes_attr
type struct_fssearchblock struct {
	returnattrs         *struct_attrlist
	returnbuffer        unsafe.Pointer
	returnbuffersize    uint
	maxmatches          uint
	timelimit           struct_timeval
	searchparams1       unsafe.Pointer
	sizeofsearchparams1 uint
	searchparams2       unsafe.Pointer
	sizeofsearchparams2 uint
	searchattrs         struct_attrlist
}
type struct_searchstate struct {
	ss_union_flags uint32
	ss_union_layer uint32
	ss_fsstate     [548]uint8
}
type os_function_t = func(unsafe.Pointer)
type os_block_t = func()
type struct_statfs64 struct {
	f_bsize       uint32
	f_iosize      int32
	f_blocks      uint64
	f_bfree       uint64
	f_bavail      uint64
	f_files       uint64
	f_ffree       uint64
	f_fsid        struct_fsid
	f_owner       uint32
	f_type        uint32
	f_flags       uint32
	f_fssubtype   uint32
	f_fstypename  [16]int8
	f_mntonname   [1024]int8
	f_mntfromname [1024]int8
	f_flags_ext   uint32
	f_reserved    [7]uint32
}
type struct_statfs struct {
	f_bsize       uint32
	f_iosize      int32
	f_blocks      uint64
	f_bfree       uint64
	f_bavail      uint64
	f_files       uint64
	f_ffree       uint64
	f_fsid        struct_fsid
	f_owner       uint32
	f_type        uint32
	f_flags       uint32
	f_fssubtype   uint32
	f_fstypename  [16]int8
	f_mntonname   [1024]int8
	f_mntfromname [1024]int8
	f_flags_ext   uint32
	f_reserved    [7]uint32
}
type struct_vfsstatfs struct {
	f_bsize       uint32
	f_iosize      uint
	f_blocks      uint64
	f_bfree       uint64
	f_bavail      uint64
	f_bused       uint64
	f_files       uint64
	f_ffree       uint64
	f_fsid        struct_fsid
	f_owner       uint32
	f_flags       uint64
	f_fstypename  [16]int8
	f_mntonname   [1024]int8
	f_mntfromname [1024]int8
	f_fssubtype   uint32
	f_reserved    [2]unsafe.Pointer
}
type mount_t = *struct_mount
type vnode_t = *struct_vnode
type struct_vfsconf struct {
	vfc_reserved1 uint32
	vfc_name      [15]int8
	vfc_typenum   int32
	vfc_refcount  int32
	vfc_flags     int32
	vfc_reserved2 uint32
	vfc_reserved3 uint32
}
type struct_vfsidctl struct {
	vc_vers  int32
	vc_fsid  struct_fsid
	vc_ptr   unsafe.Pointer
	vc_len   uint
	vc_spare [12]uint32
}
type struct_vfsquery struct {
	vq_flags uint32
	vq_spare [31]uint32
}
type struct_vfs_server struct {
	vs_minutes     int32
	vs_server_name [768]uint8
}
type struct_netfs_status struct {
	ns_status      uint32
	ns_mountopts   [512]int8
	ns_waittime    uint32
	ns_threadcount uint32
	ns_threadids   [0]uint64
}
type struct_fhandle struct {
	fh_len  uint32
	fh_data [128]uint8
}
type fhandle_t = struct_fhandle
type unixShm = struct_unixShm
type unixShmNode = struct_unixShmNode
type unixInodeInfo = struct_unixInodeInfo
type UnixUnusedFd = struct_UnixUnusedFd
type struct_UnixUnusedFd struct {
	fd    int32
	flags int32
	pNext *struct_UnixUnusedFd
}
type unixFile = struct_unixFile
type struct_unixFile struct {
	pMethod               *struct_sqlite3_io_methods
	pVfs                  *struct_sqlite3_vfs
	pInode                *struct_unixInodeInfo
	h                     int32
	eFileLock             uint8
	ctrlFlags             uint16
	lastErrno             int32
	lockingContext        unsafe.Pointer
	pPreallocatedUnused   *struct_UnixUnusedFd
	zPath                 *int8
	pShm                  *struct_unixShm
	szChunk               int32
	nFetchOut             int32
	mmapSize              int64
	mmapSizeActual        int64
	mmapSizeMax           int64
	pMapRegion            unsafe.Pointer
	sectorSize            int32
	deviceCharacteristics int32
	openFlags             int32
	fsFlags               uint32
}

var randomnessPid int32 = 0

func posixOpen(zFile *int8, flags int32, mode int32) int32 {
	return open(zFile, flags, mode)
}

type struct_unix_syscall struct {
	zName    *int8
	pCurrent func()
	pDefault func()
}

var aSyscall [29]struct_unix_syscall = [29]struct_unix_syscall{struct_unix_syscall{(*int8)(unsafe.Pointer(&[5]int8{'o', 'p', 'e', 'n', '\x00'})), (func())(posixOpen), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'c', 'l', 'o', 's', 'e', '\x00'})), (func())(close), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'a', 'c', 'c', 'e', 's', 's', '\x00'})), (func())(access), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'g', 'e', 't', 'c', 'w', 'd', '\x00'})), (func())(getcwd), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[5]int8{'s', 't', 'a', 't', '\x00'})), (func())(stat), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'f', 's', 't', 'a', 't', '\x00'})), (func())(fstat), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[10]int8{'f', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', '\x00'})), (func())(ftruncate), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'f', 'c', 'n', 't', 'l', '\x00'})), (func())(fcntl), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[5]int8{'r', 'e', 'a', 'd', '\x00'})), (func())(read), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'p', 'r', 'e', 'a', 'd', '\x00'})), (func())(pread), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[8]int8{'p', 'r', 'e', 'a', 'd', '6', '4', '\x00'})), (func())(0), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'w', 'r', 'i', 't', 'e', '\x00'})), (func())(write), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'p', 'w', 'r', 'i', 't', 'e', '\x00'})), (func())(pwrite), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[9]int8{'p', 'w', 'r', 'i', 't', 'e', '6', '4', '\x00'})), (func())(0), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'f', 'c', 'h', 'm', 'o', 'd', '\x00'})), (func())(fchmod), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[10]int8{'f', 'a', 'l', 'l', 'o', 'c', 'a', 't', 'e', '\x00'})), (func())(0), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'u', 'n', 'l', 'i', 'n', 'k', '\x00'})), (func())(unlink), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[14]int8{'o', 'p', 'e', 'n', 'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '\x00'})), (func())(openDirectory), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'m', 'k', 'd', 'i', 'r', '\x00'})), (func())(mkdir), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'r', 'm', 'd', 'i', 'r', '\x00'})), (func())(rmdir), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'f', 'c', 'h', 'o', 'w', 'n', '\x00'})), (func())(fchown), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[8]int8{'g', 'e', 't', 'e', 'u', 'i', 'd', '\x00'})), (func())(geteuid), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[5]int8{'m', 'm', 'a', 'p', '\x00'})), (func())(mmap), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'m', 'u', 'n', 'm', 'a', 'p', '\x00'})), (func())(munmap), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[7]int8{'m', 'r', 'e', 'm', 'a', 'p', '\x00'})), (func())(0), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[12]int8{'g', 'e', 't', 'p', 'a', 'g', 'e', 's', 'i', 'z', 'e', '\x00'})), (func())(unixGetpagesize), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[9]int8{'r', 'e', 'a', 'd', 'l', 'i', 'n', 'k', '\x00'})), (func())(readlink), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'l', 's', 't', 'a', 't', '\x00'})), (func())(lstat), nil}, struct_unix_syscall{(*int8)(unsafe.Pointer(&[6]int8{'i', 'o', 'c', 't', 'l', '\x00'})), (func())(0), nil}}

func robustFchown(fd int32, uid uint32, gid uint32) int32 {
	return func() int32 {
		if (func() uint32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(21)*24))).pCurrent)() != 0 {
			return 0
		} else {
			return (func(int32, uint32, uint32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(20)*24))).pCurrent)(fd, uid, gid)
		}
	}()
}
func unixSetSystemCall(pNotUsed *struct_sqlite3_vfs, zName *int8, pNewFunc func()) int32 {
	var i uint32
	var rc int32 = 12
	func() int {
		_ = pNotUsed
		return 0
	}()
	if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(0)
		for i = uint32(0); uint(i) < 696/24; i++ {
			if (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pDefault != nil {
				(*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pCurrent = (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pDefault
			}
		}
	} else {
		for i = uint32(0); uint(i) < 696/24; i++ {
			if strcmp(zName, (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).zName) == 0 {
				if uintptr(unsafe.Pointer((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pDefault)) == uintptr(unsafe.Pointer(nil)) {
					(*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pDefault = (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pCurrent
				}
				rc = int32(0)
				if uintptr(unsafe.Pointer(pNewFunc)) == uintptr(unsafe.Pointer(nil)) {
					pNewFunc = (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pDefault
				}
				(*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pCurrent = pNewFunc
				break
			}
		}
	}
	return rc
}
func unixGetSystemCall(pNotUsed *struct_sqlite3_vfs, zName *int8) func() {
	var i uint32
	func() int {
		_ = pNotUsed
		return 0
	}()
	for i = uint32(0); uint(i) < 696/24; i++ {
		if strcmp(zName, (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).zName) == 0 {
			return (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pCurrent
		}
	}
	return (func())(nil)
}
func unixNextSystemCall(p *struct_sqlite3_vfs, zName *int8) *int8 {
	var i int32 = -1
	func() int {
		_ = p
		return 0
	}()
	if zName != nil {
		for i = int32(0); i < int32(696/24)-1; i++ {
			if strcmp(zName, (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).zName) == 0 {
				break
			}
		}
	}
	for i++; i < int32(696/24); i++ {
		if uintptr(unsafe.Pointer((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).pCurrent)) != uintptr(unsafe.Pointer(nil)) {
			return (*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(i)*24))).zName
		}
	}
	return (*int8)(nil)
}
func robust_open(z *int8, f int32, m uint16) int32 {
	var fd int32
	var m2 uint16 = uint16(func() int32 {
		if int32(m) != 0 {
			return int32(m)
		} else {
			return 420
		}
	}())
	for 1 != 0 {
		fd = (func(*int8, int32, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(0)*24))).pCurrent)(z, f|16777216, int32(m2))
		if fd < 0 {
			if *__error() == 4 {
				continue
			}
			break
		}
		if fd >= 3 {
			break
		}
		(func(int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(1)*24))).pCurrent)(fd)
		sqlite3_log(28, (*int8)(unsafe.Pointer(&[43]int8{'a', 't', 't', 'e', 'm', 'p', 't', ' ', 't', 'o', ' ', 'o', 'p', 'e', 'n', ' ', '"', '%', 's', '"', ' ', 'a', 's', ' ', 'f', 'i', 'l', 'e', ' ', 'd', 'e', 's', 'c', 'r', 'i', 'p', 't', 'o', 'r', ' ', '%', 'd', '\x00'})), z, fd)
		fd = int32(-1)
		if (func(*int8, int32, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(0)*24))).pCurrent)((*int8)(unsafe.Pointer(&[10]int8{'/', 'd', 'e', 'v', '/', 'n', 'u', 'l', 'l', '\x00'})), 0, int32(m)) < 0 {
			break
		}
	}
	if fd >= 0 {
		if int32(m) != 0 {
			var statbuf struct_stat
			if (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(fd, &statbuf) == 0 && statbuf.st_size == int64(0) && int32(statbuf.st_mode)&511 != int32(m) {
				(func(int32, uint16) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(14)*24))).pCurrent)(fd, m)
			}
		}
	}
	return fd
}

var unixBigLock *struct_sqlite3_mutex = nil

func unixEnterMutex() {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(unixBigLock)
}
func unixLeaveMutex() {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_leave(unixBigLock)
}
func robust_ftruncate(h int32, sz int64) int32 {
	var rc int32
	for {
		rc = (func(int32, int64) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(6)*24))).pCurrent)(h, sz)
		if !(rc < 0 && *__error() == 4) {
			break
		}
	}
	return rc
}
func sqliteErrorFromPosixError(posixError int32, sqliteIOErr int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	switch posixError {
	case 13:
		fallthrough
	case 35:
		fallthrough
	case 60:
		fallthrough
	case 16:
		fallthrough
	case 4:
		fallthrough
	case 77:
		return int32(5)
	case 1:
		return int32(3)
	default:
		return sqliteIOErr
	}
}

type struct_vxworksFileId struct {
	pNext          *struct_vxworksFileId
	nRef           int32
	nName          int32
	zCanonicalName *int8
}
type struct_unixFileId struct {
	dev int32
	ino uint64
}
type struct_unixInodeInfo struct {
	fileId       struct_unixFileId
	pLockMutex   *struct_sqlite3_mutex
	nShared      int32
	nLock        int32
	eFileLock    uint8
	bProcessLock uint8
	pUnused      *struct_UnixUnusedFd
	nRef         int32
	pShmNode     *struct_unixShmNode
	pNext        *struct_unixInodeInfo
	pPrev        *struct_unixInodeInfo
	sharedByte   uint64
}

var inodeList *struct_unixInodeInfo = nil

func unixLogErrorAtLine(errcode int32, zFunc *int8, zPath *int8, iLine int32) int32 {
	var zErr *int8
	var iErrno int32 = *__error()
	zErr = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	if uintptr(unsafe.Pointer(zPath)) == uintptr(unsafe.Pointer(nil)) {
		zPath = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	}
	sqlite3_log(errcode, (*int8)(unsafe.Pointer(&[31]int8{'o', 's', '_', 'u', 'n', 'i', 'x', '.', 'c', ':', '%', 'd', ':', ' ', '(', '%', 'd', ')', ' ', '%', 's', '(', '%', 's', ')', ' ', '-', ' ', '%', 's', '\x00'})), iLine, iErrno, zFunc, zPath, zErr)
	return errcode
}
func robust_close(pFile *struct_unixFile, h int32, lineno int32) {
	if (func(int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(1)*24))).pCurrent)(h) != 0 {
		unixLogErrorAtLine(10|16<<8, (*int8)(unsafe.Pointer(&[6]int8{'c', 'l', 'o', 's', 'e', '\x00'})), func() *int8 {
			if pFile != nil {
				return pFile.zPath
			} else {
				return nil
			}
		}(), lineno)
	}
}
func storeLastErrno(pFile *struct_unixFile, error int32) {
	pFile.lastErrno = error
}
func closePendingFds(pFile *struct_unixFile) {
	var pInode *struct_unixInodeInfo = pFile.pInode
	var p *struct_UnixUnusedFd
	var pNext *struct_UnixUnusedFd
	func() int {
		_ = 0
		return 0
	}()
	for p = pInode.pUnused; p != nil; p = pNext {
		pNext = p.pNext
		robust_close(pFile, p.fd, 36093)
		sqlite3_free(unsafe.Pointer(p))
	}
	pInode.pUnused = (*struct_UnixUnusedFd)(nil)
}
func releaseInodeInfo(pFile *struct_unixFile) {
	var pInode *struct_unixInodeInfo = pFile.pInode
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pInode != nil {
		pInode.nRef--
		if pInode.nRef == 0 {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_mutex_enter(pInode.pLockMutex)
			closePendingFds(pFile)
			sqlite3_mutex_leave(pInode.pLockMutex)
			if pInode.pPrev != nil {
				func() int {
					_ = 0
					return 0
				}()
				pInode.pPrev.pNext = pInode.pNext
			} else {
				func() int {
					_ = 0
					return 0
				}()
				inodeList = pInode.pNext
			}
			if pInode.pNext != nil {
				func() int {
					_ = 0
					return 0
				}()
				pInode.pNext.pPrev = pInode.pPrev
			}
			sqlite3_mutex_free(pInode.pLockMutex)
			sqlite3_free(unsafe.Pointer(pInode))
		}
	}
}
func findInodeInfo(pFile *struct_unixFile, ppInode **struct_unixInodeInfo) int32 {
	var rc int32
	var fd int32
	var fileId struct_unixFileId
	var statbuf struct_stat
	var pInode *struct_unixInodeInfo = nil
	func() int {
		_ = 0
		return 0
	}()
	fd = pFile.h
	rc = (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(fd, &statbuf)
	if rc != 0 {
		storeLastErrno(pFile, *__error())
		return int32(10)
	}
	if statbuf.st_size == int64(0) && pFile.fsFlags&uint32(1) != uint32(0) {
		for {
			rc = int32((func(int32, unsafe.Pointer, uint) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(11)*24))).pCurrent)(fd, unsafe.Pointer((*int8)(unsafe.Pointer(&[2]int8{'S', '\x00'}))), uint(1)))
			if !(rc < 0 && *__error() == 4) {
				break
			}
		}
		if rc != 1 {
			storeLastErrno(pFile, *__error())
			return int32(10)
		}
		rc = (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(fd, &statbuf)
		if rc != 0 {
			storeLastErrno(pFile, *__error())
			return int32(10)
		}
	}
	__builtin___memset_chk(unsafe.Pointer(&fileId), 0, 16, __builtin_object_size(unsafe.Pointer(&fileId), 0))
	fileId.dev = statbuf.st_dev
	fileId.ino = uint64(statbuf.st_ino)
	func() int {
		_ = 0
		return 0
	}()
	pInode = inodeList
	for pInode != nil && memcmp(unsafe.Pointer(&fileId), unsafe.Pointer(&pInode.fileId), 16) != 0 {
		pInode = pInode.pNext
	}
	if uintptr(unsafe.Pointer(pInode)) == uintptr(unsafe.Pointer(nil)) {
		pInode = (*struct_unixInodeInfo)(sqlite3_malloc64(uint64(88)))
		if uintptr(unsafe.Pointer(pInode)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(pInode), 0, 88, __builtin_object_size(unsafe.Pointer(pInode), 0))
		__builtin___memcpy_chk(unsafe.Pointer(&pInode.fileId), unsafe.Pointer(&fileId), 16, __builtin_object_size(unsafe.Pointer(&pInode.fileId), 0))
		if sqlite3Config.bCoreMutex != 0 {
			pInode.pLockMutex = sqlite3_mutex_alloc(0)
			if uintptr(unsafe.Pointer(pInode.pLockMutex)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3_free(unsafe.Pointer(pInode))
				return int32(7)
			}
		}
		pInode.nRef = int32(1)
		func() int {
			_ = 0
			return 0
		}()
		pInode.pNext = inodeList
		pInode.pPrev = (*struct_unixInodeInfo)(nil)
		if inodeList != nil {
			inodeList.pPrev = pInode
		}
		inodeList = pInode
	} else {
		pInode.nRef++
	}
	*ppInode = pInode
	return int32(0)
}
func fileHasMoved(pFile *struct_unixFile) int32 {
	var buf struct_stat
	return func() int32 {
		if uintptr(unsafe.Pointer(pFile.pInode)) != uintptr(unsafe.Pointer(nil)) && ((func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(4)*24))).pCurrent)(pFile.zPath, &buf) != 0 || uint64(buf.st_ino) != pFile.pInode.fileId.ino) {
			return 1
		} else {
			return 0
		}
	}()
}
func verifyDbFile(pFile *struct_unixFile) {
	var buf struct_stat
	var rc int32
	if int32(pFile.ctrlFlags)&128 != 0 {
		return
	}
	rc = (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(pFile.h, &buf)
	if rc != 0 {
		sqlite3_log(28, (*int8)(unsafe.Pointer(&[24]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'f', 's', 't', 'a', 't', ' ', 'd', 'b', ' ', 'f', 'i', 'l', 'e', ' ', '%', 's', '\x00'})), pFile.zPath)
		return
	}
	if int32(buf.st_nlink) == 0 {
		sqlite3_log(28, (*int8)(unsafe.Pointer(&[29]int8{'f', 'i', 'l', 'e', ' ', 'u', 'n', 'l', 'i', 'n', 'k', 'e', 'd', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'o', 'p', 'e', 'n', ':', ' ', '%', 's', '\x00'})), pFile.zPath)
		return
	}
	if int32(buf.st_nlink) > 1 {
		sqlite3_log(28, (*int8)(unsafe.Pointer(&[27]int8{'m', 'u', 'l', 't', 'i', 'p', 'l', 'e', ' ', 'l', 'i', 'n', 'k', 's', ' ', 't', 'o', ' ', 'f', 'i', 'l', 'e', ':', ' ', '%', 's', '\x00'})), pFile.zPath)
		return
	}
	if fileHasMoved(pFile) != 0 {
		sqlite3_log(28, (*int8)(unsafe.Pointer(&[28]int8{'f', 'i', 'l', 'e', ' ', 'r', 'e', 'n', 'a', 'm', 'e', 'd', ' ', 'w', 'h', 'i', 'l', 'e', ' ', 'o', 'p', 'e', 'n', ':', ' ', '%', 's', '\x00'})), pFile.zPath)
		return
	}
}
func unixCheckReservedLock(id *struct_sqlite3_file, pResOut *int32) int32 {
	var rc int32 = 0
	var reserved int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(pFile.pInode.pLockMutex)
	if int32(pFile.pInode.eFileLock) > 1 {
		reserved = int32(1)
	}
	if !(reserved != 0) && !(pFile.pInode.bProcessLock != 0) {
		var lock struct_flock
		lock.l_whence = int16(0)
		lock.l_start = int64(sqlite3PendingByte + 1)
		lock.l_len = int64(1)
		lock.l_type = int16(3)
		if (func(int32, int32, ...interface {
		}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pFile.h, 7, &lock) != 0 {
			rc = int32(10 | 14<<8)
			storeLastErrno(pFile, *__error())
		} else if int32(lock.l_type) != 2 {
			reserved = int32(1)
		}
	}
	sqlite3_mutex_leave(pFile.pInode.pLockMutex)
	*pResOut = reserved
	return rc
}
func unixFileLock(pFile *struct_unixFile, pLock *struct_flock) int32 {
	var rc int32
	var pInode *struct_unixInodeInfo = pFile.pInode
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.ctrlFlags)&(1|2) == 1 {
		if int32(pInode.bProcessLock) == 0 {
			var lock struct_flock
			func() int {
				_ = 0
				return 0
			}()
			lock.l_whence = int16(0)
			lock.l_start = int64(sqlite3PendingByte + 2)
			lock.l_len = int64(510)
			lock.l_type = int16(3)
			rc = (func(int32, int32, ...interface {
			}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pFile.h, 8, &lock)
			if rc < 0 {
				return rc
			}
			pInode.bProcessLock = uint8(1)
			pInode.nLock++
		} else {
			rc = int32(0)
		}
	} else {
		rc = (func(int32, int32, ...interface {
		}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pFile.h, 8, pLock)
	}
	return rc
}
func unixLock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var rc int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var pInode *struct_unixInodeInfo
	var lock struct_flock
	var tErrno int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) >= eFileLock {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pInode = pFile.pInode
	sqlite3_mutex_enter(pInode.pLockMutex)
	if int32(pFile.eFileLock) != int32(pInode.eFileLock) && (int32(pInode.eFileLock) >= 3 || eFileLock > 1) {
		rc = int32(5)
		goto end_lock
	}
	if eFileLock == 1 && (int32(pInode.eFileLock) == 1 || int32(pInode.eFileLock) == 2) {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pFile.eFileLock = uint8(1)
		pInode.nShared++
		pInode.nLock++
		goto end_lock
	}
	lock.l_len = int64(1)
	lock.l_whence = int16(0)
	if eFileLock == 1 || eFileLock == 4 && int32(pFile.eFileLock) < 3 {
		lock.l_type = int16(func() int32 {
			if eFileLock == 1 {
				return 1
			} else {
				return 3
			}
		}())
		lock.l_start = int64(sqlite3PendingByte)
		if unixFileLock(pFile, &lock) != 0 {
			tErrno = *__error()
			rc = sqliteErrorFromPosixError(tErrno, 10|15<<8)
			if rc != 5 {
				storeLastErrno(pFile, tErrno)
			}
			goto end_lock
		}
	}
	if eFileLock == 1 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		lock.l_start = int64(sqlite3PendingByte + 2)
		lock.l_len = int64(510)
		if unixFileLock(pFile, &lock) != 0 {
			tErrno = *__error()
			rc = sqliteErrorFromPosixError(tErrno, 10|15<<8)
		}
		lock.l_start = int64(sqlite3PendingByte)
		lock.l_len = int64(1)
		lock.l_type = int16(2)
		if unixFileLock(pFile, &lock) != 0 && rc == 0 {
			tErrno = *__error()
			rc = int32(10 | 8<<8)
		}
		if rc != 0 {
			if rc != 5 {
				storeLastErrno(pFile, tErrno)
			}
			goto end_lock
		} else {
			pFile.eFileLock = uint8(1)
			pInode.nLock++
			pInode.nShared = int32(1)
		}
	} else if eFileLock == 4 && pInode.nShared > 1 {
		rc = int32(5)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		lock.l_type = int16(3)
		func() int {
			_ = 0
			return 0
		}()
		if eFileLock == 2 {
			lock.l_start = int64(sqlite3PendingByte + 1)
			lock.l_len = int64(1)
		} else {
			lock.l_start = int64(sqlite3PendingByte + 2)
			lock.l_len = int64(510)
		}
		if unixFileLock(pFile, &lock) != 0 {
			tErrno = *__error()
			rc = sqliteErrorFromPosixError(tErrno, 10|15<<8)
			if rc != 5 {
				storeLastErrno(pFile, tErrno)
			}
		}
	}
	if rc == 0 {
		pFile.eFileLock = uint8(eFileLock)
		pInode.eFileLock = uint8(eFileLock)
	} else if eFileLock == 4 {
		pFile.eFileLock = uint8(3)
		pInode.eFileLock = uint8(3)
	}
end_lock:
	sqlite3_mutex_leave(pInode.pLockMutex)
	return rc
}
func setPendingFd(pFile *struct_unixFile) {
	var pInode *struct_unixInodeInfo = pFile.pInode
	var p *struct_UnixUnusedFd = pFile.pPreallocatedUnused
	func() int {
		_ = 0
		return 0
	}()
	p.pNext = pInode.pUnused
	pInode.pUnused = p
	pFile.h = int32(-1)
	pFile.pPreallocatedUnused = (*struct_UnixUnusedFd)(nil)
}
func posixUnlock(id *struct_sqlite3_file, eFileLock int32, handleNFSUnlock int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var pInode *struct_unixInodeInfo
	var lock struct_flock
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) <= eFileLock {
		return int32(0)
	}
	pInode = pFile.pInode
	sqlite3_mutex_enter(pInode.pLockMutex)
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) > 1 {
		func() int {
			_ = 0
			return 0
		}()
		if eFileLock == 1 {
			if handleNFSUnlock != 0 {
				var tErrno int32
				var divSize int64 = int64(510 - 1)
				lock.l_type = int16(2)
				lock.l_whence = int16(0)
				lock.l_start = int64(sqlite3PendingByte + 2)
				lock.l_len = divSize
				if unixFileLock(pFile, &lock) == -1 {
					tErrno = *__error()
					rc = int32(10 | 8<<8)
					storeLastErrno(pFile, tErrno)
					goto end_unlock
				}
				lock.l_type = int16(1)
				lock.l_whence = int16(0)
				lock.l_start = int64(sqlite3PendingByte + 2)
				lock.l_len = divSize
				if unixFileLock(pFile, &lock) == -1 {
					tErrno = *__error()
					rc = sqliteErrorFromPosixError(tErrno, 10|9<<8)
					if rc != 0 && rc != 5 {
						storeLastErrno(pFile, tErrno)
					}
					goto end_unlock
				}
				lock.l_type = int16(2)
				lock.l_whence = int16(0)
				lock.l_start = int64(sqlite3PendingByte+2) + divSize
				lock.l_len = int64(510) - divSize
				if unixFileLock(pFile, &lock) == -1 {
					tErrno = *__error()
					rc = int32(10 | 8<<8)
					storeLastErrno(pFile, tErrno)
					goto end_unlock
				}
			} else {
				lock.l_type = int16(1)
				lock.l_whence = int16(0)
				lock.l_start = int64(sqlite3PendingByte + 2)
				lock.l_len = int64(510)
				if unixFileLock(pFile, &lock) != 0 {
					rc = int32(10 | 9<<8)
					storeLastErrno(pFile, *__error())
					goto end_unlock
				}
			}
		}
		lock.l_type = int16(2)
		lock.l_whence = int16(0)
		lock.l_start = int64(sqlite3PendingByte)
		lock.l_len = int64(2)
		func() int {
			_ = 0
			return 0
		}()
		if unixFileLock(pFile, &lock) == 0 {
			pInode.eFileLock = uint8(1)
		} else {
			rc = int32(10 | 8<<8)
			storeLastErrno(pFile, *__error())
			goto end_unlock
		}
	}
	if eFileLock == 0 {
		pInode.nShared--
		if pInode.nShared == 0 {
			lock.l_type = int16(2)
			lock.l_whence = int16(0)
			lock.l_start = func() (_cgo_ret int64) {
				_cgo_addr := &lock.l_len
				*_cgo_addr = int64(0)
				return *_cgo_addr
			}()
			if unixFileLock(pFile, &lock) == 0 {
				pInode.eFileLock = uint8(0)
			} else {
				rc = int32(10 | 8<<8)
				storeLastErrno(pFile, *__error())
				pInode.eFileLock = uint8(0)
				pFile.eFileLock = uint8(0)
			}
		}
		pInode.nLock--
		func() int {
			_ = 0
			return 0
		}()
		if pInode.nLock == 0 {
			closePendingFds(pFile)
		}
	}
end_unlock:
	sqlite3_mutex_leave(pInode.pLockMutex)
	if rc == 0 {
		pFile.eFileLock = uint8(eFileLock)
	}
	return rc
}
func unixUnlock(id *struct_sqlite3_file, eFileLock int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return posixUnlock(id, eFileLock, 0)
}
func closeUnixFile(id *struct_sqlite3_file) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	unixUnmapfile(pFile)
	if pFile.h >= 0 {
		robust_close(pFile, pFile.h, 36877)
		pFile.h = int32(-1)
	}
	sqlite3_free(unsafe.Pointer(pFile.pPreallocatedUnused))
	__builtin___memset_chk(unsafe.Pointer(pFile), 0, 128, __builtin_object_size(unsafe.Pointer(pFile), 0))
	return int32(0)
}
func unixClose(id *struct_sqlite3_file) int32 {
	var rc int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var pInode *struct_unixInodeInfo = pFile.pInode
	func() int {
		_ = 0
		return 0
	}()
	verifyDbFile(pFile)
	unixUnlock(id, 0)
	func() int {
		_ = 0
		return 0
	}()
	unixEnterMutex()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(pInode.pLockMutex)
	if pInode.nLock != 0 {
		setPendingFd(pFile)
	}
	sqlite3_mutex_leave(pInode.pLockMutex)
	releaseInodeInfo(pFile)
	func() int {
		_ = 0
		return 0
	}()
	rc = closeUnixFile(id)
	unixLeaveMutex()
	return rc
}
func nolockCheckReservedLock(NotUsed *struct_sqlite3_file, pResOut *int32) int32 {
	func() int {
		_ = NotUsed
		return 0
	}()
	*pResOut = int32(0)
	return int32(0)
}
func nolockLock(NotUsed *struct_sqlite3_file, NotUsed2 int32) int32 {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	return int32(0)
}
func nolockUnlock(NotUsed *struct_sqlite3_file, NotUsed2 int32) int32 {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	return int32(0)
}
func nolockClose(id *struct_sqlite3_file) int32 {
	return closeUnixFile(id)
}
func dotlockCheckReservedLock(id *struct_sqlite3_file, pResOut *int32) int32 {
	var rc int32 = 0
	var reserved int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	reserved = func() int32 {
		if (func(*int8, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(2)*24))).pCurrent)((*int8)(pFile.lockingContext), 0) == 0 {
			return 1
		} else {
			return 0
		}
	}()
	*pResOut = reserved
	return rc
}
func dotlockLock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var zLockFile *int8 = (*int8)(pFile.lockingContext)
	var rc int32 = 0
	if int32(pFile.eFileLock) > 0 {
		pFile.eFileLock = uint8(eFileLock)
		utimes(zLockFile, nil)
		return int32(0)
	}
	rc = (func(*int8, uint16) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(18)*24))).pCurrent)(zLockFile, uint16(511))
	if rc < 0 {
		var tErrno int32 = *__error()
		if 17 == tErrno {
			rc = int32(5)
		} else {
			rc = sqliteErrorFromPosixError(tErrno, 10|15<<8)
			if rc != 5 {
				storeLastErrno(pFile, tErrno)
			}
		}
		return rc
	}
	pFile.eFileLock = uint8(eFileLock)
	return rc
}
func dotlockUnlock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var zLockFile *int8 = (*int8)(pFile.lockingContext)
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) == eFileLock {
		return int32(0)
	}
	if eFileLock == 1 {
		pFile.eFileLock = uint8(1)
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = (func(*int8) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(19)*24))).pCurrent)(zLockFile)
	if rc < 0 {
		var tErrno int32 = *__error()
		if tErrno == 2 {
			rc = int32(0)
		} else {
			rc = int32(10 | 8<<8)
			storeLastErrno(pFile, tErrno)
		}
		return rc
	}
	pFile.eFileLock = uint8(0)
	return int32(0)
}
func dotlockClose(id *struct_sqlite3_file) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	dotlockUnlock(id, 0)
	sqlite3_free(pFile.lockingContext)
	return closeUnixFile(id)
}
func robust_flock(fd int32, op int32) int32 {
	var rc int32
	for {
		rc = flock(fd, op)
		if !(rc < 0 && *__error() == 4) {
			break
		}
	}
	return rc
}
func flockCheckReservedLock(id *struct_sqlite3_file, pResOut *int32) int32 {
	var rc int32 = 0
	var reserved int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) > 1 {
		reserved = int32(1)
	}
	if !(reserved != 0) {
		var lrc int32 = robust_flock(pFile.h, 2|4)
		if !(lrc != 0) {
			lrc = robust_flock(pFile.h, 8)
			if lrc != 0 {
				var tErrno int32 = *__error()
				lrc = int32(10 | 8<<8)
				storeLastErrno(pFile, tErrno)
				rc = lrc
			}
		} else {
			var tErrno int32 = *__error()
			reserved = int32(1)
			lrc = sqliteErrorFromPosixError(tErrno, 10|15<<8)
			if lrc != 0 && lrc != 5 {
				storeLastErrno(pFile, tErrno)
				rc = lrc
			}
		}
	}
	*pResOut = reserved
	return rc
}
func flockLock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var rc int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) > 0 {
		pFile.eFileLock = uint8(eFileLock)
		return int32(0)
	}
	if robust_flock(pFile.h, 2|4) != 0 {
		var tErrno int32 = *__error()
		rc = sqliteErrorFromPosixError(tErrno, 10|15<<8)
		if rc != 0 && rc != 5 {
			storeLastErrno(pFile, tErrno)
		}
	} else {
		pFile.eFileLock = uint8(eFileLock)
	}
	return rc
}
func flockUnlock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) == eFileLock {
		return int32(0)
	}
	if eFileLock == 1 {
		pFile.eFileLock = uint8(eFileLock)
		return int32(0)
	}
	if robust_flock(pFile.h, 8) != 0 {
		return int32(10 | 8<<8)
	} else {
		pFile.eFileLock = uint8(0)
		return int32(0)
	}
}
func flockClose(id *struct_sqlite3_file) int32 {
	func() int {
		_ = 0
		return 0
	}()
	flockUnlock(id, 0)
	return closeUnixFile(id)
}

type afpLockingContext = struct_afpLockingContext
type struct_afpLockingContext struct {
	reserved int32
	dbPath   *int8
}
type struct_ByteRangeLockPB2 struct {
	offset        uint64
	length        uint64
	retRangeStart uint64
	unLockFlag    uint8
	startEndFlag  uint8
	fd            int32
}

func afpSetLock(path *int8, pFile *struct_unixFile, offset uint64, length uint64, setLockFlag int32) int32 {
	var pb struct_ByteRangeLockPB2
	var err int32
	pb.unLockFlag = uint8(func() int32 {
		if setLockFlag != 0 {
			return 0
		} else {
			return 1
		}
	}())
	pb.startEndFlag = uint8(0)
	pb.offset = offset
	pb.length = length
	pb.fd = pFile.h
	err = fsctl(path, uint(uint32(2147483648)|uint32(1073741824))|32&uint(8191)<<16|uint('z'<<8)|uint(23), unsafe.Pointer(&pb), uint32(0))
	if err == -1 {
		var rc int32
		var tErrno int32 = *__error()
		rc = sqliteErrorFromPosixError(tErrno, func() int32 {
			if setLockFlag != 0 {
				return 10 | 15<<8
			} else {
				return 10 | 8<<8
			}
		}())
		if rc != 0 && rc != 5 {
			storeLastErrno(pFile, tErrno)
		}
		return rc
	} else {
		return int32(0)
	}
}
func afpCheckReservedLock(id *struct_sqlite3_file, pResOut *int32) int32 {
	var rc int32 = 0
	var reserved int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var context *struct_afpLockingContext
	func() int {
		_ = 0
		return 0
	}()
	context = (*struct_afpLockingContext)(pFile.lockingContext)
	if context.reserved != 0 {
		*pResOut = int32(1)
		return int32(0)
	}
	sqlite3_mutex_enter(pFile.pInode.pLockMutex)
	if int32(pFile.pInode.eFileLock) > 1 {
		reserved = int32(1)
	}
	if !(reserved != 0) {
		var lrc int32 = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+1), uint64(1), 1)
		if 0 == lrc {
			lrc = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+1), uint64(1), 0)
		} else {
			reserved = int32(1)
		}
		if lrc != 0 && lrc != 5 {
			rc = lrc
		}
	}
	sqlite3_mutex_leave(pFile.pInode.pLockMutex)
	*pResOut = reserved
	return rc
}
func afpLock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var rc int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var pInode *struct_unixInodeInfo = pFile.pInode
	var context *struct_afpLockingContext = (*struct_afpLockingContext)(pFile.lockingContext)
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) >= eFileLock {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pInode = pFile.pInode
	sqlite3_mutex_enter(pInode.pLockMutex)
	if int32(pFile.eFileLock) != int32(pInode.eFileLock) && (int32(pInode.eFileLock) >= 3 || eFileLock > 1) {
		rc = int32(5)
		goto afp_end_lock
	}
	if eFileLock == 1 && (int32(pInode.eFileLock) == 1 || int32(pInode.eFileLock) == 2) {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pFile.eFileLock = uint8(1)
		pInode.nShared++
		pInode.nLock++
		goto afp_end_lock
	}
	if eFileLock == 1 || eFileLock == 4 && int32(pFile.eFileLock) < 3 {
		var failed int32
		failed = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte), uint64(1), 1)
		if failed != 0 {
			rc = failed
			goto afp_end_lock
		}
	}
	if eFileLock == 1 {
		var lrc1 int32
		var lrc2 int32
		var lrc1Errno int32 = 0
		var lk int
		var mask int
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		mask = int(func() int64 {
			if 8 == uint(8) {
				return int64(4294967295) | int64(2147483647)<<32
			} else {
				return int64(2147483647)
			}
		}())
		lk = random()
		pInode.sharedByte = uint64(lk & mask % int(510-1))
		lrc1 = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+2)+pInode.sharedByte, uint64(1), 1)
		if lrc1 != 0 && lrc1 != 5 {
			lrc1Errno = pFile.lastErrno
		}
		lrc2 = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte), uint64(1), 0)
		if lrc1 != 0 && lrc1 != 5 {
			storeLastErrno(pFile, lrc1Errno)
			rc = lrc1
			goto afp_end_lock
		} else if lrc2 != 0 && lrc2 != 5 {
			rc = lrc2
			goto afp_end_lock
		} else if lrc1 != 0 {
			rc = lrc1
		} else {
			pFile.eFileLock = uint8(1)
			pInode.nLock++
			pInode.nShared = int32(1)
		}
	} else if eFileLock == 4 && pInode.nShared > 1 {
		rc = int32(5)
	} else {
		var failed int32 = 0
		func() int {
			_ = 0
			return 0
		}()
		if eFileLock >= 2 && int32(pFile.eFileLock) < 2 {
			failed = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+1), uint64(1), 1)
			if !(failed != 0) {
				context.reserved = int32(1)
			}
		}
		if !(failed != 0) && eFileLock == 4 {
			if !(func() (_cgo_ret int32) {
				_cgo_addr := &failed
				*_cgo_addr = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+2)+pInode.sharedByte, uint64(1), 0)
				return *_cgo_addr
			}() != 0) {
				var failed2 int32 = 0
				failed = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+2), uint64(510), 1)
				if failed != 0 && func() (_cgo_ret int32) {
					_cgo_addr := &failed2
					*_cgo_addr = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+2)+pInode.sharedByte, uint64(1), 1)
					return *_cgo_addr
				}() != 0 {
					rc = func() int32 {
						if failed&255 == 10 {
							return failed2
						} else {
							return 10 | 15<<8
						}
					}()
					goto afp_end_lock
				}
			} else {
				rc = failed
			}
		}
		if failed != 0 {
			rc = failed
		}
	}
	if rc == 0 {
		pFile.eFileLock = uint8(eFileLock)
		pInode.eFileLock = uint8(eFileLock)
	} else if eFileLock == 4 {
		pFile.eFileLock = uint8(3)
		pInode.eFileLock = uint8(3)
	}
afp_end_lock:
	sqlite3_mutex_leave(pInode.pLockMutex)
	return rc
}
func afpUnlock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var rc int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var pInode *struct_unixInodeInfo
	var context *struct_afpLockingContext = (*struct_afpLockingContext)(pFile.lockingContext)
	var skipShared int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) <= eFileLock {
		return int32(0)
	}
	pInode = pFile.pInode
	sqlite3_mutex_enter(pInode.pLockMutex)
	func() int {
		_ = 0
		return 0
	}()
	if int32(pFile.eFileLock) > 1 {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pFile.eFileLock) == 4 {
			rc = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+2), uint64(510), 0)
			if rc == 0 && (eFileLock == 1 || pInode.nShared > 1) {
				var sharedLockByte int32 = int32(uint64(sqlite3PendingByte+2) + pInode.sharedByte)
				rc = afpSetLock(context.dbPath, pFile, uint64(sharedLockByte), uint64(1), 1)
			} else {
				skipShared = int32(1)
			}
		}
		if rc == 0 && int32(pFile.eFileLock) >= 3 {
			rc = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte), uint64(1), 0)
		}
		if rc == 0 && int32(pFile.eFileLock) >= 2 && context.reserved != 0 {
			rc = afpSetLock(context.dbPath, pFile, uint64(sqlite3PendingByte+1), uint64(1), 0)
			if !(rc != 0) {
				context.reserved = int32(0)
			}
		}
		if rc == 0 && (eFileLock == 1 || pInode.nShared > 1) {
			pInode.eFileLock = uint8(1)
		}
	}
	if rc == 0 && eFileLock == 0 {
		var sharedLockByte uint64 = uint64(sqlite3PendingByte+2) + pInode.sharedByte
		pInode.nShared--
		if pInode.nShared == 0 {
			if !(skipShared != 0) {
				rc = afpSetLock(context.dbPath, pFile, sharedLockByte, uint64(1), 0)
			}
			if !(rc != 0) {
				pInode.eFileLock = uint8(0)
				pFile.eFileLock = uint8(0)
			}
		}
		if rc == 0 {
			pInode.nLock--
			func() int {
				_ = 0
				return 0
			}()
			if pInode.nLock == 0 {
				closePendingFds(pFile)
			}
		}
	}
	sqlite3_mutex_leave(pInode.pLockMutex)
	if rc == 0 {
		pFile.eFileLock = uint8(eFileLock)
	}
	return rc
}
func afpClose(id *struct_sqlite3_file) int32 {
	var rc int32 = 0
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	func() int {
		_ = 0
		return 0
	}()
	afpUnlock(id, 0)
	func() int {
		_ = 0
		return 0
	}()
	unixEnterMutex()
	if pFile.pInode != nil {
		var pInode *struct_unixInodeInfo = pFile.pInode
		sqlite3_mutex_enter(pInode.pLockMutex)
		if pInode.nLock != 0 {
			setPendingFd(pFile)
		}
		sqlite3_mutex_leave(pInode.pLockMutex)
	}
	releaseInodeInfo(pFile)
	sqlite3_free(pFile.lockingContext)
	rc = closeUnixFile(id)
	unixLeaveMutex()
	return rc
}
func nfsUnlock(id *struct_sqlite3_file, eFileLock int32) int32 {
	return posixUnlock(id, eFileLock, 1)
}
func seekAndRead(id *struct_unixFile, offset int64, pBuf unsafe.Pointer, cnt int32) int32 {
	var got int32
	var prior int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for {
		got = int32((func(int32, unsafe.Pointer, uint, int64) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(9)*24))).pCurrent)(id.h, pBuf, uint(cnt), offset))
		if got == cnt {
			break
		}
		if got < 0 {
			if *__error() == 4 {
				got = int32(1)
				continue
			}
			prior = int32(0)
			storeLastErrno((*struct_unixFile)(unsafe.Pointer(id)), *__error())
			break
		} else if got > 0 {
			cnt -= got
			offset += int64(got)
			prior += got
			pBuf = unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pBuf))) + uintptr(got))))
		}
		if !(got > 0) {
			break
		}
	}
	return got + prior
}
func unixRead(id *struct_sqlite3_file, pBuf unsafe.Pointer, amt int32, offset int64) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var got int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if offset < pFile.mmapSize {
		if offset+int64(amt) <= pFile.mmapSize {
			__builtin___memcpy_chk(pBuf, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pFile.pMapRegion))) + uintptr(offset)))), uint(amt), __builtin_object_size(pBuf, 0))
			return int32(0)
		} else {
			var nCopy int32 = int32(pFile.mmapSize - offset)
			__builtin___memcpy_chk(pBuf, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pFile.pMapRegion))) + uintptr(offset)))), uint(nCopy), __builtin_object_size(pBuf, 0))
			pBuf = unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pBuf))) + uintptr(nCopy))))
			amt -= nCopy
			offset += int64(nCopy)
		}
	}
	got = seekAndRead(pFile, offset, pBuf, amt)
	if got == amt {
		return int32(0)
	} else if got < 0 {
		switch pFile.lastErrno {
		case 34:
			fallthrough
		case 5:
			fallthrough
		case 6:
			fallthrough
		case 83:
			return int32(10 | 33<<8)
		}
		return int32(10 | 1<<8)
	} else {
		storeLastErrno(pFile, 0)
		__builtin___memset_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pBuf))) + uintptr(got)))), 0, uint(amt-got), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pBuf))) + uintptr(got)))), 0))
		return int32(10 | 2<<8)
	}
}
func seekAndWriteFd(fd int32, iOff int64, pBuf unsafe.Pointer, nBuf int32, piErrno *int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nBuf &= int32(131071)
	for {
		rc = int32((func(int32, unsafe.Pointer, uint, int64) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(12)*24))).pCurrent)(fd, pBuf, uint(nBuf), iOff))
		if !(rc < 0 && *__error() == 4) {
			break
		}
	}
	if rc < 0 {
		*piErrno = *__error()
	}
	return rc
}
func seekAndWrite(id *struct_unixFile, offset int64, pBuf unsafe.Pointer, cnt int32) int32 {
	return seekAndWriteFd(id.h, offset, pBuf, cnt, &id.lastErrno)
}
func unixWrite(id *struct_sqlite3_file, pBuf unsafe.Pointer, amt int32, offset int64) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var wrote int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for func() (_cgo_ret int32) {
		_cgo_addr := &wrote
		*_cgo_addr = seekAndWrite(pFile, offset, pBuf, amt)
		return *_cgo_addr
	}() < amt && wrote > 0 {
		amt -= wrote
		offset += int64(wrote)
		pBuf = unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pBuf))) + uintptr(wrote))))
	}
	if amt > wrote {
		if wrote < 0 && pFile.lastErrno != 28 {
			return int32(10 | 3<<8)
		} else {
			storeLastErrno(pFile, 0)
			return int32(13)
		}
	}
	return int32(0)
}
func full_fsync(fd int32, fullSync int32, dataOnly int32) int32 {
	var rc int32
	func() int {
		_ = dataOnly
		return 0
	}()
	if fullSync != 0 {
		rc = (func(int32, int32, ...interface {
		}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(fd, 51, 0)
	} else {
		rc = int32(1)
	}
	if rc != 0 {
		rc = fsync(fd)
	}
	if 0 != 0 && rc != -1 {
		rc = int32(0)
	}
	return rc
}
func openDirectory(zFilename *int8, pFd *int32) int32 {
	var ii int32
	var fd int32 = -1
	var zDirname [513]int8
	sqlite3_snprintf(512, (*int8)(unsafe.Pointer(&zDirname)), (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zFilename)
	for ii = int32(strlen((*int8)(unsafe.Pointer(&zDirname)))); ii > 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zDirname)))) + uintptr(ii)))) != '/'; ii-- {
	}
	if ii > 0 {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zDirname)))) + uintptr(ii))) = int8('\x00')
	} else {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zDirname)))) + uintptr(0)))) != '/' {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zDirname)))) + uintptr(0))) = int8('.')
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zDirname)))) + uintptr(1))) = int8(0)
	}
	fd = robust_open((*int8)(unsafe.Pointer(&zDirname)), 0|0, uint16(0))
	if fd >= 0 {
	}
	*pFd = fd
	if fd >= 0 {
		return int32(0)
	}
	return unixLogErrorAtLine(sqlite3CantopenError(38498), (*int8)(unsafe.Pointer(&[14]int8{'o', 'p', 'e', 'n', 'D', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '\x00'})), (*int8)(unsafe.Pointer(&zDirname)), 38498)
}
func unixSync(id *struct_sqlite3_file, flags int32) int32 {
	var rc int32
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var isDataOnly int32 = flags & 16
	var isFullsync int32 = func() int32 {
		if flags&15 == 3 {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = full_fsync(pFile.h, isFullsync, isDataOnly)
	if rc != 0 {
		storeLastErrno(pFile, *__error())
		return unixLogErrorAtLine(10|4<<8, (*int8)(unsafe.Pointer(&[11]int8{'f', 'u', 'l', 'l', '_', 'f', 's', 'y', 'n', 'c', '\x00'})), pFile.zPath, 38539)
	}
	if int32(pFile.ctrlFlags)&8 != 0 {
		var dirfd int32
		rc = (func(*int8, *int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(17)*24))).pCurrent)(pFile.zPath, &dirfd)
		if rc == 0 {
			full_fsync(dirfd, 0, 0)
			robust_close(pFile, dirfd, 38553)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			rc = int32(0)
		}
		pFile.ctrlFlags &= uint16(^8)
	}
	return rc
}
func unixTruncate(id *struct_sqlite3_file, nByte int64) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if pFile.szChunk > 0 {
		nByte = (nByte + int64(pFile.szChunk) - int64(1)) / int64(pFile.szChunk) * int64(pFile.szChunk)
	}
	rc = robust_ftruncate(pFile.h, nByte)
	if rc != 0 {
		storeLastErrno(pFile, *__error())
		return unixLogErrorAtLine(10|6<<8, (*int8)(unsafe.Pointer(&[10]int8{'f', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', '\x00'})), pFile.zPath, 38584)
	} else {
		if nByte < pFile.mmapSize {
			pFile.mmapSize = nByte
		}
		return int32(0)
	}
}
func unixFileSize(id *struct_sqlite3_file, pSize *int64) int32 {
	var rc int32
	var buf struct_stat
	func() int {
		_ = 0
		return 0
	}()
	rc = (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)((*struct_unixFile)(unsafe.Pointer(id)).h, &buf)
	if rc != 0 {
		storeLastErrno((*struct_unixFile)(unsafe.Pointer(id)), *__error())
		return int32(10 | 7<<8)
	}
	*pSize = buf.st_size
	if *pSize == int64(1) {
		*pSize = int64(0)
	}
	return int32(0)
}
func fcntlSizeHint(pFile *struct_unixFile, nByte int64) int32 {
	if pFile.szChunk > 0 {
		var nSize int64
		var buf struct_stat
		if (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(pFile.h, &buf) != 0 {
			return int32(10 | 7<<8)
		}
		nSize = (nByte + int64(pFile.szChunk) - int64(1)) / int64(pFile.szChunk) * int64(pFile.szChunk)
		if nSize > int64(buf.st_size) {
			var nBlk int32 = buf.st_blksize
			var nWrite int32 = 0
			var iWrite int64
			iWrite = buf.st_size/int64(nBlk)*int64(nBlk) + int64(nBlk) - int64(1)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			for ; iWrite < nSize+int64(nBlk)-int64(1); iWrite += int64(nBlk) {
				if iWrite >= nSize {
					iWrite = nSize - int64(1)
				}
				nWrite = seekAndWrite(pFile, iWrite, unsafe.Pointer((*int8)(unsafe.Pointer(&[1]int8{'\x00'}))), 1)
				if nWrite != 1 {
					return int32(10 | 3<<8)
				}
			}
		}
	}
	if pFile.mmapSizeMax > int64(0) && nByte > pFile.mmapSize {
		var rc int32
		if pFile.szChunk <= 0 {
			if robust_ftruncate(pFile.h, nByte) != 0 {
				storeLastErrno(pFile, *__error())
				return unixLogErrorAtLine(10|6<<8, (*int8)(unsafe.Pointer(&[10]int8{'f', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', '\x00'})), pFile.zPath, 38705)
			}
		}
		rc = unixMapfile(pFile, nByte)
		return rc
	}
	return int32(0)
}
func unixModeBit(pFile *struct_unixFile, mask uint8, pArg *int32) {
	if *pArg < 0 {
		*pArg = func() int32 {
			if int32(pFile.ctrlFlags)&int32(mask) != 0 {
				return 1
			} else {
				return 0
			}
		}()
	} else if *pArg == 0 {
		pFile.ctrlFlags &= uint16(^int32(mask))
	} else {
		pFile.ctrlFlags |= uint16(int32(mask))
	}
}
func unixFileControl(id *struct_sqlite3_file, op int32, pArg unsafe.Pointer) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	switch op {
	case 1:
		{
			*(*int32)(pArg) = int32(pFile.eFileLock)
			return int32(0)
		}
	case 4:
		{
			*(*int32)(pArg) = pFile.lastErrno
			return int32(0)
		}
	case 6:
		{
			pFile.szChunk = *(*int32)(pArg)
			return int32(0)
		}
	case 5:
		{
			var rc int32
			rc = fcntlSizeHint(pFile, *(*int64)(pArg))
			return rc
		}
	case 10:
		{
			unixModeBit(pFile, uint8(4), (*int32)(pArg))
			return int32(0)
		}
	case 13:
		{
			unixModeBit(pFile, uint8(16), (*int32)(pArg))
			return int32(0)
		}
	case 12:
		{
			*(**int8)(pArg) = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), pFile.pVfs.zName)
			return int32(0)
		}
	case 16:
		{
			var zTFile *int8 = (*int8)(sqlite3_malloc64(uint64(pFile.pVfs.mxPathname)))
			if zTFile != nil {
				unixGetTempname(pFile.pVfs.mxPathname, zTFile)
				*(**int8)(pArg) = zTFile
			}
			return int32(0)
		}
	case 20:
		{
			*(*int32)(pArg) = fileHasMoved(pFile)
			return int32(0)
		}
	case 18:
		{
			var newLimit int64 = *(*int64)(pArg)
			var rc int32 = 0
			if newLimit > sqlite3Config.mxMmap {
				newLimit = sqlite3Config.mxMmap
			}
			if newLimit > int64(0) && false {
				newLimit = newLimit & int64(2147483647)
			}
			*(*int64)(pArg) = pFile.mmapSizeMax
			if newLimit >= int64(0) && newLimit != pFile.mmapSizeMax && pFile.nFetchOut == 0 {
				pFile.mmapSizeMax = newLimit
				if pFile.mmapSize > int64(0) {
					unixUnmapfile(pFile)
					rc = unixMapfile(pFile, int64(-1))
				}
			}
			return rc
		}
	case 3:
		fallthrough
	case 2:
		{
			return proxyFileControl(id, op, pArg)
		}
	case 40:
		{
			return unixFcntlExternalReader((*struct_unixFile)(unsafe.Pointer(id)), (*int32)(pArg))
		}
	}
	return int32(12)
}
func setDeviceCharacteristics(pFd *struct_unixFile) {
	func() int {
		_ = 0
		return 0
	}()
	if pFd.sectorSize == 0 {
		if int32(pFd.ctrlFlags)&16 != 0 {
			pFd.deviceCharacteristics |= int32(4096)
		}
		pFd.sectorSize = int32(4096)
	}
}
func unixSectorSize(id *struct_sqlite3_file) int32 {
	var pFd *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	setDeviceCharacteristics(pFd)
	return pFd.sectorSize
}
func unixDeviceCharacteristics(id *struct_sqlite3_file) int32 {
	var pFd *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	setDeviceCharacteristics(pFd)
	return pFd.deviceCharacteristics
}
func unixGetpagesize() int32 {
	return int32(sysconf(29))
}

type struct_unixShmNode struct {
	pInode     *struct_unixInodeInfo
	pShmMutex  *struct_sqlite3_mutex
	zFilename  *int8
	hShm       int32
	szRegion   int32
	nRegion    uint16
	isReadonly uint8
	isUnlocked uint8
	apRegion   **int8
	nRef       int32
	pFirst     *struct_unixShm
	aLock      [8]int32
}
type struct_unixShm struct {
	pShmNode   *struct_unixShmNode
	pNext      *struct_unixShm
	hasMutex   uint8
	id         uint8
	sharedMask uint16
	exclMask   uint16
}

func unixFcntlExternalReader(pFile *struct_unixFile, piOut *int32) int32 {
	var rc int32 = 0
	*piOut = int32(0)
	if pFile.pShm != nil {
		var pShmNode *struct_unixShmNode = pFile.pShm.pShmNode
		var f struct_flock
		__builtin___memset_chk(unsafe.Pointer(&f), 0, 24, __builtin_object_size(unsafe.Pointer(&f), 0))
		f.l_type = int16(3)
		f.l_whence = int16(0)
		f.l_start = int64((22+8)*4 + 3)
		f.l_len = int64(8 - 3)
		sqlite3_mutex_enter(pShmNode.pShmMutex)
		if (func(int32, int32, ...interface {
		}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pShmNode.hShm, 7, &f) < 0 {
			rc = int32(10 | 15<<8)
		} else {
			*piOut = func() int32 {
				if int32(f.l_type) != 2 {
					return 1
				} else {
					return 0
				}
			}()
		}
		sqlite3_mutex_leave(pShmNode.pShmMutex)
	}
	return rc
}
func unixShmSystemLock(pFile *struct_unixFile, lockType int32, ofst int32, n int32) int32 {
	var pShmNode *struct_unixShmNode
	var f struct_flock
	var rc int32 = 0
	pShmNode = pFile.pInode.pShmNode
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pShmNode.hShm >= 0 {
		var res int32
		f.l_type = int16(lockType)
		f.l_whence = int16(0)
		f.l_start = int64(ofst)
		f.l_len = int64(n)
		res = (func(int32, int32, ...interface {
		}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pShmNode.hShm, 8, &f)
		if res == -1 {
			rc = int32(5)
		}
	}
	return rc
}
func unixShmRegionPerMap() int32 {
	var shmsz int32 = 32 * 1024
	var pgsz int32 = (func() int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(25)*24))).pCurrent)()
	func() int {
		_ = 0
		return 0
	}()
	if pgsz < shmsz {
		return int32(1)
	}
	return pgsz / shmsz
}
func unixShmPurge(pFd *struct_unixFile) {
	var p *struct_unixShmNode = pFd.pInode.pShmNode
	func() int {
		_ = 0
		return 0
	}()
	if p != nil && p.nRef == 0 {
		var nShmPerMap int32 = unixShmRegionPerMap()
		var i int32
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_mutex_free(p.pShmMutex)
		for i = int32(0); i < int32(p.nRegion); i += nShmPerMap {
			if p.hShm >= 0 {
				(func(unsafe.Pointer, uint) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(23)*24))).pCurrent)(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apRegion)) + uintptr(i)*8))), uint(p.szRegion))
			} else {
				sqlite3_free(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apRegion)) + uintptr(i)*8))))
			}
		}
		sqlite3_free(unsafe.Pointer(p.apRegion))
		if p.hShm >= 0 {
			robust_close(pFd, p.hShm, 39264)
			p.hShm = int32(-1)
		}
		p.pInode.pShmNode = (*struct_unixShmNode)(nil)
		sqlite3_free(unsafe.Pointer(p))
	}
}
func unixLockSharedMemory(pDbFd *struct_unixFile, pShmNode *struct_unixShmNode) int32 {
	var lock struct_flock
	var rc int32 = 0
	lock.l_whence = int16(0)
	lock.l_start = int64((22+8)*4 + 8)
	lock.l_len = int64(1)
	lock.l_type = int16(3)
	if (func(int32, int32, ...interface {
	}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pShmNode.hShm, 7, &lock) != 0 {
		rc = int32(10 | 15<<8)
	} else if int32(lock.l_type) == 2 {
		if pShmNode.isReadonly != 0 {
			pShmNode.isUnlocked = uint8(1)
			rc = int32(8 | 5<<8)
		} else {
			rc = unixShmSystemLock(pDbFd, 3, (22+8)*4+8, 1)
			if rc == 0 && robust_ftruncate(pShmNode.hShm, int64(3)) != 0 {
				rc = unixLogErrorAtLine(10|18<<8, (*int8)(unsafe.Pointer(&[10]int8{'f', 't', 'r', 'u', 'n', 'c', 'a', 't', 'e', '\x00'})), pShmNode.zFilename, 39321)
			}
		}
	} else if int32(lock.l_type) == 3 {
		rc = int32(5)
	}
	if rc == 0 {
		func() int {
			_ = 0
			return 0
		}()
		rc = unixShmSystemLock(pDbFd, 1, (22+8)*4+8, 1)
	}
	return rc
}
func unixOpenSharedMemory(pDbFd *struct_unixFile) int32 {
	var p *struct_unixShm = nil
	var pShmNode *struct_unixShmNode
	var rc int32 = 0
	var pInode *struct_unixInodeInfo
	var zShm *int8
	var nShmFilename int32
	p = (*struct_unixShm)(sqlite3_malloc64(uint64(22)))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(p), 0, 22, __builtin_object_size(unsafe.Pointer(p), 0))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	unixEnterMutex()
	pInode = pDbFd.pInode
	pShmNode = pInode.pShmNode
	if uintptr(unsafe.Pointer(pShmNode)) == uintptr(unsafe.Pointer(nil)) {
		var sStat struct_stat
		var zBasePath *int8 = pDbFd.zPath
		if (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(pDbFd.h, &sStat) != 0 {
			rc = int32(10 | 7<<8)
			goto shm_open_err
		}
		nShmFilename = 6 + int32(strlen(zBasePath))
		pShmNode = (*struct_unixShmNode)(sqlite3_malloc64(uint64(96 + uint(nShmFilename))))
		if uintptr(unsafe.Pointer(pShmNode)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
			goto shm_open_err
		}
		__builtin___memset_chk(unsafe.Pointer(pShmNode), 0, 96+uint(nShmFilename), __builtin_object_size(unsafe.Pointer(pShmNode), 0))
		zShm = func() (_cgo_ret *int8) {
			_cgo_addr := &pShmNode.zFilename
			*_cgo_addr = (*int8)(unsafe.Pointer(&*(*struct_unixShmNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pShmNode)) + uintptr(1)*96))))
			return *_cgo_addr
		}()
		sqlite3_snprintf(nShmFilename, zShm, (*int8)(unsafe.Pointer(&[7]int8{'%', 's', '-', 's', 'h', 'm', '\x00'})), zBasePath)
		pShmNode.hShm = int32(-1)
		pDbFd.pInode.pShmNode = pShmNode
		pShmNode.pInode = pDbFd.pInode
		if sqlite3Config.bCoreMutex != 0 {
			pShmNode.pShmMutex = sqlite3_mutex_alloc(0)
			if uintptr(unsafe.Pointer(pShmNode.pShmMutex)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(7)
				goto shm_open_err
			}
		}
		if int32(pInode.bProcessLock) == 0 {
			if 0 == sqlite3_uri_boolean(pDbFd.zPath, (*int8)(unsafe.Pointer(&[13]int8{'r', 'e', 'a', 'd', 'o', 'n', 'l', 'y', '_', 's', 'h', 'm', '\x00'})), 0) {
				pShmNode.hShm = robust_open(zShm, 2|512|256, uint16(int32(sStat.st_mode)&511))
			}
			if pShmNode.hShm < 0 {
				pShmNode.hShm = robust_open(zShm, 0|256, uint16(int32(sStat.st_mode)&511))
				if pShmNode.hShm < 0 {
					rc = unixLogErrorAtLine(sqlite3CantopenError(39446), (*int8)(unsafe.Pointer(&[5]int8{'o', 'p', 'e', 'n', '\x00'})), zShm, 39446)
					goto shm_open_err
				}
				pShmNode.isReadonly = uint8(1)
			}
			robustFchown(pShmNode.hShm, sStat.st_uid, sStat.st_gid)
			rc = unixLockSharedMemory(pDbFd, pShmNode)
			if rc != 0 && rc != 8|5<<8 {
				goto shm_open_err
			}
		}
	}
	p.pShmNode = pShmNode
	pShmNode.nRef++
	pDbFd.pShm = p
	unixLeaveMutex()
	sqlite3_mutex_enter(pShmNode.pShmMutex)
	p.pNext = pShmNode.pFirst
	pShmNode.pFirst = p
	sqlite3_mutex_leave(pShmNode.pShmMutex)
	return rc
shm_open_err:
	unixShmPurge(pDbFd)
	sqlite3_free(unsafe.Pointer(p))
	unixLeaveMutex()
	return rc
}
func unixShmMap(fd *struct_sqlite3_file, iRegion int32, szRegion int32, bExtend int32, pp *unsafe.Pointer) int32 {
	var pDbFd *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(fd))
	var p *struct_unixShm
	var pShmNode *struct_unixShmNode
	var rc int32 = 0
	var nShmPerMap int32 = unixShmRegionPerMap()
	var nReqRegion int32
	if uintptr(unsafe.Pointer(pDbFd.pShm)) == uintptr(unsafe.Pointer(nil)) {
		rc = unixOpenSharedMemory(pDbFd)
		if rc != 0 {
			return rc
		}
	}
	p = pDbFd.pShm
	pShmNode = p.pShmNode
	sqlite3_mutex_enter(pShmNode.pShmMutex)
	if pShmNode.isUnlocked != 0 {
		rc = unixLockSharedMemory(pDbFd, pShmNode)
		if rc != 0 {
			goto shmpage_out
		}
		pShmNode.isUnlocked = uint8(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nReqRegion = (iRegion + nShmPerMap) / nShmPerMap * nShmPerMap
	if int32(pShmNode.nRegion) < nReqRegion {
		var apNew **int8
		var nByte int32 = nReqRegion * szRegion
		var sStat struct_stat
		pShmNode.szRegion = szRegion
		if pShmNode.hShm >= 0 {
			if (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(pShmNode.hShm, &sStat) != 0 {
				rc = int32(10 | 19<<8)
				goto shmpage_out
			}
			if sStat.st_size < int64(nByte) {
				if !(bExtend != 0) {
					goto shmpage_out
				} else {
					const pgsz int32 = 4096
					var iPg int32
					func() int {
						_ = 0
						return 0
					}()
					for iPg = int32(sStat.st_size / int64(pgsz)); iPg < nByte/pgsz; iPg++ {
						var x int32 = 0
						if seekAndWriteFd(pShmNode.hShm, int64(iPg*pgsz+pgsz-1), unsafe.Pointer((*int8)(unsafe.Pointer(&[1]int8{'\x00'}))), 1, &x) != 1 {
							var zFile *int8 = pShmNode.zFilename
							rc = unixLogErrorAtLine(10|19<<8, (*int8)(unsafe.Pointer(&[6]int8{'w', 'r', 'i', 't', 'e', '\x00'})), zFile, 39590)
							goto shmpage_out
						}
					}
				}
			}
		}
		apNew = (**int8)(sqlite3_realloc(unsafe.Pointer(pShmNode.apRegion), int32(uint(nReqRegion)*8)))
		if !(apNew != nil) {
			rc = int32(10 | 12<<8)
			goto shmpage_out
		}
		pShmNode.apRegion = apNew
		for int32(pShmNode.nRegion) < nReqRegion {
			var nMap int32 = szRegion * nShmPerMap
			var i int32
			var pMem unsafe.Pointer
			if pShmNode.hShm >= 0 {
				pMem = (func(unsafe.Pointer, uint, int32, int32, int32, int64) unsafe.Pointer)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(22)*24))).pCurrent)(nil, uint(nMap), func() int32 {
					if int32(pShmNode.isReadonly) != 0 {
						return 1
					} else {
						return 1 | 2
					}
				}(), 1, pShmNode.hShm, int64(szRegion)*int64(pShmNode.nRegion))
				if uintptr(unsafe.Pointer(pMem)) == uintptr(unsafe.Pointer(unsafe.Pointer(-1))) {
					rc = unixLogErrorAtLine(10|21<<8, (*int8)(unsafe.Pointer(&[5]int8{'m', 'm', 'a', 'p', '\x00'})), pShmNode.zFilename, 39617)
					goto shmpage_out
				}
			} else {
				pMem = sqlite3_malloc64(uint64(nMap))
				if uintptr(unsafe.Pointer(pMem)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
					goto shmpage_out
				}
				__builtin___memset_chk(pMem, 0, uint(nMap), __builtin_object_size(pMem, 0))
			}
			for i = int32(0); i < nShmPerMap; i++ {
				*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pShmNode.apRegion)) + uintptr(int32(pShmNode.nRegion)+i)*8)) = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pMem))) + uintptr(szRegion*i)))
			}
			pShmNode.nRegion += uint16(nShmPerMap)
		}
	}
shmpage_out:
	if int32(pShmNode.nRegion) > iRegion {
		*pp = unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pShmNode.apRegion)) + uintptr(iRegion)*8)))
	} else {
		*pp = unsafe.Pointer(nil)
	}
	if int32(pShmNode.isReadonly) != 0 && rc == 0 {
		rc = int32(8)
	}
	sqlite3_mutex_leave(pShmNode.pShmMutex)
	return rc
}
func unixShmLock(fd *struct_sqlite3_file, ofst int32, n int32, flags int32) int32 {
	var pDbFd *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(fd))
	var p *struct_unixShm
	var pShmNode *struct_unixShmNode
	var rc int32 = 0
	var mask uint16
	var aLock *int32
	p = pDbFd.pShm
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(10 | 20<<8)
	}
	pShmNode = p.pShmNode
	if uintptr(unsafe.Pointer(pShmNode)) == uintptr(unsafe.Pointer(nil)) {
		return int32(10 | 20<<8)
	}
	aLock = (*int32)(unsafe.Pointer(&pShmNode.aLock))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	mask = uint16(1<<(ofst+n) - 1<<ofst)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(pShmNode.pShmMutex)
	func() int {
		_ = 0
		return 0
	}()
	if flags&1 != 0 {
		if (int32(p.exclMask)|int32(p.sharedMask))&int32(mask) != 0 {
			var ii int32
			var bUnlock int32 = 1
			for ii = ofst; ii < ofst+n; ii++ {
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ii)*4)) > func() int32 {
					if int32(p.sharedMask)&int32(1<<ii) != 0 {
						return 1
					} else {
						return 0
					}
				}() {
					bUnlock = int32(0)
				}
			}
			if bUnlock != 0 {
				rc = unixShmSystemLock(pDbFd, 2, ofst+(22+8)*4, n)
				if rc == 0 {
					__builtin___memset_chk(unsafe.Pointer(&*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ofst)*4))), 0, 4*uint(n), __builtin_object_size(unsafe.Pointer(&*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ofst)*4))), 0))
				}
			} else if int32(p.sharedMask)&int32(1<<ofst) != 0 {
				func() int {
					_ = 0
					return 0
				}()
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ofst)*4))--
			}
			if rc == 0 {
				p.exclMask &= uint16(^int32(mask))
				p.sharedMask &= uint16(^int32(mask))
			}
		}
	} else if flags&4 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if int32(p.sharedMask)&int32(mask) == 0 {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ofst)*4)) < 0 {
				rc = int32(5)
			} else if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ofst)*4)) == 0 {
				rc = unixShmSystemLock(pDbFd, 1, ofst+(22+8)*4, n)
			}
			if rc == 0 {
				p.sharedMask |= uint16(int32(mask))
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ofst)*4))++
			}
		}
	} else {
		var ii int32
		for ii = ofst; ii < ofst+n; ii++ {
			func() int {
				_ = 0
				return 0
			}()
			if int32(p.exclMask)&int32(1<<ii) == 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ii)*4)) != 0 {
				rc = int32(5)
				break
			}
		}
		if rc == 0 {
			rc = unixShmSystemLock(pDbFd, 3, ofst+(22+8)*4, n)
			if rc == 0 {
				func() int {
					_ = 0
					return 0
				}()
				p.exclMask |= uint16(int32(mask))
				for ii = ofst; ii < ofst+n; ii++ {
					*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLock)) + uintptr(ii)*4)) = int32(-1)
				}
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_leave(pShmNode.pShmMutex)
	return rc
}
func unixShmBarrier(fd *struct_sqlite3_file) {
	func() int {
		_ = fd
		return 0
	}()
	sqlite3MemoryBarrier()
	func() int {
		_ = 0
		return 0
	}()
	unixEnterMutex()
	unixLeaveMutex()
}
func unixShmUnmap(fd *struct_sqlite3_file, deleteFlag int32) int32 {
	var p *struct_unixShm
	var pShmNode *struct_unixShmNode
	var pp **struct_unixShm
	var pDbFd *struct_unixFile
	pDbFd = (*struct_unixFile)(unsafe.Pointer(fd))
	p = pDbFd.pShm
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	pShmNode = p.pShmNode
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(pShmNode.pShmMutex)
	for pp = &pShmNode.pFirst; uintptr(unsafe.Pointer(*pp)) != uintptr(unsafe.Pointer(p)); pp = &(*pp).pNext {
	}
	*pp = p.pNext
	sqlite3_free(unsafe.Pointer(p))
	pDbFd.pShm = (*struct_unixShm)(nil)
	sqlite3_mutex_leave(pShmNode.pShmMutex)
	func() int {
		_ = 0
		return 0
	}()
	unixEnterMutex()
	func() int {
		_ = 0
		return 0
	}()
	pShmNode.nRef--
	if pShmNode.nRef == 0 {
		if deleteFlag != 0 && pShmNode.hShm >= 0 {
			(func(*int8) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(16)*24))).pCurrent)(pShmNode.zFilename)
		}
		unixShmPurge(pDbFd)
	}
	unixLeaveMutex()
	return int32(0)
}
func unixUnmapfile(pFd *struct_unixFile) {
	func() int {
		_ = 0
		return 0
	}()
	if pFd.pMapRegion != nil {
		(func(unsafe.Pointer, uint) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(23)*24))).pCurrent)(pFd.pMapRegion, uint(pFd.mmapSizeActual))
		pFd.pMapRegion = unsafe.Pointer(nil)
		pFd.mmapSize = int64(0)
		pFd.mmapSizeActual = int64(0)
	}
}
func unixRemapfile(pFd *struct_unixFile, nNew int64) {
	var zErr *int8 = (*int8)(unsafe.Pointer(&[5]int8{'m', 'm', 'a', 'p', '\x00'}))
	var h int32 = pFd.h
	var pOrig *uint8 = (*uint8)(pFd.pMapRegion)
	var nOrig int64 = pFd.mmapSizeActual
	var pNew *uint8 = nil
	var flags int32 = 1
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pOrig != nil {
		var szSyspage int32 = (func() int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(25)*24))).pCurrent)()
		var nReuse int64 = pFd.mmapSize & int64(^(szSyspage - 1))
		var pReq *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOrig)) + uintptr(nReuse)))
		if nReuse != nOrig {
			(func(unsafe.Pointer, uint) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(23)*24))).pCurrent)(unsafe.Pointer(pReq), uint(nOrig-nReuse))
		}
		pNew = (*uint8)((func(unsafe.Pointer, uint, int32, int32, int32, int64) unsafe.Pointer)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(22)*24))).pCurrent)(unsafe.Pointer(pReq), uint(nNew-nReuse), flags, 1, h, nReuse))
		if uintptr(unsafe.Pointer(pNew)) != uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(-1)))) {
			if uintptr(unsafe.Pointer(pNew)) != uintptr(unsafe.Pointer(pReq)) {
				(func(unsafe.Pointer, uint) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(23)*24))).pCurrent)(unsafe.Pointer(pNew), uint(nNew-nReuse))
				pNew = (*uint8)(nil)
			} else {
				pNew = pOrig
			}
		}
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(-1)))) || uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			(func(unsafe.Pointer, uint) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(23)*24))).pCurrent)(unsafe.Pointer(pOrig), uint(nReuse))
		}
	}
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		pNew = (*uint8)((func(unsafe.Pointer, uint, int32, int32, int32, int64) unsafe.Pointer)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(22)*24))).pCurrent)(nil, uint(nNew), flags, 1, h, int64(0)))
	}
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(-1)))) {
		pNew = (*uint8)(nil)
		nNew = int64(0)
		unixLogErrorAtLine(0, zErr, pFd.zPath, 39991)
		pFd.mmapSizeMax = int64(0)
	}
	pFd.pMapRegion = unsafe.Pointer(pNew)
	pFd.mmapSize = func() (_cgo_ret int64) {
		_cgo_addr := &pFd.mmapSizeActual
		*_cgo_addr = nNew
		return *_cgo_addr
	}()
}
func unixMapfile(pFd *struct_unixFile, nMap int64) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pFd.nFetchOut > 0 {
		return int32(0)
	}
	if nMap < int64(0) {
		var statbuf struct_stat
		if (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(pFd.h, &statbuf) != 0 {
			return int32(10 | 7<<8)
		}
		nMap = statbuf.st_size
	}
	if nMap > pFd.mmapSizeMax {
		nMap = pFd.mmapSizeMax
	}
	func() int {
		_ = 0
		return 0
	}()
	if nMap != pFd.mmapSize {
		unixRemapfile(pFd, nMap)
	}
	return int32(0)
}
func unixFetch(fd *struct_sqlite3_file, iOff int64, nAmt int32, pp *unsafe.Pointer) int32 {
	var pFd *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(fd))
	*pp = unsafe.Pointer(nil)
	if pFd.mmapSizeMax > int64(0) {
		if uintptr(unsafe.Pointer(pFd.pMapRegion)) == uintptr(unsafe.Pointer(nil)) {
			var rc int32 = unixMapfile(pFd, int64(-1))
			if rc != 0 {
				return rc
			}
		}
		if pFd.mmapSize >= iOff+int64(nAmt) {
			*pp = unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pFd.pMapRegion))) + uintptr(iOff))))
			pFd.nFetchOut++
		}
	}
	return int32(0)
}
func unixUnfetch(fd *struct_sqlite3_file, iOff int64, p unsafe.Pointer) int32 {
	var pFd *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(fd))
	func() int {
		_ = iOff
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p != nil {
		pFd.nFetchOut--
	} else {
		unixUnmapfile(pFd)
	}
	func() int {
		_ = 0
		return 0
	}()
	return int32(0)
}

var posixIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{3, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, unixUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func posixIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &posixIoMethods
}

var posixIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = posixIoFinderImpl
var nolockIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{3, nolockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, nolockLock, nolockUnlock, nolockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, nil, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func nolockIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &nolockIoMethods
}

var nolockIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = nolockIoFinderImpl
var dotlockIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{1, dotlockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, dotlockLock, dotlockUnlock, dotlockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, nil, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func dotlockIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &dotlockIoMethods
}

var dotlockIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = dotlockIoFinderImpl
var flockIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{1, flockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, flockLock, flockUnlock, flockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, nil, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func flockIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &flockIoMethods
}

var flockIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = flockIoFinderImpl
var afpIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{1, afpClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, afpLock, afpUnlock, afpCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, nil, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func afpIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &afpIoMethods
}

var afpIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = afpIoFinderImpl
var proxyIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{1, proxyClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, proxyLock, proxyUnlock, proxyCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, nil, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func proxyIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &proxyIoMethods
}

var proxyIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = proxyIoFinderImpl
var nfsIoMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{1, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, nfsUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, nil, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch}

func nfsIoFinderImpl(z *int8, p *struct_unixFile) *struct_sqlite3_io_methods {
	func() int {
		_ = z
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
	return &nfsIoMethods
}

var nfsIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = nfsIoFinderImpl

func autolockIoFinderImpl(filePath *int8, pNew *struct_unixFile) *struct_sqlite3_io_methods {
	type struct_Mapping struct {
		zFilesystem *int8
		pMethods    *struct_sqlite3_io_methods
	}
	var aMap [6]struct_Mapping = [6]struct_Mapping{struct_Mapping{(*int8)(unsafe.Pointer(&[4]int8{'h', 'f', 's', '\x00'})), &posixIoMethods}, struct_Mapping{(*int8)(unsafe.Pointer(&[4]int8{'u', 'f', 's', '\x00'})), &posixIoMethods}, struct_Mapping{(*int8)(unsafe.Pointer(&[6]int8{'a', 'f', 'p', 'f', 's', '\x00'})), &afpIoMethods}, struct_Mapping{(*int8)(unsafe.Pointer(&[6]int8{'s', 'm', 'b', 'f', 's', '\x00'})), &afpIoMethods}, struct_Mapping{(*int8)(unsafe.Pointer(&[7]int8{'w', 'e', 'b', 'd', 'a', 'v', '\x00'})), &nolockIoMethods}, struct_Mapping{nil, nil}}
	var i int32
	var fsInfo struct_statfs
	var lockInfo struct_flock
	if !(filePath != nil) {
		return &nolockIoMethods
	}
	if statfs(filePath, &fsInfo) != -1 {
		if fsInfo.f_flags&uint32(1) != 0 {
			return &nolockIoMethods
		}
		for i = int32(0); (*(*struct_Mapping)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Mapping)(unsafe.Pointer(&aMap)))) + uintptr(i)*16))).zFilesystem != nil; i++ {
			if strcmp((*int8)(unsafe.Pointer(&fsInfo.f_fstypename)), (*(*struct_Mapping)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Mapping)(unsafe.Pointer(&aMap)))) + uintptr(i)*16))).zFilesystem) == 0 {
				return (*(*struct_Mapping)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Mapping)(unsafe.Pointer(&aMap)))) + uintptr(i)*16))).pMethods
			}
		}
	}
	lockInfo.l_len = int64(1)
	lockInfo.l_start = int64(0)
	lockInfo.l_whence = int16(0)
	lockInfo.l_type = int16(1)
	if (func(int32, int32, ...interface {
	}) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(7)*24))).pCurrent)(pNew.h, 7, &lockInfo) != -1 {
		if strcmp((*int8)(unsafe.Pointer(&fsInfo.f_fstypename)), (*int8)(unsafe.Pointer(&[4]int8{'n', 'f', 's', '\x00'}))) == 0 {
			return &nfsIoMethods
		} else {
			return &posixIoMethods
		}
	} else {
		return &dotlockIoMethods
	}
}

var autolockIoFinder func(*int8, *struct_unixFile) *struct_sqlite3_io_methods = autolockIoFinderImpl

type finder_type = func(*int8, *struct_unixFile) *struct_sqlite3_io_methods

func fillInUnixFile(pVfs *struct_sqlite3_vfs, h int32, pId *struct_sqlite3_file, zFilename *int8, ctrlFlags int32) int32 {
	var pLockingStyle *struct_sqlite3_io_methods
	var pNew *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(pId))
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pNew.h = h
	pNew.pVfs = pVfs
	pNew.zPath = zFilename
	pNew.ctrlFlags = uint16(uint8(ctrlFlags))
	pNew.mmapSizeMax = sqlite3Config.szMmap
	if sqlite3_uri_boolean(func() *int8 {
		if ctrlFlags&64 != 0 {
			return zFilename
		} else {
			return nil
		}
	}(), (*int8)(unsafe.Pointer(&[5]int8{'p', 's', 'o', 'w', '\x00'})), 1) != 0 {
		pNew.ctrlFlags |= uint16(16)
	}
	if strcmp(pVfs.zName, (*int8)(unsafe.Pointer(&[10]int8{'u', 'n', 'i', 'x', '-', 'e', 'x', 'c', 'l', '\x00'}))) == 0 {
		pNew.ctrlFlags |= uint16(1)
	}
	if ctrlFlags&128 != 0 {
		pLockingStyle = &nolockIoMethods
	} else {
		pLockingStyle = (*(*func(*int8, *struct_unixFile) *struct_sqlite3_io_methods)(pVfs.pAppData))(zFilename, pNew)
		pNew.lockingContext = unsafe.Pointer(zFilename)
	}
	if uintptr(unsafe.Pointer(pLockingStyle)) == uintptr(unsafe.Pointer(&posixIoMethods)) || uintptr(unsafe.Pointer(pLockingStyle)) == uintptr(unsafe.Pointer(&nfsIoMethods)) {
		unixEnterMutex()
		rc = findInodeInfo(pNew, &pNew.pInode)
		if rc != 0 {
			robust_close(pNew, h, 40494)
			h = int32(-1)
		}
		unixLeaveMutex()
	} else if uintptr(unsafe.Pointer(pLockingStyle)) == uintptr(unsafe.Pointer(&afpIoMethods)) {
		var pCtx *struct_afpLockingContext
		pNew.lockingContext = unsafe.Pointer(func() (_cgo_ret *struct_afpLockingContext) {
			_cgo_addr := &pCtx
			*_cgo_addr = (*struct_afpLockingContext)(sqlite3_malloc64(uint64(16)))
			return *_cgo_addr
		}())
		if uintptr(unsafe.Pointer(pCtx)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
		} else {
			pCtx.dbPath = zFilename
			pCtx.reserved = int32(0)
			srandomdev()
			unixEnterMutex()
			rc = findInodeInfo(pNew, &pNew.pInode)
			if rc != 0 {
				sqlite3_free(pNew.lockingContext)
				robust_close(pNew, h, 40520)
				h = int32(-1)
			}
			unixLeaveMutex()
		}
	} else if uintptr(unsafe.Pointer(pLockingStyle)) == uintptr(unsafe.Pointer(&dotlockIoMethods)) {
		var zLockFile *int8
		var nFilename int32
		func() int {
			_ = 0
			return 0
		}()
		nFilename = int32(strlen(zFilename)) + 6
		zLockFile = (*int8)(sqlite3_malloc64(uint64(nFilename)))
		if uintptr(unsafe.Pointer(zLockFile)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
		} else {
			sqlite3_snprintf(nFilename, zLockFile, (*int8)(unsafe.Pointer(&[8]int8{'%', 's', '.', 'l', 'o', 'c', 'k', '\x00'})), zFilename)
		}
		pNew.lockingContext = unsafe.Pointer(zLockFile)
	}
	storeLastErrno(pNew, 0)
	if rc != 0 {
		if h >= 0 {
			robust_close(pNew, h, 40579)
		}
	} else {
		pId.pMethods = pLockingStyle
		verifyDbFile(pNew)
	}
	return rc
}

var azTempDirs [6]*int8 = [6]*int8{nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'/', 'v', 'a', 'r', '/', 't', 'm', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'/', 'u', 's', 'r', '/', 't', 'm', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'/', 't', 'm', 'p', '\x00'})), (*int8)(unsafe.Pointer(&[2]int8{'.', '\x00'}))}

func unixTempFileInit() {
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azTempDirs)))) + uintptr(0)*8)) = getenv((*int8)(unsafe.Pointer(&[14]int8{'S', 'Q', 'L', 'I', 'T', 'E', '_', 'T', 'M', 'P', 'D', 'I', 'R', '\x00'})))
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azTempDirs)))) + uintptr(1)*8)) = getenv((*int8)(unsafe.Pointer(&[7]int8{'T', 'M', 'P', 'D', 'I', 'R', '\x00'})))
}
func unixTempFileDir() *int8 {
	var i uint32 = uint32(0)
	var buf struct_stat
	var zDir *int8 = sqlite3_temp_directory
	for 1 != 0 {
		if uintptr(unsafe.Pointer(zDir)) != uintptr(unsafe.Pointer(nil)) && (func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(4)*24))).pCurrent)(zDir, &buf) == 0 && int32(buf.st_mode)&61440 == 16384 && (func(*int8, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(2)*24))).pCurrent)(zDir, 3) == 0 {
			return zDir
		}
		if uint(i) >= 48/8 {
			break
		}
		zDir = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azTempDirs)))) + uintptr(func() (_cgo_ret uint32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*8))
	}
	return (*int8)(nil)
}
func unixGetTempname(nBuf int32, zBuf *int8) int32 {
	var zDir *int8
	var iLimit int32 = 0
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(0))) = int8(0)
	zDir = unixTempFileDir()
	if uintptr(unsafe.Pointer(zDir)) == uintptr(unsafe.Pointer(nil)) {
		return int32(10 | 25<<8)
	}
	for {
		var r uint64
		sqlite3_randomness(int32(8), unsafe.Pointer(&r))
		func() int {
			_ = 0
			return 0
		}()
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(nBuf-2))) = int8(0)
		sqlite3_snprintf(nBuf, zBuf, (*int8)(unsafe.Pointer(&[17]int8{'%', 's', '/', 'e', 't', 'i', 'l', 'q', 's', '_', '%', 'l', 'l', 'x', '%', 'c', '\x00'})), zDir, r, 0)
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(nBuf-2)))) != 0 || func() (_cgo_ret int32) {
			_cgo_addr := &iLimit
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}() > 10 {
			return int32(1)
		}
		if !((func(*int8, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(2)*24))).pCurrent)(zBuf, 0) == 0) {
			break
		}
	}
	return int32(0)
}
func findReusableFd(zPath *int8, flags int32) *struct_UnixUnusedFd {
	var pUnused *struct_UnixUnusedFd = nil
	var sStat struct_stat
	unixEnterMutex()
	if uintptr(unsafe.Pointer(inodeList)) != uintptr(unsafe.Pointer(nil)) && 0 == (func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(4)*24))).pCurrent)(zPath, &sStat) {
		var pInode *struct_unixInodeInfo
		pInode = inodeList
		for pInode != nil && (pInode.fileId.dev != sStat.st_dev || pInode.fileId.ino != uint64(sStat.st_ino)) {
			pInode = pInode.pNext
		}
		if pInode != nil {
			var pp **struct_UnixUnusedFd
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_mutex_enter(pInode.pLockMutex)
			flags &= int32(1 | 2)
			for pp = &pInode.pUnused; *pp != nil && (*pp).flags != flags; pp = &(*pp).pNext {
			}
			pUnused = *pp
			if pUnused != nil {
				*pp = pUnused.pNext
			}
			sqlite3_mutex_leave(pInode.pLockMutex)
		}
	}
	unixLeaveMutex()
	return pUnused
}
func getFileMode(zFile *int8, pMode *uint16, pUid *uint32, pGid *uint32) int32 {
	var sStat struct_stat
	var rc int32 = 0
	if 0 == (func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(4)*24))).pCurrent)(zFile, &sStat) {
		*pMode = uint16(int32(sStat.st_mode) & 511)
		*pUid = sStat.st_uid
		*pGid = sStat.st_gid
	} else {
		rc = int32(10 | 7<<8)
	}
	return rc
}
func findCreateFileMode(zPath *int8, flags int32, pMode *uint16, pUid *uint32, pGid *uint32) int32 {
	var rc int32 = 0
	*pMode = uint16(0)
	*pUid = uint32(0)
	*pGid = uint32(0)
	if flags&(524288|2048) != 0 {
		var zDb [513]int8
		var nDb int32
		nDb = sqlite3Strlen30(zPath) - 1
		for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(nDb)))) != '-' {
			if nDb == 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(nDb)))) == '.' {
				return int32(0)
			}
			nDb--
		}
		__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&zDb))), unsafe.Pointer(zPath), uint(nDb), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&zDb))), 0))
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zDb)))) + uintptr(nDb))) = int8('\x00')
		rc = getFileMode((*int8)(unsafe.Pointer(&zDb)), pMode, pUid, pGid)
	} else if flags&8 != 0 {
		*pMode = uint16(384)
	} else if flags&64 != 0 {
		var z *int8 = sqlite3_uri_parameter(zPath, (*int8)(unsafe.Pointer(&[7]int8{'m', 'o', 'd', 'e', 'o', 'f', '\x00'})))
		if z != nil {
			rc = getFileMode(z, pMode, pUid, pGid)
		}
	}
	return rc
}
func unixOpen(pVfs *struct_sqlite3_vfs, zPath *int8, pFile *struct_sqlite3_file, flags int32, pOutFlags *int32) int32 {
	var p *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(pFile))
	var fd int32 = -1
	var openFlags int32 = 0
	var eType int32 = flags & 1048320
	var noLock int32
	var rc int32 = 0
	var ctrlFlags int32 = 0
	var isExclusive int32 = flags & 16
	var isDelete int32 = flags & 8
	var isCreate int32 = flags & 4
	var isReadonly int32 = flags & 1
	var isReadWrite int32 = flags & 2
	var isAutoProxy int32 = flags & 32
	var fsInfo struct_statfs
	var isNewJrnl int32 = func() int32 {
		if isCreate != 0 && (eType == 16384 || eType == 2048 || eType == 524288) {
			return 1
		} else {
			return 0
		}
	}()
	var zTmpname [514]int8
	var zName *int8 = zPath
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if randomnessPid != int32(getpid()) {
		randomnessPid = int32(getpid())
		sqlite3_randomness(0, nil)
	}
	__builtin___memset_chk(unsafe.Pointer(p), 0, 128, __builtin_object_size(unsafe.Pointer(p), 0))
	if eType == 256 {
		var pUnused *struct_UnixUnusedFd
		pUnused = findReusableFd(zName, flags)
		if pUnused != nil {
			fd = pUnused.fd
		} else {
			pUnused = (*struct_UnixUnusedFd)(sqlite3_malloc64(uint64(16)))
			if !(pUnused != nil) {
				return int32(7)
			}
		}
		p.pPreallocatedUnused = pUnused
		func() int {
			_ = 0
			return 0
		}()
	} else if !(zName != nil) {
		func() int {
			_ = 0
			return 0
		}()
		rc = unixGetTempname(pVfs.mxPathname, (*int8)(unsafe.Pointer(&zTmpname)))
		if rc != 0 {
			return rc
		}
		zName = (*int8)(unsafe.Pointer(&zTmpname))
		func() int {
			_ = 0
			return 0
		}()
	}
	if isReadonly != 0 {
		openFlags |= int32(0)
	}
	if isReadWrite != 0 {
		openFlags |= int32(2)
	}
	if isCreate != 0 {
		openFlags |= int32(512)
	}
	if isExclusive != 0 {
		openFlags |= int32(2048 | 256)
	}
	openFlags |= int32(0 | 0 | 256)
	if fd < 0 {
		var openMode uint16
		var uid uint32
		var gid uint32
		rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid)
		if rc != 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			return rc
		}
		fd = robust_open(zName, openFlags, openMode)
		func() int {
			_ = 0
			return 0
		}()
		if fd < 0 {
			if isNewJrnl != 0 && *__error() == 13 && (func(*int8, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(2)*24))).pCurrent)(zName, 0) != 0 {
				rc = int32(8 | 6<<8)
			} else if *__error() != 21 && isReadWrite != 0 {
				flags &= int32(^(2 | 4))
				openFlags &= int32(^(2 | 512))
				flags |= int32(1)
				openFlags |= int32(0)
				isReadonly = int32(1)
				fd = robust_open(zName, openFlags, openMode)
			}
		}
		if fd < 0 {
			var rc2 int32 = unixLogErrorAtLine(sqlite3CantopenError(41008), (*int8)(unsafe.Pointer(&[5]int8{'o', 'p', 'e', 'n', '\x00'})), zName, 41008)
			if rc == 0 {
				rc = rc2
			}
			goto open_finished
		}
		if int32(openMode) != 0 && flags&(524288|2048) != 0 {
			robustFchown(fd, uid, gid)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if pOutFlags != nil {
		*pOutFlags = flags
	}
	if p.pPreallocatedUnused != nil {
		p.pPreallocatedUnused.fd = fd
		p.pPreallocatedUnused.flags = flags & (1 | 2)
	}
	if isDelete != 0 {
		(func(*int8) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(16)*24))).pCurrent)(zName)
	} else {
		p.openFlags = openFlags
	}
	if fstatfs(fd, &fsInfo) == -1 {
		storeLastErrno(p, *__error())
		robust_close(p, fd, 41062)
		return int32(10 | 13<<8)
	}
	if 0 == strncmp((*int8)(unsafe.Pointer(&[6]int8{'m', 's', 'd', 'o', 's', '\x00'})), (*int8)(unsafe.Pointer(&fsInfo.f_fstypename)), uint(5)) {
		(*struct_unixFile)(unsafe.Pointer(pFile)).fsFlags |= uint32(1)
	}
	if 0 == strncmp((*int8)(unsafe.Pointer(&[6]int8{'e', 'x', 'f', 'a', 't', '\x00'})), (*int8)(unsafe.Pointer(&fsInfo.f_fstypename)), uint(5)) {
		(*struct_unixFile)(unsafe.Pointer(pFile)).fsFlags |= uint32(1)
	}
	if isDelete != 0 {
		ctrlFlags |= int32(32)
	}
	if isReadonly != 0 {
		ctrlFlags |= int32(2)
	}
	noLock = func() int32 {
		if eType != 256 {
			return 1
		} else {
			return 0
		}
	}()
	if noLock != 0 {
		ctrlFlags |= int32(128)
	}
	if isNewJrnl != 0 {
		ctrlFlags |= int32(8)
	}
	if flags&64 != 0 {
		ctrlFlags |= int32(64)
	}
	if isAutoProxy != 0 && uintptr(unsafe.Pointer(zPath)) != uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(0)))) && !(noLock != 0) && pVfs.xOpen != nil {
		var envforce *int8 = getenv((*int8)(unsafe.Pointer(&[27]int8{'S', 'Q', 'L', 'I', 'T', 'E', '_', 'F', 'O', 'R', 'C', 'E', '_', 'P', 'R', 'O', 'X', 'Y', '_', 'L', 'O', 'C', 'K', 'I', 'N', 'G', '\x00'})))
		var useProxy int32 = 0
		if uintptr(unsafe.Pointer(envforce)) != uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(0)))) {
			useProxy = func() int32 {
				if atoi(envforce) > 0 {
					return 1
				} else {
					return 0
				}
			}()
		} else {
			useProxy = func() int32 {
				if !(fsInfo.f_flags&uint32(4096) != 0) {
					return 1
				} else {
					return 0
				}
			}()
		}
		if useProxy != 0 {
			rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags)
			if rc == 0 {
				rc = proxyTransformUnixFile((*struct_unixFile)(unsafe.Pointer(pFile)), (*int8)(unsafe.Pointer(&[7]int8{':', 'a', 'u', 't', 'o', ':', '\x00'})))
				if rc != 0 {
					unixClose(pFile)
					return rc
				}
			}
			goto open_finished
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags)
open_finished:
	if rc != 0 {
		sqlite3_free(unsafe.Pointer(p.pPreallocatedUnused))
	}
	return rc
}
func unixDelete(NotUsed *struct_sqlite3_vfs, zPath *int8, dirSync int32) int32 {
	var rc int32 = 0
	func() int {
		_ = NotUsed
		return 0
	}()
	if (func(*int8) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(16)*24))).pCurrent)(zPath) == -1 {
		if *__error() == 2 {
			rc = int32(10 | 23<<8)
		} else {
			rc = unixLogErrorAtLine(10|10<<8, (*int8)(unsafe.Pointer(&[7]int8{'u', 'n', 'l', 'i', 'n', 'k', '\x00'})), zPath, 41147)
		}
		return rc
	}
	if dirSync&1 != 0 {
		var fd int32
		rc = (func(*int8, *int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(17)*24))).pCurrent)(zPath, &fd)
		if rc == 0 {
			if full_fsync(fd, 0, 0) != 0 {
				rc = unixLogErrorAtLine(10|5<<8, (*int8)(unsafe.Pointer(&[6]int8{'f', 's', 'y', 'n', 'c', '\x00'})), zPath, 41157)
			}
			robust_close(nil, fd, 41159)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			rc = int32(0)
		}
	}
	return rc
}
func unixAccess(NotUsed *struct_sqlite3_vfs, zPath *int8, flags int32, pResOut *int32) int32 {
	func() int {
		_ = NotUsed
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if flags == 0 {
		var buf struct_stat
		*pResOut = func() int32 {
			if 0 == (func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(4)*24))).pCurrent)(zPath, &buf) && (!(int32(buf.st_mode)&61440 == 32768) || buf.st_size > int64(0)) {
				return 1
			} else {
				return 0
			}
		}()
	} else {
		*pResOut = func() int32 {
			if (func(*int8, int32) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(2)*24))).pCurrent)(zPath, 1<<1|1<<2) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	return int32(0)
}
func unixBackupDir(z *int8, pJ *int32) int32 {
	var j int32 = *pJ
	var i int32
	if j <= 0 {
		return int32(0)
	}
	for i = j - 1; i > 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i-1)))) != '/'; i-- {
	}
	if i == 0 {
		return int32(0)
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == '.' && i == j-2 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))) == '.' {
		return int32(0)
	}
	*pJ = i - 1
	return int32(1)
}
func mkFullPathname(zPath *int8, zOut *int8, nOut int32) int32 {
	var nPath int32 = sqlite3Strlen30(zPath)
	var iOff int32 = 0
	var i int32
	var j int32
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) != '/' {
		if uintptr(unsafe.Pointer((func(*int8, uint) *int8)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(3)*24))).pCurrent)(zOut, uint(nOut-2)))) == uintptr(unsafe.Pointer(nil)) {
			return unixLogErrorAtLine(sqlite3CantopenError(41236), (*int8)(unsafe.Pointer(&[7]int8{'g', 'e', 't', 'c', 'w', 'd', '\x00'})), zPath, 41236)
		}
		iOff = sqlite3Strlen30(zOut)
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &iOff
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('/')
	}
	if iOff+nPath+1 > nOut {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(iOff))) = int8('\x00')
		return sqlite3CantopenError(41245)
	}
	sqlite3_snprintf(nOut-iOff, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(iOff))), (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zPath)
	for i = func() (_cgo_ret int32) {
		_cgo_addr := &j
		*_cgo_addr = int32(1)
		return *_cgo_addr
	}(); *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i))) != 0; i++ {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &j
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i)))
		for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i)))) == '/' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i+1)))) == '/' {
			i++
		}
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j))) = int8(0)
	func() int {
		_ = 0
		return 0
	}()
	for i = func() (_cgo_ret int32) {
		_cgo_addr := &j
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}(); *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i)))) == '/' {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i+1)))) == '.' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i+2)))) == '/' {
				i += int32(1)
				continue
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i+1)))) == '.' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i+2)))) == '.' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i+3)))) == '/' && unixBackupDir(zOut, &j) != 0 {
				i += int32(2)
				continue
			}
		}
		if j >= 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(i)))
		}
		j++
	}
	if j == 0 {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &j
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('/')
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j))) = int8(0)
	return int32(0)
}
func unixFullPathname(pVfs *struct_sqlite3_vfs, zPath *int8, nOut int32, zOut *int8) int32 {
	var rc int32 = 0
	var nByte int32
	var nLink int32 = 0
	var zIn *int8 = zPath
	var zDel *int8 = nil
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = pVfs
		return 0
	}()
	for {
		var bLink int32 = 0
		var buf struct_stat
		if (func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(27)*24))).pCurrent)(zIn, &buf) != 0 {
			if *__error() != 2 {
				rc = unixLogErrorAtLine(sqlite3CantopenError(41328), (*int8)(unsafe.Pointer(&[6]int8{'l', 's', 't', 'a', 't', '\x00'})), zIn, 41328)
			}
		} else {
			bLink = func() int32 {
				if int32(buf.st_mode)&61440 == 40960 {
					return 1
				} else {
					return 0
				}
			}()
		}
		if bLink != 0 {
			nLink++
			if uintptr(unsafe.Pointer(zDel)) == uintptr(unsafe.Pointer(nil)) {
				zDel = (*int8)(sqlite3_malloc(nOut))
				if uintptr(unsafe.Pointer(zDel)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
				}
			} else if nLink >= 100 {
				rc = sqlite3CantopenError(41340)
			}
			if rc == 0 {
				nByte = int32((func(*int8, *int8, uint) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(26)*24))).pCurrent)(zIn, zDel, uint(nOut-1)))
				if nByte < 0 {
					rc = unixLogErrorAtLine(sqlite3CantopenError(41346), (*int8)(unsafe.Pointer(&[9]int8{'r', 'e', 'a', 'd', 'l', 'i', 'n', 'k', '\x00'})), zIn, 41346)
				} else {
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDel)) + uintptr(0)))) != '/' {
						var n int32
						for n = sqlite3Strlen30(zIn); n > 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(n-1)))) != '/'; n-- {
						}
						if nByte+n+1 > nOut {
							rc = sqlite3CantopenError(41352)
						} else {
							__builtin___memmove_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDel)) + uintptr(n)))), unsafe.Pointer(zDel), uint(nByte+1), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDel)) + uintptr(n)))), 0))
							__builtin___memcpy_chk(unsafe.Pointer(zDel), unsafe.Pointer(zIn), uint(n), __builtin_object_size(unsafe.Pointer(zDel), 0))
							nByte += n
						}
					}
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDel)) + uintptr(nByte))) = int8('\x00')
				}
			}
			zIn = zDel
		}
		func() int {
			_ = 0
			return 0
		}()
		if rc == 0 && uintptr(unsafe.Pointer(zIn)) != uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(zOut)))) {
			rc = mkFullPathname(zIn, zOut, nOut)
		}
		if bLink == 0 {
			break
		}
		zIn = zOut
		if !(rc == 0) {
			break
		}
	}
	sqlite3_free(unsafe.Pointer(zDel))
	if rc == 0 && nLink != 0 {
		rc = int32(0 | 2<<8)
	}
	return rc
}

type struct_dl_info struct {
	dli_fname *int8
	dli_fbase unsafe.Pointer
	dli_sname *int8
	dli_saddr unsafe.Pointer
}
type Dl_info = struct_dl_info

func unixDlOpen(NotUsed *struct_sqlite3_vfs, zFilename *int8) unsafe.Pointer {
	func() int {
		_ = NotUsed
		return 0
	}()
	return dlopen(zFilename, 2|8)
}
func unixDlError(NotUsed *struct_sqlite3_vfs, nBuf int32, zBufOut *int8) {
	var zErr *int8
	func() int {
		_ = NotUsed
		return 0
	}()
	unixEnterMutex()
	zErr = dlerror()
	if zErr != nil {
		sqlite3_snprintf(nBuf, zBufOut, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zErr)
	}
	unixLeaveMutex()
}
func unixDlSym(NotUsed *struct_sqlite3_vfs, p unsafe.Pointer, zSym *int8) func() {
	var x func(unsafe.Pointer, *int8) func()
	func() int {
		_ = NotUsed
		return 0
	}()
	x = (func(unsafe.Pointer, *int8) func())(dlsym)
	return x(p, zSym)
}
func unixDlClose(NotUsed *struct_sqlite3_vfs, pHandle unsafe.Pointer) {
	func() int {
		_ = NotUsed
		return 0
	}()
	dlclose(pHandle)
}
func unixRandomness(NotUsed *struct_sqlite3_vfs, nBuf int32, zBuf *int8) int32 {
	func() int {
		_ = NotUsed
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(zBuf), 0, uint(nBuf), __builtin_object_size(unsafe.Pointer(zBuf), 0))
	randomnessPid = int32(getpid())
	{
		var fd int32
		var got int32
		fd = robust_open((*int8)(unsafe.Pointer(&[13]int8{'/', 'd', 'e', 'v', '/', 'u', 'r', 'a', 'n', 'd', 'o', 'm', '\x00'})), 0, uint16(0))
		if fd < 0 {
			var t int
			time(&t)
			__builtin___memcpy_chk(unsafe.Pointer(zBuf), unsafe.Pointer(&t), 8, __builtin_object_size(unsafe.Pointer(zBuf), 0))
			__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(8)))), unsafe.Pointer(&randomnessPid), 4, __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(8)))), 0))
			func() int {
				_ = 0
				return 0
			}()
			nBuf = int32(8 + 4)
		} else {
			for {
				got = int32((func(int32, unsafe.Pointer, uint) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(8)*24))).pCurrent)(fd, unsafe.Pointer(zBuf), uint(nBuf)))
				if !(got < 0 && *__error() == 4) {
					break
				}
			}
			robust_close(nil, fd, 41477)
		}
	}
	return nBuf
}
func unixSleep(NotUsed *struct_sqlite3_vfs, microseconds int32) int32 {
	var seconds int32 = (microseconds + 999999) / 1000000
	sleep(uint32(seconds))
	func() int {
		_ = NotUsed
		return 0
	}()
	return seconds * 1000000
}
func unixCurrentTimeInt64(NotUsed *struct_sqlite3_vfs, piNow *int64) int32 {
	var unixEpoch int64 = int64(24405875) * int64(8640000)
	var rc int32 = 0
	var sNow struct_timeval
	func() int {
		_ = gettimeofday(&sNow, nil)
		return 0
	}()
	*piNow = unixEpoch + int64(1000)*int64(sNow.tv_sec) + int64(sNow.tv_usec/1000)
	func() int {
		_ = NotUsed
		return 0
	}()
	return rc
}
func unixCurrentTime(NotUsed *struct_sqlite3_vfs, prNow *float64) int32 {
	var i int64 = int64(0)
	var rc int32
	func() int {
		_ = NotUsed
		return 0
	}()
	rc = unixCurrentTimeInt64(nil, &i)
	*prNow = float64(i) / 8.64e+7
	return rc
}
func unixGetLastError(NotUsed *struct_sqlite3_vfs, NotUsed2 int32, NotUsed3 *int8) int32 {
	func() int {
		_ = NotUsed
		return 0
	}()
	func() int {
		_ = NotUsed2
		return 0
	}()
	func() int {
		_ = NotUsed3
		return 0
	}()
	return *__error()
}

type proxyLockingContext = struct_proxyLockingContext
type struct_proxyLockingContext struct {
	conchFile         *struct_unixFile
	conchFilePath     *int8
	lockProxy         *struct_unixFile
	lockProxyPath     *int8
	dbPath            *int8
	conchHeld         int32
	nFails            int32
	oldLockingContext unsafe.Pointer
	pOldMethod        *struct_sqlite3_io_methods
}

func proxyGetLockPath(dbPath *int8, lPath *int8, maxLen uint) int32 {
	var len int32
	var dbLen int32
	var i int32
	{
		if !(confstr(65537, lPath, maxLen) != 0) {
			return int32(10 | 15<<8)
		}
		len = int32(__builtin___strlcat_chk(lPath, (*int8)(unsafe.Pointer(&[13]int8{'s', 'q', 'l', 'i', 't', 'e', 'p', 'l', 'o', 'c', 'k', 's', '\x00'})), maxLen, __builtin_object_size(unsafe.Pointer(lPath), func() int32 {
			if true {
				return 1
			} else {
				return 0
			}
		}())))
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(lPath)) + uintptr(len-1)))) != '/' {
		len = int32(__builtin___strlcat_chk(lPath, (*int8)(unsafe.Pointer(&[2]int8{'/', '\x00'})), maxLen, __builtin_object_size(unsafe.Pointer(lPath), func() int32 {
			if true {
				return 1
			} else {
				return 0
			}
		}())))
	}
	dbLen = int32(strlen(dbPath))
	for i = int32(0); i < dbLen && i+len+7 < int32(maxLen); i++ {
		var c int8 = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(dbPath)) + uintptr(i)))
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(lPath)) + uintptr(i+len))) = int8(func() int32 {
			if int32(c) == '/' {
				return '_'
			} else {
				return int32(c)
			}
		}())
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(lPath)) + uintptr(i+len))) = int8('\x00')
	__builtin___strlcat_chk(lPath, (*int8)(unsafe.Pointer(&[7]int8{':', 'a', 'u', 't', 'o', ':', '\x00'})), maxLen, __builtin_object_size(unsafe.Pointer(lPath), func() int32 {
		if true {
			return 1
		} else {
			return 0
		}
	}()))
	return int32(0)
}
func proxyCreateLockPath(lockPath *int8) int32 {
	var i int32
	var len int32
	var buf [1024]int8
	var start int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	len = int32(strlen(lockPath))
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(0))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(lockPath)) + uintptr(0)))
	for i = int32(1); i < len; i++ {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(lockPath)) + uintptr(i)))) == '/' && i-start > 0 {
			if i-start > 2 || i-start == 1 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(start)))) != '.' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(start)))) != '/' || i-start == 2 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(start)))) != '.' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(start+1)))) != '.' {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(i))) = int8('\x00')
				if (func(*int8, uint16) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(18)*24))).pCurrent)((*int8)(unsafe.Pointer(&buf)), uint16(493)) != 0 {
					var err int32 = *__error()
					if err != 17 {
						return err
					}
				}
			}
			start = i + 1
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&buf)))) + uintptr(i))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(lockPath)) + uintptr(i)))
	}
	return int32(0)
}
func proxyCreateUnixFile(path *int8, ppFile **struct_unixFile, islockfile int32) int32 {
	var fd int32 = -1
	var pNew *struct_unixFile
	var rc int32 = 0
	var openFlags int32 = 2 | 512 | 256
	var dummyVfs struct_sqlite3_vfs
	var terrno int32 = 0
	var pUnused *struct_UnixUnusedFd = nil
	pUnused = findReusableFd(path, openFlags)
	if pUnused != nil {
		fd = pUnused.fd
	} else {
		pUnused = (*struct_UnixUnusedFd)(sqlite3_malloc64(uint64(16)))
		if !(pUnused != nil) {
			return int32(7)
		}
	}
	if fd < 0 {
		fd = robust_open(path, openFlags, uint16(0))
		terrno = *__error()
		if fd < 0 && *__error() == 2 && islockfile != 0 {
			if proxyCreateLockPath(path) == 0 {
				fd = robust_open(path, openFlags, uint16(0))
			}
		}
	}
	if fd < 0 {
		openFlags = int32(0 | 256)
		fd = robust_open(path, openFlags, uint16(0))
		terrno = *__error()
	}
	if fd < 0 {
		if islockfile != 0 {
			return int32(5)
		}
		switch terrno {
		case 13:
			return int32(3)
		case 5:
			return int32(10 | 15<<8)
		default:
			return sqlite3CantopenError(41906)
		}
	}
	pNew = (*struct_unixFile)(sqlite3_malloc64(uint64(128)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer((*struct_unixFile)(unsafe.Pointer(0)))) {
		rc = int32(7)
		goto end_create_proxy
	}
	__builtin___memset_chk(unsafe.Pointer(pNew), 0, 128, __builtin_object_size(unsafe.Pointer(pNew), 0))
	pNew.openFlags = openFlags
	__builtin___memset_chk(unsafe.Pointer(&dummyVfs), 0, 168, __builtin_object_size(unsafe.Pointer(&dummyVfs), 0))
	dummyVfs.pAppData = unsafe.Pointer(&autolockIoFinder)
	dummyVfs.zName = (*int8)(unsafe.Pointer(&[6]int8{'d', 'u', 'm', 'm', 'y', '\x00'}))
	pUnused.fd = fd
	pUnused.flags = openFlags
	pNew.pPreallocatedUnused = pUnused
	rc = fillInUnixFile(&dummyVfs, fd, (*struct_sqlite3_file)(unsafe.Pointer(pNew)), path, 0)
	if rc == 0 {
		*ppFile = pNew
		return int32(0)
	}
end_create_proxy:
	robust_close(pNew, fd, 41930)
	sqlite3_free(unsafe.Pointer(pNew))
	sqlite3_free(unsafe.Pointer(pUnused))
	return rc
}
func proxyGetHostID(pHostID *uint8, pError *int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(pHostID), 0, uint(16), __builtin_object_size(unsafe.Pointer(pHostID), 0))
	{
		var timeout struct_timespec = struct_timespec{int(1), int(0)}
		if gethostuuid(pHostID, &timeout) != 0 {
			var err int32 = *__error()
			if pError != nil {
				*pError = err
			}
			return int32(10)
		}
	}
	return int32(0)
}
func proxyBreakConchLock(pFile *struct_unixFile, myHostID *uint8) int32 {
	var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
	var conchFile *struct_unixFile = pCtx.conchFile
	var tPath [1024]int8
	var buf [1041]int8
	var cPath *int8 = pCtx.conchFilePath
	var readLen uint = uint(0)
	var pathLen uint = uint(0)
	var errmsg [64]int8 = [64]int8{'\x00'}
	var fd int32 = -1
	var rc int32 = -1
	func() int {
		_ = myHostID
		return 0
	}()
	pathLen = __builtin___strlcpy_chk((*int8)(unsafe.Pointer(&tPath)), cPath, uint(1024), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&tPath))), func() int32 {
		if true {
			return 1
		} else {
			return 0
		}
	}()))
	if pathLen > uint(1024) || pathLen < uint(6) || __builtin___strlcpy_chk(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&tPath)))) + uintptr(pathLen-uint(5)))), (*int8)(unsafe.Pointer(&[6]int8{'b', 'r', 'e', 'a', 'k', '\x00'})), uint(6), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&tPath)))) + uintptr(pathLen-uint(5))))), func() int32 {
		if true {
			return 1
		} else {
			return 0
		}
	}())) != uint(5) {
		sqlite3_snprintf(int32(64), (*int8)(unsafe.Pointer(&errmsg)), (*int8)(unsafe.Pointer(&[20]int8{'p', 'a', 't', 'h', ' ', 'e', 'r', 'r', 'o', 'r', ' ', '(', 'l', 'e', 'n', ' ', '%', 'd', ')', '\x00'})), int32(pathLen))
		goto end_breaklock
	}
	readLen = uint((func(int32, unsafe.Pointer, uint, int64) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(9)*24))).pCurrent)(conchFile.h, unsafe.Pointer((*int8)(unsafe.Pointer(&buf))), uint(1+16+1024), int64(0)))
	if readLen < uint(1+16) {
		sqlite3_snprintf(int32(64), (*int8)(unsafe.Pointer(&errmsg)), (*int8)(unsafe.Pointer(&[20]int8{'r', 'e', 'a', 'd', ' ', 'e', 'r', 'r', 'o', 'r', ' ', '(', 'l', 'e', 'n', ' ', '%', 'd', ')', '\x00'})), int32(readLen))
		goto end_breaklock
	}
	fd = robust_open((*int8)(unsafe.Pointer(&tPath)), 2|512|2048|256, uint16(0))
	if fd < 0 {
		sqlite3_snprintf(int32(64), (*int8)(unsafe.Pointer(&errmsg)), (*int8)(unsafe.Pointer(&[19]int8{'c', 'r', 'e', 'a', 't', 'e', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ' ', '(', '%', 'd', ')', '\x00'})), *__error())
		goto end_breaklock
	}
	if (func(int32, unsafe.Pointer, uint, int64) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(12)*24))).pCurrent)(fd, unsafe.Pointer((*int8)(unsafe.Pointer(&buf))), readLen, int64(0)) != int(readLen) {
		sqlite3_snprintf(int32(64), (*int8)(unsafe.Pointer(&errmsg)), (*int8)(unsafe.Pointer(&[18]int8{'w', 'r', 'i', 't', 'e', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ' ', '(', '%', 'd', ')', '\x00'})), *__error())
		goto end_breaklock
	}
	if rename((*int8)(unsafe.Pointer(&tPath)), cPath) != 0 {
		sqlite3_snprintf(int32(64), (*int8)(unsafe.Pointer(&errmsg)), (*int8)(unsafe.Pointer(&[19]int8{'r', 'e', 'n', 'a', 'm', 'e', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ' ', '(', '%', 'd', ')', '\x00'})), *__error())
		goto end_breaklock
	}
	rc = int32(0)
	fprintf(__stderrp, (*int8)(unsafe.Pointer(&[24]int8{'b', 'r', 'o', 'k', 'e', ' ', 's', 't', 'a', 'l', 'e', ' ', 'l', 'o', 'c', 'k', ' ', 'o', 'n', ' ', '%', 's', '\n', '\x00'})), cPath)
	robust_close(pFile, conchFile.h, 42033)
	conchFile.h = fd
	conchFile.openFlags = int32(2 | 512)
end_breaklock:
	if rc != 0 {
		if fd >= 0 {
			(func(*int8) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(16)*24))).pCurrent)((*int8)(unsafe.Pointer(&tPath)))
			robust_close(pFile, fd, 42041)
		}
		fprintf(__stderrp, (*int8)(unsafe.Pointer(&[38]int8{'f', 'a', 'i', 'l', 'e', 'd', ' ', 't', 'o', ' ', 'b', 'r', 'e', 'a', 'k', ' ', 's', 't', 'a', 'l', 'e', ' ', 'l', 'o', 'c', 'k', ' ', 'o', 'n', ' ', '%', 's', ',', ' ', '%', 's', '\n', '\x00'})), cPath, (*int8)(unsafe.Pointer(&errmsg)))
	}
	return rc
}
func proxyConchLock(pFile *struct_unixFile, myHostID *uint8, lockType int32) int32 {
	var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
	var conchFile *struct_unixFile = pCtx.conchFile
	var rc int32 = 0
	var nTries int32 = 0
	var conchModTime struct_timespec
	__builtin___memset_chk(unsafe.Pointer(&conchModTime), 0, 16, __builtin_object_size(unsafe.Pointer(&conchModTime), 0))
	for {
		rc = conchFile.pMethod.xLock((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), lockType)
		nTries++
		if rc == 5 {
			var buf struct_stat
			if (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(conchFile.h, &buf) != 0 {
				storeLastErrno(pFile, *__error())
				return int32(10 | 15<<8)
			}
			if nTries == 1 {
				conchModTime = buf.st_mtimespec
				unixSleep(nil, 500000)
				continue
			}
			func() int {
				_ = 0
				return 0
			}()
			if conchModTime.tv_sec != buf.st_mtimespec.tv_sec || conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec {
				return int32(5)
			}
			if nTries == 2 {
				var tBuf [1041]int8
				var len int32 = int32((func(int32, unsafe.Pointer, uint, int64) int)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(9)*24))).pCurrent)(conchFile.h, unsafe.Pointer((*int8)(unsafe.Pointer(&tBuf))), uint(1+16+1024), int64(0)))
				if len < 0 {
					storeLastErrno(pFile, *__error())
					return int32(10 | 15<<8)
				}
				if len > 1+16 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&tBuf)))) + uintptr(0)))) == int32(int8(2)) {
					if 0 != memcmp(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&tBuf)))) + uintptr(1)))), unsafe.Pointer(myHostID), uint(16)) {
						return int32(5)
					}
				} else {
					return int32(5)
				}
				unixSleep(nil, 10000000)
				continue
			}
			func() int {
				_ = 0
				return 0
			}()
			if 0 == proxyBreakConchLock(pFile, myHostID) {
				rc = int32(0)
				if lockType == 4 {
					rc = conchFile.pMethod.xLock((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), 1)
				}
				if !(rc != 0) {
					rc = conchFile.pMethod.xLock((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), lockType)
				}
			}
		}
		if !(rc == 5 && nTries < 3) {
			break
		}
	}
	return rc
}
func proxyTakeConch(pFile *struct_unixFile) int32 {

	var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
	if pCtx.conchHeld != 0 {
		return int32(0)
	} else {
		var conchFile *struct_unixFile = pCtx.conchFile
		var myHostID [16]uint8
		var pError int32 = 0
		var readBuf [1041]int8
		var lockPath [1024]int8
		var tempLockPath *int8 = nil
		var rc int32 = 0
		var createConch int32 = 0
		var hostIdMatch int32 = 0
		var readLen int32 = 0
		var tryOldLockPath int32 = 0
		var forceNewLockPath int32 = 0
		rc = proxyGetHostID((*uint8)(unsafe.Pointer(&myHostID)), &pError)
		if !(rc&255 == 10) {
			goto _cgol_1
		}
		storeLastErrno(pFile, pError)
		goto end_takeconch
	_cgol_1:
		rc = proxyConchLock(pFile, (*uint8)(unsafe.Pointer(&myHostID)), 1)
		if !(rc != 0) {
			goto _cgol_2
		}
		goto end_takeconch
	_cgol_2:
		readLen = seekAndRead((*struct_unixFile)(unsafe.Pointer(conchFile)), int64(0), unsafe.Pointer((*int8)(unsafe.Pointer(&readBuf))), 1+16+1024)
		if !(readLen < 0) {
			goto _cgol_4
		}
		storeLastErrno(pFile, conchFile.lastErrno)
		rc = int32(10 | 1<<8)
		goto end_takeconch
		goto _cgol_3
	_cgol_4:
		if readLen <= 1+16 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&readBuf)))) + uintptr(0)))) != int32(int8(2)) {
			createConch = int32(1)
		}
	_cgol_3:
		;
	_cgol_5:
		if !(createConch != 0) && !(forceNewLockPath != 0) {
			hostIdMatch = func() int32 {
				if !(memcmp(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&readBuf)))) + uintptr(1)))), unsafe.Pointer((*uint8)(unsafe.Pointer(&myHostID))), uint(16)) != 0) {
					return 1
				} else {
					return 0
				}
			}()
			if !(pCtx.lockProxyPath != nil) {
				if hostIdMatch != 0 {
					var pathLen uint = uint(readLen - (1 + 16))
					if pathLen >= uint(1024) {
						pathLen = uint(1024 - 1)
					}
					__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&lockPath))), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&readBuf)))) + uintptr(1+16)))), pathLen, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&lockPath))), 0))
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&lockPath)))) + uintptr(pathLen))) = int8(0)
					tempLockPath = (*int8)(unsafe.Pointer(&lockPath))
					tryOldLockPath = int32(1)
					goto end_takeconch
				}
			} else if hostIdMatch != 0 && !(strncmp(pCtx.lockProxyPath, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&readBuf)))) + uintptr(1+16))), uint(readLen-(1+16))) != 0) {
				goto end_takeconch
			}
		}
		if conchFile.openFlags&2 == 0 {
			rc = int32(5)
			goto end_takeconch
		}
		if !(pCtx.lockProxyPath != nil) {
			proxyGetLockPath(pCtx.dbPath, (*int8)(unsafe.Pointer(&lockPath)), uint(1024))
			tempLockPath = (*int8)(unsafe.Pointer(&lockPath))
		}
		futimes(conchFile.h, nil)
		if hostIdMatch != 0 && !(createConch != 0) {
			if conchFile.pInode != nil && conchFile.pInode.nShared > 1 {
				rc = int32(5)
			} else {
				rc = proxyConchLock(pFile, (*uint8)(unsafe.Pointer(&myHostID)), 4)
			}
		} else {
			rc = proxyConchLock(pFile, (*uint8)(unsafe.Pointer(&myHostID)), 4)
		}
		if rc == 0 {
			var writeBuffer [1041]int8
			var writeSize int32 = 0
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(0))) = int8(2)
			__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1)))), unsafe.Pointer((*uint8)(unsafe.Pointer(&myHostID))), uint(16), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1)))), 0))
			if uintptr(unsafe.Pointer(pCtx.lockProxyPath)) != uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(0)))) {
				__builtin___strlcpy_chk(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1+16))), pCtx.lockProxyPath, uint(1024), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1+16)))), func() int32 {
					if true {
						return 1
					} else {
						return 0
					}
				}()))
			} else {
				__builtin___strlcpy_chk(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1+16))), tempLockPath, uint(1024), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1+16)))), func() int32 {
					if true {
						return 1
					} else {
						return 0
					}
				}()))
			}
			writeSize = int32(uint(1+16) + strlen(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer)))) + uintptr(1+16)))))
			robust_ftruncate(conchFile.h, int64(writeSize))
			rc = unixWrite((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), unsafe.Pointer((*int8)(unsafe.Pointer(&writeBuffer))), writeSize, int64(0))
			full_fsync(conchFile.h, 0, 0)
			if rc == 0 && createConch != 0 {
				var buf struct_stat
				var err int32 = (func(int32, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(5)*24))).pCurrent)(pFile.h, &buf)
				if err == 0 {
					var cmode uint16 = uint16(int32(buf.st_mode) & (256 | 128 | 32 | 16 | 4 | 2))
					(func(int32, uint16) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(14)*24))).pCurrent)(conchFile.h, cmode)
				}
			}
		}
		conchFile.pMethod.xUnlock((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), 1)
	end_takeconch:
		if rc == 0 && pFile.openFlags != 0 {
			var fd int32
			if pFile.h >= 0 {
				robust_close(pFile, pFile.h, 42294)
			}
			pFile.h = int32(-1)
			fd = robust_open(pCtx.dbPath, pFile.openFlags, uint16(0))
			if fd >= 0 {
				pFile.h = fd
			} else {
				rc = sqlite3CantopenError(42302)
			}
		}
		if rc == 0 && !(pCtx.lockProxy != nil) {
			var path *int8 = func() *int8 {
				if tempLockPath != nil {
					return tempLockPath
				} else {
					return pCtx.lockProxyPath
				}
			}()
			rc = proxyCreateUnixFile(path, &pCtx.lockProxy, 1)
			if rc != 0 && rc != 7 && tryOldLockPath != 0 {
				forceNewLockPath = int32(1)
				tryOldLockPath = int32(0)
				goto _cgol_5
			}
		}
		if rc == 0 {
			if tempLockPath != nil {
				pCtx.lockProxyPath = sqlite3DbStrDup(nil, tempLockPath)
				if !(pCtx.lockProxyPath != nil) {
					rc = int32(7)
				}
			}
		}
		if rc == 0 {
			pCtx.conchHeld = int32(1)
			if uintptr(unsafe.Pointer(pCtx.lockProxy.pMethod)) == uintptr(unsafe.Pointer(&afpIoMethods)) {
				var afpCtx *struct_afpLockingContext
				afpCtx = (*struct_afpLockingContext)(pCtx.lockProxy.lockingContext)
				afpCtx.dbPath = pCtx.lockProxyPath
			}
		} else {
			conchFile.pMethod.xUnlock((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), 0)
		}
		return rc
		if 1 != 0 {
			goto _cgol_5
		}
	}
}
func proxyReleaseConch(pFile *struct_unixFile) int32 {
	var rc int32 = 0
	var pCtx *struct_proxyLockingContext
	var conchFile *struct_unixFile
	pCtx = (*struct_proxyLockingContext)(pFile.lockingContext)
	conchFile = pCtx.conchFile
	if pCtx.conchHeld > 0 {
		rc = conchFile.pMethod.xUnlock((*struct_sqlite3_file)(unsafe.Pointer(conchFile)), 0)
	}
	pCtx.conchHeld = int32(0)
	return rc
}
func proxyCreateConchPathname(dbPath *int8, pConchPath **int8) int32 {
	var i int32
	var len int32 = int32(strlen(dbPath))
	var conchPath *int8
	*pConchPath = func() (_cgo_ret *int8) {
		_cgo_addr := &conchPath
		*_cgo_addr = (*int8)(sqlite3_malloc64(uint64(len + 8)))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(conchPath)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memcpy_chk(unsafe.Pointer(conchPath), unsafe.Pointer(dbPath), uint(len+1), __builtin_object_size(unsafe.Pointer(conchPath), 0))
	for i = len - 1; i >= 0; i-- {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(conchPath)) + uintptr(i)))) == '/' {
			i++
			break
		}
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(conchPath)) + uintptr(i))) = int8('.')
	for i < len {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(conchPath)) + uintptr(i+1))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(dbPath)) + uintptr(i)))
		i++
	}
	__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(conchPath)) + uintptr(i+1)))), unsafe.Pointer((*int8)(unsafe.Pointer(&[7]int8{'-', 'c', 'o', 'n', 'c', 'h', '\x00'}))), uint(7), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(conchPath)) + uintptr(i+1)))), 0))
	func() int {
		_ = 0
		return 0
	}()
	return int32(0)
}
func switchLockProxyPath(pFile *struct_unixFile, path *int8) int32 {
	var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
	var oldPath *int8 = pCtx.lockProxyPath
	var rc int32 = 0
	if int32(pFile.eFileLock) != 0 {
		return int32(5)
	}
	if !(path != nil) || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(path)) + uintptr(0)))) == '\x00' || !(strcmp(path, (*int8)(unsafe.Pointer(&[7]int8{':', 'a', 'u', 't', 'o', ':', '\x00'}))) != 0) || oldPath != nil && !(strncmp(oldPath, path, uint(1024)) != 0) {
		return int32(0)
	} else {
		var lockProxy *struct_unixFile = pCtx.lockProxy
		pCtx.lockProxy = (*struct_unixFile)(nil)
		pCtx.conchHeld = int32(0)
		if uintptr(unsafe.Pointer(lockProxy)) != uintptr(unsafe.Pointer((*struct_unixFile)(unsafe.Pointer(0)))) {
			rc = lockProxy.pMethod.xClose((*struct_sqlite3_file)(unsafe.Pointer(lockProxy)))
			if rc != 0 {
				return rc
			}
			sqlite3_free(unsafe.Pointer(lockProxy))
		}
		sqlite3_free(unsafe.Pointer(oldPath))
		pCtx.lockProxyPath = sqlite3DbStrDup(nil, path)
	}
	return rc
}
func proxyGetDbPathForUnixFile(pFile *struct_unixFile, dbPath *int8) int32 {
	if uintptr(unsafe.Pointer(pFile.pMethod)) == uintptr(unsafe.Pointer(&afpIoMethods)) {
		func() int {
			_ = 0
			return 0
		}()
		__builtin___strlcpy_chk(dbPath, (*struct_afpLockingContext)(pFile.lockingContext).dbPath, uint(1024), __builtin_object_size(unsafe.Pointer(dbPath), func() int32 {
			if true {
				return 1
			} else {
				return 0
			}
		}()))
	} else if uintptr(unsafe.Pointer(pFile.pMethod)) == uintptr(unsafe.Pointer(&dotlockIoMethods)) {
		var len int32 = int32(strlen((*int8)(pFile.lockingContext)) - strlen((*int8)(unsafe.Pointer(&[6]int8{'.', 'l', 'o', 'c', 'k', '\x00'}))))
		__builtin___memcpy_chk(unsafe.Pointer(dbPath), unsafe.Pointer((*int8)(pFile.lockingContext)), uint(len+1), __builtin_object_size(unsafe.Pointer(dbPath), 0))
	} else {
		func() int {
			_ = 0
			return 0
		}()
		__builtin___strlcpy_chk(dbPath, (*int8)(pFile.lockingContext), uint(1024), __builtin_object_size(unsafe.Pointer(dbPath), func() int32 {
			if true {
				return 1
			} else {
				return 0
			}
		}()))
	}
	return int32(0)
}
func proxyTransformUnixFile(pFile *struct_unixFile, path *int8) int32 {
	var pCtx *struct_proxyLockingContext
	var dbPath [1025]int8
	var lockPath *int8 = nil
	var rc int32 = 0
	if int32(pFile.eFileLock) != 0 {
		return int32(5)
	}
	proxyGetDbPathForUnixFile(pFile, (*int8)(unsafe.Pointer(&dbPath)))
	if !(path != nil) || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(path)) + uintptr(0)))) == '\x00' || !(strcmp(path, (*int8)(unsafe.Pointer(&[7]int8{':', 'a', 'u', 't', 'o', ':', '\x00'}))) != 0) {
		lockPath = (*int8)(nil)
	} else {
		lockPath = (*int8)(unsafe.Pointer(path))
	}
	pCtx = (*struct_proxyLockingContext)(sqlite3_malloc64(uint64(64)))
	if uintptr(unsafe.Pointer(pCtx)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(pCtx), 0, 64, __builtin_object_size(unsafe.Pointer(pCtx), 0))
	rc = proxyCreateConchPathname((*int8)(unsafe.Pointer(&dbPath)), &pCtx.conchFilePath)
	if rc == 0 {
		rc = proxyCreateUnixFile(pCtx.conchFilePath, &pCtx.conchFile, 0)
		if rc == 14 && pFile.openFlags&2 == 0 {
			var fsInfo struct_statfs
			var conchInfo struct_stat
			var goLockless int32 = 0
			if (func(*int8, *struct_stat) int32)((*(*struct_unix_syscall)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_unix_syscall)(unsafe.Pointer(&aSyscall)))) + uintptr(4)*24))).pCurrent)(pCtx.conchFilePath, &conchInfo) == -1 {
				var err int32 = *__error()
				if err == 2 && statfs((*int8)(unsafe.Pointer(&dbPath)), &fsInfo) != -1 {
					goLockless = func() int32 {
						if fsInfo.f_flags&uint32(1) == uint32(1) {
							return 1
						} else {
							return 0
						}
					}()
				}
			}
			if goLockless != 0 {
				pCtx.conchHeld = int32(-1)
				rc = int32(0)
			}
		}
	}
	if rc == 0 && lockPath != nil {
		pCtx.lockProxyPath = sqlite3DbStrDup(nil, lockPath)
	}
	if rc == 0 {
		pCtx.dbPath = sqlite3DbStrDup(nil, (*int8)(unsafe.Pointer(&dbPath)))
		if uintptr(unsafe.Pointer(pCtx.dbPath)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(0)))) {
			rc = int32(7)
		}
	}
	if rc == 0 {
		pCtx.oldLockingContext = pFile.lockingContext
		pFile.lockingContext = unsafe.Pointer(pCtx)
		pCtx.pOldMethod = pFile.pMethod
		pFile.pMethod = &proxyIoMethods
	} else {
		if pCtx.conchFile != nil {
			pCtx.conchFile.pMethod.xClose((*struct_sqlite3_file)(unsafe.Pointer(pCtx.conchFile)))
			sqlite3_free(unsafe.Pointer(pCtx.conchFile))
		}
		sqlite3DbFree(nil, unsafe.Pointer(pCtx.lockProxyPath))
		sqlite3_free(unsafe.Pointer(pCtx.conchFilePath))
		sqlite3_free(unsafe.Pointer(pCtx))
	}
	return rc
}
func proxyFileControl(id *struct_sqlite3_file, op int32, pArg unsafe.Pointer) int32 {
	switch op {
	case 2:
		{
			var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
			if uintptr(unsafe.Pointer(pFile.pMethod)) == uintptr(unsafe.Pointer(&proxyIoMethods)) {
				var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
				proxyTakeConch(pFile)
				if pCtx.lockProxyPath != nil {
					*(**int8)(pArg) = pCtx.lockProxyPath
				} else {
					*(**int8)(pArg) = (*int8)(unsafe.Pointer(&[18]int8{':', 'a', 'u', 't', 'o', ':', ' ', '(', 'n', 'o', 't', ' ', 'h', 'e', 'l', 'd', ')', '\x00'}))
				}
			} else {
				*(**int8)(pArg) = (*int8)(nil)
			}
			return int32(0)
		}
	case 3:
		{
			var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
			var rc int32 = 0
			var isProxyStyle int32 = func() int32 {
				if uintptr(unsafe.Pointer(pFile.pMethod)) == uintptr(unsafe.Pointer(&proxyIoMethods)) {
					return 1
				} else {
					return 0
				}
			}()
			if uintptr(unsafe.Pointer(pArg)) == uintptr(unsafe.Pointer(unsafe.Pointer(0))) || uintptr(unsafe.Pointer((*int8)(pArg))) == uintptr(unsafe.Pointer(nil)) {
				if isProxyStyle != 0 {
					rc = int32(1)
				} else {
					rc = int32(0)
				}
			} else {
				var proxyPath *int8 = (*int8)(pArg)
				if isProxyStyle != 0 {
					var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
					if !(strcmp((*int8)(pArg), (*int8)(unsafe.Pointer(&[7]int8{':', 'a', 'u', 't', 'o', ':', '\x00'}))) != 0) || pCtx.lockProxyPath != nil && !(strncmp(pCtx.lockProxyPath, proxyPath, uint(1024)) != 0) {
						rc = int32(0)
					} else {
						rc = switchLockProxyPath(pFile, proxyPath)
					}
				} else {
					rc = proxyTransformUnixFile(pFile, proxyPath)
				}
			}
			return rc
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	return int32(1)
}
func proxyCheckReservedLock(id *struct_sqlite3_file, pResOut *int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var rc int32 = proxyTakeConch(pFile)
	if rc == 0 {
		var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
		if pCtx.conchHeld > 0 {
			var proxy *struct_unixFile = pCtx.lockProxy
			return proxy.pMethod.xCheckReservedLock((*struct_sqlite3_file)(unsafe.Pointer(proxy)), pResOut)
		} else {
			pResOut = (*int32)(nil)
		}
	}
	return rc
}
func proxyLock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var rc int32 = proxyTakeConch(pFile)
	if rc == 0 {
		var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
		if pCtx.conchHeld > 0 {
			var proxy *struct_unixFile = pCtx.lockProxy
			rc = proxy.pMethod.xLock((*struct_sqlite3_file)(unsafe.Pointer(proxy)), eFileLock)
			pFile.eFileLock = proxy.eFileLock
		} else {
		}
	}
	return rc
}
func proxyUnlock(id *struct_sqlite3_file, eFileLock int32) int32 {
	var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
	var rc int32 = proxyTakeConch(pFile)
	if rc == 0 {
		var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
		if pCtx.conchHeld > 0 {
			var proxy *struct_unixFile = pCtx.lockProxy
			rc = proxy.pMethod.xUnlock((*struct_sqlite3_file)(unsafe.Pointer(proxy)), eFileLock)
			pFile.eFileLock = proxy.eFileLock
		} else {
		}
	}
	return rc
}
func proxyClose(id *struct_sqlite3_file) int32 {
	if id != nil {
		var pFile *struct_unixFile = (*struct_unixFile)(unsafe.Pointer(id))
		var pCtx *struct_proxyLockingContext = (*struct_proxyLockingContext)(pFile.lockingContext)
		var lockProxy *struct_unixFile = pCtx.lockProxy
		var conchFile *struct_unixFile = pCtx.conchFile
		var rc int32 = 0
		if lockProxy != nil {
			rc = lockProxy.pMethod.xUnlock((*struct_sqlite3_file)(unsafe.Pointer(lockProxy)), 0)
			if rc != 0 {
				return rc
			}
			rc = lockProxy.pMethod.xClose((*struct_sqlite3_file)(unsafe.Pointer(lockProxy)))
			if rc != 0 {
				return rc
			}
			sqlite3_free(unsafe.Pointer(lockProxy))
			pCtx.lockProxy = (*struct_unixFile)(nil)
		}
		if conchFile != nil {
			if pCtx.conchHeld != 0 {
				rc = proxyReleaseConch(pFile)
				if rc != 0 {
					return rc
				}
			}
			rc = conchFile.pMethod.xClose((*struct_sqlite3_file)(unsafe.Pointer(conchFile)))
			if rc != 0 {
				return rc
			}
			sqlite3_free(unsafe.Pointer(conchFile))
		}
		sqlite3DbFree(nil, unsafe.Pointer(pCtx.lockProxyPath))
		sqlite3_free(unsafe.Pointer(pCtx.conchFilePath))
		sqlite3DbFree(nil, unsafe.Pointer(pCtx.dbPath))
		pFile.lockingContext = pCtx.oldLockingContext
		pFile.pMethod = pCtx.pOldMethod
		sqlite3_free(unsafe.Pointer(pCtx))
		return pFile.pMethod.xClose(id)
	}
	return int32(0)
}
func sqlite3_os_init() int32 {
	var aVfs [9]struct_sqlite3_vfs = [9]struct_sqlite3_vfs{struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[5]int8{'u', 'n', 'i', 'x', '\x00'})), unsafe.Pointer(&autolockIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[10]int8{'u', 'n', 'i', 'x', '-', 'n', 'o', 'n', 'e', '\x00'})), unsafe.Pointer(&nolockIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[13]int8{'u', 'n', 'i', 'x', '-', 'd', 'o', 't', 'f', 'i', 'l', 'e', '\x00'})), unsafe.Pointer(&dotlockIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[10]int8{'u', 'n', 'i', 'x', '-', 'e', 'x', 'c', 'l', '\x00'})), unsafe.Pointer(&posixIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[11]int8{'u', 'n', 'i', 'x', '-', 'p', 'o', 's', 'i', 'x', '\x00'})), unsafe.Pointer(&posixIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[11]int8{'u', 'n', 'i', 'x', '-', 'f', 'l', 'o', 'c', 'k', '\x00'})), unsafe.Pointer(&flockIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[9]int8{'u', 'n', 'i', 'x', '-', 'a', 'f', 'p', '\x00'})), unsafe.Pointer(&afpIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[9]int8{'u', 'n', 'i', 'x', '-', 'n', 'f', 's', '\x00'})), unsafe.Pointer(&nfsIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}, struct_sqlite3_vfs{3, int32(128), 512, nil, (*int8)(unsafe.Pointer(&[11]int8{'u', 'n', 'i', 'x', '-', 'p', 'r', 'o', 'x', 'y', '\x00'})), unsafe.Pointer(&proxyIoFinder), unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall}}
	var i uint32
	func() int {
		_ = 0
		return 0
	}()
	for i = uint32(0); uint(i) < 1512/168; i++ {
		sqlite3_vfs_register(&*(*struct_sqlite3_vfs)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sqlite3_vfs)(unsafe.Pointer(&aVfs)))) + uintptr(i)*168)), func() int32 {
			if i == uint32(0) {
				return 1
			} else {
				return 0
			}
		}())
	}
	unixBigLock = sqlite3MutexAlloc(11)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	unixTempFileInit()
	return int32(0)
}
func sqlite3_os_end() int32 {
	unixBigLock = (*struct_sqlite3_mutex)(nil)
	return int32(0)
}

type MemVfs = struct_sqlite3_vfs
type MemFile = struct_MemFile
type MemStore = struct_MemStore
type struct_MemStore struct {
	sz      int64
	szAlloc int64
	szMax   int64
	aData   *uint8
	pMutex  *struct_sqlite3_mutex
	nMmap   int32
	mFlags  uint32
	nRdLock int32
	nWrLock int32
	nRef    int32
	zFName  *int8
}
type struct_MemFile struct {
	base   struct_sqlite3_file
	pStore *struct_MemStore
	eLock  int32
}
type struct_MemFS struct {
	nMemStore  int32
	apMemStore **struct_MemStore
}

var memdb_g struct_MemFS
var memdb_vfs struct_sqlite3_vfs = struct_sqlite3_vfs{2, 0, 1024, nil, (*int8)(unsafe.Pointer(&[6]int8{'m', 'e', 'm', 'd', 'b', '\x00'})), nil, memdbOpen, nil, memdbAccess, memdbFullPathname, memdbDlOpen, memdbDlError, memdbDlSym, memdbDlClose, memdbRandomness, memdbSleep, nil, memdbGetLastError, memdbCurrentTimeInt64, nil, nil, nil}
var memdb_io_methods struct_sqlite3_io_methods = struct_sqlite3_io_methods{3, memdbClose, memdbRead, memdbWrite, memdbTruncate, memdbSync, memdbFileSize, memdbLock, memdbLock, nil, memdbFileControl, nil, memdbDeviceCharacteristics, nil, nil, nil, nil, memdbFetch, memdbUnfetch}

func memdbEnter(p *struct_MemStore) {
	sqlite3_mutex_enter(p.pMutex)
}
func memdbLeave(p *struct_MemStore) {
	sqlite3_mutex_leave(p.pMutex)
}
func memdbClose(pFile *struct_sqlite3_file) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	if p.zFName != nil {
		var i int32
		var pVfsMutex *struct_sqlite3_mutex = sqlite3MutexAlloc(11)
		sqlite3_mutex_enter(pVfsMutex)
		for i = int32(0); i < memdb_g.nMemStore; i++ {
			if uintptr(unsafe.Pointer(*(**struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(memdb_g.apMemStore)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(p)) {
				memdbEnter(p)
				if p.nRef == 1 {
					*(**struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(memdb_g.apMemStore)) + uintptr(i)*8)) = *(**struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(memdb_g.apMemStore)) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &memdb_g.nMemStore
						*_cgo_addr--
						return *_cgo_addr
					}())*8))
					if memdb_g.nMemStore == 0 {
						sqlite3_free(unsafe.Pointer(memdb_g.apMemStore))
						memdb_g.apMemStore = (**struct_MemStore)(nil)
					}
				}
				break
			}
		}
		sqlite3_mutex_leave(pVfsMutex)
	} else {
		memdbEnter(p)
	}
	p.nRef--
	if p.nRef <= 0 {
		if p.mFlags&uint32(1) != 0 {
			sqlite3_free(unsafe.Pointer(p.aData))
		}
		memdbLeave(p)
		sqlite3_mutex_free(p.pMutex)
		sqlite3_free(unsafe.Pointer(p))
	} else {
		memdbLeave(p)
	}
	return int32(0)
}
func memdbRead(pFile *struct_sqlite3_file, zBuf unsafe.Pointer, iAmt int32, iOfst int64) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	memdbEnter(p)
	if iOfst+int64(iAmt) > p.sz {
		__builtin___memset_chk(zBuf, 0, uint(iAmt), __builtin_object_size(zBuf, 0))
		if iOfst < p.sz {
			__builtin___memcpy_chk(zBuf, unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData))+uintptr(iOfst)))), uint(p.sz-iOfst), __builtin_object_size(zBuf, 0))
		}
		memdbLeave(p)
		return int32(10 | 2<<8)
	}
	__builtin___memcpy_chk(zBuf, unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData))+uintptr(iOfst)))), uint(iAmt), __builtin_object_size(zBuf, 0))
	memdbLeave(p)
	return int32(0)
}
func memdbEnlarge(p *struct_MemStore, newSz int64) int32 {
	var pNew *uint8
	if p.mFlags&uint32(2) == uint32(0) || p.nMmap > 0 {
		return int32(13)
	}
	if newSz > p.szMax {
		return int32(13)
	}
	newSz *= int64(2)
	if newSz > p.szMax {
		newSz = p.szMax
	}
	pNew = (*uint8)(sqlite3Realloc(unsafe.Pointer(p.aData), uint64(newSz)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return int32(10 | 12<<8)
	}
	p.aData = pNew
	p.szAlloc = newSz
	return int32(0)
}
func memdbWrite(pFile *struct_sqlite3_file, z unsafe.Pointer, iAmt int32, iOfst int64) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	memdbEnter(p)
	if p.mFlags&uint32(4) != 0 {
		memdbLeave(p)
		return int32(10 | 3<<8)
	}
	if iOfst+int64(iAmt) > p.sz {
		var rc int32
		if iOfst+int64(iAmt) > p.szAlloc && func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = memdbEnlarge(p, iOfst+int64(iAmt))
			return *_cgo_addr
		}() != 0 {
			memdbLeave(p)
			return rc
		}
		if iOfst > p.sz {
			__builtin___memset_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData))+uintptr(p.sz)))), 0, uint(iOfst-p.sz), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData))+uintptr(p.sz)))), 0))
		}
		p.sz = iOfst + int64(iAmt)
	}
	__builtin___memcpy_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData))+uintptr(iOfst)))), z, uint(iAmt), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData))+uintptr(iOfst)))), 0))
	memdbLeave(p)
	return int32(0)
}
func memdbTruncate(pFile *struct_sqlite3_file, size int64) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	var rc int32 = 0
	memdbEnter(p)
	if size > p.sz {
		rc = int32(11)
	} else {
		p.sz = size
	}
	memdbLeave(p)
	return rc
}
func memdbSync(pFile *struct_sqlite3_file, flags int32) int32 {
	func() int {
		_ = pFile
		return 0
	}()
	func() int {
		_ = flags
		return 0
	}()
	return int32(0)
}
func memdbFileSize(pFile *struct_sqlite3_file, pSize *int64) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	memdbEnter(p)
	*pSize = p.sz
	memdbLeave(p)
	return int32(0)
}
func memdbLock(pFile *struct_sqlite3_file, eLock int32) int32 {
	var pThis *struct_MemFile = (*struct_MemFile)(unsafe.Pointer(pFile))
	var p *struct_MemStore = pThis.pStore
	var rc int32 = 0
	if eLock == pThis.eLock {
		return int32(0)
	}
	memdbEnter(p)
	if eLock > 1 {
		if p.mFlags&uint32(4) != 0 {
			rc = int32(8)
		} else if pThis.eLock <= 1 {
			if p.nWrLock != 0 {
				rc = int32(5)
			} else {
				p.nWrLock = int32(1)
			}
		}
	} else if eLock == 1 {
		if pThis.eLock > 1 {
			func() int {
				_ = 0
				return 0
			}()
			p.nWrLock = int32(0)
		} else if p.nWrLock != 0 {
			rc = int32(5)
		} else {
			p.nRdLock++
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if pThis.eLock > 1 {
			func() int {
				_ = 0
				return 0
			}()
			p.nWrLock = int32(0)
		}
		func() int {
			_ = 0
			return 0
		}()
		p.nRdLock--
	}
	if rc == 0 {
		pThis.eLock = eLock
	}
	memdbLeave(p)
	return rc
}
func memdbFileControl(pFile *struct_sqlite3_file, op int32, pArg unsafe.Pointer) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	var rc int32 = 12
	memdbEnter(p)
	if op == 12 {
		*(**int8)(pArg) = sqlite3_mprintf((*int8)(unsafe.Pointer(&[15]int8{'m', 'e', 'm', 'd', 'b', '(', '%', 'p', ',', '%', 'l', 'l', 'd', ')', '\x00'})), p.aData, p.sz)
		rc = int32(0)
	}
	if op == 36 {
		var iLimit int64 = *(*int64)(pArg)
		if iLimit < p.sz {
			if iLimit < int64(0) {
				iLimit = p.szMax
			} else {
				iLimit = p.sz
			}
		}
		p.szMax = iLimit
		*(*int64)(pArg) = iLimit
		rc = int32(0)
	}
	memdbLeave(p)
	return rc
}
func memdbDeviceCharacteristics(pFile *struct_sqlite3_file) int32 {
	func() int {
		_ = pFile
		return 0
	}()
	return int32(1 | 4096 | 512 | 1024)
}
func memdbFetch(pFile *struct_sqlite3_file, iOfst int64, iAmt int32, pp *unsafe.Pointer) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	memdbEnter(p)
	if iOfst+int64(iAmt) > p.sz || p.mFlags&uint32(2) != uint32(0) {
		*pp = unsafe.Pointer(nil)
	} else {
		p.nMmap++
		*pp = unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aData)) + uintptr(iOfst))))
	}
	memdbLeave(p)
	return int32(0)
}
func memdbUnfetch(pFile *struct_sqlite3_file, iOfst int64, pPage unsafe.Pointer) int32 {
	var p *struct_MemStore = (*struct_MemFile)(unsafe.Pointer(pFile)).pStore
	func() int {
		_ = iOfst
		return 0
	}()
	func() int {
		_ = pPage
		return 0
	}()
	memdbEnter(p)
	p.nMmap--
	memdbLeave(p)
	return int32(0)
}
func memdbOpen(pVfs *struct_sqlite3_vfs, zName *int8, pFd *struct_sqlite3_file, flags int32, pOutFlags *int32) int32 {
	var pFile *struct_MemFile = (*struct_MemFile)(unsafe.Pointer(pFd))
	var p *struct_MemStore = nil
	var szName int32
	func() int {
		_ = pVfs
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(pFile), 0, 20, __builtin_object_size(unsafe.Pointer(pFile), 0))
	szName = sqlite3Strlen30(zName)
	if szName > 1 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(0)))) == '/' {
		var i int32
		var pVfsMutex *struct_sqlite3_mutex = sqlite3MutexAlloc(11)
		sqlite3_mutex_enter(pVfsMutex)
		for i = int32(0); i < memdb_g.nMemStore; i++ {
			if strcmp((*(**struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(memdb_g.apMemStore)) + uintptr(i)*8))).zFName, zName) == 0 {
				p = *(**struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(memdb_g.apMemStore)) + uintptr(i)*8))
				break
			}
		}
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			var apNew **struct_MemStore
			p = (*struct_MemStore)(sqlite3Malloc(uint64(72 + uint(szName) + uint(3))))
			if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3_mutex_leave(pVfsMutex)
				return int32(7)
			}
			apNew = (**struct_MemStore)(sqlite3Realloc(unsafe.Pointer(memdb_g.apMemStore), uint64(8*uint(memdb_g.nMemStore+1))))
			if uintptr(unsafe.Pointer(apNew)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3_free(unsafe.Pointer(p))
				sqlite3_mutex_leave(pVfsMutex)
				return int32(7)
			}
			*(**struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(apNew)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &memdb_g.nMemStore
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8)) = p
			memdb_g.apMemStore = apNew
			__builtin___memset_chk(unsafe.Pointer(p), 0, 72, __builtin_object_size(unsafe.Pointer(p), 0))
			p.mFlags = uint32(2 | 1)
			p.szMax = sqlite3Config.mxMemdbSize
			p.zFName = (*int8)(unsafe.Pointer(&*(*struct_MemStore)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*72))))
			__builtin___memcpy_chk(unsafe.Pointer(p.zFName), unsafe.Pointer(zName), uint(szName+1), __builtin_object_size(unsafe.Pointer(p.zFName), 0))
			p.pMutex = sqlite3_mutex_alloc(0)
			if uintptr(unsafe.Pointer(p.pMutex)) == uintptr(unsafe.Pointer(nil)) {
				memdb_g.nMemStore--
				sqlite3_free(unsafe.Pointer(p))
				sqlite3_mutex_leave(pVfsMutex)
				return int32(7)
			}
			p.nRef = int32(1)
			memdbEnter(p)
		} else {
			memdbEnter(p)
			p.nRef++
		}
		sqlite3_mutex_leave(pVfsMutex)
	} else {
		p = (*struct_MemStore)(sqlite3Malloc(uint64(72)))
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(p), 0, 72, __builtin_object_size(unsafe.Pointer(p), 0))
		p.mFlags = uint32(2 | 1)
		p.szMax = sqlite3Config.mxMemdbSize
	}
	pFile.pStore = p
	if uintptr(unsafe.Pointer(pOutFlags)) != uintptr(unsafe.Pointer(nil)) {
		*pOutFlags = flags | 128
	}
	pFd.pMethods = &memdb_io_methods
	memdbLeave(p)
	return int32(0)
}
func memdbAccess(pVfs *struct_sqlite3_vfs, zPath *int8, flags int32, pResOut *int32) int32 {
	func() int {
		_ = pVfs
		return 0
	}()
	func() int {
		_ = zPath
		return 0
	}()
	func() int {
		_ = flags
		return 0
	}()
	*pResOut = int32(0)
	return int32(0)
}
func memdbFullPathname(pVfs *struct_sqlite3_vfs, zPath *int8, nOut int32, zOut *int8) int32 {
	func() int {
		_ = pVfs
		return 0
	}()
	sqlite3_snprintf(nOut, zOut, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zPath)
	return int32(0)
}
func memdbDlOpen(pVfs *struct_sqlite3_vfs, zPath *int8) unsafe.Pointer {
	return (*struct_sqlite3_vfs)(pVfs.pAppData).xDlOpen((*struct_sqlite3_vfs)(pVfs.pAppData), zPath)
}
func memdbDlError(pVfs *struct_sqlite3_vfs, nByte int32, zErrMsg *int8) {
	(*struct_sqlite3_vfs)(pVfs.pAppData).xDlError((*struct_sqlite3_vfs)(pVfs.pAppData), nByte, zErrMsg)
}
func memdbDlSym(pVfs *struct_sqlite3_vfs, p unsafe.Pointer, zSym *int8) func() {
	return (*struct_sqlite3_vfs)(pVfs.pAppData).xDlSym((*struct_sqlite3_vfs)(pVfs.pAppData), p, zSym)
}
func memdbDlClose(pVfs *struct_sqlite3_vfs, pHandle unsafe.Pointer) {
	(*struct_sqlite3_vfs)(pVfs.pAppData).xDlClose((*struct_sqlite3_vfs)(pVfs.pAppData), pHandle)
}
func memdbRandomness(pVfs *struct_sqlite3_vfs, nByte int32, zBufOut *int8) int32 {
	return (*struct_sqlite3_vfs)(pVfs.pAppData).xRandomness((*struct_sqlite3_vfs)(pVfs.pAppData), nByte, zBufOut)
}
func memdbSleep(pVfs *struct_sqlite3_vfs, nMicro int32) int32 {
	return (*struct_sqlite3_vfs)(pVfs.pAppData).xSleep((*struct_sqlite3_vfs)(pVfs.pAppData), nMicro)
}
func memdbGetLastError(pVfs *struct_sqlite3_vfs, a int32, b *int8) int32 {
	return (*struct_sqlite3_vfs)(pVfs.pAppData).xGetLastError((*struct_sqlite3_vfs)(pVfs.pAppData), a, b)
}
func memdbCurrentTimeInt64(pVfs *struct_sqlite3_vfs, p *int64) int32 {
	return (*struct_sqlite3_vfs)(pVfs.pAppData).xCurrentTimeInt64((*struct_sqlite3_vfs)(pVfs.pAppData), p)
}
func memdbFromDbSchema(db *struct_sqlite3, zSchema *int8) *struct_MemFile {
	var p *struct_MemFile = nil
	var pStore *struct_MemStore
	var rc int32 = sqlite3_file_control(db, zSchema, 7, unsafe.Pointer(&p))
	if rc != 0 {
		return (*struct_MemFile)(nil)
	}
	if uintptr(unsafe.Pointer(p.base.pMethods)) != uintptr(unsafe.Pointer(&memdb_io_methods)) {
		return (*struct_MemFile)(nil)
	}
	pStore = p.pStore
	memdbEnter(pStore)
	if uintptr(unsafe.Pointer(pStore.zFName)) != uintptr(unsafe.Pointer(nil)) {
		p = (*struct_MemFile)(nil)
	}
	memdbLeave(pStore)
	return p
}
func sqlite3_serialize(db *struct_sqlite3, zSchema *int8, piSize *int64, mFlags uint32) *uint8 {
	var p *struct_MemFile
	var iDb int32
	var pBt *struct_Btree
	var sz int64
	var szPage int32 = 0
	var pStmt *struct_sqlite3_stmt = nil
	var pOut *uint8
	var zSql *int8
	var rc int32
	if uintptr(unsafe.Pointer(zSchema)) == uintptr(unsafe.Pointer(nil)) {
		zSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).zDbSName
	}
	p = memdbFromDbSchema(db, zSchema)
	iDb = sqlite3FindDbName(db, zSchema)
	if piSize != nil {
		*piSize = int64(-1)
	}
	if iDb < 0 {
		return (*uint8)(nil)
	}
	if p != nil {
		var pStore *struct_MemStore = p.pStore
		func() int {
			_ = 0
			return 0
		}()
		if piSize != nil {
			*piSize = pStore.sz
		}
		if mFlags&uint32(1) != 0 {
			pOut = pStore.aData
		} else {
			pOut = (*uint8)(sqlite3_malloc64(uint64(pStore.sz)))
			if pOut != nil {
				__builtin___memcpy_chk(unsafe.Pointer(pOut), unsafe.Pointer(pStore.aData), uint(pStore.sz), __builtin_object_size(unsafe.Pointer(pOut), 0))
			}
		}
		return pOut
	}
	pBt = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt
	if uintptr(unsafe.Pointer(pBt)) == uintptr(unsafe.Pointer(nil)) {
		return (*uint8)(nil)
	}
	szPage = sqlite3BtreeGetPageSize(pBt)
	zSql = sqlite3_mprintf((*int8)(unsafe.Pointer(&[23]int8{'P', 'R', 'A', 'G', 'M', 'A', ' ', '"', '%', 'w', '"', '.', 'p', 'a', 'g', 'e', '_', 'c', 'o', 'u', 'n', 't', '\x00'})), zSchema)
	rc = func() int32 {
		if zSql != nil {
			return sqlite3_prepare_v2(db, zSql, -1, &pStmt, nil)
		} else {
			return 7
		}
	}()
	sqlite3_free(unsafe.Pointer(zSql))
	if rc != 0 {
		return (*uint8)(nil)
	}
	rc = sqlite3_step(pStmt)
	if rc != 100 {
		pOut = (*uint8)(nil)
	} else {
		sz = sqlite3_column_int64(pStmt, 0) * int64(szPage)
		if piSize != nil {
			*piSize = sz
		}
		if mFlags&uint32(1) != 0 {
			pOut = (*uint8)(nil)
		} else {
			pOut = (*uint8)(sqlite3_malloc64(uint64(sz)))
			if pOut != nil {
				var nPage int32 = sqlite3_column_int(pStmt, 0)
				var pPager *struct_Pager = sqlite3BtreePager(pBt)
				var pgno int32
				for pgno = int32(1); pgno <= nPage; pgno++ {
					var pPage *struct_PgHdr = nil
					var pTo *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut)) + uintptr(int64(szPage)*int64(pgno-1))))
					rc = sqlite3PagerGet(pPager, uint32(pgno), (**struct_PgHdr)(unsafe.Pointer(&pPage)), 0)
					if rc == 0 {
						__builtin___memcpy_chk(unsafe.Pointer(pTo), sqlite3PagerGetData(pPage), uint(szPage), __builtin_object_size(unsafe.Pointer(pTo), 0))
					} else {
						__builtin___memset_chk(unsafe.Pointer(pTo), 0, uint(szPage), __builtin_object_size(unsafe.Pointer(pTo), 0))
					}
					sqlite3PagerUnref(pPage)
				}
			}
		}
	}
	sqlite3_finalize(pStmt)
	return pOut
}
func sqlite3_deserialize(db *struct_sqlite3, zSchema *int8, pData *uint8, szDb int64, szBuf int64, mFlags uint32) int32 {
	var p *struct_MemFile
	var zSql *int8
	var pStmt *struct_sqlite3_stmt = nil
	var rc int32
	var iDb int32
	sqlite3_mutex_enter(db.mutex)
	if uintptr(unsafe.Pointer(zSchema)) == uintptr(unsafe.Pointer(nil)) {
		zSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).zDbSName
	}
	iDb = sqlite3FindDbName(db, zSchema)
	if iDb < 2 && iDb != 0 {
		rc = int32(1)
		goto end_deserialize
	}
	zSql = sqlite3_mprintf((*int8)(unsafe.Pointer(&[15]int8{'A', 'T', 'T', 'A', 'C', 'H', ' ', 'x', ' ', 'A', 'S', ' ', '%', 'Q', '\x00'})), zSchema)
	if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(7)
	} else {
		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, nil)
		sqlite3_free(unsafe.Pointer(zSql))
	}
	if rc != 0 {
		goto end_deserialize
	}
	db.init.iDb = uint8(iDb)
	{
		_autoGo_1 := &db.init.Xbf_0
		*_autoGo_1 = *_autoGo_1&^4 | uint32(1)&1<<2
	}
	rc = sqlite3_step(pStmt)
	{
		_autoGo_2 := &db.init.Xbf_0
		*_autoGo_2 = *_autoGo_2&^4 | uint32(0)&1<<2
	}
	if rc != 101 {
		rc = int32(1)
		goto end_deserialize
	}
	p = memdbFromDbSchema(db, zSchema)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(1)
	} else {
		var pStore *struct_MemStore = p.pStore
		pStore.aData = pData
		pData = (*uint8)(nil)
		pStore.sz = szDb
		pStore.szAlloc = szBuf
		pStore.szMax = szBuf
		if pStore.szMax < sqlite3Config.mxMemdbSize {
			pStore.szMax = sqlite3Config.mxMemdbSize
		}
		pStore.mFlags = mFlags
		rc = int32(0)
	}
end_deserialize:
	sqlite3_finalize(pStmt)
	if pData != nil && mFlags&uint32(1) != uint32(0) {
		sqlite3_free(unsafe.Pointer(pData))
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3MemdbInit() int32 {
	var pLower *struct_sqlite3_vfs = sqlite3_vfs_find(nil)
	var sz uint32
	if uintptr(unsafe.Pointer(pLower)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	sz = uint32(pLower.szOsFile)
	memdb_vfs.pAppData = unsafe.Pointer(pLower)
	if uint(sz) < 20 {
		sz = uint32(20)
	}
	memdb_vfs.szOsFile = int32(sz)
	return sqlite3_vfs_register(&memdb_vfs, 0)
}

type _cgoa_73 struct {
	aBitmap [496]uint8
}
type struct_Bitvec struct {
	iSize    uint32
	nSet     uint32
	iDivisor uint32
	u        _cgoa_73
}

func sqlite3BitvecCreate(iSize uint32) *struct_Bitvec {
	var p *struct_Bitvec
	func() int {
		_ = 0
		return 0
	}()
	p = (*struct_Bitvec)(sqlite3MallocZero(uint64(508)))
	if p != nil {
		p.iSize = iSize
	}
	return p
}
func sqlite3BitvecTestNotNull(p *struct_Bitvec, i uint32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	i--
	if i >= p.iSize {
		return int32(0)
	}
	for p.iDivisor != 0 {
		var bin uint32 = i / p.iDivisor
		i = i % p.iDivisor
		p = *(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(bin)*8))
		if !(p != nil) {
			return int32(0)
		}
	}
	if uint(p.iSize) <= (uint(512)-uint(3)*4)/8*8/1*uint(8) {
		return func() int32 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&p.u.aBitmap)))) + uintptr(i/uint32(8)))))&int32(1<<(i&uint32(8-1))) != 0 {
				return 1
			} else {
				return 0
			}
		}()
	} else {
		var h uint32 = uint32(uint(func() (_cgo_ret uint32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()*uint32(1)) % ((uint(512) - uint(3)*4) / 8 * 8 / 4))
		for *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) != 0 {
			if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) == i {
				return int32(1)
			}
			h = uint32(uint(h+uint32(1)) % ((uint(512) - uint(3)*4) / 8 * 8 / 4))
		}
		return int32(0)
	}
}
func sqlite3BitvecTest(p *struct_Bitvec, i uint32) int32 {
	return func() int32 {
		if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) && sqlite3BitvecTestNotNull(p, i) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3BitvecSet(p *struct_Bitvec, i uint32) int32 {
	var h uint32
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	i--
	for uint(p.iSize) > (uint(512)-uint(3)*4)/8*8/1*uint(8) && p.iDivisor != 0 {
		var bin uint32 = i / p.iDivisor
		i = i % p.iDivisor
		if uintptr(unsafe.Pointer(*(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(bin)*8)))) == uintptr(unsafe.Pointer(nil)) {
			*(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(bin)*8)) = sqlite3BitvecCreate(p.iDivisor)
			if uintptr(unsafe.Pointer(*(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(bin)*8)))) == uintptr(unsafe.Pointer(nil)) {
				return int32(7)
			}
		}
		p = *(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(bin)*8))
	}
	if uint(p.iSize) <= (uint(512)-uint(3)*4)/8*8/1*uint(8) {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&p.u.aBitmap)))) + uintptr(i/uint32(8)))) |= uint8(1 << (i & uint32(8-1)))
		return int32(0)
	}
	h = uint32(uint(func() (_cgo_ret uint32) {
		_cgo_addr := &i
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()*uint32(1)) % ((uint(512) - uint(3)*4) / 8 * 8 / 4))
	if !(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) != 0) {
		if uint(p.nSet) < (uint(512)-uint(3)*4)/8*8/4-uint(1) {
			goto bitvec_set_end
		} else {
			goto bitvec_set_rehash
		}
	}
	for {
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) == i {
			return int32(0)
		}
		h++
		if uint(h) >= (uint(512)-uint(3)*4)/8*8/4 {
			h = uint32(0)
		}
		if !(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) != 0) {
			break
		}
	}
bitvec_set_rehash:
	if uint(p.nSet) >= (uint(512)-uint(3)*4)/8*8/4/uint(2) {
		var j uint32
		var rc int32
		var aiValues *uint32 = (*uint32)(sqlite3DbMallocRaw(nil, uint64(496)))
		if uintptr(unsafe.Pointer(aiValues)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		} else {
			__builtin___memcpy_chk(unsafe.Pointer(aiValues), unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u))))), 496, __builtin_object_size(unsafe.Pointer(aiValues), 0))
			__builtin___memset_chk(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u))))), 0, 496, __builtin_object_size(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u))))), 0))
			p.iDivisor = uint32((uint(p.iSize) + (uint(512)-uint(3)*4)/8*8/8 - uint(1)) / ((uint(512) - uint(3)*4) / 8 * 8 / 8))
			rc = sqlite3BitvecSet(p, i)
			for j = uint32(0); uint(j) < (uint(512)-uint(3)*4)/8*8/4; j++ {
				if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiValues)) + uintptr(j)*4)) != 0 {
					rc |= sqlite3BitvecSet(p, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiValues)) + uintptr(j)*4)))
				}
			}
			sqlite3DbFree(nil, unsafe.Pointer(aiValues))
			return rc
		}
	}
bitvec_set_end:
	p.nSet++
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) = i
	return int32(0)
}
func sqlite3BitvecClear(p *struct_Bitvec, i uint32, pBuf unsafe.Pointer) {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	i--
	for p.iDivisor != 0 {
		var bin uint32 = i / p.iDivisor
		i = i % p.iDivisor
		p = *(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(bin)*8))
		if !(p != nil) {
			return
		}
	}
	if uint(p.iSize) <= (uint(512)-uint(3)*4)/8*8/1*uint(8) {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&p.u.aBitmap)))) + uintptr(i/uint32(8)))) &= uint8(^(1 << (i & uint32(8-1))))
	} else {
		var j uint32
		var aiValues *uint32 = (*uint32)(pBuf)
		__builtin___memcpy_chk(unsafe.Pointer(aiValues), unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u))))), 496, __builtin_object_size(unsafe.Pointer(aiValues), 0))
		__builtin___memset_chk(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u))))), 0, 496, __builtin_object_size(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u))))), 0))
		p.nSet = uint32(0)
		for j = uint32(0); uint(j) < (uint(512)-uint(3)*4)/8*8/4; j++ {
			if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiValues)) + uintptr(j)*4)) != 0 && *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiValues)) + uintptr(j)*4)) != i+uint32(1) {
				var h uint32 = uint32(uint((*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiValues)) + uintptr(j)*4))-uint32(1))*uint32(1)) % ((uint(512) - uint(3)*4) / 8 * 8 / 4))
				p.nSet++
				for *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) != 0 {
					h++
					if uint(h) >= (uint(512)-uint(3)*4)/8*8/4 {
						h = uint32(0)
					}
				}
				*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&*(*[124]uint32)(unsafe.Pointer(&p.u)))))) + uintptr(h)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiValues)) + uintptr(j)*4))
			}
		}
	}
}
func sqlite3BitvecDestroy(p *struct_Bitvec) {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if p.iDivisor != 0 {
		var i uint32
		for i = uint32(0); uint(i) < (uint(512)-uint(3)*4)/8*8/8; i++ {
			sqlite3BitvecDestroy(*(**struct_Bitvec)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Bitvec)(unsafe.Pointer(&*(*[62]*struct_Bitvec)(unsafe.Pointer(&p.u)))))) + uintptr(i)*8)))
		}
	}
	sqlite3_free(unsafe.Pointer(p))
}
func sqlite3BitvecSize(p *struct_Bitvec) uint32 {
	return p.iSize
}
func sqlite3BitvecBuiltinTest(sz int32, aOp *int32) int32 {
	var pBitvec *struct_Bitvec = nil
	var pV *uint8 = nil
	var rc int32 = -1
	var i int32
	var nx int32
	var pc int32
	var op int32
	var pTmpSpace unsafe.Pointer
	pBitvec = sqlite3BitvecCreate(uint32(sz))
	pV = (*uint8)(sqlite3MallocZero(uint64((sz+7)/8 + 1)))
	pTmpSpace = sqlite3_malloc64(uint64(512))
	if uintptr(unsafe.Pointer(pBitvec)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pV)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pTmpSpace)) == uintptr(unsafe.Pointer(nil)) {
		goto bitvec_end
	}
	sqlite3BitvecSet(nil, uint32(1))
	sqlite3BitvecClear(nil, uint32(1), pTmpSpace)
	pc = func() (_cgo_ret int32) {
		_cgo_addr := &i
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}()
	for func() (_cgo_ret int32) {
		_cgo_addr := &op
		*_cgo_addr = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pc)*4))
		return *_cgo_addr
	}() != 0 {
		switch op {
		case 1:
			fallthrough
		case 2:
			fallthrough
		case 5:
			{
				nx = int32(4)
				i = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pc+2)*4)) - 1
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pc+2)*4)) += *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pc+3)*4))
				break
			}
		case 3:
			fallthrough
		case 4:
			fallthrough
		default:
			{
				nx = int32(2)
				sqlite3_randomness(int32(4), unsafe.Pointer(&i))
				break
			}
		}
		if func() (_cgo_ret int32) {
			_cgo_addr := &*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pc+1)*4))
			*_cgo_addr--
			return *_cgo_addr
		}() > 0 {
			nx = int32(0)
		}
		pc += nx
		i = i & 2147483647 % sz
		if op&1 != 0 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pV)) + uintptr((i+1)>>3))) |= uint8(1 << ((i + 1) & 7))
			if op != 5 {
				if sqlite3BitvecSet(pBitvec, uint32(i+1)) != 0 {
					goto bitvec_end
				}
			}
		} else {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pV)) + uintptr((i+1)>>3))) &= uint8(^(1 << ((i + 1) & 7)))
			sqlite3BitvecClear(pBitvec, uint32(i+1), pTmpSpace)
		}
	}
	rc = int32(uint32(sqlite3BitvecTest(nil, uint32(0))+sqlite3BitvecTest(pBitvec, uint32(sz+1))+sqlite3BitvecTest(pBitvec, uint32(0))) + (sqlite3BitvecSize(pBitvec) - uint32(sz)))
	for i = int32(1); i <= sz; i++ {
		if func() int32 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pV)) + uintptr(i>>3))))&int32(1<<(i&7)) != 0 {
				return 1
			} else {
				return 0
			}
		}() != sqlite3BitvecTest(pBitvec, uint32(i)) {
			rc = i
			break
		}
	}
bitvec_end:
	sqlite3_free(pTmpSpace)
	sqlite3_free(unsafe.Pointer(pV))
	sqlite3BitvecDestroy(pBitvec)
	return rc
}

type struct_PCache struct {
	pDirty     *struct_PgHdr
	pDirtyTail *struct_PgHdr
	pSynced    *struct_PgHdr
	nRefSum    int32
	szCache    int32
	szSpill    int32
	szPage     int32
	szExtra    int32
	bPurgeable uint8
	eCreate    uint8
	xStress    func(unsafe.Pointer, *struct_PgHdr) int32
	pStress    unsafe.Pointer
	pCache     *struct_sqlite3_pcache
}

func pcacheManageDirtyList(pPage *struct_PgHdr, addRemove uint8) {
	var p *struct_PCache = pPage.pCache
	if int32(addRemove)&1 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(p.pSynced)) == uintptr(unsafe.Pointer(pPage)) {
			p.pSynced = pPage.pDirtyPrev
		}
		if pPage.pDirtyNext != nil {
			pPage.pDirtyNext.pDirtyPrev = pPage.pDirtyPrev
		} else {
			func() int {
				_ = 0
				return 0
			}()
			p.pDirtyTail = pPage.pDirtyPrev
		}
		if pPage.pDirtyPrev != nil {
			pPage.pDirtyPrev.pDirtyNext = pPage.pDirtyNext
		} else {
			func() int {
				_ = 0
				return 0
			}()
			p.pDirty = pPage.pDirtyNext
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(p.pDirty)) == uintptr(unsafe.Pointer(nil)) {
				func() int {
					_ = 0
					return 0
				}()
				p.eCreate = uint8(2)
			}
		}
	}
	if int32(addRemove)&2 != 0 {
		pPage.pDirtyPrev = (*struct_PgHdr)(nil)
		pPage.pDirtyNext = p.pDirty
		if pPage.pDirtyNext != nil {
			func() int {
				_ = 0
				return 0
			}()
			pPage.pDirtyNext.pDirtyPrev = pPage
		} else {
			p.pDirtyTail = pPage
			if p.bPurgeable != 0 {
				func() int {
					_ = 0
					return 0
				}()
				p.eCreate = uint8(1)
			}
		}
		p.pDirty = pPage
		if !(p.pSynced != nil) && 0 == int32(pPage.flags)&8 {
			p.pSynced = pPage
		}
	}
}
func pcacheUnpin(p *struct_PgHdr) {
	if p.pCache.bPurgeable != 0 {
		sqlite3Config.pcache2.xUnpin(p.pCache.pCache, p.pPage, 0)
	}
}
func numberOfCachePages(p *struct_PCache) int32 {
	if p.szCache >= 0 {
		return p.szCache
	} else {
		var n int64
		n = int64(-1024) * int64(p.szCache) / int64(p.szPage+p.szExtra)
		if n > int64(1000000000) {
			n = int64(1000000000)
		}
		return int32(n)
	}
}
func sqlite3PcacheInitialize() int32 {
	if uintptr(unsafe.Pointer(sqlite3Config.pcache2.xInit)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3PCacheSetDefault()
		func() int {
			_ = 0
			return 0
		}()
	}
	return sqlite3Config.pcache2.xInit(sqlite3Config.pcache2.pArg)
}
func sqlite3PcacheShutdown() {
	if sqlite3Config.pcache2.xShutdown != nil {
		sqlite3Config.pcache2.xShutdown(sqlite3Config.pcache2.pArg)
	}
}
func sqlite3PcacheSize() int32 {
	return int32(72)
}
func sqlite3PcacheOpen(szPage int32, szExtra int32, bPurgeable int32, xStress func(unsafe.Pointer, *struct_PgHdr) int32, pStress unsafe.Pointer, p *struct_PCache) int32 {
	__builtin___memset_chk(unsafe.Pointer(p), 0, 72, __builtin_object_size(unsafe.Pointer(p), 0))
	p.szPage = int32(1)
	p.szExtra = szExtra
	func() int {
		_ = 0
		return 0
	}()
	p.bPurgeable = uint8(bPurgeable)
	p.eCreate = uint8(2)
	p.xStress = xStress
	p.pStress = pStress
	p.szCache = int32(100)
	p.szSpill = int32(1)
	return sqlite3PcacheSetPageSize(p, szPage)
}
func sqlite3PcacheSetPageSize(pCache *struct_PCache, szPage int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if pCache.szPage != 0 {
		var pNew *struct_sqlite3_pcache
		pNew = sqlite3Config.pcache2.xCreate(szPage, int32(uint(pCache.szExtra)+(72+uint(7))&uint(18446744073709551608)), int32(pCache.bPurgeable))
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		sqlite3Config.pcache2.xCachesize(pNew, numberOfCachePages(pCache))
		if pCache.pCache != nil {
			sqlite3Config.pcache2.xDestroy(pCache.pCache)
		}
		pCache.pCache = pNew
		pCache.szPage = szPage
	}
	return int32(0)
}
func sqlite3PcacheFetch(pCache *struct_PCache, pgno uint32, createFlag int32) *struct_sqlite3_pcache_page {
	var eCreate int32
	var pRes *struct_sqlite3_pcache_page
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	eCreate = createFlag & int32(pCache.eCreate)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pRes = sqlite3Config.pcache2.xFetch(pCache.pCache, pgno, eCreate)
	return pRes
}
func sqlite3PcacheFetchStress(pCache *struct_PCache, pgno uint32, ppPage **struct_sqlite3_pcache_page) int32 {
	var pPg *struct_PgHdr
	if int32(pCache.eCreate) == 2 {
		return int32(0)
	}
	if sqlite3PcachePagecount(pCache) > pCache.szSpill {
		for pPg = pCache.pSynced; pPg != nil && (int32(pPg.nRef) != 0 || int32(pPg.flags)&8 != 0); pPg = pPg.pDirtyPrev {
		}
		pCache.pSynced = pPg
		if !(pPg != nil) {
			for pPg = pCache.pDirtyTail; pPg != nil && int32(pPg.nRef) != 0; pPg = pPg.pDirtyPrev {
			}
		}
		if pPg != nil {
			var rc int32
			rc = pCache.xStress(pCache.pStress, pPg)
			if rc != 0 && rc != 5 {
				return rc
			}
		}
	}
	*ppPage = sqlite3Config.pcache2.xFetch(pCache.pCache, pgno, 2)
	return func() int32 {
		if uintptr(unsafe.Pointer(*ppPage)) == uintptr(unsafe.Pointer(nil)) {
			return 7
		} else {
			return 0
		}
	}()
}
func pcacheFetchFinishWithInit(pCache *struct_PCache, pgno uint32, pPage *struct_sqlite3_pcache_page) *struct_PgHdr {
	var pPgHdr *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	pPgHdr = (*struct_PgHdr)(pPage.pExtra)
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&pPgHdr.pDirty), 0, 72-32, __builtin_object_size(unsafe.Pointer(&pPgHdr.pDirty), 0))
	pPgHdr.pPage = pPage
	pPgHdr.pData = pPage.pBuf
	pPgHdr.pExtra = unsafe.Pointer(&*(*struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(pPgHdr)) + uintptr(1)*72)))
	__builtin___memset_chk(pPgHdr.pExtra, 0, uint(8), __builtin_object_size(pPgHdr.pExtra, 0))
	pPgHdr.pCache = pCache
	pPgHdr.pgno = pgno
	pPgHdr.flags = uint16(1)
	return sqlite3PcacheFetchFinish(pCache, pgno, pPage)
}
func sqlite3PcacheFetchFinish(pCache *struct_PCache, pgno uint32, pPage *struct_sqlite3_pcache_page) *struct_PgHdr {
	var pPgHdr *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	pPgHdr = (*struct_PgHdr)(pPage.pExtra)
	if !(pPgHdr.pPage != nil) {
		return pcacheFetchFinishWithInit(pCache, pgno, pPage)
	}
	pCache.nRefSum++
	pPgHdr.nRef++
	func() int {
		_ = 0
		return 0
	}()
	return pPgHdr
}
func sqlite3PcacheRelease(p *struct_PgHdr) {
	func() int {
		_ = 0
		return 0
	}()
	p.pCache.nRefSum--
	if int32(func() (_cgo_ret int16) {
		_cgo_addr := &p.nRef
		*_cgo_addr--
		return *_cgo_addr
	}()) == 0 {
		if int32(p.flags)&1 != 0 {
			pcacheUnpin(p)
		} else {
			pcacheManageDirtyList(p, uint8(3))
		}
	}
}
func sqlite3PcacheRef(p *struct_PgHdr) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	p.nRef++
	p.pCache.nRefSum++
}
func sqlite3PcacheDrop(p *struct_PgHdr) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&2 != 0 {
		pcacheManageDirtyList(p, uint8(1))
	}
	p.pCache.nRefSum--
	sqlite3Config.pcache2.xUnpin(p.pCache.pCache, p.pPage, 1)
}
func sqlite3PcacheMakeDirty(p *struct_PgHdr) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&(1|16) != 0 {
		p.flags &= uint16(^16)
		if int32(p.flags)&1 != 0 {
			p.flags ^= uint16(2 | 1)
			func() int {
				_ = 0
				return 0
			}()
			pcacheManageDirtyList(p, uint8(2))
		}
		func() int {
			_ = 0
			return 0
		}()
	}
}
func sqlite3PcacheMakeClean(p *struct_PgHdr) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pcacheManageDirtyList(p, uint8(1))
	p.flags &= uint16(^(2 | 8 | 4))
	p.flags |= uint16(1)
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.nRef) == 0 {
		pcacheUnpin(p)
	}
}
func sqlite3PcacheCleanAll(pCache *struct_PCache) {
	var p *struct_PgHdr
	for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_PgHdr) {
		_cgo_addr := &p
		*_cgo_addr = pCache.pDirty
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		sqlite3PcacheMakeClean(p)
	}
}
func sqlite3PcacheClearWritable(pCache *struct_PCache) {
	var p *struct_PgHdr
	for p = pCache.pDirty; p != nil; p = p.pDirtyNext {
		p.flags &= uint16(^(8 | 4))
	}
	pCache.pSynced = pCache.pDirtyTail
}
func sqlite3PcacheClearSyncFlags(pCache *struct_PCache) {
	var p *struct_PgHdr
	for p = pCache.pDirty; p != nil; p = p.pDirtyNext {
		p.flags &= uint16(^8)
	}
	pCache.pSynced = pCache.pDirtyTail
}
func sqlite3PcacheMove(p *struct_PgHdr, newPgno uint32) {
	var pCache *struct_PCache = p.pCache
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3Config.pcache2.xRekey(pCache.pCache, p.pPage, p.pgno, newPgno)
	p.pgno = newPgno
	if int32(p.flags)&2 != 0 && int32(p.flags)&8 != 0 {
		pcacheManageDirtyList(p, uint8(3))
	}
}
func sqlite3PcacheTruncate(pCache *struct_PCache, pgno uint32) {
	if pCache.pCache != nil {
		var p *struct_PgHdr
		var pNext *struct_PgHdr
		for p = pCache.pDirty; p != nil; p = pNext {
			pNext = p.pDirtyNext
			func() int {
				_ = 0
				return 0
			}()
			if p.pgno > pgno {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3PcacheMakeClean(p)
			}
		}
		if pgno == uint32(0) && pCache.nRefSum != 0 {
			var pPage1 *struct_sqlite3_pcache_page
			pPage1 = sqlite3Config.pcache2.xFetch(pCache.pCache, uint32(1), 0)
			if pPage1 != nil {
				__builtin___memset_chk(pPage1.pBuf, 0, uint(pCache.szPage), __builtin_object_size(pPage1.pBuf, 0))
				pgno = uint32(1)
			}
		}
		sqlite3Config.pcache2.xTruncate(pCache.pCache, pgno+uint32(1))
	}
}
func sqlite3PcacheClose(pCache *struct_PCache) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3Config.pcache2.xDestroy(pCache.pCache)
}
func sqlite3PcacheClear(pCache *struct_PCache) {
	sqlite3PcacheTruncate(pCache, uint32(0))
}
func pcacheMergeDirtyList(pA *struct_PgHdr, pB *struct_PgHdr) *struct_PgHdr {
	var result struct_PgHdr
	var pTail *struct_PgHdr
	pTail = &result
	func() int {
		_ = 0
		return 0
	}()
	for {
		if pA.pgno < pB.pgno {
			pTail.pDirty = pA
			pTail = pA
			pA = pA.pDirty
			if uintptr(unsafe.Pointer(pA)) == uintptr(unsafe.Pointer(nil)) {
				pTail.pDirty = pB
				break
			}
		} else {
			pTail.pDirty = pB
			pTail = pB
			pB = pB.pDirty
			if uintptr(unsafe.Pointer(pB)) == uintptr(unsafe.Pointer(nil)) {
				pTail.pDirty = pA
				break
			}
		}
	}
	return result.pDirty
}
func pcacheSortDirtyList(pIn *struct_PgHdr) *struct_PgHdr {
	var a [32]*struct_PgHdr
	var p *struct_PgHdr
	var i int32
	__builtin___memset_chk(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a))), 0, 256, __builtin_object_size(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a))), 0))
	for pIn != nil {
		p = pIn
		pIn = p.pDirty
		p.pDirty = (*struct_PgHdr)(nil)
		for i = int32(0); i < 32-1; i++ {
			if uintptr(unsafe.Pointer(*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
				*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)) = p
				break
			} else {
				p = pcacheMergeDirtyList(*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)), p)
				*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)) = (*struct_PgHdr)(nil)
			}
		}
		if i == 32-1 {
			*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)) = pcacheMergeDirtyList(*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)), p)
		}
	}
	p = *(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(0)*8))
	for i = int32(1); i < 32; i++ {
		if uintptr(unsafe.Pointer(*(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		p = func() *struct_PgHdr {
			if p != nil {
				return pcacheMergeDirtyList(p, *(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8)))
			} else {
				return *(**struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_PgHdr)(unsafe.Pointer(&a)))) + uintptr(i)*8))
			}
		}()
	}
	return p
}
func sqlite3PcacheDirtyList(pCache *struct_PCache) *struct_PgHdr {
	var p *struct_PgHdr
	for p = pCache.pDirty; p != nil; p = p.pDirtyNext {
		p.pDirty = p.pDirtyNext
	}
	return pcacheSortDirtyList(pCache.pDirty)
}
func sqlite3PcacheRefCount(pCache *struct_PCache) int32 {
	return pCache.nRefSum
}
func sqlite3PcachePageRefcount(p *struct_PgHdr) int32 {
	return int32(p.nRef)
}
func sqlite3PcachePagecount(pCache *struct_PCache) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3Config.pcache2.xPagecount(pCache.pCache)
}
func sqlite3PcacheSetCachesize(pCache *struct_PCache, mxPage int32) {
	func() int {
		_ = 0
		return 0
	}()
	pCache.szCache = mxPage
	sqlite3Config.pcache2.xCachesize(pCache.pCache, numberOfCachePages(pCache))
}
func sqlite3PcacheSetSpillsize(p *struct_PCache, mxPage int32) int32 {
	var res int32
	func() int {
		_ = 0
		return 0
	}()
	if mxPage != 0 {
		if mxPage < 0 {
			mxPage = int32(int64(-1024) * int64(mxPage) / int64(p.szPage+p.szExtra))
		}
		p.szSpill = mxPage
	}
	res = numberOfCachePages(p)
	if res < p.szSpill {
		res = p.szSpill
	}
	return res
}
func sqlite3PcacheShrink(pCache *struct_PCache) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3Config.pcache2.xShrink(pCache.pCache)
}
func sqlite3HeaderSizePcache() int32 {
	return int32((72 + uint(7)) & uint(18446744073709551608))
}
func sqlite3PCachePercentDirty(pCache *struct_PCache) int32 {
	var pDirty *struct_PgHdr
	var nDirty int32 = 0
	var nCache int32 = numberOfCachePages(pCache)
	for pDirty = pCache.pDirty; pDirty != nil; pDirty = pDirty.pDirtyNext {
		nDirty++
	}
	return func() int32 {
		if nCache != 0 {
			return int32(int64(nDirty) * int64(100) / int64(nCache))
		} else {
			return 0
		}
	}()
}

type PCache1 = struct_PCache1
type PgHdr1 = struct_PgHdr1
type PgFreeslot = struct_PgFreeslot
type PGroup = struct_PGroup
type struct_PgHdr1 struct {
	page        struct_sqlite3_pcache_page
	iKey        uint32
	isBulkLocal uint16
	isAnchor    uint16
	pNext       *struct_PgHdr1
	pCache      *struct_PCache1
	pLruNext    *struct_PgHdr1
	pLruPrev    *struct_PgHdr1
}
type struct_PGroup struct {
	mutex      *struct_sqlite3_mutex
	nMaxPage   uint32
	nMinPage   uint32
	mxPinned   uint32
	nPurgeable uint32
	lru        struct_PgHdr1
}
type struct_PCache1 struct {
	pGroup          *struct_PGroup
	pnPurgeable     *uint32
	szPage          int32
	szExtra         int32
	szAlloc         int32
	bPurgeable      int32
	nMin            uint32
	nMax            uint32
	n90pct          uint32
	iMaxKey         uint32
	nPurgeableDummy uint32
	nRecyclable     uint32
	nPage           uint32
	nHash           uint32
	apHash          **struct_PgHdr1
	pFree           *struct_PgHdr1
	pBulk           unsafe.Pointer
}
type struct_PgFreeslot struct {
	pNext *struct_PgFreeslot
}
type struct_PCacheGlobal struct {
	grp            struct_PGroup
	isInit         int32
	separateCache  int32
	nInitPage      int32
	szSlot         int32
	nSlot          int32
	nReserve       int32
	pStart         unsafe.Pointer
	pEnd           unsafe.Pointer
	mutex          *struct_sqlite3_mutex
	pFree          *struct_PgFreeslot
	nFreeSlot      int32
	bUnderPressure int32
}

var pcache1_g struct_PCacheGlobal

func sqlite3PCacheBufferSetup(pBuf unsafe.Pointer, sz int32, n int32) {
	if pcache1_g.isInit != 0 {
		var p *struct_PgFreeslot
		if uintptr(unsafe.Pointer(pBuf)) == uintptr(unsafe.Pointer(nil)) {
			sz = func() (_cgo_ret int32) {
				_cgo_addr := &n
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
		}
		if n == 0 {
			sz = int32(0)
		}
		sz = sz & ^7
		pcache1_g.szSlot = sz
		pcache1_g.nSlot = func() (_cgo_ret int32) {
			_cgo_addr := &pcache1_g.nFreeSlot
			*_cgo_addr = n
			return *_cgo_addr
		}()
		pcache1_g.nReserve = func() int32 {
			if n > 90 {
				return 10
			} else {
				return n/10 + 1
			}
		}()
		pcache1_g.pStart = pBuf
		pcache1_g.pFree = (*struct_PgFreeslot)(nil)
		pcache1_g.bUnderPressure = int32(0)
		for func() (_cgo_ret int32) {
			_cgo_addr := &n
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}() != 0 {
			p = (*struct_PgFreeslot)(pBuf)
			p.pNext = pcache1_g.pFree
			pcache1_g.pFree = p
			pBuf = unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pBuf))) + uintptr(sz))))
		}
		pcache1_g.pEnd = pBuf
	}
}
func pcache1InitBulk(pCache *struct_PCache1) int32 {
	var szBulk int64
	var zBulk *int8
	if pcache1_g.nInitPage == 0 {
		return int32(0)
	}
	if pCache.nMax < uint32(3) {
		return int32(0)
	}
	sqlite3BeginBenignMalloc()
	if pcache1_g.nInitPage > 0 {
		szBulk = int64(pCache.szAlloc) * int64(pcache1_g.nInitPage)
	} else {
		szBulk = int64(-1024) * int64(pcache1_g.nInitPage)
	}
	if szBulk > int64(pCache.szAlloc)*int64(pCache.nMax) {
		szBulk = int64(pCache.szAlloc) * int64(pCache.nMax)
	}
	zBulk = (*int8)(func() (_cgo_ret unsafe.Pointer) {
		_cgo_addr := &pCache.pBulk
		*_cgo_addr = sqlite3Malloc(uint64(szBulk))
		return *_cgo_addr
	}())
	sqlite3EndBenignMalloc()
	if zBulk != nil {
		var nBulk int32 = sqlite3MallocSize(unsafe.Pointer(zBulk)) / pCache.szAlloc
		for {
			var pX *struct_PgHdr1 = (*struct_PgHdr1)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBulk)) + uintptr(pCache.szPage)))))
			pX.page.pBuf = unsafe.Pointer(zBulk)
			pX.page.pExtra = unsafe.Pointer(&*(*struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pX)) + uintptr(1)*56)))
			pX.isBulkLocal = uint16(1)
			pX.isAnchor = uint16(0)
			pX.pNext = pCache.pFree
			pX.pLruPrev = (*struct_PgHdr1)(nil)
			pCache.pFree = pX
			*(*uintptr)(unsafe.Pointer(&zBulk)) += uintptr(pCache.szAlloc)
			if !(func() (_cgo_ret int32) {
				_cgo_addr := &nBulk
				*_cgo_addr--
				return *_cgo_addr
			}() != 0) {
				break
			}
		}
	}
	return func() int32 {
		if uintptr(unsafe.Pointer(pCache.pFree)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
}
func pcache1Alloc(nByte int32) unsafe.Pointer {
	var p unsafe.Pointer = nil
	func() int {
		_ = 0
		return 0
	}()
	if nByte <= pcache1_g.szSlot {
		sqlite3_mutex_enter(pcache1_g.mutex)
		p = unsafe.Pointer((*struct_PgHdr1)(unsafe.Pointer(pcache1_g.pFree)))
		if p != nil {
			pcache1_g.pFree = pcache1_g.pFree.pNext
			pcache1_g.nFreeSlot--
			pcache1_g.bUnderPressure = func() int32 {
				if pcache1_g.nFreeSlot < pcache1_g.nReserve {
					return 1
				} else {
					return 0
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3StatusHighwater(7, nByte)
			sqlite3StatusUp(1, 1)
		}
		sqlite3_mutex_leave(pcache1_g.mutex)
	}
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		p = sqlite3Malloc(uint64(nByte))
		if p != nil {
			var sz int32 = sqlite3MallocSize(p)
			sqlite3_mutex_enter(pcache1_g.mutex)
			sqlite3StatusHighwater(7, nByte)
			sqlite3StatusUp(2, sz)
			sqlite3_mutex_leave(pcache1_g.mutex)
		}
	}
	return p
}
func pcache1Free(p unsafe.Pointer) {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uint64(p) >= uint64(pcache1_g.pStart) && uint64(p) < uint64(pcache1_g.pEnd) {
		var pSlot *struct_PgFreeslot
		sqlite3_mutex_enter(pcache1_g.mutex)
		sqlite3StatusDown(1, 1)
		pSlot = (*struct_PgFreeslot)(p)
		pSlot.pNext = pcache1_g.pFree
		pcache1_g.pFree = pSlot
		pcache1_g.nFreeSlot++
		pcache1_g.bUnderPressure = func() int32 {
			if pcache1_g.nFreeSlot < pcache1_g.nReserve {
				return 1
			} else {
				return 0
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_mutex_leave(pcache1_g.mutex)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		{
			var nFreed int32 = 0
			nFreed = sqlite3MallocSize(p)
			sqlite3_mutex_enter(pcache1_g.mutex)
			sqlite3StatusDown(2, nFreed)
			sqlite3_mutex_leave(pcache1_g.mutex)
		}
		sqlite3_free(p)
	}
}
func pcache1AllocPage(pCache *struct_PCache1, benignMalloc int32) *struct_PgHdr1 {
	var p *struct_PgHdr1 = nil
	var pPg unsafe.Pointer
	func() int {
		_ = 0
		return 0
	}()
	if pCache.pFree != nil || pCache.nPage == uint32(0) && pcache1InitBulk(pCache) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		p = pCache.pFree
		pCache.pFree = p.pNext
		p.pNext = (*struct_PgHdr1)(nil)
	} else {
		if benignMalloc != 0 {
			sqlite3BeginBenignMalloc()
		}
		pPg = pcache1Alloc(pCache.szAlloc)
		if benignMalloc != 0 {
			sqlite3EndBenignMalloc()
		}
		if uintptr(unsafe.Pointer(pPg)) == uintptr(unsafe.Pointer(nil)) {
			return (*struct_PgHdr1)(nil)
		}
		p = (*struct_PgHdr1)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pPg))) + uintptr(pCache.szPage)))))
		p.page.pBuf = pPg
		p.page.pExtra = unsafe.Pointer(&*(*struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*56)))
		p.isBulkLocal = uint16(0)
		p.isAnchor = uint16(0)
		p.pLruPrev = (*struct_PgHdr1)(nil)
	}
	*pCache.pnPurgeable++
	return p
}
func pcache1FreePage(p *struct_PgHdr1) {
	var pCache *struct_PCache1
	func() int {
		_ = 0
		return 0
	}()
	pCache = p.pCache
	func() int {
		_ = 0
		return 0
	}()
	if p.isBulkLocal != 0 {
		p.pNext = pCache.pFree
		pCache.pFree = p
	} else {
		pcache1Free(p.page.pBuf)
	}
	*pCache.pnPurgeable--
}
func sqlite3PageMalloc(sz int32) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	return pcache1Alloc(sz)
}
func sqlite3PageFree(p unsafe.Pointer) {
	pcache1Free(p)
}
func pcache1UnderMemoryPressure(pCache *struct_PCache1) int32 {
	if pcache1_g.nSlot != 0 && pCache.szPage+pCache.szExtra <= pcache1_g.szSlot {
		return pcache1_g.bUnderPressure
	} else {
		return sqlite3HeapNearlyFull()
	}
}
func pcache1ResizeHash(p *struct_PCache1) {
	var apNew **struct_PgHdr1
	var nNew uint32
	var i uint32
	func() int {
		_ = 0
		return 0
	}()
	nNew = p.nHash * uint32(2)
	if nNew < uint32(256) {
		nNew = uint32(256)
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.nHash != 0 {
		sqlite3BeginBenignMalloc()
	}
	apNew = (**struct_PgHdr1)(sqlite3MallocZero(uint64(8 * uint(nNew))))
	if p.nHash != 0 {
		sqlite3EndBenignMalloc()
	}
	func() int {
		_ = 0
		return 0
	}()
	if apNew != nil {
		for i = uint32(0); i < p.nHash; i++ {
			var pPage *struct_PgHdr1
			var pNext *struct_PgHdr1 = *(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apHash)) + uintptr(i)*8))
			for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_PgHdr1) {
				_cgo_addr := &pPage
				*_cgo_addr = pNext
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) {
				var h uint32 = pPage.iKey % nNew
				pNext = pPage.pNext
				pPage.pNext = *(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(apNew)) + uintptr(h)*8))
				*(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(apNew)) + uintptr(h)*8)) = pPage
			}
		}
		sqlite3_free(unsafe.Pointer(p.apHash))
		p.apHash = apNew
		p.nHash = nNew
	}
}
func pcache1PinPage(pPage *struct_PgHdr1) *struct_PgHdr1 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPage.pLruPrev.pLruNext = pPage.pLruNext
	pPage.pLruNext.pLruPrev = pPage.pLruPrev
	pPage.pLruNext = (*struct_PgHdr1)(nil)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPage.pCache.nRecyclable--
	return pPage
}
func pcache1RemoveFromHash(pPage *struct_PgHdr1, freeFlag int32) {
	var h uint32
	var pCache *struct_PCache1 = pPage.pCache
	var pp **struct_PgHdr1
	func() int {
		_ = 0
		return 0
	}()
	h = pPage.iKey % pCache.nHash
	for pp = &*(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8)); uintptr(unsafe.Pointer(*pp)) != uintptr(unsafe.Pointer(pPage)); pp = &(*pp).pNext {
	}
	*pp = (*pp).pNext
	pCache.nPage--
	if freeFlag != 0 {
		pcache1FreePage(pPage)
	}
}
func pcache1EnforceMaxPage(pCache *struct_PCache1) {
	var pGroup *struct_PGroup = pCache.pGroup
	var p *struct_PgHdr1
	func() int {
		_ = 0
		return 0
	}()
	for pGroup.nPurgeable > pGroup.nMaxPage && int32(func() (_cgo_ret *struct_PgHdr1) {
		_cgo_addr := &p
		*_cgo_addr = pGroup.lru.pLruPrev
		return *_cgo_addr
	}().isAnchor) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pcache1PinPage(p)
		pcache1RemoveFromHash(p, 1)
	}
	if pCache.nPage == uint32(0) && pCache.pBulk != nil {
		sqlite3_free(pCache.pBulk)
		pCache.pBulk = unsafe.Pointer(func() (_cgo_ret *struct_PgHdr1) {
			_cgo_addr := &pCache.pFree
			*_cgo_addr = (*struct_PgHdr1)(nil)
			return *_cgo_addr
		}())
	}
}
func pcache1TruncateUnsafe(pCache *struct_PCache1, iLimit uint32) {
	var h uint32
	var iStop uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pCache.iMaxKey-iLimit < pCache.nHash {
		h = iLimit % pCache.nHash
		iStop = pCache.iMaxKey % pCache.nHash
	} else {
		h = pCache.nHash / uint32(2)
		iStop = h - uint32(1)
	}
	for {
		var pp **struct_PgHdr1
		var pPage *struct_PgHdr1
		func() int {
			_ = 0
			return 0
		}()
		pp = &*(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8))
		for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_PgHdr1) {
			_cgo_addr := &pPage
			*_cgo_addr = *pp
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			if pPage.iKey >= iLimit {
				pCache.nPage--
				*pp = pPage.pNext
				if uintptr(unsafe.Pointer(pPage.pLruNext)) != uintptr(unsafe.Pointer(nil)) {
					pcache1PinPage(pPage)
				}
				pcache1FreePage(pPage)
			} else {
				pp = &pPage.pNext
			}
		}
		if h == iStop {
			break
		}
		h = (h + uint32(1)) % pCache.nHash
	}
	func() int {
		_ = 0
		return 0
	}()
}
func pcache1Init(NotUsed unsafe.Pointer) int32 {
	func() int {
		_ = NotUsed
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&pcache1_g), 0, 144, __builtin_object_size(unsafe.Pointer(&pcache1_g), 0))
	pcache1_g.separateCache = func() int32 {
		if uintptr(unsafe.Pointer(sqlite3Config.pPage)) == uintptr(unsafe.Pointer(nil)) || int32(sqlite3Config.bCoreMutex) > 0 {
			return 1
		} else {
			return 0
		}
	}()
	if sqlite3Config.bCoreMutex != 0 {
		pcache1_g.grp.mutex = sqlite3MutexAlloc(6)
		pcache1_g.mutex = sqlite3MutexAlloc(7)
	}
	if pcache1_g.separateCache != 0 && sqlite3Config.nPage != 0 && uintptr(unsafe.Pointer(sqlite3Config.pPage)) == uintptr(unsafe.Pointer(nil)) {
		pcache1_g.nInitPage = sqlite3Config.nPage
	} else {
		pcache1_g.nInitPage = int32(0)
	}
	pcache1_g.grp.mxPinned = uint32(10)
	pcache1_g.isInit = int32(1)
	return int32(0)
}
func pcache1Shutdown(NotUsed unsafe.Pointer) {
	func() int {
		_ = NotUsed
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&pcache1_g), 0, 144, __builtin_object_size(unsafe.Pointer(&pcache1_g), 0))
}
func pcache1Create(szPage int32, szExtra int32, bPurgeable int32) *struct_sqlite3_pcache {
	var pCache *struct_PCache1
	var pGroup *struct_PGroup
	var sz int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sz = int32(88 + 80*uint(pcache1_g.separateCache))
	pCache = (*struct_PCache1)(sqlite3MallocZero(uint64(sz)))
	if pCache != nil {
		if pcache1_g.separateCache != 0 {
			pGroup = (*struct_PGroup)(unsafe.Pointer(&*(*struct_PCache1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache)) + uintptr(1)*88))))
			pGroup.mxPinned = uint32(10)
		} else {
			pGroup = &pcache1_g.grp
		}
		func() int {
			_ = 0
			return 0
		}()
		if int32(pGroup.lru.isAnchor) == 0 {
			pGroup.lru.isAnchor = uint16(1)
			pGroup.lru.pLruPrev = func() (_cgo_ret *struct_PgHdr1) {
				_cgo_addr := &pGroup.lru.pLruNext
				*_cgo_addr = &pGroup.lru
				return *_cgo_addr
			}()
		}
		pCache.pGroup = pGroup
		pCache.szPage = szPage
		pCache.szExtra = szExtra
		pCache.szAlloc = int32(uint(szPage+szExtra) + (56+uint(7))&uint(18446744073709551608))
		pCache.bPurgeable = func() int32 {
			if bPurgeable != 0 {
				return 1
			} else {
				return 0
			}
		}()
		pcache1ResizeHash(pCache)
		if bPurgeable != 0 {
			pCache.nMin = uint32(10)
			pGroup.nMinPage += pCache.nMin
			pGroup.mxPinned = pGroup.nMaxPage + uint32(10) - pGroup.nMinPage
			pCache.pnPurgeable = &pGroup.nPurgeable
		} else {
			pCache.pnPurgeable = &pCache.nPurgeableDummy
		}
		func() int {
			_ = 0
			return 0
		}()
		if pCache.nHash == uint32(0) {
			pcache1Destroy((*struct_sqlite3_pcache)(unsafe.Pointer(pCache)))
			pCache = (*struct_PCache1)(nil)
		}
	}
	return (*struct_sqlite3_pcache)(unsafe.Pointer(pCache))
}
func pcache1Cachesize(p *struct_sqlite3_pcache, nMax int32) {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	var n uint32
	func() int {
		_ = 0
		return 0
	}()
	if pCache.bPurgeable != 0 {
		var pGroup *struct_PGroup = pCache.pGroup
		func() int {
			_ = 0
			return 0
		}()
		n = uint32(nMax)
		if n > uint32(2147418112)-pGroup.nMaxPage+pCache.nMax {
			n = uint32(2147418112) - pGroup.nMaxPage + pCache.nMax
		}
		pGroup.nMaxPage += n - pCache.nMax
		pGroup.mxPinned = pGroup.nMaxPage + uint32(10) - pGroup.nMinPage
		pCache.nMax = n
		pCache.n90pct = pCache.nMax * uint32(9) / uint32(10)
		pcache1EnforceMaxPage(pCache)
		func() int {
			_ = 0
			return 0
		}()
	}
}
func pcache1Shrink(p *struct_sqlite3_pcache) {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	if pCache.bPurgeable != 0 {
		var pGroup *struct_PGroup = pCache.pGroup
		var savedMaxPage uint32
		func() int {
			_ = 0
			return 0
		}()
		savedMaxPage = pGroup.nMaxPage
		pGroup.nMaxPage = uint32(0)
		pcache1EnforceMaxPage(pCache)
		pGroup.nMaxPage = savedMaxPage
		func() int {
			_ = 0
			return 0
		}()
	}
}
func pcache1Pagecount(p *struct_sqlite3_pcache) int32 {
	var n int32
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	func() int {
		_ = 0
		return 0
	}()
	n = int32(pCache.nPage)
	func() int {
		_ = 0
		return 0
	}()
	return n
}
func pcache1FetchStage2(pCache *struct_PCache1, iKey uint32, createFlag int32) *struct_PgHdr1 {
	var nPinned uint32
	var pGroup *struct_PGroup = pCache.pGroup
	var pPage *struct_PgHdr1 = nil
	func() int {
		_ = 0
		return 0
	}()
	nPinned = pCache.nPage - pCache.nRecyclable
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if createFlag == 1 && (nPinned >= pGroup.mxPinned || nPinned >= pCache.n90pct || pcache1UnderMemoryPressure(pCache) != 0 && pCache.nRecyclable < nPinned) {
		return (*struct_PgHdr1)(nil)
	}
	if pCache.nPage >= pCache.nHash {
		pcache1ResizeHash(pCache)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pCache.bPurgeable != 0 && !(pGroup.lru.pLruPrev.isAnchor != 0) && (pCache.nPage+uint32(1) >= pCache.nMax || pcache1UnderMemoryPressure(pCache) != 0) {
		var pOther *struct_PCache1
		pPage = pGroup.lru.pLruPrev
		func() int {
			_ = 0
			return 0
		}()
		pcache1RemoveFromHash(pPage, 0)
		pcache1PinPage(pPage)
		pOther = pPage.pCache
		if pOther.szAlloc != pCache.szAlloc {
			pcache1FreePage(pPage)
			pPage = (*struct_PgHdr1)(nil)
		} else {
			pGroup.nPurgeable -= uint32(pOther.bPurgeable - pCache.bPurgeable)
		}
	}
	if !(pPage != nil) {
		pPage = pcache1AllocPage(pCache, func() int32 {
			if createFlag == 1 {
				return 1
			} else {
				return 0
			}
		}())
	}
	if pPage != nil {
		var h uint32 = iKey % pCache.nHash
		pCache.nPage++
		pPage.iKey = iKey
		pPage.pNext = *(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8))
		pPage.pCache = pCache
		pPage.pLruNext = (*struct_PgHdr1)(nil)
		*(*unsafe.Pointer)(pPage.page.pExtra) = unsafe.Pointer(nil)
		*(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8)) = pPage
		if iKey > pCache.iMaxKey {
			pCache.iMaxKey = iKey
		}
	}
	return pPage
}
func pcache1FetchNoMutex(p *struct_sqlite3_pcache, iKey uint32, createFlag int32) *struct_PgHdr1 {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	var pPage *struct_PgHdr1 = nil
	pPage = *(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(iKey%pCache.nHash)*8))
	for pPage != nil && pPage.iKey != iKey {
		pPage = pPage.pNext
	}
	if pPage != nil {
		if uintptr(unsafe.Pointer(pPage.pLruNext)) != uintptr(unsafe.Pointer(nil)) {
			return pcache1PinPage(pPage)
		} else {
			return pPage
		}
	} else if createFlag != 0 {
		return pcache1FetchStage2(pCache, iKey, createFlag)
	} else {
		return (*struct_PgHdr1)(nil)
	}
}
func pcache1Fetch(p *struct_sqlite3_pcache, iKey uint32, createFlag int32) *struct_sqlite3_pcache_page {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	{
		return (*struct_sqlite3_pcache_page)(unsafe.Pointer(pcache1FetchNoMutex(p, iKey, createFlag)))
	}
}
func pcache1Unpin(p *struct_sqlite3_pcache, pPg *struct_sqlite3_pcache_page, reuseUnlikely int32) {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	var pPage *struct_PgHdr1 = (*struct_PgHdr1)(unsafe.Pointer(pPg))
	var pGroup *struct_PGroup = pCache.pGroup
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if reuseUnlikely != 0 || pGroup.nPurgeable > pGroup.nMaxPage {
		pcache1RemoveFromHash(pPage, 1)
	} else {
		var ppFirst **struct_PgHdr1 = &pGroup.lru.pLruNext
		pPage.pLruPrev = &pGroup.lru
		func() (_cgo_ret *struct_PgHdr1) {
			_cgo_addr := &pPage.pLruNext
			*_cgo_addr = *ppFirst
			return *_cgo_addr
		}().pLruPrev = pPage
		*ppFirst = pPage
		pCache.nRecyclable++
	}
	func() int {
		_ = 0
		return 0
	}()
}
func pcache1Rekey(p *struct_sqlite3_pcache, pPg *struct_sqlite3_pcache_page, iOld uint32, iNew uint32) {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	var pPage *struct_PgHdr1 = (*struct_PgHdr1)(unsafe.Pointer(pPg))
	var pp **struct_PgHdr1
	var h uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	h = iOld % pCache.nHash
	pp = &*(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8))
	for uintptr(unsafe.Pointer(*pp)) != uintptr(unsafe.Pointer(pPage)) {
		pp = &(*pp).pNext
	}
	*pp = pPage.pNext
	h = iNew % pCache.nHash
	pPage.iKey = iNew
	pPage.pNext = *(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8))
	*(**struct_PgHdr1)(unsafe.Pointer(uintptr(unsafe.Pointer(pCache.apHash)) + uintptr(h)*8)) = pPage
	if iNew > pCache.iMaxKey {
		pCache.iMaxKey = iNew
	}
	func() int {
		_ = 0
		return 0
	}()
}
func pcache1Truncate(p *struct_sqlite3_pcache, iLimit uint32) {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	func() int {
		_ = 0
		return 0
	}()
	if iLimit <= pCache.iMaxKey {
		pcache1TruncateUnsafe(pCache, iLimit)
		pCache.iMaxKey = iLimit - uint32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
}
func pcache1Destroy(p *struct_sqlite3_pcache) {
	var pCache *struct_PCache1 = (*struct_PCache1)(unsafe.Pointer(p))
	var pGroup *struct_PGroup = pCache.pGroup
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pCache.nPage != 0 {
		pcache1TruncateUnsafe(pCache, uint32(0))
	}
	func() int {
		_ = 0
		return 0
	}()
	pGroup.nMaxPage -= pCache.nMax
	func() int {
		_ = 0
		return 0
	}()
	pGroup.nMinPage -= pCache.nMin
	pGroup.mxPinned = pGroup.nMaxPage + uint32(10) - pGroup.nMinPage
	pcache1EnforceMaxPage(pCache)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_free(pCache.pBulk)
	sqlite3_free(unsafe.Pointer(pCache.apHash))
	sqlite3_free(unsafe.Pointer(pCache))
}
func sqlite3PCacheSetDefault() {
	var defaultMethods struct_sqlite3_pcache_methods2 = struct_sqlite3_pcache_methods2{1, nil, pcache1Init, pcache1Shutdown, pcache1Create, pcache1Cachesize, pcache1Pagecount, pcache1Fetch, pcache1Unpin, pcache1Rekey, pcache1Truncate, pcache1Destroy, pcache1Shrink}
	sqlite3_config(18, &defaultMethods)
}
func sqlite3HeaderSizePcache1() int32 {
	return int32((56 + uint(7)) & uint(18446744073709551608))
}
func sqlite3Pcache1Mutex() *struct_sqlite3_mutex {
	return pcache1_g.mutex
}

type struct_RowSetEntry struct {
	v      int64
	pRight *struct_RowSetEntry
	pLeft  *struct_RowSetEntry
}
type struct_RowSetChunk struct {
	pNextChunk *struct_RowSetChunk
	aEntry     [42]struct_RowSetEntry
}
type struct_RowSet struct {
	pChunk  *struct_RowSetChunk
	db      *struct_sqlite3
	pEntry  *struct_RowSetEntry
	pLast   *struct_RowSetEntry
	pFresh  *struct_RowSetEntry
	pForest *struct_RowSetEntry
	nFresh  uint16
	rsFlags uint16
	iBatch  int32
}

func sqlite3RowSetInit(db *struct_sqlite3) *struct_RowSet {
	var p *struct_RowSet = (*struct_RowSet)(sqlite3DbMallocRawNN(db, uint64(56)))
	if p != nil {
		var N int32 = sqlite3DbMallocSize(db, unsafe.Pointer(p))
		p.pChunk = (*struct_RowSetChunk)(nil)
		p.db = db
		p.pEntry = (*struct_RowSetEntry)(nil)
		p.pLast = (*struct_RowSetEntry)(nil)
		p.pForest = (*struct_RowSetEntry)(nil)
		p.pFresh = (*struct_RowSetEntry)(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p)))) + uintptr((56+uint(7))&uint(18446744073709551608))))))
		p.nFresh = uint16((uint(N) - (56+uint(7))&uint(18446744073709551608)) / 24)
		p.rsFlags = uint16(1)
		p.iBatch = int32(0)
	}
	return p
}
func sqlite3RowSetClear(pArg unsafe.Pointer) {
	var p *struct_RowSet = (*struct_RowSet)(pArg)
	var pChunk *struct_RowSetChunk
	var pNextChunk *struct_RowSetChunk
	for pChunk = p.pChunk; pChunk != nil; pChunk = pNextChunk {
		pNextChunk = pChunk.pNextChunk
		sqlite3DbFree(p.db, unsafe.Pointer(pChunk))
	}
	p.pChunk = (*struct_RowSetChunk)(nil)
	p.nFresh = uint16(0)
	p.pEntry = (*struct_RowSetEntry)(nil)
	p.pLast = (*struct_RowSetEntry)(nil)
	p.pForest = (*struct_RowSetEntry)(nil)
	p.rsFlags = uint16(1)
}
func sqlite3RowSetDelete(pArg unsafe.Pointer) {
	sqlite3RowSetClear(pArg)
	sqlite3DbFree((*struct_RowSet)(pArg).db, pArg)
}
func rowSetEntryAlloc(p *struct_RowSet) *struct_RowSetEntry {
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.nFresh) == 0 {
		var pNew *struct_RowSetChunk
		pNew = (*struct_RowSetChunk)(sqlite3DbMallocRawNN(p.db, uint64(1016)))
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			return (*struct_RowSetEntry)(nil)
		}
		pNew.pNextChunk = p.pChunk
		p.pChunk = pNew
		p.pFresh = (*struct_RowSetEntry)(unsafe.Pointer(&pNew.aEntry))
		p.nFresh = uint16(uint(1024-8) / 24)
	}
	p.nFresh--
	return func() (_cgo_ret *struct_RowSetEntry) {
		_cgo_addr := &p.pFresh
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 24
		return
	}()
}
func sqlite3RowSetInsert(p *struct_RowSet, rowid int64) {
	var pEntry *struct_RowSetEntry
	var pLast *struct_RowSetEntry
	func() int {
		_ = 0
		return 0
	}()
	pEntry = rowSetEntryAlloc(p)
	if uintptr(unsafe.Pointer(pEntry)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	pEntry.v = rowid
	pEntry.pRight = (*struct_RowSetEntry)(nil)
	pLast = p.pLast
	if pLast != nil {
		if rowid <= pLast.v {
			p.rsFlags &= uint16(^1)
		}
		pLast.pRight = pEntry
	} else {
		p.pEntry = pEntry
	}
	p.pLast = pEntry
}
func rowSetEntryMerge(pA *struct_RowSetEntry, pB *struct_RowSetEntry) *struct_RowSetEntry {
	var head struct_RowSetEntry
	var pTail *struct_RowSetEntry
	pTail = &head
	func() int {
		_ = 0
		return 0
	}()
	for {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pA.v <= pB.v {
			if pA.v < pB.v {
				pTail = func() (_cgo_ret *struct_RowSetEntry) {
					_cgo_addr := &pTail.pRight
					*_cgo_addr = pA
					return *_cgo_addr
				}()
			}
			pA = pA.pRight
			if uintptr(unsafe.Pointer(pA)) == uintptr(unsafe.Pointer(nil)) {
				pTail.pRight = pB
				break
			}
		} else {
			pTail = func() (_cgo_ret *struct_RowSetEntry) {
				_cgo_addr := &pTail.pRight
				*_cgo_addr = pB
				return *_cgo_addr
			}()
			pB = pB.pRight
			if uintptr(unsafe.Pointer(pB)) == uintptr(unsafe.Pointer(nil)) {
				pTail.pRight = pA
				break
			}
		}
	}
	return head.pRight
}
func rowSetEntrySort(pIn *struct_RowSetEntry) *struct_RowSetEntry {
	var i uint32
	var pNext *struct_RowSetEntry
	var aBucket [40]*struct_RowSetEntry
	__builtin___memset_chk(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket))), 0, 320, __builtin_object_size(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket))), 0))
	for pIn != nil {
		pNext = pIn.pRight
		pIn.pRight = (*struct_RowSetEntry)(nil)
		for i = uint32(0); *(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8)) != nil; i++ {
			pIn = rowSetEntryMerge(*(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8)), pIn)
			*(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8)) = (*struct_RowSetEntry)(nil)
		}
		*(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8)) = pIn
		pIn = pNext
	}
	pIn = *(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(0)*8))
	for i = uint32(1); uint(i) < 320/8; i++ {
		if uintptr(unsafe.Pointer(*(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		pIn = func() *struct_RowSetEntry {
			if pIn != nil {
				return rowSetEntryMerge(pIn, *(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8)))
			} else {
				return *(**struct_RowSetEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_RowSetEntry)(unsafe.Pointer(&aBucket)))) + uintptr(i)*8))
			}
		}()
	}
	return pIn
}
func rowSetTreeToList(pIn *struct_RowSetEntry, ppFirst **struct_RowSetEntry, ppLast **struct_RowSetEntry) {
	func() int {
		_ = 0
		return 0
	}()
	if pIn.pLeft != nil {
		var p *struct_RowSetEntry
		rowSetTreeToList(pIn.pLeft, ppFirst, &p)
		p.pRight = pIn
	} else {
		*ppFirst = pIn
	}
	if pIn.pRight != nil {
		rowSetTreeToList(pIn.pRight, &pIn.pRight, ppLast)
	} else {
		*ppLast = pIn
	}
	func() int {
		_ = 0
		return 0
	}()
}
func rowSetNDeepTree(ppList **struct_RowSetEntry, iDepth int32) *struct_RowSetEntry {
	var p *struct_RowSetEntry
	var pLeft *struct_RowSetEntry
	if uintptr(unsafe.Pointer(*ppList)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_RowSetEntry)(nil)
	}
	if iDepth > 1 {
		pLeft = rowSetNDeepTree(ppList, iDepth-1)
		p = *ppList
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			return pLeft
		}
		p.pLeft = pLeft
		*ppList = p.pRight
		p.pRight = rowSetNDeepTree(ppList, iDepth-1)
	} else {
		p = *ppList
		*ppList = p.pRight
		p.pLeft = func() (_cgo_ret *struct_RowSetEntry) {
			_cgo_addr := &p.pRight
			*_cgo_addr = (*struct_RowSetEntry)(nil)
			return *_cgo_addr
		}()
	}
	return p
}
func rowSetListToTree(pList *struct_RowSetEntry) *struct_RowSetEntry {
	var iDepth int32
	var p *struct_RowSetEntry
	var pLeft *struct_RowSetEntry
	func() int {
		_ = 0
		return 0
	}()
	p = pList
	pList = p.pRight
	p.pLeft = func() (_cgo_ret *struct_RowSetEntry) {
		_cgo_addr := &p.pRight
		*_cgo_addr = (*struct_RowSetEntry)(nil)
		return *_cgo_addr
	}()
	for iDepth = int32(1); pList != nil; iDepth++ {
		pLeft = p
		p = pList
		pList = p.pRight
		p.pLeft = pLeft
		p.pRight = rowSetNDeepTree(&pList, iDepth)
	}
	return p
}
func sqlite3RowSetNext(p *struct_RowSet, pRowid *int64) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.rsFlags)&2 == 0 {
		if int32(p.rsFlags)&1 == 0 {
			p.pEntry = rowSetEntrySort(p.pEntry)
		}
		p.rsFlags |= uint16(1 | 2)
	}
	if p.pEntry != nil {
		*pRowid = p.pEntry.v
		p.pEntry = p.pEntry.pRight
		if uintptr(unsafe.Pointer(p.pEntry)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3RowSetClear(unsafe.Pointer(p))
		}
		return int32(1)
	} else {
		return int32(0)
	}
}
func sqlite3RowSetTest(pRowSet *struct_RowSet, iBatch int32, iRowid int64) int32 {
	var p *struct_RowSetEntry
	var pTree *struct_RowSetEntry
	func() int {
		_ = 0
		return 0
	}()
	if iBatch != pRowSet.iBatch {
		p = pRowSet.pEntry
		if p != nil {
			var ppPrevTree **struct_RowSetEntry = &pRowSet.pForest
			if int32(pRowSet.rsFlags)&1 == 0 {
				p = rowSetEntrySort(p)
			}
			for pTree = pRowSet.pForest; pTree != nil; pTree = pTree.pRight {
				ppPrevTree = &pTree.pRight
				if uintptr(unsafe.Pointer(pTree.pLeft)) == uintptr(unsafe.Pointer(nil)) {
					pTree.pLeft = rowSetListToTree(p)
					break
				} else {
					var pAux *struct_RowSetEntry
					var pTail *struct_RowSetEntry
					rowSetTreeToList(pTree.pLeft, &pAux, &pTail)
					pTree.pLeft = (*struct_RowSetEntry)(nil)
					p = rowSetEntryMerge(pAux, p)
				}
			}
			if uintptr(unsafe.Pointer(pTree)) == uintptr(unsafe.Pointer(nil)) {
				*ppPrevTree = func() (_cgo_ret *struct_RowSetEntry) {
					_cgo_addr := &pTree
					*_cgo_addr = rowSetEntryAlloc(pRowSet)
					return *_cgo_addr
				}()
				if pTree != nil {
					pTree.v = int64(0)
					pTree.pRight = (*struct_RowSetEntry)(nil)
					pTree.pLeft = rowSetListToTree(p)
				}
			}
			pRowSet.pEntry = (*struct_RowSetEntry)(nil)
			pRowSet.pLast = (*struct_RowSetEntry)(nil)
			pRowSet.rsFlags |= uint16(1)
		}
		pRowSet.iBatch = iBatch
	}
	for pTree = pRowSet.pForest; pTree != nil; pTree = pTree.pRight {
		p = pTree.pLeft
		for p != nil {
			if p.v < iRowid {
				p = p.pRight
			} else if p.v > iRowid {
				p = p.pLeft
			} else {
				return int32(1)
			}
		}
	}
	return int32(0)
}

type Wal = struct_Wal
type PagerSavepoint = struct_PagerSavepoint
type struct_PagerSavepoint struct {
	iOffset            int64
	iHdrOffset         int64
	pInSavepoint       *struct_Bitvec
	nOrig              uint32
	iSubRec            uint32
	bTruncateOnRelease int32
	aWalData           [4]uint32
}
type struct_Pager struct {
	pVfs              *struct_sqlite3_vfs
	exclusiveMode     uint8
	journalMode       uint8
	useJournal        uint8
	noSync            uint8
	fullSync          uint8
	extraSync         uint8
	syncFlags         uint8
	walSyncFlags      uint8
	tempFile          uint8
	noLock            uint8
	readOnly          uint8
	memDb             uint8
	memVfs            uint8
	eState            uint8
	eLock             uint8
	changeCountDone   uint8
	setSuper          uint8
	doNotSpill        uint8
	subjInMemory      uint8
	bUseFetch         uint8
	hasHeldSharedLock uint8
	dbSize            uint32
	dbOrigSize        uint32
	dbFileSize        uint32
	dbHintSize        uint32
	errCode           int32
	nRec              int32
	cksumInit         uint32
	nSubRec           uint32
	pInJournal        *struct_Bitvec
	fd                *struct_sqlite3_file
	jfd               *struct_sqlite3_file
	sjfd              *struct_sqlite3_file
	journalOff        int64
	journalHdr        int64
	pBackup           *struct_sqlite3_backup
	aSavepoint        *struct_PagerSavepoint
	nSavepoint        int32
	iDataVersion      uint32
	dbFileVers        [16]int8
	nMmapOut          int32
	szMmap            int64
	pMmapFreelist     *struct_PgHdr
	nExtra            uint16
	nReserve          int16
	vfsFlags          uint32
	sectorSize        uint32
	mxPgno            uint32
	pageSize          int64
	journalSizeLimit  int64
	zFilename         *int8
	zJournal          *int8
	xBusyHandler      func(unsafe.Pointer) int32
	pBusyHandlerArg   unsafe.Pointer
	aStat             [4]int32
	xReiniter         func(*struct_PgHdr)
	xGet              func(*struct_Pager, uint32, **struct_PgHdr, int32) int32
	pTmpSpace         *int8
	pPCache           *struct_PCache
	pWal              *struct_Wal
	zWal              *int8
}

var aJournalMagic [8]uint8 = [8]uint8{uint8(217), uint8(213), uint8(5), uint8(249), uint8(32), uint8(161), uint8(99), uint8(215)}

func setGetterMethod(pPager *struct_Pager) {
	if pPager.errCode != 0 {
		pPager.xGet = getPageError
	} else if pPager.bUseFetch != 0 {
		pPager.xGet = getPageMMap
	} else {
		pPager.xGet = getPageNormal
	}
}
func subjRequiresPage(pPg *struct_PgHdr) int32 {
	var pPager *struct_Pager = pPg.pPager
	var p *struct_PagerSavepoint
	var pgno uint32 = pPg.pgno
	var i int32
	for i = int32(0); i < pPager.nSavepoint; i++ {
		p = &*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(i)*52))
		if p.nOrig >= pgno && 0 == sqlite3BitvecTestNotNull(p.pInSavepoint, pgno) {
			for i = i + 1; i < pPager.nSavepoint; i++ {
				(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(i)*52))).bTruncateOnRelease = int32(0)
			}
			return int32(1)
		}
	}
	return int32(0)
}
func read32bits(fd *struct_sqlite3_file, offset int64, pRes *uint32) int32 {
	var ac [4]uint8
	var rc int32 = sqlite3OsRead(fd, unsafe.Pointer((*uint8)(unsafe.Pointer(&ac))), int32(4), offset)
	if rc == 0 {
		*pRes = sqlite3Get4byte((*uint8)(unsafe.Pointer(&ac)))
	}
	return rc
}
func write32bits(fd *struct_sqlite3_file, offset int64, val uint32) int32 {
	var ac [4]int8
	sqlite3Put4byte((*uint8)(unsafe.Pointer((*int8)(unsafe.Pointer(&ac)))), val)
	return sqlite3OsWrite(fd, unsafe.Pointer((*int8)(unsafe.Pointer(&ac))), 4, offset)
}
func pagerUnlockDb(pPager *struct_Pager, eLock int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		rc = func() int32 {
			if int32(pPager.noLock) != 0 {
				return 0
			} else {
				return sqlite3OsUnlock(pPager.fd, eLock)
			}
		}()
		if int32(pPager.eLock) != 4+1 {
			pPager.eLock = uint8(eLock)
		}
	}
	pPager.changeCountDone = pPager.tempFile
	return rc
}
func pagerLockDb(pPager *struct_Pager, eLock int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.eLock) < eLock || int32(pPager.eLock) == 4+1 {
		rc = func() int32 {
			if int32(pPager.noLock) != 0 {
				return 0
			} else {
				return sqlite3OsLock(pPager.fd, eLock)
			}
		}()
		if rc == 0 && (int32(pPager.eLock) != 4+1 || eLock == 4) {
			pPager.eLock = uint8(eLock)
		}
	}
	return rc
}
func jrnlBufferSize(pPager *struct_Pager) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = pPager
		return 0
	}()
	return int32(0)
}
func readSuperJournal(pJrnl *struct_sqlite3_file, zSuper *int8, nSuper uint32) int32 {
	var rc int32
	var len uint32
	var szJ int64
	var cksum uint32
	var u uint32
	var aMagic [8]uint8
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(0))) = int8('\x00')
	if 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3OsFileSize(pJrnl, &szJ)
		return *_cgo_addr
	}() || szJ < int64(16) || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = read32bits(pJrnl, szJ-int64(16), &len)
		return *_cgo_addr
	}() || len >= nSuper || int64(len) > szJ-int64(16) || len == uint32(0) || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = read32bits(pJrnl, szJ-int64(12), &cksum)
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3OsRead(pJrnl, unsafe.Pointer((*uint8)(unsafe.Pointer(&aMagic))), 8, szJ-int64(8))
		return *_cgo_addr
	}() || memcmp(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMagic))), unsafe.Pointer((*uint8)(unsafe.Pointer(&aJournalMagic))), uint(8)) != 0 || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3OsRead(pJrnl, unsafe.Pointer(zSuper), int32(len), szJ-int64(16)-int64(len))
		return *_cgo_addr
	}() {
		return rc
	}
	for u = uint32(0); u < len; u++ {
		cksum -= uint32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(u))))
	}
	if cksum != 0 {
		len = uint32(0)
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(len))) = int8('\x00')
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(len+uint32(1)))) = int8('\x00')
	return int32(0)
}
func journalHdrOffset(pPager *struct_Pager) int64 {
	var offset int64 = int64(0)
	var c int64 = pPager.journalOff
	if c != 0 {
		offset = ((c-int64(1))/int64(pPager.sectorSize) + int64(1)) * int64(pPager.sectorSize)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return offset
}
func zeroJournalHdr(pPager *struct_Pager, doTruncate int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.journalOff != 0 {
		var iLimit int64 = pPager.journalSizeLimit
		if doTruncate != 0 || iLimit == int64(0) {
			rc = sqlite3OsTruncate(pPager.jfd, int64(0))
		} else {
			var zeroHdr [28]int8 = [28]int8{int8(0)}
			rc = sqlite3OsWrite(pPager.jfd, unsafe.Pointer((*int8)(unsafe.Pointer(&zeroHdr))), int32(28), int64(0))
		}
		if rc == 0 && !(pPager.noSync != 0) {
			rc = sqlite3OsSync(pPager.jfd, 16|int32(pPager.syncFlags))
		}
		if rc == 0 && iLimit > int64(0) {
			var sz int64
			rc = sqlite3OsFileSize(pPager.jfd, &sz)
			if rc == 0 && sz > iLimit {
				rc = sqlite3OsTruncate(pPager.jfd, iLimit)
			}
		}
	}
	return rc
}
func writeJournalHdr(pPager *struct_Pager) int32 {
	var rc int32 = 0
	var zHeader *int8 = pPager.pTmpSpace
	var nHeader uint32 = uint32(pPager.pageSize)
	var nWrite uint32
	var ii int32
	func() int {
		_ = 0
		return 0
	}()
	if nHeader > pPager.sectorSize {
		nHeader = pPager.sectorSize
	}
	for ii = int32(0); ii < pPager.nSavepoint; ii++ {
		if (*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(ii)*52))).iHdrOffset == int64(0) {
			(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(ii)*52))).iHdrOffset = pPager.journalOff
		}
	}
	pPager.journalHdr = func() (_cgo_ret int64) {
		_cgo_addr := &pPager.journalOff
		*_cgo_addr = journalHdrOffset(pPager)
		return *_cgo_addr
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.noSync) != 0 || int32(pPager.journalMode) == 4 || sqlite3OsDeviceCharacteristics(pPager.fd)&512 != 0 {
		__builtin___memcpy_chk(unsafe.Pointer(zHeader), unsafe.Pointer((*uint8)(unsafe.Pointer(&aJournalMagic))), 8, __builtin_object_size(unsafe.Pointer(zHeader), 0))
		sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8))))), 4294967295)
	} else {
		__builtin___memset_chk(unsafe.Pointer(zHeader), 0, 8+uint(4), __builtin_object_size(unsafe.Pointer(zHeader), 0))
	}
	sqlite3_randomness(int32(4), unsafe.Pointer(&pPager.cksumInit))
	sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8+uint(4)))))), pPager.cksumInit)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8+uint(8)))))), pPager.dbOrigSize)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8+uint(12)))))), pPager.sectorSize)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8+uint(16)))))), uint32(pPager.pageSize))
	__builtin___memset_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8+uint(20))))), 0, uint(nHeader)-(8+uint(20)), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHeader)) + uintptr(8+uint(20))))), 0))
	for nWrite = uint32(0); rc == 0 && nWrite < pPager.sectorSize; nWrite += nHeader {
		rc = sqlite3OsWrite(pPager.jfd, unsafe.Pointer(zHeader), int32(nHeader), pPager.journalOff)
		func() int {
			_ = 0
			return 0
		}()
		pPager.journalOff += int64(nHeader)
	}
	return rc
}
func readJournalHdr(pPager *struct_Pager, isHot int32, journalSize int64, pNRec *uint32, pDbSize *uint32) int32 {
	var rc int32
	var aMagic [8]uint8
	var iHdrOff int64
	func() int {
		_ = 0
		return 0
	}()
	pPager.journalOff = journalHdrOffset(pPager)
	if pPager.journalOff+int64(pPager.sectorSize) > journalSize {
		return int32(101)
	}
	iHdrOff = pPager.journalOff
	if isHot != 0 || iHdrOff != pPager.journalHdr {
		rc = sqlite3OsRead(pPager.jfd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aMagic))), int32(8), iHdrOff)
		if rc != 0 {
			return rc
		}
		if memcmp(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMagic))), unsafe.Pointer((*uint8)(unsafe.Pointer(&aJournalMagic))), 8) != 0 {
			return int32(101)
		}
	}
	if 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = read32bits(pPager.jfd, iHdrOff+int64(8), pNRec)
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = read32bits(pPager.jfd, iHdrOff+int64(12), &pPager.cksumInit)
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = read32bits(pPager.jfd, iHdrOff+int64(16), pDbSize)
		return *_cgo_addr
	}() {
		return rc
	}
	if pPager.journalOff == int64(0) {
		var iPageSize uint32
		var iSectorSize uint32
		if 0 != func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = read32bits(pPager.jfd, iHdrOff+int64(20), &iSectorSize)
			return *_cgo_addr
		}() || 0 != func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = read32bits(pPager.jfd, iHdrOff+int64(24), &iPageSize)
			return *_cgo_addr
		}() {
			return rc
		}
		if iPageSize == uint32(0) {
			iPageSize = uint32(pPager.pageSize)
		}
		if iPageSize < uint32(512) || iSectorSize < uint32(32) || iPageSize > uint32(65536) || iSectorSize > uint32(65536) || (iPageSize-uint32(1))&iPageSize != uint32(0) || (iSectorSize-uint32(1))&iSectorSize != uint32(0) {
			return int32(101)
		}
		rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1)
		pPager.sectorSize = iSectorSize
	}
	pPager.journalOff += int64(pPager.sectorSize)
	return rc
}
func writeSuperJournal(pPager *struct_Pager, zSuper *int8) int32 {
	var rc int32
	var nSuper int32
	var iHdrOff int64
	var jrnlSize int64
	var cksum uint32 = uint32(0)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(zSuper != nil) || int32(pPager.journalMode) == 4 || !(uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil))) {
		return int32(0)
	}
	pPager.setSuper = uint8(1)
	func() int {
		_ = 0
		return 0
	}()
	for nSuper = int32(0); *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(nSuper))) != 0; nSuper++ {
		cksum += uint32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(nSuper))))
	}
	if pPager.fullSync != 0 {
		pPager.journalOff = journalHdrOffset(pPager)
	}
	iHdrOff = pPager.journalOff
	if 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = write32bits(pPager.jfd, iHdrOff, uint32(int64(sqlite3PendingByte)/pPager.pageSize+int64(1)))
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3OsWrite(pPager.jfd, unsafe.Pointer(zSuper), nSuper, iHdrOff+int64(4))
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = write32bits(pPager.jfd, iHdrOff+int64(4)+int64(nSuper), uint32(nSuper))
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = write32bits(pPager.jfd, iHdrOff+int64(4)+int64(nSuper)+int64(4), cksum)
		return *_cgo_addr
	}() || 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3OsWrite(pPager.jfd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aJournalMagic))), 8, iHdrOff+int64(4)+int64(nSuper)+int64(8))
		return *_cgo_addr
	}() {
		return rc
	}
	pPager.journalOff += int64(nSuper + 20)
	if 0 == func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3OsFileSize(pPager.jfd, &jrnlSize)
		return *_cgo_addr
	}() && jrnlSize > pPager.journalOff {
		rc = sqlite3OsTruncate(pPager.jfd, pPager.journalOff)
	}
	return rc
}
func pager_reset(pPager *struct_Pager) {
	pPager.iDataVersion++
	sqlite3BackupRestart(pPager.pBackup)
	sqlite3PcacheClear(pPager.pPCache)
}
func sqlite3PagerDataVersion(pPager *struct_Pager) uint32 {
	return pPager.iDataVersion
}
func releaseAllSavepoints(pPager *struct_Pager) {
	var ii int32
	for ii = int32(0); ii < pPager.nSavepoint; ii++ {
		sqlite3BitvecDestroy((*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(ii)*52))).pInSavepoint)
	}
	if !(pPager.exclusiveMode != 0) || sqlite3JournalIsInMemory(pPager.sjfd) != 0 {
		sqlite3OsClose(pPager.sjfd)
	}
	sqlite3_free(unsafe.Pointer(pPager.aSavepoint))
	pPager.aSavepoint = (*struct_PagerSavepoint)(nil)
	pPager.nSavepoint = int32(0)
	pPager.nSubRec = uint32(0)
}
func addToSavepointBitvecs(pPager *struct_Pager, pgno uint32) int32 {
	var ii int32
	var rc int32 = 0
	for ii = int32(0); ii < pPager.nSavepoint; ii++ {
		var p *struct_PagerSavepoint = &*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(ii)*52))
		if pgno <= p.nOrig {
			rc |= sqlite3BitvecSet(p.pInSavepoint, pgno)
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	return rc
}
func pager_unlock(pPager *struct_Pager) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BitvecDestroy(pPager.pInJournal)
	pPager.pInJournal = (*struct_Bitvec)(nil)
	releaseAllSavepoints(pPager)
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3WalEndReadTransaction(pPager.pWal)
		pPager.eState = uint8(0)
	} else if !(pPager.exclusiveMode != 0) {
		var rc int32
		var iDc int32 = func() int32 {
			if uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
				return sqlite3OsDeviceCharacteristics(pPager.fd)
			} else {
				return 0
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if 0 == iDc&2048 || 1 != int32(pPager.journalMode)&5 {
			sqlite3OsClose(pPager.jfd)
		}
		rc = pagerUnlockDb(pPager, 0)
		if rc != 0 && int32(pPager.eState) == 6 {
			pPager.eLock = uint8(4 + 1)
		}
		func() int {
			_ = 0
			return 0
		}()
		pPager.eState = uint8(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pPager.errCode != 0 {
		if int32(pPager.tempFile) == 0 {
			pager_reset(pPager)
			pPager.changeCountDone = uint8(0)
			pPager.eState = uint8(0)
		} else {
			pPager.eState = uint8(func() int32 {
				if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
					return 0
				} else {
					return 1
				}
			}())
		}
		if pPager.bUseFetch != 0 {
			sqlite3OsUnfetch(pPager.fd, int64(0), nil)
		}
		pPager.errCode = int32(0)
		setGetterMethod(pPager)
	}
	pPager.journalOff = int64(0)
	pPager.journalHdr = int64(0)
	pPager.setSuper = uint8(0)
}
func pager_error(pPager *struct_Pager, rc int32) int32 {
	var rc2 int32 = rc & 255
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if rc2 == 13 || rc2 == 10 {
		pPager.errCode = rc
		pPager.eState = uint8(6)
		setGetterMethod(pPager)
	}
	return rc
}
func pagerFlushOnCommit(pPager *struct_Pager, bCommit int32) int32 {
	if int32(pPager.tempFile) == 0 {
		return int32(1)
	}
	if !(bCommit != 0) {
		return int32(0)
	}
	if !(uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil))) {
		return int32(0)
	}
	return func() int32 {
		if sqlite3PCachePercentDirty(pPager.pPCache) >= 25 {
			return 1
		} else {
			return 0
		}
	}()
}
func pager_end_transaction(pPager *struct_Pager, hasSuper int32, bCommit int32) int32 {
	var rc int32 = 0
	var rc2 int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.eState) < 2 && int32(pPager.eLock) < 2 {
		return int32(0)
	}
	releaseAllSavepoints(pPager)
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		if sqlite3JournalIsInMemory(pPager.jfd) != 0 {
			sqlite3OsClose(pPager.jfd)
		} else if int32(pPager.journalMode) == 3 {
			if pPager.journalOff == int64(0) {
				rc = int32(0)
			} else {
				rc = sqlite3OsTruncate(pPager.jfd, int64(0))
				if rc == 0 && int32(pPager.fullSync) != 0 {
					rc = sqlite3OsSync(pPager.jfd, int32(pPager.syncFlags))
				}
			}
			pPager.journalOff = int64(0)
		} else if int32(pPager.journalMode) == 1 || int32(pPager.exclusiveMode) != 0 && int32(pPager.journalMode) != 5 {
			rc = zeroJournalHdr(pPager, func() int32 {
				if hasSuper != 0 || int32(pPager.tempFile) != 0 {
					return 1
				} else {
					return 0
				}
			}())
			pPager.journalOff = int64(0)
		} else {
			var bDelete int32 = func() int32 {
				if !(pPager.tempFile != 0) {
					return 1
				} else {
					return 0
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3OsClose(pPager.jfd)
			if bDelete != 0 {
				rc = sqlite3OsDelete(pPager.pVfs, pPager.zJournal, int32(pPager.extraSync))
			}
		}
	}
	sqlite3BitvecDestroy(pPager.pInJournal)
	pPager.pInJournal = (*struct_Bitvec)(nil)
	pPager.nRec = int32(0)
	if rc == 0 {
		if int32(pPager.memDb) != 0 || pagerFlushOnCommit(pPager, bCommit) != 0 {
			sqlite3PcacheCleanAll(pPager.pPCache)
		} else {
			sqlite3PcacheClearWritable(pPager.pPCache)
		}
		sqlite3PcacheTruncate(pPager.pPCache, pPager.dbSize)
	}
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		rc2 = sqlite3WalEndWriteTransaction(pPager.pWal)
		func() int {
			_ = 0
			return 0
		}()
	} else if rc == 0 && bCommit != 0 && pPager.dbFileSize > pPager.dbSize {
		func() int {
			_ = 0
			return 0
		}()
		rc = pager_truncate(pPager, pPager.dbSize)
	}
	if rc == 0 && bCommit != 0 {
		rc = sqlite3OsFileControl(pPager.fd, 22, nil)
		if rc == 12 {
			rc = int32(0)
		}
	}
	if !(pPager.exclusiveMode != 0) && (!(uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil))) || sqlite3WalExclusiveMode(pPager.pWal, 0) != 0) {
		rc2 = pagerUnlockDb(pPager, 1)
	}
	pPager.eState = uint8(1)
	pPager.setSuper = uint8(0)
	return func() int32 {
		if rc == 0 {
			return rc2
		} else {
			return rc
		}
	}()
}
func pagerUnlockAndRollback(pPager *struct_Pager) {
	if int32(pPager.eState) != 6 && int32(pPager.eState) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pPager.eState) >= 2 {
			sqlite3BeginBenignMalloc()
			sqlite3PagerRollback(pPager)
			sqlite3EndBenignMalloc()
		} else if !(pPager.exclusiveMode != 0) {
			func() int {
				_ = 0
				return 0
			}()
			pager_end_transaction(pPager, 0, 0)
		}
	}
	pager_unlock(pPager)
}
func pager_cksum(pPager *struct_Pager, aData *uint8) uint32 {
	var cksum uint32 = pPager.cksumInit
	var i int32 = int32(pPager.pageSize - int64(200))
	for i > 0 {
		cksum += uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(i))))
		i -= int32(200)
	}
	return cksum
}
func pager_playback_one_page(pPager *struct_Pager, pOffset *int64, pDone *struct_Bitvec, isMainJrnl int32, isSavepnt int32) int32 {
	var rc int32
	var pPg *struct_PgHdr
	var pgno uint32
	var cksum uint32
	var aData *int8
	var jfd *struct_sqlite3_file
	var isSynced int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	aData = pPager.pTmpSpace
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	jfd = func() *struct_sqlite3_file {
		if isMainJrnl != 0 {
			return pPager.jfd
		} else {
			return pPager.sjfd
		}
	}()
	rc = read32bits(jfd, *pOffset, &pgno)
	if rc != 0 {
		return rc
	}
	rc = sqlite3OsRead(jfd, unsafe.Pointer((*uint8)(unsafe.Pointer(aData))), int32(pPager.pageSize), *pOffset+int64(4))
	if rc != 0 {
		return rc
	}
	*pOffset += pPager.pageSize + int64(4) + int64(isMainJrnl*4)
	if pgno == uint32(0) || pgno == uint32(int64(sqlite3PendingByte)/pPager.pageSize+int64(1)) {
		func() int {
			_ = 0
			return 0
		}()
		return int32(101)
	}
	if pgno > uint32(pPager.dbSize) || sqlite3BitvecTest(pDone, pgno) != 0 {
		return int32(0)
	}
	if isMainJrnl != 0 {
		rc = read32bits(jfd, *pOffset-int64(4), &cksum)
		if rc != 0 {
			return rc
		}
		if !(isSavepnt != 0) && pager_cksum(pPager, (*uint8)(unsafe.Pointer(aData))) != cksum {
			return int32(101)
		}
	}
	if pDone != nil && func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3BitvecSet(pDone, pgno)
		return *_cgo_addr
	}() != 0 {
		return rc
	}
	if pgno == uint32(1) && int32(pPager.nReserve) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(aData)))) + uintptr(20)))) {
		pPager.nReserve = int16(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(aData)))) + uintptr(20))))
	}
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		pPg = (*struct_PgHdr)(nil)
	} else {
		pPg = sqlite3PagerLookup(pPager, pgno)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if isMainJrnl != 0 {
		isSynced = func() int32 {
			if int32(pPager.noSync) != 0 || *pOffset <= pPager.journalHdr {
				return 1
			} else {
				return 0
			}
		}()
	} else {
		isSynced = func() int32 {
			if uintptr(unsafe.Pointer(pPg)) == uintptr(unsafe.Pointer(nil)) || 0 == int32(pPg.flags)&8 {
				return 1
			} else {
				return 0
			}
		}()
	}
	if uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) && (int32(pPager.eState) >= 4 || int32(pPager.eState) == 0) && isSynced != 0 {
		var ofst int64 = int64(pgno-uint32(1)) * int64(pPager.pageSize)
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3OsWrite(pPager.fd, unsafe.Pointer((*uint8)(unsafe.Pointer(aData))), int32(pPager.pageSize), ofst)
		if pgno > pPager.dbFileSize {
			pPager.dbFileSize = pgno
		}
		if pPager.pBackup != nil {
			sqlite3BackupUpdate(pPager.pBackup, pgno, (*uint8)(unsafe.Pointer(aData)))
		}
	} else if !(isMainJrnl != 0) && uintptr(unsafe.Pointer(pPg)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pPager.doNotSpill |= uint8(2)
		rc = sqlite3PagerGet(pPager, pgno, &pPg, 1)
		func() int {
			_ = 0
			return 0
		}()
		pPager.doNotSpill &= uint8(^2)
		if rc != 0 {
			return rc
		}
		sqlite3PcacheMakeDirty(pPg)
	}
	if pPg != nil {
		var pData unsafe.Pointer
		pData = pPg.pData
		__builtin___memcpy_chk(pData, unsafe.Pointer((*uint8)(unsafe.Pointer(aData))), uint(pPager.pageSize), __builtin_object_size(pData, 0))
		pPager.xReiniter(pPg)
		if pgno == uint32(1) {
			__builtin___memcpy_chk(unsafe.Pointer(&pPager.dbFileVers), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pData))) + uintptr(24)))), 16, __builtin_object_size(unsafe.Pointer(&pPager.dbFileVers), 0))
		}
		sqlite3PcacheRelease(pPg)
	}
	return rc
}
func pager_delsuper(pPager *struct_Pager, zSuper *int8) int32 {
	var pVfs *struct_sqlite3_vfs = pPager.pVfs
	var rc int32
	var pSuper *struct_sqlite3_file
	var pJournal *struct_sqlite3_file
	var zSuperJournal *int8 = nil
	var nSuperJournal int64
	var zJournal *int8
	var zSuperPtr *int8
	var zFree *int8 = nil
	var nSuperPtr int32
	pSuper = (*struct_sqlite3_file)(sqlite3MallocZero(uint64(pVfs.szOsFile * 2)))
	if !(pSuper != nil) {
		rc = int32(7)
		pJournal = (*struct_sqlite3_file)(nil)
	} else {
		var flags int32 = 1 | 16384
		rc = sqlite3OsOpen(pVfs, zSuper, pSuper, flags, nil)
		pJournal = (*struct_sqlite3_file)(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pSuper)))) + uintptr(pVfs.szOsFile)))))
	}
	if rc != 0 {
		goto delsuper_out
	}
	rc = sqlite3OsFileSize(pSuper, &nSuperJournal)
	if rc != 0 {
		goto delsuper_out
	}
	nSuperPtr = pVfs.mxPathname + 1
	zFree = (*int8)(sqlite3Malloc(uint64(int64(4) + nSuperJournal + int64(nSuperPtr) + int64(2))))
	if !(zFree != nil) {
		rc = int32(7)
		goto delsuper_out
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFree)) + uintptr(0))) = func() (_cgo_ret int8) {
		_cgo_addr := &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFree)) + uintptr(1)))
		*_cgo_addr = func() (_cgo_ret int8) {
			_cgo_addr := &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFree)) + uintptr(2)))
			*_cgo_addr = func() (_cgo_ret int8) {
				_cgo_addr := &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFree)) + uintptr(3)))
				*_cgo_addr = int8(0)
				return *_cgo_addr
			}()
			return *_cgo_addr
		}()
		return *_cgo_addr
	}()
	zSuperJournal = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFree)) + uintptr(4)))
	zSuperPtr = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuperJournal)) + uintptr(nSuperJournal+int64(2))))
	rc = sqlite3OsRead(pSuper, unsafe.Pointer(zSuperJournal), int32(nSuperJournal), int64(0))
	if rc != 0 {
		goto delsuper_out
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuperJournal)) + uintptr(nSuperJournal))) = int8(0)
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuperJournal)) + uintptr(nSuperJournal+int64(1)))) = int8(0)
	zJournal = zSuperJournal
	for int64(uintptr(unsafe.Pointer(zJournal))-uintptr(unsafe.Pointer(zSuperJournal))) < nSuperJournal {
		var exists int32
		rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists)
		if rc != 0 {
			goto delsuper_out
		}
		if exists != 0 {
			var c int32
			var flags int32 = 1 | 16384
			rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, nil)
			if rc != 0 {
				goto delsuper_out
			}
			rc = readSuperJournal(pJournal, zSuperPtr, uint32(nSuperPtr))
			sqlite3OsClose(pJournal)
			if rc != 0 {
				goto delsuper_out
			}
			c = func() int32 {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuperPtr)) + uintptr(0)))) != 0 && strcmp(zSuperPtr, zSuper) == 0 {
					return 1
				} else {
					return 0
				}
			}()
			if c != 0 {
				goto delsuper_out
			}
		}
		*(*uintptr)(unsafe.Pointer(&zJournal)) += uintptr(sqlite3Strlen30(zJournal) + 1)
	}
	sqlite3OsClose(pSuper)
	rc = sqlite3OsDelete(pVfs, zSuper, 0)
delsuper_out:
	sqlite3_free(unsafe.Pointer(zFree))
	if pSuper != nil {
		sqlite3OsClose(pSuper)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_free(unsafe.Pointer(pSuper))
	}
	return rc
}
func pager_truncate(pPager *struct_Pager, nPage uint32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) && (int32(pPager.eState) >= 4 || int32(pPager.eState) == 0) {
		var currentSize int64
		var newSize int64
		var szPage int32 = int32(pPager.pageSize)
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3OsFileSize(pPager.fd, &currentSize)
		newSize = int64(szPage) * int64(nPage)
		if rc == 0 && currentSize != newSize {
			if currentSize > newSize {
				rc = sqlite3OsTruncate(pPager.fd, newSize)
			} else if currentSize+int64(szPage) <= newSize {
				var pTmp *int8 = pPager.pTmpSpace
				__builtin___memset_chk(unsafe.Pointer(pTmp), 0, uint(szPage), __builtin_object_size(unsafe.Pointer(pTmp), 0))
				rc = sqlite3OsWrite(pPager.fd, unsafe.Pointer(pTmp), szPage, newSize-int64(szPage))
			}
			if rc == 0 {
				pPager.dbFileSize = nPage
			}
		}
	}
	return rc
}
func sqlite3SectorSize(pFile *struct_sqlite3_file) int32 {
	var iRet int32 = sqlite3OsSectorSize(pFile)
	if iRet < 32 {
		iRet = int32(512)
	} else if iRet > 65536 {
		func() int {
			_ = 0
			return 0
		}()
		iRet = int32(65536)
	}
	return iRet
}
func setSectorSize(pPager *struct_Pager) {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.tempFile) != 0 || sqlite3OsDeviceCharacteristics(pPager.fd)&4096 != 0 {
		pPager.sectorSize = uint32(512)
	} else {
		pPager.sectorSize = uint32(sqlite3SectorSize(pPager.fd))
	}
}
func pager_playback(pPager *struct_Pager, isHot int32) int32 {
	var pVfs *struct_sqlite3_vfs = pPager.pVfs
	var szJ int64
	var nRec uint32
	var u uint32
	var mxPg uint32 = uint32(0)
	var rc int32
	var res int32 = 1
	var zSuper *int8 = nil
	var needPagerReset int32
	var nPlayback int32 = 0
	var savedPageSize uint32 = uint32(pPager.pageSize)
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3OsFileSize(pPager.jfd, &szJ)
	if rc != 0 {
		goto end_playback
	}
	zSuper = pPager.pTmpSpace
	rc = readSuperJournal(pPager.jfd, zSuper, uint32(pPager.pVfs.mxPathname+1))
	if rc == 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(0)))) != 0 {
		rc = sqlite3OsAccess(pVfs, zSuper, 0, &res)
	}
	zSuper = (*int8)(nil)
	if rc != 0 || !(res != 0) {
		goto end_playback
	}
	pPager.journalOff = int64(0)
	needPagerReset = isHot
	for 1 != 0 {
		rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg)
		if rc != 0 {
			if rc == 101 {
				rc = int32(0)
			}
			goto end_playback
		}
		if nRec == 4294967295 {
			func() int {
				_ = 0
				return 0
			}()
			nRec = uint32(int32((szJ - int64(pPager.sectorSize)) / (pPager.pageSize + int64(8))))
		}
		if nRec == uint32(0) && !(isHot != 0) && pPager.journalHdr+int64(pPager.sectorSize) == pPager.journalOff {
			nRec = uint32(int32((szJ - pPager.journalOff) / (pPager.pageSize + int64(8))))
		}
		if pPager.journalOff == int64(pPager.sectorSize) {
			rc = pager_truncate(pPager, mxPg)
			if rc != 0 {
				goto end_playback
			}
			pPager.dbSize = mxPg
			if pPager.mxPgno < mxPg {
				pPager.mxPgno = mxPg
			}
		}
		for u = uint32(0); u < nRec; u++ {
			if needPagerReset != 0 {
				pager_reset(pPager)
				needPagerReset = int32(0)
			}
			rc = pager_playback_one_page(pPager, &pPager.journalOff, nil, 1, 0)
			if rc == 0 {
				nPlayback++
			} else if rc == 101 {
				pPager.journalOff = szJ
				break
			} else if rc == 10|2<<8 {
				rc = int32(0)
				goto end_playback
			} else {
				goto end_playback
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
end_playback:
	if rc == 0 {
		rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1)
	}
	pPager.changeCountDone = pPager.tempFile
	if rc == 0 {
		zSuper = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.pTmpSpace)) + uintptr(4)))
		rc = readSuperJournal(pPager.jfd, zSuper, uint32(pPager.pVfs.mxPathname+1))
	}
	if rc == 0 && (int32(pPager.eState) >= 4 || int32(pPager.eState) == 0) {
		rc = sqlite3PagerSync(pPager, nil)
	}
	if rc == 0 {
		rc = pager_end_transaction(pPager, func() int32 {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(0)))) != '\x00' {
				return 1
			} else {
				return 0
			}
		}(), 0)
	}
	if rc == 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(0)))) != 0 && res != 0 {
		func() int {
			_ = 0
			return 0
		}()
		__builtin___memset_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) - uintptr(- -4)))), 0, uint(4), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) - uintptr(- -4)))), 0))
		rc = pager_delsuper(pPager, zSuper)
	}
	if isHot != 0 && nPlayback != 0 {
		sqlite3_log(27|2<<8, (*int8)(unsafe.Pointer(&[27]int8{'r', 'e', 'c', 'o', 'v', 'e', 'r', 'e', 'd', ' ', '%', 'd', ' ', 'p', 'a', 'g', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', '%', 's', '\x00'})), nPlayback, pPager.zJournal)
	}
	setSectorSize(pPager)
	return rc
}
func readDbPage(pPg *struct_PgHdr) int32 {
	var pPager *struct_Pager = pPg.pPager
	var rc int32 = 0
	var iFrame uint32 = uint32(0)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		rc = sqlite3WalFindFrame(pPager.pWal, pPg.pgno, &iFrame)
		if rc != 0 {
			return rc
		}
	}
	if iFrame != 0 {
		rc = sqlite3WalReadFrame(pPager.pWal, iFrame, int32(pPager.pageSize), (*uint8)(pPg.pData))
	} else {
		var iOffset int64 = int64(pPg.pgno-uint32(1)) * int64(pPager.pageSize)
		rc = sqlite3OsRead(pPager.fd, pPg.pData, int32(pPager.pageSize), iOffset)
		if rc == 10|2<<8 {
			rc = int32(0)
		}
	}
	if pPg.pgno == uint32(1) {
		if rc != 0 {
			__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&pPager.dbFileVers))), 255, 16, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&pPager.dbFileVers))), 0))
		} else {
			var dbFileVers *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pPg.pData))) + uintptr(24)))
			__builtin___memcpy_chk(unsafe.Pointer(&pPager.dbFileVers), unsafe.Pointer(dbFileVers), 16, __builtin_object_size(unsafe.Pointer(&pPager.dbFileVers), 0))
		}
	}
	return rc
}
func pager_write_changecounter(pPg *struct_PgHdr) {
	var change_counter uint32
	if uintptr(unsafe.Pointer(pPg)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	change_counter = sqlite3Get4byte((*uint8)(unsafe.Pointer((*int8)(unsafe.Pointer(&pPg.pPager.dbFileVers))))) + uint32(1)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*int8)(pPg.pData)))))+uintptr(24))), change_counter)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*int8)(pPg.pData)))))+uintptr(92))), change_counter)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*int8)(pPg.pData)))))+uintptr(96))), uint32(3038002))
}
func pagerUndoCallback(pCtx unsafe.Pointer, iPg uint32) int32 {
	var rc int32 = 0
	var pPager *struct_Pager = (*struct_Pager)(pCtx)
	var pPg *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	pPg = sqlite3PagerLookup(pPager, iPg)
	if pPg != nil {
		if sqlite3PcachePageRefcount(pPg) == 1 {
			sqlite3PcacheDrop(pPg)
		} else {
			rc = readDbPage(pPg)
			if rc == 0 {
				pPager.xReiniter(pPg)
			}
			sqlite3PagerUnrefNotNull(pPg)
		}
	}
	sqlite3BackupRestart(pPager.pBackup)
	return rc
}
func pagerRollbackWal(pPager *struct_Pager) int32 {
	var rc int32
	var pList *struct_PgHdr
	pPager.dbSize = pPager.dbOrigSize
	rc = sqlite3WalUndo(pPager.pWal, pagerUndoCallback, unsafe.Pointer(pPager))
	pList = sqlite3PcacheDirtyList(pPager.pPCache)
	for pList != nil && rc == 0 {
		var pNext *struct_PgHdr = pList.pDirty
		rc = pagerUndoCallback(unsafe.Pointer(pPager), pList.pgno)
		pList = pNext
	}
	return rc
}
func pagerWalFrames(pPager *struct_Pager, pList *struct_PgHdr, nTruncate uint32, isCommit int32) int32 {
	var rc int32
	var nList int32
	var p *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if isCommit != 0 {
		var ppNext **struct_PgHdr = &pList
		nList = int32(0)
		for p = pList; uintptr(unsafe.Pointer(func() (_cgo_ret *struct_PgHdr) {
			_cgo_addr := &*ppNext
			*_cgo_addr = p
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)); p = p.pDirty {
			if p.pgno <= nTruncate {
				ppNext = &p.pDirty
				nList++
			}
		}
		func() int {
			_ = 0
			return 0
		}()
	} else {
		nList = int32(1)
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(2)*4)) += nList
	if pList.pgno == uint32(1) {
		pager_write_changecounter(pList)
	}
	rc = sqlite3WalFrames(pPager.pWal, int32(pPager.pageSize), pList, nTruncate, isCommit, int32(pPager.walSyncFlags))
	if rc == 0 && pPager.pBackup != nil {
		for p = pList; p != nil; p = p.pDirty {
			sqlite3BackupUpdate(pPager.pBackup, p.pgno, (*uint8)(p.pData))
		}
	}
	return rc
}
func pagerBeginReadTransaction(pPager *struct_Pager) int32 {
	var rc int32
	var changed int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3WalEndReadTransaction(pPager.pWal)
	rc = sqlite3WalBeginReadTransaction(pPager.pWal, &changed)
	if rc != 0 || changed != 0 {
		pager_reset(pPager)
		if pPager.bUseFetch != 0 {
			sqlite3OsUnfetch(pPager.fd, int64(0), nil)
		}
	}
	return rc
}
func pagerPagecount(pPager *struct_Pager, pnPage *uint32) int32 {
	var nPage uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nPage = sqlite3WalDbsize(pPager.pWal)
	if nPage == uint32(0) && uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
		var n int64 = int64(0)
		var rc int32 = sqlite3OsFileSize(pPager.fd, &n)
		if rc != 0 {
			return rc
		}
		nPage = uint32((n + pPager.pageSize - int64(1)) / pPager.pageSize)
	}
	if nPage > pPager.mxPgno {
		pPager.mxPgno = uint32(nPage)
	}
	*pnPage = nPage
	return int32(0)
}
func pagerOpenWalIfPresent(pPager *struct_Pager) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(pPager.tempFile != 0) {
		var isWal int32
		rc = sqlite3OsAccess(pPager.pVfs, pPager.zWal, 0, &isWal)
		if rc == 0 {
			if isWal != 0 {
				var nPage uint32
				rc = pagerPagecount(pPager, &nPage)
				if rc != 0 {
					return rc
				}
				if nPage == uint32(0) {
					rc = sqlite3OsDelete(pPager.pVfs, pPager.zWal, 0)
				} else {
					rc = sqlite3PagerOpenWal(pPager, nil)
				}
			} else if int32(pPager.journalMode) == 5 {
				pPager.journalMode = uint8(0)
			}
		}
	}
	return rc
}
func pagerPlaybackSavepoint(pPager *struct_Pager, pSavepoint *struct_PagerSavepoint) int32 {
	var szJ int64
	var iHdrOff int64
	var rc int32 = 0
	var pDone *struct_Bitvec = nil
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pSavepoint != nil {
		pDone = sqlite3BitvecCreate(pSavepoint.nOrig)
		if !(pDone != nil) {
			return int32(7)
		}
	}
	pPager.dbSize = func() uint32 {
		if pSavepoint != nil {
			return pSavepoint.nOrig
		} else {
			return pPager.dbOrigSize
		}
	}()
	pPager.changeCountDone = pPager.tempFile
	if !(pSavepoint != nil) && uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		return pagerRollbackWal(pPager)
	}
	szJ = pPager.journalOff
	func() int {
		_ = 0
		return 0
	}()
	if pSavepoint != nil && !(uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil))) {
		iHdrOff = func() int64 {
			if pSavepoint.iHdrOffset != 0 {
				return pSavepoint.iHdrOffset
			} else {
				return szJ
			}
		}()
		pPager.journalOff = pSavepoint.iOffset
		for rc == 0 && pPager.journalOff < iHdrOff {
			rc = pager_playback_one_page(pPager, &pPager.journalOff, pDone, 1, 1)
		}
		func() int {
			_ = 0
			return 0
		}()
	} else {
		pPager.journalOff = int64(0)
	}
	for rc == 0 && pPager.journalOff < szJ {
		var ii uint32
		var nJRec uint32 = uint32(0)
		var dummy uint32
		rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy)
		func() int {
			_ = 0
			return 0
		}()
		if nJRec == uint32(0) && pPager.journalHdr+int64(pPager.sectorSize) == pPager.journalOff {
			nJRec = uint32((szJ - pPager.journalOff) / (pPager.pageSize + int64(8)))
		}
		for ii = uint32(0); rc == 0 && ii < nJRec && pPager.journalOff < szJ; ii++ {
			rc = pager_playback_one_page(pPager, &pPager.journalOff, pDone, 1, 1)
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	func() int {
		_ = 0
		return 0
	}()
	if pSavepoint != nil {
		var ii uint32
		var offset int64 = int64(pSavepoint.iSubRec) * (int64(4) + pPager.pageSize)
		if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
			rc = sqlite3WalSavepointUndo(pPager.pWal, (*uint32)(unsafe.Pointer(&pSavepoint.aWalData)))
		}
		for ii = pSavepoint.iSubRec; rc == 0 && ii < pPager.nSubRec; ii++ {
			func() int {
				_ = 0
				return 0
			}()
			rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1)
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3BitvecDestroy(pDone)
	if rc == 0 {
		pPager.journalOff = szJ
	}
	return rc
}
func sqlite3PagerSetCachesize(pPager *struct_Pager, mxPage int32) {
	sqlite3PcacheSetCachesize(pPager.pPCache, mxPage)
}
func sqlite3PagerSetSpillsize(pPager *struct_Pager, mxPage int32) int32 {
	return sqlite3PcacheSetSpillsize(pPager.pPCache, mxPage)
}
func pagerFixMaplimit(pPager *struct_Pager) {
	var fd *struct_sqlite3_file = pPager.fd
	if uintptr(unsafe.Pointer(fd.pMethods)) != uintptr(unsafe.Pointer(nil)) && fd.pMethods.iVersion >= 3 {
		var sz int64
		sz = pPager.szMmap
		pPager.bUseFetch = func() uint8 {
			if sz > int64(0) {
				return 1
			} else {
				return 0
			}
		}()
		setGetterMethod(pPager)
		sqlite3OsFileControlHint(pPager.fd, 18, unsafe.Pointer(&sz))
	}
}
func sqlite3PagerSetMmapLimit(pPager *struct_Pager, szMmap int64) {
	pPager.szMmap = szMmap
	pagerFixMaplimit(pPager)
}
func sqlite3PagerShrink(pPager *struct_Pager) {
	sqlite3PcacheShrink(pPager.pPCache)
}
func sqlite3PagerSetFlags(pPager *struct_Pager, pgFlags uint32) {
	var level uint32 = pgFlags & uint32(7)
	if pPager.tempFile != 0 {
		pPager.noSync = uint8(1)
		pPager.fullSync = uint8(0)
		pPager.extraSync = uint8(0)
	} else {
		pPager.noSync = uint8(func() int32 {
			if level == uint32(1) {
				return 1
			} else {
				return 0
			}
		}())
		pPager.fullSync = uint8(func() int32 {
			if level >= uint32(3) {
				return 1
			} else {
				return 0
			}
		}())
		pPager.extraSync = uint8(func() int32 {
			if level == uint32(4) {
				return 1
			} else {
				return 0
			}
		}())
	}
	if pPager.noSync != 0 {
		pPager.syncFlags = uint8(0)
	} else if pgFlags&uint32(8) != 0 {
		pPager.syncFlags = uint8(3)
	} else {
		pPager.syncFlags = uint8(2)
	}
	pPager.walSyncFlags = uint8(int32(pPager.syncFlags) << 2)
	if pPager.fullSync != 0 {
		pPager.walSyncFlags |= uint8(int32(pPager.syncFlags))
	}
	if pgFlags&uint32(16) != 0 && !(pPager.noSync != 0) {
		pPager.walSyncFlags |= uint8(3 << 2)
	}
	if pgFlags&uint32(32) != 0 {
		pPager.doNotSpill &= uint8(^1)
	} else {
		pPager.doNotSpill |= uint8(1)
	}
}
func pagerOpentemp(pPager *struct_Pager, pFile *struct_sqlite3_file, vfsFlags int32) int32 {
	var rc int32
	vfsFlags |= int32(2 | 4 | 16 | 8)
	rc = sqlite3OsOpen(pPager.pVfs, nil, pFile, vfsFlags, nil)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3PagerSetBusyHandler(pPager *struct_Pager, xBusyHandler func(unsafe.Pointer) int32, pBusyHandlerArg unsafe.Pointer) {
	var ap *unsafe.Pointer
	pPager.xBusyHandler = xBusyHandler
	pPager.pBusyHandlerArg = pBusyHandlerArg
	ap = (*unsafe.Pointer)(unsafe.Pointer(&pPager.xBusyHandler))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3OsFileControlHint(pPager.fd, 15, unsafe.Pointer(ap))
}
func sqlite3PagerSetPagesize(pPager *struct_Pager, pPageSize *uint32, nReserve int32) int32 {
	var rc int32 = 0
	var pageSize uint32 = *pPageSize
	func() int {
		_ = 0
		return 0
	}()
	if (int32(pPager.memDb) == 0 || pPager.dbSize == uint32(0)) && sqlite3PcacheRefCount(pPager.pPCache) == 0 && pageSize != 0 && pageSize != uint32(pPager.pageSize) {
		var pNew *int8 = nil
		var nByte int64 = int64(0)
		if int32(pPager.eState) > 0 && uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
			rc = sqlite3OsFileSize(pPager.fd, &nByte)
		}
		if rc == 0 {
			pNew = (*int8)(sqlite3PageMalloc(int32(pageSize + uint32(8))))
			if !(pNew != nil) {
				rc = int32(7)
			} else {
				__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew))+uintptr(pageSize)))), 0, uint(8), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew))+uintptr(pageSize)))), 0))
			}
		}
		if rc == 0 {
			pager_reset(pPager)
			rc = sqlite3PcacheSetPageSize(pPager.pPCache, int32(pageSize))
		}
		if rc == 0 {
			sqlite3PageFree(unsafe.Pointer(pPager.pTmpSpace))
			pPager.pTmpSpace = pNew
			pPager.dbSize = uint32((nByte + int64(pageSize) - int64(1)) / int64(pageSize))
			pPager.pageSize = int64(pageSize)
		} else {
			sqlite3PageFree(unsafe.Pointer(pNew))
		}
	}
	*pPageSize = uint32(pPager.pageSize)
	if rc == 0 {
		if nReserve < 0 {
			nReserve = int32(pPager.nReserve)
		}
		func() int {
			_ = 0
			return 0
		}()
		pPager.nReserve = int16(nReserve)
		pagerFixMaplimit(pPager)
	}
	return rc
}
func sqlite3PagerTempSpace(pPager *struct_Pager) unsafe.Pointer {
	return unsafe.Pointer(pPager.pTmpSpace)
}
func sqlite3PagerMaxPageCount(pPager *struct_Pager, mxPage uint32) uint32 {
	if mxPage > uint32(0) {
		pPager.mxPgno = mxPage
	}
	func() int {
		_ = 0
		return 0
	}()
	return pPager.mxPgno
}
func sqlite3PagerReadFileheader(pPager *struct_Pager, N int32, pDest *uint8) int32 {
	var rc int32 = 0
	__builtin___memset_chk(unsafe.Pointer(pDest), 0, uint(N), __builtin_object_size(unsafe.Pointer(pDest), 0))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
		rc = sqlite3OsRead(pPager.fd, unsafe.Pointer(pDest), N, int64(0))
		if rc == 10|2<<8 {
			rc = int32(0)
		}
	}
	return rc
}
func sqlite3PagerPagecount(pPager *struct_Pager, pnPage *int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*pnPage = int32(pPager.dbSize)
}
func pager_wait_on_lock(pPager *struct_Pager, locktype int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	for {
		rc = pagerLockDb(pPager, locktype)
		if !(rc == 5 && pPager.xBusyHandler(pPager.pBusyHandlerArg) != 0) {
			break
		}
	}
	return rc
}
func sqlite3PagerTruncateImage(pPager *struct_Pager, nPage uint32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPager.dbSize = nPage
}
func pagerSyncHotJournal(pPager *struct_Pager) int32 {
	var rc int32 = 0
	if !(pPager.noSync != 0) {
		rc = sqlite3OsSync(pPager.jfd, 2)
	}
	if rc == 0 {
		rc = sqlite3OsFileSize(pPager.jfd, &pPager.journalHdr)
	}
	return rc
}
func pagerAcquireMapPage(pPager *struct_Pager, pgno uint32, pData unsafe.Pointer, ppPage **struct_PgHdr) int32 {
	var p *struct_PgHdr
	if pPager.pMmapFreelist != nil {
		*ppPage = func() (_cgo_ret *struct_PgHdr) {
			_cgo_addr := &p
			*_cgo_addr = pPager.pMmapFreelist
			return *_cgo_addr
		}()
		pPager.pMmapFreelist = p.pDirty
		p.pDirty = (*struct_PgHdr)(nil)
		func() int {
			_ = 0
			return 0
		}()
		__builtin___memset_chk(p.pExtra, 0, uint(8), __builtin_object_size(p.pExtra, 0))
	} else {
		*ppPage = func() (_cgo_ret *struct_PgHdr) {
			_cgo_addr := &p
			*_cgo_addr = (*struct_PgHdr)(sqlite3MallocZero(uint64(72 + uint(pPager.nExtra))))
			return *_cgo_addr
		}()
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3OsUnfetch(pPager.fd, int64(pgno-uint32(1))*pPager.pageSize, pData)
			return int32(7)
		}
		p.pExtra = unsafe.Pointer(&*(*struct_PgHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*72)))
		p.flags = uint16(32)
		p.nRef = int16(1)
		p.pPager = pPager
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	p.pgno = pgno
	p.pData = pData
	pPager.nMmapOut++
	return int32(0)
}
func pagerReleaseMapPage(pPg *struct_PgHdr) {
	var pPager *struct_Pager = pPg.pPager
	pPager.nMmapOut--
	pPg.pDirty = pPager.pMmapFreelist
	pPager.pMmapFreelist = pPg
	func() int {
		_ = 0
		return 0
	}()
	sqlite3OsUnfetch(pPager.fd, int64(pPg.pgno-uint32(1))*pPager.pageSize, pPg.pData)
}
func pagerFreeMapHdrs(pPager *struct_Pager) {
	var p *struct_PgHdr
	var pNext *struct_PgHdr
	for p = pPager.pMmapFreelist; p != nil; p = pNext {
		pNext = p.pDirty
		sqlite3_free(unsafe.Pointer(p))
	}
}
func databaseIsUnmoved(pPager *struct_Pager) int32 {
	var bHasMoved int32 = 0
	var rc int32
	if pPager.tempFile != 0 {
		return int32(0)
	}
	if pPager.dbSize == uint32(0) {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3OsFileControl(pPager.fd, 20, unsafe.Pointer(&bHasMoved))
	if rc == 12 {
		rc = int32(0)
	} else if rc == 0 && bHasMoved != 0 {
		rc = int32(8 | 4<<8)
	}
	return rc
}
func sqlite3PagerClose(pPager *struct_Pager, db *struct_sqlite3) int32 {
	var pTmp *uint8 = (*uint8)(unsafe.Pointer(pPager.pTmpSpace))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BeginBenignMalloc()
	pagerFreeMapHdrs(pPager)
	pPager.exclusiveMode = uint8(0)
	{
		var a *uint8 = nil
		func() int {
			_ = 0
			return 0
		}()
		if db != nil && uint64(0) == db.flags&uint64(2048) && 0 == databaseIsUnmoved(pPager) {
			a = pTmp
		}
		sqlite3WalClose(pPager.pWal, db, int32(pPager.walSyncFlags), int32(pPager.pageSize), a)
		pPager.pWal = (*struct_Wal)(nil)
	}
	pager_reset(pPager)
	if pPager.memDb != 0 {
		pager_unlock(pPager)
	} else {
		if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
			pager_error(pPager, pagerSyncHotJournal(pPager))
		}
		pagerUnlockAndRollback(pPager)
	}
	sqlite3EndBenignMalloc()
	sqlite3OsClose(pPager.jfd)
	sqlite3OsClose(pPager.fd)
	sqlite3PageFree(unsafe.Pointer(pTmp))
	sqlite3PcacheClose(pPager.pPCache)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_free(unsafe.Pointer(pPager))
	return int32(0)
}
func sqlite3PagerRef(pPg *struct_PgHdr) {
	sqlite3PcacheRef(pPg)
}
func syncJournal(pPager *struct_Pager, newHdr int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3PagerExclusiveLock(pPager)
	if rc != 0 {
		return rc
	}
	if !(pPager.noSync != 0) {
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) && int32(pPager.journalMode) != 4 {
			var iDc int32 = sqlite3OsDeviceCharacteristics(pPager.fd)
			func() int {
				_ = 0
				return 0
			}()
			if 0 == iDc&512 {
				var iNextHdrOffset int64
				var aMagic [8]uint8
				var zHeader [12]uint8
				__builtin___memcpy_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(&zHeader))), unsafe.Pointer((*uint8)(unsafe.Pointer(&aJournalMagic))), 8, __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(&zHeader))), 0))
				sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&zHeader)))) + uintptr(8))))), uint32(pPager.nRec))
				iNextHdrOffset = journalHdrOffset(pPager)
				rc = sqlite3OsRead(pPager.jfd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aMagic))), 8, iNextHdrOffset)
				if rc == 0 && 0 == memcmp(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMagic))), unsafe.Pointer((*uint8)(unsafe.Pointer(&aJournalMagic))), uint(8)) {
					var zerobyte uint8 = uint8(0)
					rc = sqlite3OsWrite(pPager.jfd, unsafe.Pointer(&zerobyte), 1, iNextHdrOffset)
				}
				if rc != 0 && rc != 10|2<<8 {
					return rc
				}
				if int32(pPager.fullSync) != 0 && 0 == iDc&1024 {
					rc = sqlite3OsSync(pPager.jfd, int32(pPager.syncFlags))
					if rc != 0 {
						return rc
					}
				}
				rc = sqlite3OsWrite(pPager.jfd, unsafe.Pointer((*uint8)(unsafe.Pointer(&zHeader))), int32(12), pPager.journalHdr)
				if rc != 0 {
					return rc
				}
			}
			if 0 == iDc&1024 {
				rc = sqlite3OsSync(pPager.jfd, int32(pPager.syncFlags)|func() int32 {
					if int32(pPager.syncFlags) == 3 {
						return 16
					} else {
						return 0
					}
				}())
				if rc != 0 {
					return rc
				}
			}
			pPager.journalHdr = pPager.journalOff
			if newHdr != 0 && 0 == iDc&512 {
				pPager.nRec = int32(0)
				rc = writeJournalHdr(pPager)
				if rc != 0 {
					return rc
				}
			}
		} else {
			pPager.journalHdr = pPager.journalOff
		}
	}
	sqlite3PcacheClearSyncFlags(pPager.pPCache)
	pPager.eState = uint8(4)
	func() int {
		_ = 0
		return 0
	}()
	return int32(0)
}
func pager_write_pagelist(pPager *struct_Pager, pList *struct_PgHdr) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil))) {
		func() int {
			_ = 0
			return 0
		}()
		rc = pagerOpentemp(pPager, pPager.fd, int32(pPager.vfsFlags))
	}
	func() int {
		_ = 0
		return 0
	}()
	if rc == 0 && pPager.dbHintSize < pPager.dbSize && (pList.pDirty != nil || pList.pgno > pPager.dbHintSize) {
		var szFile int64 = pPager.pageSize * int64(pPager.dbSize)
		sqlite3OsFileControlHint(pPager.fd, 5, unsafe.Pointer(&szFile))
		pPager.dbHintSize = pPager.dbSize
	}
	for rc == 0 && pList != nil {
		var pgno uint32 = pList.pgno
		if pgno <= pPager.dbSize && 0 == int32(pList.flags)&16 {
			var offset int64 = int64(pgno-uint32(1)) * int64(pPager.pageSize)
			var pData *int8
			func() int {
				_ = 0
				return 0
			}()
			if pList.pgno == uint32(1) {
				pager_write_changecounter(pList)
			}
			pData = (*int8)(pList.pData)
			rc = sqlite3OsWrite(pPager.fd, unsafe.Pointer(pData), int32(pPager.pageSize), offset)
			if pgno == uint32(1) {
				__builtin___memcpy_chk(unsafe.Pointer(&pPager.dbFileVers), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pData)) + uintptr(24)))), 16, __builtin_object_size(unsafe.Pointer(&pPager.dbFileVers), 0))
			}
			if pgno > pPager.dbFileSize {
				pPager.dbFileSize = pgno
			}
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(2)*4))++
			sqlite3BackupUpdate(pPager.pBackup, pgno, (*uint8)(pList.pData))
		} else {
		}
		pList = pList.pDirty
	}
	return rc
}
func openSubJournal(pPager *struct_Pager) int32 {
	var rc int32 = 0
	if !(uintptr(unsafe.Pointer(pPager.sjfd.pMethods)) != uintptr(unsafe.Pointer(nil))) {
		var flags int32 = 8192 | 2 | 4 | 16 | 8
		var nStmtSpill int32 = sqlite3Config.nStmtSpill
		if int32(pPager.journalMode) == 4 || int32(pPager.subjInMemory) != 0 {
			nStmtSpill = int32(-1)
		}
		rc = sqlite3JournalOpen(pPager.pVfs, nil, pPager.sjfd, flags, nStmtSpill)
	}
	return rc
}
func subjournalPage(pPg *struct_PgHdr) int32 {
	var rc int32 = 0
	var pPager *struct_Pager = pPg.pPager
	if int32(pPager.journalMode) != 2 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		rc = openSubJournal(pPager)
		if rc == 0 {
			var pData unsafe.Pointer = pPg.pData
			var offset int64 = int64(pPager.nSubRec) * (int64(4) + pPager.pageSize)
			var pData2 *int8
			pData2 = (*int8)(pData)
			rc = write32bits(pPager.sjfd, offset, pPg.pgno)
			if rc == 0 {
				rc = sqlite3OsWrite(pPager.sjfd, unsafe.Pointer(pData2), int32(pPager.pageSize), offset+int64(4))
			}
		}
	}
	if rc == 0 {
		pPager.nSubRec++
		func() int {
			_ = 0
			return 0
		}()
		rc = addToSavepointBitvecs(pPager, pPg.pgno)
	}
	return rc
}
func subjournalPageIfRequired(pPg *struct_PgHdr) int32 {
	if subjRequiresPage(pPg) != 0 {
		return subjournalPage(pPg)
	} else {
		return int32(0)
	}
}
func pagerStress(p unsafe.Pointer, pPg *struct_PgHdr) int32 {
	var pPager *struct_Pager = (*struct_Pager)(p)
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.errCode != 0 {
		return int32(0)
	}
	if int32(pPager.doNotSpill) != 0 && (int32(pPager.doNotSpill)&(2|1) != 0 || int32(pPg.flags)&8 != 0) {
		return int32(0)
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(3)*4))++
	pPg.pDirty = (*struct_PgHdr)(nil)
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		rc = subjournalPageIfRequired(pPg)
		if rc == 0 {
			rc = pagerWalFrames(pPager, pPg, uint32(0), 0)
		}
	} else {
		if int32(pPg.flags)&8 != 0 || int32(pPager.eState) == 3 {
			rc = syncJournal(pPager, 1)
		}
		if rc == 0 {
			func() int {
				_ = 0
				return 0
			}()
			rc = pager_write_pagelist(pPager, pPg)
		}
	}
	if rc == 0 {
		sqlite3PcacheMakeClean(pPg)
	}
	return pager_error(pPager, rc)
}
func sqlite3PagerFlush(pPager *struct_Pager) int32 {
	var rc int32 = pPager.errCode
	if !(pPager.memDb != 0) {
		var pList *struct_PgHdr = sqlite3PcacheDirtyList(pPager.pPCache)
		func() int {
			_ = 0
			return 0
		}()
		for rc == 0 && pList != nil {
			var pNext *struct_PgHdr = pList.pDirty
			if int32(pList.nRef) == 0 {
				rc = pagerStress(unsafe.Pointer(pPager), pList)
			}
			pList = pNext
		}
	}
	return rc
}
func sqlite3PagerOpen(pVfs *struct_sqlite3_vfs, ppPager **struct_Pager, zFilename *int8, nExtra int32, flags int32, vfsFlags int32, xReinit func(*struct_PgHdr)) int32 {
	var (
		fout_cgo3 int32
		iDc_cgo5  int32
	)
	var pPtr *uint8
	var pPager *struct_Pager = nil
	var rc int32 = 0
	var tempFile int32 = 0
	var memDb int32 = 0
	var memJM int32 = 0
	var readOnly int32 = 0
	var journalFileSize int32
	var zPathname *int8 = nil
	var nPathname int32 = 0
	var useJournal int32 = func() int32 {
		if flags&1 == 0 {
			return 1
		} else {
			return 0
		}
	}()
	var pcacheSize int32 = sqlite3PcacheSize()
	var szPageDflt uint32 = uint32(4096)
	var zUri *int8 = nil
	var nUriByte int32 = 1
	var nUri int32 = 0
	journalFileSize = (sqlite3JournalSize(pVfs) + 7) & ^7
	*ppPager = (*struct_Pager)(nil)
	if flags&2 != 0 {
		memDb = int32(1)
		if zFilename != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0 {
			zPathname = sqlite3DbStrDup(nil, zFilename)
			if uintptr(unsafe.Pointer(zPathname)) == uintptr(unsafe.Pointer(nil)) {
				return int32(7)
			}
			nPathname = sqlite3Strlen30(zPathname)
			zFilename = (*int8)(nil)
		}
	}
	if zFilename != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0 {
		var z *int8
		nPathname = pVfs.mxPathname + 1
		zPathname = (*int8)(sqlite3DbMallocRaw(nil, uint64(nPathname*2)))
		if uintptr(unsafe.Pointer(zPathname)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPathname)) + uintptr(0))) = int8(0)
		rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname)
		if rc != 0 {
			if rc == 0|2<<8 {
				if vfsFlags&16777216 != 0 {
					rc = int32(14 | 6<<8)
				} else {
					rc = int32(0)
				}
			}
		}
		nPathname = sqlite3Strlen30(zPathname)
		z = func() (_cgo_ret *int8) {
			_cgo_addr := &zUri
			*_cgo_addr = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(sqlite3Strlen30(zFilename)+1)))
			return *_cgo_addr
		}()
		for *z != 0 {
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(strlen(z) + uint(1))
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(strlen(z) + uint(1))
			nUri++
		}
		nUriByte = int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1))))) - uintptr(unsafe.Pointer(zUri)))
		func() int {
			_ = 0
			return 0
		}()
		if rc == 0 && nPathname+8 > pVfs.mxPathname {
			rc = sqlite3CantopenError(57967)
		}
		if rc != 0 {
			sqlite3DbFree(nil, unsafe.Pointer(zPathname))
			return rc
		}
	}
	pPtr = (*uint8)(sqlite3MallocZero(uint64((304+uint(7))&uint(18446744073709551608) + uint((pcacheSize+7) & ^7) + uint((pVfs.szOsFile+7) & ^7) + uint(journalFileSize*2) + 8 + uint(4) + uint(nPathname) + uint(1) + uint(nUriByte) + uint(nPathname) + uint(8) + uint(1) + uint(nPathname) + uint(4) + uint(1) + uint(3))))
	func() int {
		_ = 0
		return 0
	}()
	if !(pPtr != nil) {
		sqlite3DbFree(nil, unsafe.Pointer(zPathname))
		return int32(7)
	}
	pPager = (*struct_Pager)(unsafe.Pointer(pPtr))
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr((304 + uint(7)) & uint(18446744073709551608))
	pPager.pPCache = (*struct_PCache)(unsafe.Pointer(pPtr))
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr((pcacheSize + 7) & ^7)
	pPager.fd = (*struct_sqlite3_file)(unsafe.Pointer(pPtr))
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr((pVfs.szOsFile + 7) & ^7)
	pPager.sjfd = (*struct_sqlite3_file)(unsafe.Pointer(pPtr))
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(journalFileSize)
	pPager.jfd = (*struct_sqlite3_file)(unsafe.Pointer(pPtr))
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(journalFileSize)
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer(&pPager), 8, __builtin_object_size(unsafe.Pointer(pPtr), 0))
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(8)
	*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(4)
	pPager.zFilename = (*int8)(unsafe.Pointer(pPtr))
	if nPathname > 0 {
		__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer(zPathname), uint(nPathname), __builtin_object_size(unsafe.Pointer(pPtr), 0))
		*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(nPathname + 1)
		if zUri != nil {
			__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer(zUri), uint(nUriByte), __builtin_object_size(unsafe.Pointer(pPtr), 0))
			*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(nUriByte)
		} else {
			*(*uintptr)(unsafe.Pointer(&pPtr))++
		}
	}
	if nPathname > 0 {
		pPager.zJournal = (*int8)(unsafe.Pointer(pPtr))
		__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer(zPathname), uint(nPathname), __builtin_object_size(unsafe.Pointer(pPtr), 0))
		*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(nPathname)
		__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer((*int8)(unsafe.Pointer(&[9]int8{'-', 'j', 'o', 'u', 'r', 'n', 'a', 'l', '\x00'}))), uint(8), __builtin_object_size(unsafe.Pointer(pPtr), 0))
		*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(8 + 1)
	} else {
		pPager.zJournal = (*int8)(nil)
	}
	if nPathname > 0 {
		pPager.zWal = (*int8)(unsafe.Pointer(pPtr))
		__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer(zPathname), uint(nPathname), __builtin_object_size(unsafe.Pointer(pPtr), 0))
		*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(nPathname)
		__builtin___memcpy_chk(unsafe.Pointer(pPtr), unsafe.Pointer((*int8)(unsafe.Pointer(&[5]int8{'-', 'w', 'a', 'l', '\x00'}))), uint(4), __builtin_object_size(unsafe.Pointer(pPtr), 0))
		*(*uintptr)(unsafe.Pointer(&pPtr)) += uintptr(4 + 1)
	} else {
		pPager.zWal = (*int8)(nil)
	}
	func() int {
		_ = pPtr
		return 0
	}()
	if nPathname != 0 {
		sqlite3DbFree(nil, unsafe.Pointer(zPathname))
	}
	pPager.pVfs = pVfs
	pPager.vfsFlags = uint32(vfsFlags)
	if !(zFilename != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0) {
		goto _cgol_2
	}
	fout_cgo3 = 0
	rc = sqlite3OsOpen(pVfs, pPager.zFilename, pPager.fd, vfsFlags, &fout_cgo3)
	func() int {
		_ = 0
		return 0
	}()
	pPager.memVfs = uint8(func() (_cgo_ret int32) {
		_cgo_addr := &memJM
		*_cgo_addr = func() int32 {
			if fout_cgo3&128 != 0 {
				return 1
			} else {
				return 0
			}
		}()
		return *_cgo_addr
	}())
	readOnly = func() int32 {
		if fout_cgo3&1 != 0 {
			return 1
		} else {
			return 0
		}
	}()
	if !(rc == 0) {
		goto _cgol_4
	}
	iDc_cgo5 = sqlite3OsDeviceCharacteristics(pPager.fd)
	if !(readOnly != 0) {
		setSectorSize(pPager)
		func() int {
			_ = 0
			return 0
		}()
		if szPageDflt < pPager.sectorSize {
			if pPager.sectorSize > uint32(8192) {
				szPageDflt = uint32(8192)
			} else {
				szPageDflt = uint32(pPager.sectorSize)
			}
		}
	}
	pPager.noLock = uint8(sqlite3_uri_boolean(pPager.zFilename, (*int8)(unsafe.Pointer(&[7]int8{'n', 'o', 'l', 'o', 'c', 'k', '\x00'})), 0))
	if !(iDc_cgo5&8192 != 0 || sqlite3_uri_boolean(pPager.zFilename, (*int8)(unsafe.Pointer(&[10]int8{'i', 'm', 'm', 'u', 't', 'a', 'b', 'l', 'e', '\x00'})), 0) != 0) {
		goto _cgol_6
	}
	vfsFlags |= int32(1)
	goto act_like_temp_file
_cgol_6:
	;
_cgol_4:
	goto _cgol_1
_cgol_2:
	;
act_like_temp_file:
	tempFile = int32(1)
	pPager.eState = uint8(1)
	pPager.eLock = uint8(4)
	pPager.noLock = uint8(1)
	readOnly = vfsFlags & 1
_cgol_1:
	if rc == 0 {
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1)
	}
	if rc == 0 {
		nExtra = (nExtra + 7) & ^7
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3PcacheOpen(int32(szPageDflt), nExtra, func() int32 {
			if !(memDb != 0) {
				return 1
			} else {
				return 0
			}
		}(), func() func(unsafe.Pointer, *struct_PgHdr) int32 {
			if !(memDb != 0) {
				return pagerStress
			} else {
				return nil
			}
		}(), unsafe.Pointer(pPager), pPager.pPCache)
	}
	if rc != 0 {
		sqlite3OsClose(pPager.fd)
		sqlite3PageFree(unsafe.Pointer(pPager.pTmpSpace))
		sqlite3_free(unsafe.Pointer(pPager))
		return rc
	}
	pPager.useJournal = uint8(useJournal)
	pPager.mxPgno = uint32(1073741823)
	pPager.tempFile = uint8(tempFile)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPager.exclusiveMode = uint8(tempFile)
	pPager.changeCountDone = pPager.tempFile
	pPager.memDb = uint8(memDb)
	pPager.readOnly = uint8(readOnly)
	func() int {
		_ = 0
		return 0
	}()
	pPager.noSync = pPager.tempFile
	if pPager.noSync != 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	} else {
		pPager.fullSync = uint8(1)
		pPager.extraSync = uint8(0)
		pPager.syncFlags = uint8(2)
		pPager.walSyncFlags = uint8(2 | 2<<2)
	}
	pPager.nExtra = uint16(nExtra)
	pPager.journalSizeLimit = int64(-1)
	func() int {
		_ = 0
		return 0
	}()
	setSectorSize(pPager)
	if !(useJournal != 0) {
		pPager.journalMode = uint8(2)
	} else if memDb != 0 || memJM != 0 {
		pPager.journalMode = uint8(4)
	}
	pPager.xReiniter = xReinit
	setGetterMethod(pPager)
	*ppPager = pPager
	return int32(0)
}
func sqlite3_database_file_object(zName *int8) *struct_sqlite3_file {
	var pPager *struct_Pager
	for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -1)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -2)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -3)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -4)))) != 0 {
		*(*uintptr)(unsafe.Pointer(&zName))--
	}
	pPager = *(**struct_Pager)(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))-uintptr(4))))) - uintptr(8)))))
	return pPager.fd
}
func hasHotJournal(pPager *struct_Pager, pExists *int32) int32 {
	var pVfs *struct_sqlite3_vfs = pPager.pVfs
	var rc int32 = 0
	var exists int32 = 1
	var jrnlOpen int32 = func() int32 {
		if !!(uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil))) {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*pExists = int32(0)
	if !(jrnlOpen != 0) {
		rc = sqlite3OsAccess(pVfs, pPager.zJournal, 0, &exists)
	}
	if rc == 0 && exists != 0 {
		var locked int32 = 0
		rc = sqlite3OsCheckReservedLock(pPager.fd, &locked)
		if rc == 0 && !(locked != 0) {
			var nPage uint32
			func() int {
				_ = 0
				return 0
			}()
			rc = pagerPagecount(pPager, &nPage)
			if rc == 0 {
				if nPage == uint32(0) && !(jrnlOpen != 0) {
					sqlite3BeginBenignMalloc()
					if pagerLockDb(pPager, 2) == 0 {
						sqlite3OsDelete(pVfs, pPager.zJournal, 0)
						if !(pPager.exclusiveMode != 0) {
							pagerUnlockDb(pPager, 1)
						}
					}
					sqlite3EndBenignMalloc()
				} else {
					if !(jrnlOpen != 0) {
						var f int32 = 1 | 2048
						rc = sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, f, &f)
					}
					if rc == 0 {
						var first uint8 = uint8(0)
						rc = sqlite3OsRead(pPager.jfd, unsafe.Pointer(&first), 1, int64(0))
						if rc == 10|2<<8 {
							rc = int32(0)
						}
						if !(jrnlOpen != 0) {
							sqlite3OsClose(pPager.jfd)
						}
						*pExists = func() int32 {
							if int32(first) != 0 {
								return 1
							} else {
								return 0
							}
						}()
					} else if rc == 14 {
						*pExists = int32(1)
						rc = int32(0)
					}
				}
			}
		}
	}
	return rc
}
func sqlite3PagerSharedLock(pPager *struct_Pager) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil))) && int32(pPager.eState) == 0 {
		var bHotJournal int32 = 1
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		rc = pager_wait_on_lock(pPager, 1)
		if rc != 0 {
			func() int {
				_ = 0
				return 0
			}()
			goto failed
		}
		if int32(pPager.eLock) <= 1 {
			rc = hasHotJournal(pPager, &bHotJournal)
		}
		if rc != 0 {
			goto failed
		}
		if bHotJournal != 0 {
			if pPager.readOnly != 0 {
				rc = int32(8 | 3<<8)
				goto failed
			}
			rc = pagerLockDb(pPager, 4)
			if rc != 0 {
				goto failed
			}
			if !(uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil))) && int32(pPager.journalMode) != 2 {
				var pVfs *struct_sqlite3_vfs = pPager.pVfs
				var bExists int32
				rc = sqlite3OsAccess(pVfs, pPager.zJournal, 0, &bExists)
				if rc == 0 && bExists != 0 {
					var fout int32 = 0
					var f int32 = 2 | 2048
					func() int {
						_ = 0
						return 0
					}()
					rc = sqlite3OsOpen(pVfs, pPager.zJournal, pPager.jfd, f, &fout)
					func() int {
						_ = 0
						return 0
					}()
					if rc == 0 && fout&1 != 0 {
						rc = sqlite3CantopenError(58497)
						sqlite3OsClose(pPager.jfd)
					}
				}
			}
			if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
				func() int {
					_ = 0
					return 0
				}()
				rc = pagerSyncHotJournal(pPager)
				if rc == 0 {
					rc = pager_playback(pPager, func() int32 {
						if !(pPager.tempFile != 0) {
							return 1
						} else {
							return 0
						}
					}())
					pPager.eState = uint8(0)
				}
			} else if !(pPager.exclusiveMode != 0) {
				pagerUnlockDb(pPager, 1)
			}
			if rc != 0 {
				pager_error(pPager, rc)
				goto failed
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
		}
		if !(pPager.tempFile != 0) && int32(pPager.hasHeldSharedLock) != 0 {
			var dbFileVers [16]int8
			rc = sqlite3OsRead(pPager.fd, unsafe.Pointer(&dbFileVers), int32(16), int64(24))
			if rc != 0 {
				if rc != 10|2<<8 {
					goto failed
				}
				__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&dbFileVers))), 0, 16, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&dbFileVers))), 0))
			}
			if memcmp(unsafe.Pointer((*int8)(unsafe.Pointer(&pPager.dbFileVers))), unsafe.Pointer((*int8)(unsafe.Pointer(&dbFileVers))), 16) != 0 {
				pager_reset(pPager)
				if pPager.bUseFetch != 0 {
					sqlite3OsUnfetch(pPager.fd, int64(0), nil)
				}
			}
		}
		rc = pagerOpenWalIfPresent(pPager)
		func() int {
			_ = 0
			return 0
		}()
	}
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		rc = pagerBeginReadTransaction(pPager)
	}
	if int32(pPager.tempFile) == 0 && int32(pPager.eState) == 0 && rc == 0 {
		rc = pagerPagecount(pPager, &pPager.dbSize)
	}
failed:
	if rc != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pager_unlock(pPager)
		func() int {
			_ = 0
			return 0
		}()
	} else {
		pPager.eState = uint8(1)
		pPager.hasHeldSharedLock = uint8(1)
	}
	return rc
}
func pagerUnlockIfUnused(pPager *struct_Pager) {
	if sqlite3PcacheRefCount(pPager.pPCache) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		pagerUnlockAndRollback(pPager)
	}
}
func getPageNormal(pPager *struct_Pager, pgno uint32, ppPage **struct_PgHdr, flags int32) int32 {
	var rc int32 = 0
	var pPg *struct_PgHdr
	var noContent uint8
	var pBase *struct_sqlite3_pcache_page
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pgno == uint32(0) {
		return sqlite3CorruptError(58710)
	}
	pBase = sqlite3PcacheFetch(pPager.pPCache, pgno, 3)
	if uintptr(unsafe.Pointer(pBase)) == uintptr(unsafe.Pointer(nil)) {
		pPg = (*struct_PgHdr)(nil)
		rc = sqlite3PcacheFetchStress(pPager.pPCache, pgno, &pBase)
		if rc != 0 {
			goto pager_acquire_err
		}
		if uintptr(unsafe.Pointer(pBase)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
			goto pager_acquire_err
		}
	}
	pPg = func() (_cgo_ret *struct_PgHdr) {
		_cgo_addr := &*ppPage
		*_cgo_addr = sqlite3PcacheFetchFinish(pPager.pPCache, pgno, pBase)
		return *_cgo_addr
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	noContent = func() uint8 {
		if flags&1 != 0 {
			return 1
		} else {
			return 0
		}
	}()
	if pPg.pPager != nil && !(noContent != 0) {
		func() int {
			_ = 0
			return 0
		}()
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(0)*4))++
		return int32(0)
	} else {
		if pgno == uint32(int64(sqlite3PendingByte)/pPager.pageSize+int64(1)) {
			rc = sqlite3CorruptError(58742)
			goto pager_acquire_err
		}
		pPg.pPager = pPager
		func() int {
			_ = 0
			return 0
		}()
		if !(uintptr(unsafe.Pointer(pPager.fd.pMethods)) != uintptr(unsafe.Pointer(nil))) || pPager.dbSize < pgno || int32(noContent) != 0 {
			if pgno > pPager.mxPgno {
				rc = int32(13)
				goto pager_acquire_err
			}
			if noContent != 0 {
				sqlite3BeginBenignMalloc()
				if pgno <= pPager.dbOrigSize {
					sqlite3BitvecSet(pPager.pInJournal, pgno)
				}
				addToSavepointBitvecs(pPager, pgno)
				sqlite3EndBenignMalloc()
			}
			__builtin___memset_chk(pPg.pData, 0, uint(pPager.pageSize), __builtin_object_size(pPg.pData, 0))
		} else {
			func() int {
				_ = 0
				return 0
			}()
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(1)*4))++
			rc = readDbPage(pPg)
			if rc != 0 {
				goto pager_acquire_err
			}
		}
	}
	return int32(0)
pager_acquire_err:
	func() int {
		_ = 0
		return 0
	}()
	if pPg != nil {
		sqlite3PcacheDrop(pPg)
	}
	pagerUnlockIfUnused(pPager)
	*ppPage = (*struct_PgHdr)(nil)
	return rc
}
func getPageMMap(pPager *struct_Pager, pgno uint32, ppPage **struct_PgHdr, flags int32) int32 {
	var rc int32 = 0
	var pPg *struct_PgHdr = nil
	var iFrame uint32 = uint32(0)
	var bMmapOk int32 = func() int32 {
		if pgno > uint32(1) && (int32(pPager.eState) == 1 || flags&2 != 0) {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pgno <= uint32(1) && pgno == uint32(0) {
		return sqlite3CorruptError(58821)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if bMmapOk != 0 && uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		rc = sqlite3WalFindFrame(pPager.pWal, pgno, &iFrame)
		if rc != 0 {
			*ppPage = (*struct_PgHdr)(nil)
			return rc
		}
	}
	if bMmapOk != 0 && iFrame == uint32(0) {
		var pData unsafe.Pointer = nil
		rc = sqlite3OsFetch(pPager.fd, int64(pgno-uint32(1))*pPager.pageSize, int32(pPager.pageSize), &pData)
		if rc == 0 && pData != nil {
			if int32(pPager.eState) > 1 || int32(pPager.tempFile) != 0 {
				pPg = sqlite3PagerLookup(pPager, pgno)
			}
			if uintptr(unsafe.Pointer(pPg)) == uintptr(unsafe.Pointer(nil)) {
				rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg)
			} else {
				sqlite3OsUnfetch(pPager.fd, int64(pgno-uint32(1))*pPager.pageSize, pData)
			}
			if pPg != nil {
				func() int {
					_ = 0
					return 0
				}()
				*ppPage = pPg
				return int32(0)
			}
		}
		if rc != 0 {
			*ppPage = (*struct_PgHdr)(nil)
			return rc
		}
	}
	return getPageNormal(pPager, pgno, ppPage, flags)
}
func getPageError(pPager *struct_Pager, pgno uint32, ppPage **struct_PgHdr, flags int32) int32 {
	func() int {
		_ = pgno
		return 0
	}()
	func() int {
		_ = flags
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*ppPage = (*struct_PgHdr)(nil)
	return pPager.errCode
}
func sqlite3PagerGet(pPager *struct_Pager, pgno uint32, ppPage **struct_PgHdr, flags int32) int32 {
	return pPager.xGet(pPager, pgno, ppPage, flags)
}
func sqlite3PagerLookup(pPager *struct_Pager, pgno uint32) *struct_PgHdr {
	var pPage *struct_sqlite3_pcache_page
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPage = sqlite3PcacheFetch(pPager.pPCache, pgno, 0)
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPage)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_PgHdr)(nil)
	}
	return sqlite3PcacheFetchFinish(pPager.pPCache, pgno, pPage)
}
func sqlite3PagerUnrefNotNull(pPg *struct_PgHdr) {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPg.flags)&32 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pagerReleaseMapPage(pPg)
	} else {
		sqlite3PcacheRelease(pPg)
	}
	func() int {
		_ = 0
		return 0
	}()
}
func sqlite3PagerUnref(pPg *struct_PgHdr) {
	if pPg != nil {
		sqlite3PagerUnrefNotNull(pPg)
	}
}
func sqlite3PagerUnrefPageOne(pPg *struct_PgHdr) {
	var pPager *struct_Pager
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPager = pPg.pPager
	sqlite3PcacheRelease(pPg)
	pagerUnlockIfUnused(pPager)
}
func pager_open_journal(pPager *struct_Pager) int32 {
	var rc int32 = 0
	var pVfs *struct_sqlite3_vfs = pPager.pVfs
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.errCode != 0 {
		return pPager.errCode
	}
	if !(uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil))) && int32(pPager.journalMode) != 2 {
		pPager.pInJournal = sqlite3BitvecCreate(pPager.dbSize)
		if uintptr(unsafe.Pointer(pPager.pInJournal)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		if !(uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil))) {
			if int32(pPager.journalMode) == 4 {
				sqlite3MemJournalOpen(pPager.jfd)
			} else {
				var flags int32 = 2 | 4
				var nSpill int32
				if pPager.tempFile != 0 {
					flags |= int32(8 | 4096)
					nSpill = sqlite3Config.nStmtSpill
				} else {
					flags |= int32(2048)
					nSpill = jrnlBufferSize(pPager)
				}
				rc = databaseIsUnmoved(pPager)
				if rc == 0 {
					rc = sqlite3JournalOpen(pVfs, pPager.zJournal, pPager.jfd, flags, nSpill)
				}
			}
			func() int {
				_ = 0
				return 0
			}()
		}
		if rc == 0 {
			pPager.nRec = int32(0)
			pPager.journalOff = int64(0)
			pPager.setSuper = uint8(0)
			pPager.journalHdr = int64(0)
			rc = writeJournalHdr(pPager)
		}
	}
	if rc != 0 {
		sqlite3BitvecDestroy(pPager.pInJournal)
		pPager.pInJournal = (*struct_Bitvec)(nil)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		pPager.eState = uint8(3)
	}
	return rc
}
func sqlite3PagerBegin(pPager *struct_Pager, exFlag int32, subjInMemory int32) int32 {
	var rc int32 = 0
	if pPager.errCode != 0 {
		return pPager.errCode
	}
	func() int {
		_ = 0
		return 0
	}()
	pPager.subjInMemory = uint8(subjInMemory)
	if int32(pPager.eState) == 1 {
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
			if int32(pPager.exclusiveMode) != 0 && sqlite3WalExclusiveMode(pPager.pWal, -1) != 0 {
				rc = pagerLockDb(pPager, 4)
				if rc != 0 {
					return rc
				}
				func() int {
					_ = sqlite3WalExclusiveMode(pPager.pWal, 1)
					return 0
				}()
			}
			rc = sqlite3WalBeginWriteTransaction(pPager.pWal)
		} else {
			rc = pagerLockDb(pPager, 2)
			if rc == 0 && exFlag != 0 {
				rc = pager_wait_on_lock(pPager, 4)
			}
		}
		if rc == 0 {
			pPager.eState = uint8(2)
			pPager.dbHintSize = pPager.dbSize
			pPager.dbFileSize = pPager.dbSize
			pPager.dbOrigSize = pPager.dbSize
			pPager.journalOff = int64(0)
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	return rc
}
func pagerAddPageToRollbackJournal(pPg *struct_PgHdr) int32 {
	var pPager *struct_Pager = pPg.pPager
	var rc int32
	var cksum uint32
	var pData2 *int8
	var iOff int64 = pPager.journalOff
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pData2 = (*int8)(pPg.pData)
	cksum = pager_cksum(pPager, (*uint8)(unsafe.Pointer(pData2)))
	pPg.flags |= uint16(8)
	rc = write32bits(pPager.jfd, iOff, pPg.pgno)
	if rc != 0 {
		return rc
	}
	rc = sqlite3OsWrite(pPager.jfd, unsafe.Pointer(pData2), int32(pPager.pageSize), iOff+int64(4))
	if rc != 0 {
		return rc
	}
	rc = write32bits(pPager.jfd, iOff+pPager.pageSize+int64(4), cksum)
	if rc != 0 {
		return rc
	}
	pPager.journalOff += int64(8) + pPager.pageSize
	pPager.nRec++
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3BitvecSet(pPager.pInJournal, pPg.pgno)
	func() int {
		_ = 0
		return 0
	}()
	rc |= addToSavepointBitvecs(pPager, pPg.pgno)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func pager_write(pPg *struct_PgHdr) int32 {
	var pPager *struct_Pager = pPg.pPager
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.eState) == 2 {
		rc = pager_open_journal(pPager)
		if rc != 0 {
			return rc
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3PcacheMakeDirty(pPg)
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pPager.pInJournal)) != uintptr(unsafe.Pointer(nil)) && sqlite3BitvecTestNotNull(pPager.pInJournal, pPg.pgno) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		if pPg.pgno <= pPager.dbOrigSize {
			rc = pagerAddPageToRollbackJournal(pPg)
			if rc != 0 {
				return rc
			}
		} else if int32(pPager.eState) != 4 {
			pPg.flags |= uint16(8)
		}
	}
	pPg.flags |= uint16(4)
	if pPager.nSavepoint > 0 {
		rc = subjournalPageIfRequired(pPg)
	}
	if pPager.dbSize < pPg.pgno {
		pPager.dbSize = pPg.pgno
	}
	return rc
}
func pagerWriteLargeSector(pPg *struct_PgHdr) int32 {
	var rc int32 = 0
	var nPageCount uint32
	var pg1 uint32
	var nPage int32 = 0
	var ii int32
	var needSync int32 = 0
	var pPager *struct_Pager = pPg.pPager
	var nPagePerSector uint32 = uint32(int64(pPager.sectorSize) / pPager.pageSize)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPager.doNotSpill |= uint8(4)
	pg1 = (pPg.pgno-uint32(1)) & ^(nPagePerSector-uint32(1)) + uint32(1)
	nPageCount = pPager.dbSize
	if pPg.pgno > nPageCount {
		nPage = int32(pPg.pgno - pg1 + uint32(1))
	} else if pg1+nPagePerSector-uint32(1) > nPageCount {
		nPage = int32(nPageCount + uint32(1) - pg1)
	} else {
		nPage = int32(nPagePerSector)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for ii = int32(0); ii < nPage && rc == 0; ii++ {
		var pg uint32 = pg1 + uint32(ii)
		var pPage *struct_PgHdr
		if pg == pPg.pgno || !(sqlite3BitvecTest(pPager.pInJournal, pg) != 0) {
			if pg != uint32(int64(sqlite3PendingByte)/pPager.pageSize+int64(1)) {
				rc = sqlite3PagerGet(pPager, pg, &pPage, 0)
				if rc == 0 {
					rc = pager_write(pPage)
					if int32(pPage.flags)&8 != 0 {
						needSync = int32(1)
					}
					sqlite3PagerUnrefNotNull(pPage)
				}
			}
		} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_PgHdr) {
			_cgo_addr := &pPage
			*_cgo_addr = sqlite3PagerLookup(pPager, pg)
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			if int32(pPage.flags)&8 != 0 {
				needSync = int32(1)
			}
			sqlite3PagerUnrefNotNull(pPage)
		}
	}
	if rc == 0 && needSync != 0 {
		func() int {
			_ = 0
			return 0
		}()
		for ii = int32(0); ii < nPage; ii++ {
			var pPage *struct_PgHdr = sqlite3PagerLookup(pPager, pg1+uint32(ii))
			if pPage != nil {
				pPage.flags |= uint16(8)
				sqlite3PagerUnrefNotNull(pPage)
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	pPager.doNotSpill &= uint8(^4)
	return rc
}
func sqlite3PagerWrite(pPg *struct_PgHdr) int32 {
	var pPager *struct_Pager = pPg.pPager
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPg.flags)&4 != 0 && pPager.dbSize >= pPg.pgno {
		if pPager.nSavepoint != 0 {
			return subjournalPageIfRequired(pPg)
		}
		return int32(0)
	} else if pPager.errCode != 0 {
		return pPager.errCode
	} else if pPager.sectorSize > uint32(pPager.pageSize) {
		func() int {
			_ = 0
			return 0
		}()
		return pagerWriteLargeSector(pPg)
	} else {
		return pager_write(pPg)
	}
}
func sqlite3PagerDontWrite(pPg *struct_PgHdr) {
	var pPager *struct_Pager = pPg.pPager
	if !(pPager.tempFile != 0) && int32(pPg.flags)&2 != 0 && pPager.nSavepoint == 0 {
		pPg.flags |= uint16(16)
		pPg.flags &= uint16(^4)
	}
}
func pager_incr_changecounter(pPager *struct_Pager, isDirectMode int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = isDirectMode
		return 0
	}()
	if !(pPager.changeCountDone != 0) && pPager.dbSize > uint32(0) {
		var pPgHdr *struct_PgHdr
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3PagerGet(pPager, uint32(1), &pPgHdr, 0)
		func() int {
			_ = 0
			return 0
		}()
		if true && rc == 0 {
			rc = sqlite3PagerWrite(pPgHdr)
		}
		if rc == 0 {
			pager_write_changecounter(pPgHdr)
			if 0 != 0 {
				var zBuf unsafe.Pointer
				func() int {
					_ = 0
					return 0
				}()
				zBuf = pPgHdr.pData
				if rc == 0 {
					rc = sqlite3OsWrite(pPager.fd, zBuf, int32(pPager.pageSize), int64(0))
					*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(2)*4))++
				}
				if rc == 0 {
					var pCopy unsafe.Pointer = unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(zBuf))) + uintptr(24))))
					__builtin___memcpy_chk(unsafe.Pointer(&pPager.dbFileVers), pCopy, 16, __builtin_object_size(unsafe.Pointer(&pPager.dbFileVers), 0))
					pPager.changeCountDone = uint8(1)
				}
			} else {
				pPager.changeCountDone = uint8(1)
			}
		}
		sqlite3PagerUnref(pPgHdr)
	}
	return rc
}
func sqlite3PagerSync(pPager *struct_Pager, zSuper *int8) int32 {
	var rc int32 = 0
	var pArg unsafe.Pointer = unsafe.Pointer(zSuper)
	rc = sqlite3OsFileControl(pPager.fd, 21, pArg)
	if rc == 12 {
		rc = int32(0)
	}
	if rc == 0 && !(pPager.noSync != 0) {
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3OsSync(pPager.fd, int32(pPager.syncFlags))
	}
	return rc
}
func sqlite3PagerExclusiveLock(pPager *struct_Pager) int32 {
	var rc int32 = pPager.errCode
	func() int {
		_ = 0
		return 0
	}()
	if rc == 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if 0 == func() int32 {
			if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}() {
			rc = pager_wait_on_lock(pPager, 4)
		}
	}
	return rc
}
func sqlite3PagerCommitPhaseOne(pPager *struct_Pager, zSuper *int8, noSync int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.errCode != 0 {
		return pPager.errCode
	}
	if sqlite3FaultSim(400) != 0 {
		return int32(10)
	}
	if int32(pPager.eState) < 3 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if 0 == pagerFlushOnCommit(pPager, 1) {
		sqlite3BackupRestart(pPager.pBackup)
	} else {
		var pList *struct_PgHdr
		if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
			var pPageOne *struct_PgHdr = nil
			pList = sqlite3PcacheDirtyList(pPager.pPCache)
			if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
				rc = sqlite3PagerGet(pPager, uint32(1), &pPageOne, 0)
				pList = pPageOne
				pList.pDirty = (*struct_PgHdr)(nil)
			}
			func() int {
				_ = 0
				return 0
			}()
			if pList != nil {
				rc = pagerWalFrames(pPager, pList, pPager.dbSize, 1)
			}
			sqlite3PagerUnref(pPageOne)
			if rc == 0 {
				sqlite3PcacheCleanAll(pPager.pPCache)
			}
		} else {
			rc = pager_incr_changecounter(pPager, 0)
			if rc != 0 {
				goto commit_phase_one_exit
			}
			rc = writeSuperJournal(pPager, zSuper)
			if rc != 0 {
				goto commit_phase_one_exit
			}
			rc = syncJournal(pPager, 0)
			if rc != 0 {
				goto commit_phase_one_exit
			}
			pList = sqlite3PcacheDirtyList(pPager.pPCache)
			if 0 == 0 {
				rc = pager_write_pagelist(pPager, pList)
			}
			if rc != 0 {
				func() int {
					_ = 0
					return 0
				}()
				goto commit_phase_one_exit
			}
			sqlite3PcacheCleanAll(pPager.pPCache)
			if pPager.dbSize > pPager.dbFileSize {
				var nNew uint32 = pPager.dbSize - func() uint32 {
					if pPager.dbSize == uint32(int64(sqlite3PendingByte)/pPager.pageSize+int64(1)) {
						return 1
					} else {
						return 0
					}
				}()
				func() int {
					_ = 0
					return 0
				}()
				rc = pager_truncate(pPager, nNew)
				if rc != 0 {
					goto commit_phase_one_exit
				}
			}
			if !(noSync != 0) {
				rc = sqlite3PagerSync(pPager, zSuper)
			}
		}
	}
commit_phase_one_exit:
	if rc == 0 && !(uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil))) {
		pPager.eState = uint8(5)
	}
	return rc
}
func sqlite3PagerCommitPhaseTwo(pPager *struct_Pager) int32 {
	var rc int32 = 0
	if pPager.errCode != 0 {
		return pPager.errCode
	}
	pPager.iDataVersion++
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.eState) == 2 && int32(pPager.exclusiveMode) != 0 && int32(pPager.journalMode) == 1 {
		func() int {
			_ = 0
			return 0
		}()
		pPager.eState = uint8(1)
		return int32(0)
	}
	rc = pager_end_transaction(pPager, int32(pPager.setSuper), 1)
	return pager_error(pPager, rc)
}
func sqlite3PagerRollback(pPager *struct_Pager) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.eState) == 6 {
		return pPager.errCode
	}
	if int32(pPager.eState) <= 1 {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
		var rc2 int32
		rc = sqlite3PagerSavepoint(pPager, 2, -1)
		rc2 = pager_end_transaction(pPager, int32(pPager.setSuper), 0)
		if rc == 0 {
			rc = rc2
		}
	} else if !(uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil))) || int32(pPager.eState) == 2 {
		var eState int32 = int32(pPager.eState)
		rc = pager_end_transaction(pPager, 0, 0)
		if !(pPager.memDb != 0) && eState > 2 {
			pPager.errCode = int32(4)
			pPager.eState = uint8(6)
			setGetterMethod(pPager)
			return rc
		}
	} else {
		rc = pager_playback(pPager, 0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return pager_error(pPager, rc)
}
func sqlite3PagerIsreadonly(pPager *struct_Pager) uint8 {
	return pPager.readOnly
}
func sqlite3PagerMemUsed(pPager *struct_Pager) int32 {
	var perPageSize int32 = int32(pPager.pageSize + int64(pPager.nExtra) + int64(int32(72+uint(5)*8)))
	return int32(int64(perPageSize*sqlite3PcachePagecount(pPager.pPCache)+sqlite3MallocSize(unsafe.Pointer(pPager))) + pPager.pageSize)
}
func sqlite3PagerPageRefcount(pPage *struct_PgHdr) int32 {
	return sqlite3PcachePageRefcount(pPage)
}
func sqlite3PagerCacheStat(pPager *struct_Pager, eStat int32, reset int32, pnVal *int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	eStat -= int32(7)
	*pnVal += *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(eStat)*4))
	if reset != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pPager.aStat)))) + uintptr(eStat)*4)) = int32(0)
	}
}
func sqlite3PagerIsMemdb(pPager *struct_Pager) int32 {
	return func() int32 {
		if int32(pPager.tempFile) != 0 || int32(pPager.memVfs) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func pagerOpenSavepoint(pPager *struct_Pager, nSavepoint int32) int32 {
	var rc int32 = 0
	var nCurrent int32 = pPager.nSavepoint
	var ii int32
	var aNew *struct_PagerSavepoint
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	aNew = (*struct_PagerSavepoint)(sqlite3Realloc(unsafe.Pointer(pPager.aSavepoint), uint64(52*uint(nSavepoint))))
	if !(aNew != nil) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(&*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(nCurrent)*52))), 0, uint(nSavepoint-nCurrent)*52, __builtin_object_size(unsafe.Pointer(&*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(nCurrent)*52))), 0))
	pPager.aSavepoint = aNew
	for ii = nCurrent; ii < nSavepoint; ii++ {
		(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).nOrig = pPager.dbSize
		if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) && pPager.journalOff > int64(0) {
			(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).iOffset = pPager.journalOff
		} else {
			(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).iOffset = int64(pPager.sectorSize)
		}
		(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).iSubRec = pPager.nSubRec
		(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).pInSavepoint = sqlite3BitvecCreate(pPager.dbSize)
		(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).bTruncateOnRelease = int32(1)
		if !((*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).pInSavepoint != nil) {
			return int32(7)
		}
		if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) {
			sqlite3WalSavepoint(pPager.pWal, (*uint32)(unsafe.Pointer(&(*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(ii)*52))).aWalData)))
		}
		pPager.nSavepoint = ii + 1
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3PagerOpenSavepoint(pPager *struct_Pager, nSavepoint int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nSavepoint > pPager.nSavepoint && int32(pPager.useJournal) != 0 {
		return pagerOpenSavepoint(pPager, nSavepoint)
	} else {
		return int32(0)
	}
}
func sqlite3PagerSavepoint(pPager *struct_Pager, op int32, iSavepoint int32) int32 {
	var rc int32 = pPager.errCode
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if rc == 0 && iSavepoint < pPager.nSavepoint {
		var ii int32
		var nNew int32
		nNew = iSavepoint + func() int32 {
			if op == 1 {
				return 0
			} else {
				return 1
			}
		}()
		for ii = nNew; ii < pPager.nSavepoint; ii++ {
			sqlite3BitvecDestroy((*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(ii)*52))).pInSavepoint)
		}
		pPager.nSavepoint = nNew
		if op == 1 {
			var pRel *struct_PagerSavepoint = &*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(nNew)*52))
			if pRel.bTruncateOnRelease != 0 && uintptr(unsafe.Pointer(pPager.sjfd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
				if sqlite3JournalIsInMemory(pPager.sjfd) != 0 {
					var sz int64 = (pPager.pageSize + int64(4)) * int64(pRel.iSubRec)
					rc = sqlite3OsTruncate(pPager.sjfd, sz)
					func() int {
						_ = 0
						return 0
					}()
				}
				pPager.nSubRec = pRel.iSubRec
			}
		} else if uintptr(unsafe.Pointer(pPager.pWal)) != uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) {
			var pSavepoint *struct_PagerSavepoint = func() *struct_PagerSavepoint {
				if nNew == 0 {
					return nil
				} else {
					return &*(*struct_PagerSavepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pPager.aSavepoint)) + uintptr(nNew-1)*52))
				}
			}()
			rc = pagerPlaybackSavepoint(pPager, pSavepoint)
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	return rc
}
func sqlite3PagerFilename(pPager *struct_Pager, nullIfMemDb int32) *int8 {
	var zFake [8]int8 = [8]int8{int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0)}
	return func() *int8 {
		if nullIfMemDb != 0 && int32(pPager.memDb) != 0 {
			return &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zFake)))) + uintptr(4)))
		} else {
			return (*int8)(unsafe.Pointer(pPager.zFilename))
		}
	}()
}
func sqlite3PagerVfs(pPager *struct_Pager) *struct_sqlite3_vfs {
	return pPager.pVfs
}
func sqlite3PagerFile(pPager *struct_Pager) *struct_sqlite3_file {
	return pPager.fd
}
func sqlite3PagerJrnlFile(pPager *struct_Pager) *struct_sqlite3_file {
	return func() *struct_sqlite3_file {
		if pPager.pWal != nil {
			return sqlite3WalFile(pPager.pWal)
		} else {
			return pPager.jfd
		}
	}()
}
func sqlite3PagerJournalname(pPager *struct_Pager) *int8 {
	return pPager.zJournal
}
func sqlite3PagerMovepage(pPager *struct_Pager, pPg *struct_PgHdr, pgno uint32, isCommit int32) int32 {
	var pPgOld *struct_PgHdr
	var needSyncPgno uint32 = uint32(0)
	var rc int32
	var origPgno uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.tempFile != 0 {
		rc = sqlite3PagerWrite(pPg)
		if rc != 0 {
			return rc
		}
	}
	if int32(pPg.flags)&2 != 0 && 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = subjournalPageIfRequired(pPg)
		return *_cgo_addr
	}() {
		return rc
	}
	if int32(pPg.flags)&8 != 0 && !(isCommit != 0) {
		needSyncPgno = pPg.pgno
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	pPg.flags &= uint16(^8)
	pPgOld = sqlite3PagerLookup(pPager, pgno)
	func() int {
		_ = 0
		return 0
	}()
	if pPgOld != nil {
		if int32(pPgOld.nRef) > 1 {
			sqlite3PagerUnrefNotNull(pPgOld)
			return sqlite3CorruptError(60360)
		}
		pPg.flags |= uint16(int32(pPgOld.flags) & 8)
		if pPager.tempFile != 0 {
			sqlite3PcacheMove(pPgOld, pPager.dbSize+uint32(1))
		} else {
			sqlite3PcacheDrop(pPgOld)
		}
	}
	origPgno = pPg.pgno
	sqlite3PcacheMove(pPg, pgno)
	sqlite3PcacheMakeDirty(pPg)
	if int32(pPager.tempFile) != 0 && pPgOld != nil {
		sqlite3PcacheMove(pPgOld, origPgno)
		sqlite3PagerUnrefNotNull(pPgOld)
	}
	if needSyncPgno != 0 {
		var pPgHdr *struct_PgHdr
		rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0)
		if rc != 0 {
			if needSyncPgno <= pPager.dbOrigSize {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3BitvecClear(pPager.pInJournal, needSyncPgno, unsafe.Pointer(pPager.pTmpSpace))
			}
			return rc
		}
		pPgHdr.flags |= uint16(8)
		sqlite3PcacheMakeDirty(pPgHdr)
		sqlite3PagerUnrefNotNull(pPgHdr)
	}
	return int32(0)
}
func sqlite3PagerRekey(pPg *struct_PgHdr, iNew uint32, flags uint16) {
	func() int {
		_ = 0
		return 0
	}()
	pPg.flags = flags
	sqlite3PcacheMove(pPg, iNew)
}
func sqlite3PagerGetData(pPg *struct_PgHdr) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	return pPg.pData
}
func sqlite3PagerGetExtra(pPg *struct_PgHdr) unsafe.Pointer {
	return pPg.pExtra
}
func sqlite3PagerLockingMode(pPager *struct_Pager, eMode int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if eMode >= 0 && !(pPager.tempFile != 0) && !(sqlite3WalHeapMemory(pPager.pWal) != 0) {
		pPager.exclusiveMode = uint8(eMode)
	}
	return int32(pPager.exclusiveMode)
}
func sqlite3PagerSetJournalMode(pPager *struct_Pager, eMode int32) int32 {
	var eOld uint8 = pPager.journalMode
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.memDb != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if eMode != 4 && eMode != 2 {
			eMode = int32(eOld)
		}
	}
	if eMode != int32(eOld) {
		func() int {
			_ = 0
			return 0
		}()
		pPager.journalMode = uint8(eMode)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if !(pPager.exclusiveMode != 0) && int32(eOld)&5 == 1 && eMode&1 == 0 {
			sqlite3OsClose(pPager.jfd)
			if int32(pPager.eLock) >= 2 {
				sqlite3OsDelete(pPager.pVfs, pPager.zJournal, 0)
			} else {
				var rc int32 = 0
				var state int32 = int32(pPager.eState)
				func() int {
					_ = 0
					return 0
				}()
				if state == 0 {
					rc = sqlite3PagerSharedLock(pPager)
				}
				if int32(pPager.eState) == 1 {
					func() int {
						_ = 0
						return 0
					}()
					rc = pagerLockDb(pPager, 2)
				}
				if rc == 0 {
					sqlite3OsDelete(pPager.pVfs, pPager.zJournal, 0)
				}
				if rc == 0 && state == 1 {
					pagerUnlockDb(pPager, 1)
				} else if state == 0 {
					pager_unlock(pPager)
				}
				func() int {
					_ = 0
					return 0
				}()
			}
		} else if eMode == 2 {
			sqlite3OsClose(pPager.jfd)
		}
	}
	return int32(pPager.journalMode)
}
func sqlite3PagerGetJournalMode(pPager *struct_Pager) int32 {
	return int32(pPager.journalMode)
}
func sqlite3PagerOkToChangeJournalMode(pPager *struct_Pager) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.eState) >= 3 {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pPager.jfd.pMethods)) != uintptr(unsafe.Pointer(nil)) && pPager.journalOff > int64(0) {
		return int32(0)
	}
	return int32(1)
}
func sqlite3PagerJournalSizeLimit(pPager *struct_Pager, iLimit int64) int64 {
	if iLimit >= int64(-1) {
		pPager.journalSizeLimit = iLimit
		sqlite3WalLimit(pPager.pWal, iLimit)
	}
	return pPager.journalSizeLimit
}
func sqlite3PagerBackupPtr(pPager *struct_Pager) **struct_sqlite3_backup {
	return &pPager.pBackup
}
func sqlite3PagerClearCache(pPager *struct_Pager) {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPager.tempFile) == 0 {
		pager_reset(pPager)
	}
}
func sqlite3PagerCheckpoint(pPager *struct_Pager, db *struct_sqlite3, eMode int32, pnLog *int32, pnCkpt *int32) int32 {
	var rc int32 = 0
	if uintptr(unsafe.Pointer(pPager.pWal)) == uintptr(unsafe.Pointer(nil)) && int32(pPager.journalMode) == 5 {
		sqlite3_exec(db, (*int8)(unsafe.Pointer(&[18]int8{'P', 'R', 'A', 'G', 'M', 'A', ' ', 't', 'a', 'b', 'l', 'e', '_', 'l', 'i', 's', 't', '\x00'})), nil, nil, nil)
	}
	if pPager.pWal != nil {
		rc = sqlite3WalCheckpoint(pPager.pWal, db, eMode, func() func(unsafe.Pointer) int32 {
			if eMode == 0 {
				return nil
			} else {
				return pPager.xBusyHandler
			}
		}(), pPager.pBusyHandlerArg, int32(pPager.walSyncFlags), int32(pPager.pageSize), (*uint8)(unsafe.Pointer(pPager.pTmpSpace)), pnLog, pnCkpt)
	}
	return rc
}
func sqlite3PagerWalCallback(pPager *struct_Pager) int32 {
	return sqlite3WalCallback(pPager.pWal)
}
func sqlite3PagerWalSupported(pPager *struct_Pager) int32 {
	var pMethods *struct_sqlite3_io_methods = pPager.fd.pMethods
	if pPager.noLock != 0 {
		return int32(0)
	}
	return func() int32 {
		if int32(pPager.exclusiveMode) != 0 || pMethods.iVersion >= 2 && pMethods.xShmMap != nil {
			return 1
		} else {
			return 0
		}
	}()
}
func pagerExclusiveLock(pPager *struct_Pager) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	rc = pagerLockDb(pPager, 4)
	if rc != 0 {
		pagerUnlockDb(pPager, 1)
	}
	return rc
}
func pagerOpenWal(pPager *struct_Pager) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPager.exclusiveMode != 0 {
		rc = pagerExclusiveLock(pPager)
	}
	if rc == 0 {
		rc = sqlite3WalOpen(pPager.pVfs, pPager.fd, pPager.zWal, int32(pPager.exclusiveMode), pPager.journalSizeLimit, &pPager.pWal)
	}
	pagerFixMaplimit(pPager)
	return rc
}
func sqlite3PagerOpenWal(pPager *struct_Pager, pbOpen *int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(pPager.tempFile != 0) && !(pPager.pWal != nil) {
		if !(sqlite3PagerWalSupported(pPager) != 0) {
			return int32(14)
		}
		sqlite3OsClose(pPager.jfd)
		rc = pagerOpenWal(pPager)
		if rc == 0 {
			pPager.journalMode = uint8(5)
			pPager.eState = uint8(0)
		}
	} else {
		*pbOpen = int32(1)
	}
	return rc
}
func sqlite3PagerCloseWal(pPager *struct_Pager, db *struct_sqlite3) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if !(pPager.pWal != nil) {
		var logexists int32 = 0
		rc = pagerLockDb(pPager, 1)
		if rc == 0 {
			rc = sqlite3OsAccess(pPager.pVfs, pPager.zWal, 0, &logexists)
		}
		if rc == 0 && logexists != 0 {
			rc = pagerOpenWal(pPager)
		}
	}
	if rc == 0 && pPager.pWal != nil {
		rc = pagerExclusiveLock(pPager)
		if rc == 0 {
			rc = sqlite3WalClose(pPager.pWal, db, int32(pPager.walSyncFlags), int32(pPager.pageSize), (*uint8)(unsafe.Pointer(pPager.pTmpSpace)))
			pPager.pWal = (*struct_Wal)(nil)
			pagerFixMaplimit(pPager)
			if rc != 0 && !(pPager.exclusiveMode != 0) {
				pagerUnlockDb(pPager, 1)
			}
		}
	}
	return rc
}

type WalIndexHdr = struct_WalIndexHdr
type WalIterator = struct_WalIterator
type WalCkptInfo = struct_WalCkptInfo
type struct_WalIndexHdr struct {
	iVersion    uint32
	unused      uint32
	iChange     uint32
	isInit      uint8
	bigEndCksum uint8
	szPage      uint16
	mxFrame     uint32
	nPage       uint32
	aFrameCksum [2]uint32
	aSalt       [2]uint32
	aCksum      [2]uint32
}
type struct_WalCkptInfo struct {
	nBackfill          uint32
	aReadMark          [5]uint32
	aLock              [8]uint8
	nBackfillAttempted uint32
	notUsed0           uint32
}
type struct_Wal struct {
	pVfs                *struct_sqlite3_vfs
	pDbFd               *struct_sqlite3_file
	pWalFd              *struct_sqlite3_file
	iCallback           uint32
	mxWalSize           int64
	nWiData             int32
	szFirstBlock        int32
	apWiData            **uint32
	szPage              uint32
	readLock            int16
	syncFlags           uint8
	exclusiveMode       uint8
	writeLock           uint8
	ckptLock            uint8
	readOnly            uint8
	truncateOnCommit    uint8
	syncHeader          uint8
	padToSectorBoundary uint8
	bShmUnreliable      uint8
	hdr                 struct_WalIndexHdr
	minFrame            uint32
	iReCksum            uint32
	zWalName            *int8
	nCkpt               uint32
}
type ht_slot = uint16
type struct_WalSegment struct {
	iNext  int32
	aIndex *uint16
	aPgno  *uint32
	nEntry int32
	iZero  int32
}
type struct_WalIterator struct {
	iPrior   uint32
	nSegment int32
	aSegment [1]struct_WalSegment
}

func walIndexPageRealloc(pWal *struct_Wal, iPage int32, ppPage **uint32) int32 {
	var rc int32 = 0
	if pWal.nWiData <= iPage {
		var nByte int64 = int64(8 * uint(iPage+1))
		var apNew **uint32
		apNew = (**uint32)(sqlite3Realloc(unsafe.Pointer(pWal.apWiData), uint64(nByte)))
		if !(apNew != nil) {
			*ppPage = (*uint32)(nil)
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(&*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(apNew)) + uintptr(pWal.nWiData)*8))), 0, 8*uint(iPage+1-pWal.nWiData), __builtin_object_size(unsafe.Pointer(&*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(apNew)) + uintptr(pWal.nWiData)*8))), 0))
		pWal.apWiData = apNew
		pWal.nWiData = iPage + 1
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(pWal.exclusiveMode) == 2 {
		*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPage)*8)) = (*uint32)(sqlite3MallocZero(uint64(2*uint(4096*2) + uint(4096)*4)))
		if !(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPage)*8)) != nil) {
			rc = int32(7)
		}
	} else {
		rc = sqlite3OsShmMap(pWal.pDbFd, iPage, int32(2*uint(4096*2)+uint(4096)*4), int32(pWal.writeLock), (*unsafe.Pointer)(unsafe.Pointer(&*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPage)*8)))))
		func() int {
			_ = 0
			return 0
		}()
		if rc == 0 {
			if iPage > 0 && sqlite3FaultSim(600) != 0 {
				rc = int32(7)
			}
		} else if rc&255 == 8 {
			pWal.readOnly |= uint8(2)
			if rc == 8 {
				rc = int32(0)
			}
		}
	}
	*ppPage = *(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPage)*8))
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func walIndexPage(pWal *struct_Wal, iPage int32, ppPage **uint32) int32 {
	if pWal.nWiData <= iPage || uintptr(unsafe.Pointer(func() (_cgo_ret *uint32) {
		_cgo_addr := &*ppPage
		*_cgo_addr = *(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPage)*8))
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return walIndexPageRealloc(pWal, iPage, ppPage)
	}
	return int32(0)
}
func walCkptInfo(pWal *struct_Wal) *struct_WalCkptInfo {
	func() int {
		_ = 0
		return 0
	}()
	return (*struct_WalCkptInfo)(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(0)*8)))) + uintptr(48/uint(2))*4))))
}
func walIndexHdr(pWal *struct_Wal) *struct_WalIndexHdr {
	func() int {
		_ = 0
		return 0
	}()
	return (*struct_WalIndexHdr)(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(0)*8))))
}
func walChecksumBytes(nativeCksum int32, a *uint8, nByte int32, aIn *uint32, aOut *uint32) {
	var s1 uint32
	var s2 uint32
	var aData *uint32 = (*uint32)(unsafe.Pointer(a))
	var aEnd *uint32 = (*uint32)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(nByte)))))
	if aIn != nil {
		s1 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aIn)) + uintptr(0)*4))
		s2 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aIn)) + uintptr(1)*4))
	} else {
		s1 = func() (_cgo_ret uint32) {
			_cgo_addr := &s2
			*_cgo_addr = uint32(0)
			return *_cgo_addr
		}()
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nativeCksum != 0 {
		for {
			s1 += *func() (_cgo_ret *uint32) {
				_cgo_addr := &aData
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 4
				return
			}() + s2
			s2 += *func() (_cgo_ret *uint32) {
				_cgo_addr := &aData
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 4
				return
			}() + s1
			if !(uintptr(unsafe.Pointer(aData)) < uintptr(unsafe.Pointer(aEnd))) {
				break
			}
		}
	} else {
		for {
			s1 += *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(0)*4))&uint32(255)<<24 + *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(0)*4))&uint32(65280)<<8 + *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(0)*4))&uint32(16711680)>>8 + *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(0)*4))&4278190080>>24 + s2
			s2 += *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(1)*4))&uint32(255)<<24 + *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(1)*4))&uint32(65280)<<8 + *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(1)*4))&uint32(16711680)>>8 + *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(1)*4))&4278190080>>24 + s1
			*(*uintptr)(unsafe.Pointer(&aData)) += uintptr(2) * 4
			if !(uintptr(unsafe.Pointer(aData)) < uintptr(unsafe.Pointer(aEnd))) {
				break
			}
		}
	}
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOut)) + uintptr(0)*4)) = s1
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOut)) + uintptr(1)*4)) = s2
}
func walShmBarrier(pWal *struct_Wal) {
	if int32(pWal.exclusiveMode) != 2 {
		sqlite3OsShmBarrier(pWal.pDbFd)
	}
}
func walIndexWriteHdr(pWal *struct_Wal) {
	var aHdr *struct_WalIndexHdr = walIndexHdr(pWal)
	var nCksum int32 = int32(40)
	func() int {
		_ = 0
		return 0
	}()
	pWal.hdr.isInit = uint8(1)
	pWal.hdr.iVersion = uint32(3007000)
	walChecksumBytes(1, (*uint8)(unsafe.Pointer(&pWal.hdr)), nCksum, nil, (*uint32)(unsafe.Pointer(&pWal.hdr.aCksum)))
	__builtin___memcpy_chk(unsafe.Pointer(&*(*struct_WalIndexHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(aHdr)) + uintptr(1)*48))), unsafe.Pointer(&pWal.hdr), 48, __builtin_object_size(unsafe.Pointer(&*(*struct_WalIndexHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(aHdr)) + uintptr(1)*48))), 0))
	walShmBarrier(pWal)
	__builtin___memcpy_chk(unsafe.Pointer(&*(*struct_WalIndexHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(aHdr)) + uintptr(0)*48))), unsafe.Pointer(&pWal.hdr), 48, __builtin_object_size(unsafe.Pointer(&*(*struct_WalIndexHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(aHdr)) + uintptr(0)*48))), 0))
}
func walEncodeFrame(pWal *struct_Wal, iPage uint32, nTruncate uint32, aData *uint8, aFrame *uint8) {
	var nativeCksum int32
	var aCksum *uint32 = (*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum))
	func() int {
		_ = 0
		return 0
	}()
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(0))), iPage)
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(4))), nTruncate)
	if pWal.iReCksum == uint32(0) {
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(8)))), unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aSalt))), uint(8), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(8)))), 0))
		nativeCksum = func() int32 {
			if int32(pWal.hdr.bigEndCksum) == 0 {
				return 1
			} else {
				return 0
			}
		}()
		walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum)
		walChecksumBytes(nativeCksum, aData, int32(pWal.szPage), aCksum, aCksum)
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(16))), *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCksum)) + uintptr(0)*4)))
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(20))), *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCksum)) + uintptr(1)*4)))
	} else {
		__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(8)))), 0, uint(16), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(8)))), 0))
	}
}
func walDecodeFrame(pWal *struct_Wal, piPage *uint32, pnTruncate *uint32, aData *uint8, aFrame *uint8) int32 {
	var nativeCksum int32
	var aCksum *uint32 = (*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum))
	var pgno uint32
	func() int {
		_ = 0
		return 0
	}()
	if memcmp(unsafe.Pointer(&pWal.hdr.aSalt), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(8)))), uint(8)) != 0 {
		return int32(0)
	}
	pgno = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(0))))
	if pgno == uint32(0) {
		return int32(0)
	}
	nativeCksum = func() int32 {
		if int32(pWal.hdr.bigEndCksum) == 0 {
			return 1
		} else {
			return 0
		}
	}()
	walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum)
	walChecksumBytes(nativeCksum, aData, int32(pWal.szPage), aCksum, aCksum)
	if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCksum)) + uintptr(0)*4)) != sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(16)))) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCksum)) + uintptr(1)*4)) != sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(20)))) {
		return int32(0)
	}
	*piPage = pgno
	*pnTruncate = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(4))))
	return int32(1)
}
func walLockShared(pWal *struct_Wal, lockIdx int32) int32 {
	var rc int32
	if pWal.exclusiveMode != 0 {
		return int32(0)
	}
	rc = sqlite3OsShmLock(pWal.pDbFd, lockIdx, 1, 2|4)
	return rc
}
func walUnlockShared(pWal *struct_Wal, lockIdx int32) {
	if pWal.exclusiveMode != 0 {
		return
	}
	func() int {
		_ = sqlite3OsShmLock(pWal.pDbFd, lockIdx, 1, 1|4)
		return 0
	}()
}
func walLockExclusive(pWal *struct_Wal, lockIdx int32, n int32) int32 {
	var rc int32
	if pWal.exclusiveMode != 0 {
		return int32(0)
	}
	rc = sqlite3OsShmLock(pWal.pDbFd, lockIdx, n, 2|8)
	return rc
}
func walUnlockExclusive(pWal *struct_Wal, lockIdx int32, n int32) {
	if pWal.exclusiveMode != 0 {
		return
	}
	func() int {
		_ = sqlite3OsShmLock(pWal.pDbFd, lockIdx, n, 1|8)
		return 0
	}()
}
func walHash(iPage uint32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return int32(iPage * uint32(383) & uint32(4096*2-1))
}
func walNextHash(iPriorHash int32) int32 {
	return (iPriorHash + 1) & (4096*2 - 1)
}

type WalHashLoc = struct_WalHashLoc
type struct_WalHashLoc struct {
	aHash *uint16
	aPgno *uint32
	iZero uint32
}

func walHashGet(pWal *struct_Wal, iHash int32, pLoc *struct_WalHashLoc) int32 {
	var rc int32
	rc = walIndexPage(pWal, iHash, &pLoc.aPgno)
	func() int {
		_ = 0
		return 0
	}()
	if pLoc.aPgno != nil {
		pLoc.aHash = (*uint16)(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoc.aPgno)) + uintptr(4096)*4))))
		if iHash == 0 {
			pLoc.aPgno = &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoc.aPgno)) + uintptr((48*uint(2)+40)/4)*4))
			pLoc.iZero = uint32(0)
		} else {
			pLoc.iZero = uint32(uint(4096) - (48*uint(2)+40)/4 + uint((iHash-1)*4096))
		}
	} else if rc == 0 {
		rc = int32(1)
	}
	return rc
}
func walFramePage(iFrame uint32) int32 {
	var iHash int32 = int32((uint(iFrame+uint32(4096)) - (uint(4096) - (48*uint(2)+40)/4) - uint(1)) / uint(4096))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return iHash
}
func walFramePgno(pWal *struct_Wal, iFrame uint32) uint32 {
	var iHash int32 = walFramePage(iFrame)
	if iHash == 0 {
		return *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(0)*8)))) + uintptr((48*uint(2)+40)/4+uint(iFrame)-uint(1))*4))
	}
	return *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iHash)*8)))) + uintptr((uint(iFrame-uint32(1))-(uint(4096)-(48*uint(2)+40)/4))%uint(4096))*4))
}
func walCleanupHash(pWal *struct_Wal) {
	var sLoc struct_WalHashLoc
	var iLimit int32 = 0
	var nByte int32
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	if pWal.hdr.mxFrame == uint32(0) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	i = walHashGet(pWal, walFramePage(pWal.hdr.mxFrame), &sLoc)
	if i != 0 {
		return
	}
	iLimit = int32(pWal.hdr.mxFrame - sLoc.iZero)
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < 4096*2; i++ {
		if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aHash)) + uintptr(i)*2))) > iLimit {
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aHash)) + uintptr(i)*2)) = uint16(0)
		}
	}
	nByte = int32(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(sLoc.aHash)))) - uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aPgno)) + uintptr(iLimit)*4)))))))
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aPgno)) + uintptr(iLimit)*4))), 0, uint(nByte), __builtin_object_size(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aPgno)) + uintptr(iLimit)*4))), 0))
}
func walIndexAppend(pWal *struct_Wal, iFrame uint32, iPage uint32) int32 {
	var rc int32
	var sLoc struct_WalHashLoc
	rc = walHashGet(pWal, walFramePage(iFrame), &sLoc)
	if rc == 0 {
		var iKey int32
		var idx int32
		var nCollide int32
		idx = int32(iFrame - sLoc.iZero)
		func() int {
			_ = 0
			return 0
		}()
		if idx == 1 {
			var nByte int32 = int32(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aHash)) + uintptr(4096*2)*2)))))) - uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(sLoc.aPgno)))))
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memset_chk(unsafe.Pointer(sLoc.aPgno), 0, uint(nByte), __builtin_object_size(unsafe.Pointer(sLoc.aPgno), 0))
		}
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aPgno)) + uintptr(idx-1)*4)) != 0 {
			walCleanupHash(pWal)
			func() int {
				_ = 0
				return 0
			}()
		}
		nCollide = idx
		for iKey = walHash(iPage); *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aHash)) + uintptr(iKey)*2)) != 0; iKey = walNextHash(iKey) {
			if func() (_cgo_ret int32) {
				_cgo_addr := &nCollide
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}() == 0 {
				return sqlite3CorruptError(62124)
			}
		}
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aPgno)) + uintptr(idx-1)*4)) = iPage
		__atomic_store_n_u16(&*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aHash)) + uintptr(iKey)*2)), 0, uint16(idx))
	}
	return rc
}
func walIndexRecover(pWal *struct_Wal) int32 {
	var rc int32
	var nSize int64
	var aFrameCksum [2]uint32 = [2]uint32{uint32(0), uint32(0)}
	var iLock int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iLock = 1 + int32(pWal.ckptLock)
	rc = walLockExclusive(pWal, iLock, 3+0-iLock)
	if rc != 0 {
		return rc
	}
	__builtin___memset_chk(unsafe.Pointer(&pWal.hdr), 0, 48, __builtin_object_size(unsafe.Pointer(&pWal.hdr), 0))
	rc = sqlite3OsFileSize(pWal.pWalFd, &nSize)
	if rc != 0 {
		goto recovery_error
	}
	if nSize > int64(32) {
		var aBuf [32]uint8
		var aPrivate *uint32 = nil
		var aFrame *uint8 = nil
		var szFrame int32
		var aData *uint8
		var szPage int32
		var magic uint32
		var version uint32
		var isValid int32
		var iPg uint32
		var iLastFrame uint32
		rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf))), 32, int64(0))
		if rc != 0 {
			goto recovery_error
		}
		magic = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(0))))
		szPage = int32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(8)))))
		if magic&4294967294 != uint32(931071618) || szPage&(szPage-1) != 0 || szPage > 65536 || szPage < 512 {
			goto finished
		}
		pWal.hdr.bigEndCksum = uint8(magic & uint32(1))
		pWal.szPage = uint32(szPage)
		pWal.nCkpt = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(12))))
		__builtin___memcpy_chk(unsafe.Pointer(&pWal.hdr.aSalt), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(16)))), uint(8), __builtin_object_size(unsafe.Pointer(&pWal.hdr.aSalt), 0))
		walChecksumBytes(func() int32 {
			if int32(pWal.hdr.bigEndCksum) == 0 {
				return 1
			} else {
				return 0
			}
		}(), (*uint8)(unsafe.Pointer(&aBuf)), 32-2*4, nil, (*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4)) != sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(24)))) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4)) != sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(28)))) {
			goto finished
		}
		version = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(4))))
		if version != uint32(3007000) {
			rc = sqlite3CantopenError(62256)
			goto finished
		}
		szFrame = szPage + 24
		aFrame = (*uint8)(sqlite3_malloc64(uint64(uint(szFrame) + (2*uint(4096*2) + uint(4096)*4))))
		if !(aFrame != nil) {
			rc = int32(7)
			goto recovery_error
		}
		aData = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(24)))
		aPrivate = (*uint32)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(szPage)))))
		iLastFrame = uint32((nSize - int64(32)) / int64(szFrame))
		for iPg = uint32(0); iPg <= uint32(walFramePage(iLastFrame)); iPg++ {
			var aShare *uint32
			var iFrame uint32
			var iLast uint32 = uint32(func() uint {
				if uint(iLastFrame) < uint(4096)-(48*uint(2)+40)/4+uint(iPg*uint32(4096)) {
					return uint(iLastFrame)
				} else {
					return uint(4096) - (48*uint(2)+40)/4 + uint(iPg*uint32(4096))
				}
			}())
			var iFirst uint32 = uint32(uint(1) + func() uint {
				if iPg == uint32(0) {
					return uint(0)
				} else {
					return uint(4096) - (48*uint(2)+40)/4 + uint((iPg-uint32(1))*uint32(4096))
				}
			}())
			var nHdr uint32
			var nHdr32 uint32
			rc = walIndexPage(pWal, int32(iPg), (**uint32)(unsafe.Pointer(&aShare)))
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(aShare)) == uintptr(unsafe.Pointer(nil)) {
				break
			}
			*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPg)*8)) = aPrivate
			for iFrame = iFirst; iFrame <= iLast; iFrame++ {
				var iOffset int64 = int64(32) + int64(iFrame-uint32(1))*int64(szPage+24)
				var pgno uint32
				var nTruncate uint32
				rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer(aFrame), szFrame, iOffset)
				if rc != 0 {
					break
				}
				isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame)
				if !(isValid != 0) {
					break
				}
				rc = walIndexAppend(pWal, iFrame, pgno)
				if rc != 0 {
					break
				}
				if nTruncate != 0 {
					pWal.hdr.mxFrame = iFrame
					pWal.hdr.nPage = nTruncate
					pWal.hdr.szPage = uint16(szPage&65280 | szPage>>16)
					*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aFrameCksum)))) + uintptr(0)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4))
					*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aFrameCksum)))) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4))
				}
			}
			*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(iPg)*8)) = aShare
			nHdr = uint32(func() uint {
				if iPg == uint32(0) {
					return 48*uint(2) + 40
				} else {
					return uint(0)
				}
			}())
			nHdr32 = uint32(uint(nHdr) / 4)
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aShare)) + uintptr(nHdr32)*4))), unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aPrivate)) + uintptr(nHdr32)*4))), 2*uint(4096*2)+uint(4096)*4-uint(nHdr), __builtin_object_size(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aShare)) + uintptr(nHdr32)*4))), 0))
			if iFrame <= iLast {
				break
			}
		}
		sqlite3_free(unsafe.Pointer(aFrame))
	}
finished:
	if rc == 0 {
		var pInfo *struct_WalCkptInfo
		var i int32
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aFrameCksum)))) + uintptr(0)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aFrameCksum)))) + uintptr(1)*4))
		walIndexWriteHdr(pWal)
		pInfo = walCkptInfo(pWal)
		pInfo.nBackfill = uint32(0)
		pInfo.nBackfillAttempted = pWal.hdr.mxFrame
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark)))) + uintptr(0)*4)) = uint32(0)
		for i = int32(1); i < 8-3; i++ {
			rc = walLockExclusive(pWal, 3+i, 1)
			if rc == 0 {
				if i == 1 && pWal.hdr.mxFrame != 0 {
					*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark)))) + uintptr(i)*4)) = pWal.hdr.mxFrame
				} else {
					*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark)))) + uintptr(i)*4)) = uint32(4294967295)
				}
				walUnlockExclusive(pWal, 3+i, 1)
			} else if rc != 5 {
				goto recovery_error
			}
		}
		if pWal.hdr.nPage != 0 {
			sqlite3_log(27|1<<8, (*int8)(unsafe.Pointer(&[37]int8{'r', 'e', 'c', 'o', 'v', 'e', 'r', 'e', 'd', ' ', '%', 'd', ' ', 'f', 'r', 'a', 'm', 'e', 's', ' ', 'f', 'r', 'o', 'm', ' ', 'W', 'A', 'L', ' ', 'f', 'i', 'l', 'e', ' ', '%', 's', '\x00'})), pWal.hdr.mxFrame, pWal.zWalName)
		}
	}
recovery_error:
	walUnlockExclusive(pWal, iLock, 3+0-iLock)
	return rc
}
func walIndexClose(pWal *struct_Wal, isDelete int32) {
	if int32(pWal.exclusiveMode) == 2 || int32(pWal.bShmUnreliable) != 0 {
		var i int32
		for i = int32(0); i < pWal.nWiData; i++ {
			sqlite3_free(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(i)*8))))
			*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(i)*8)) = (*uint32)(nil)
		}
	}
	if int32(pWal.exclusiveMode) != 2 {
		sqlite3OsShmUnmap(pWal.pDbFd, isDelete)
	}
}
func sqlite3WalOpen(pVfs *struct_sqlite3_vfs, pDbFd *struct_sqlite3_file, zWalName *int8, bNoShm int32, mxWalSize int64, ppWal **struct_Wal) int32 {
	var rc int32
	var pRet *struct_Wal
	var flags int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*ppWal = (*struct_Wal)(nil)
	pRet = (*struct_Wal)(sqlite3MallocZero(uint64(140 + uint(pVfs.szOsFile))))
	if !(pRet != nil) {
		return int32(7)
	}
	pRet.pVfs = pVfs
	pRet.pWalFd = (*struct_sqlite3_file)(unsafe.Pointer(&*(*struct_Wal)(unsafe.Pointer(uintptr(unsafe.Pointer(pRet)) + uintptr(1)*140))))
	pRet.pDbFd = pDbFd
	pRet.readLock = int16(-1)
	pRet.mxWalSize = mxWalSize
	pRet.zWalName = zWalName
	pRet.syncHeader = uint8(1)
	pRet.padToSectorBoundary = uint8(1)
	pRet.exclusiveMode = uint8(func() int32 {
		if bNoShm != 0 {
			return 2
		} else {
			return 0
		}
	}())
	flags = int32(2 | 4 | 524288)
	rc = sqlite3OsOpen(pVfs, zWalName, pRet.pWalFd, flags, &flags)
	if rc == 0 && flags&1 != 0 {
		pRet.readOnly = uint8(1)
	}
	if rc != 0 {
		walIndexClose(pRet, 0)
		sqlite3OsClose(pRet.pWalFd)
		sqlite3_free(unsafe.Pointer(pRet))
	} else {
		var iDC int32 = sqlite3OsDeviceCharacteristics(pDbFd)
		if iDC&1024 != 0 {
			pRet.syncHeader = uint8(0)
		}
		if iDC&4096 != 0 {
			pRet.padToSectorBoundary = uint8(0)
		}
		*ppWal = pRet
	}
	return rc
}
func sqlite3WalLimit(pWal *struct_Wal, iLimit int64) {
	if pWal != nil {
		pWal.mxWalSize = iLimit
	}
}
func walIteratorNext(p *struct_WalIterator, piPage *uint32, piFrame *uint32) int32 {
	var iMin uint32
	var iRet uint32 = 4294967295
	var i int32
	iMin = p.iPrior
	func() int {
		_ = 0
		return 0
	}()
	for i = p.nSegment - 1; i >= 0; i-- {
		var pSegment *struct_WalSegment = &*(*struct_WalSegment)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WalSegment)(unsafe.Pointer(&p.aSegment)))) + uintptr(i)*32))
		for pSegment.iNext < pSegment.nEntry {
			var iPg uint32 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pSegment.aPgno)) + uintptr(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(pSegment.aIndex)) + uintptr(pSegment.iNext)*2)))*4))
			if iPg > iMin {
				if iPg < iRet {
					iRet = iPg
					*piFrame = uint32(pSegment.iZero + int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(pSegment.aIndex)) + uintptr(pSegment.iNext)*2))))
				}
				break
			}
			pSegment.iNext++
		}
	}
	*piPage = func() (_cgo_ret uint32) {
		_cgo_addr := &p.iPrior
		*_cgo_addr = iRet
		return *_cgo_addr
	}()
	return func() int32 {
		if iRet == 4294967295 {
			return 1
		} else {
			return 0
		}
	}()
}
func walMerge(aContent *uint32, aLeft *uint16, nLeft int32, paRight **uint16, pnRight *int32, aTmp *uint16) {
	var iLeft int32 = 0
	var iRight int32 = 0
	var iOut int32 = 0
	var nRight int32 = *pnRight
	var aRight *uint16 = *paRight
	func() int {
		_ = 0
		return 0
	}()
	for iRight < nRight || iLeft < nLeft {
		var logpage uint16
		var dbpage uint32
		if iLeft < nLeft && (iRight >= nRight || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aContent)) + uintptr(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aLeft)) + uintptr(iLeft)*2)))*4)) < *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aContent)) + uintptr(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aRight)) + uintptr(iRight)*2)))*4))) {
			logpage = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aLeft)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &iLeft
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*2))
		} else {
			logpage = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aRight)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &iRight
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*2))
		}
		dbpage = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aContent)) + uintptr(logpage)*4))
		*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aTmp)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &iOut
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*2)) = logpage
		if iLeft < nLeft && *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aContent)) + uintptr(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aLeft)) + uintptr(iLeft)*2)))*4)) == dbpage {
			iLeft++
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	*paRight = aLeft
	*pnRight = iOut
	__builtin___memcpy_chk(unsafe.Pointer(aLeft), unsafe.Pointer(aTmp), 2*uint(iOut), __builtin_object_size(unsafe.Pointer(aLeft), 0))
}
func walMergesort(aContent *uint32, aBuffer *uint16, aList *uint16, pnList *int32) {
	type struct_Sublist struct {
		nList int32
		aList *uint16
	}
	var nList int32 = *pnList
	var nMerge int32 = 0
	var aMerge *uint16 = nil
	var iList int32
	var iSub uint32 = uint32(0)
	var aSub [13]struct_Sublist
	__builtin___memset_chk(unsafe.Pointer((*struct_Sublist)(unsafe.Pointer(&aSub))), 0, 208, __builtin_object_size(unsafe.Pointer((*struct_Sublist)(unsafe.Pointer(&aSub))), 0))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for iList = int32(0); iList < nList; iList++ {
		nMerge = int32(1)
		aMerge = &*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aList)) + uintptr(iList)*2))
		for iSub = uint32(0); iList&int32(1<<iSub) != 0; iSub++ {
			var p *struct_Sublist
			func() int {
				_ = 0
				return 0
			}()
			p = &*(*struct_Sublist)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Sublist)(unsafe.Pointer(&aSub)))) + uintptr(iSub)*16))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			walMerge(aContent, p.aList, p.nList, &aMerge, &nMerge, aBuffer)
		}
		(*(*struct_Sublist)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Sublist)(unsafe.Pointer(&aSub)))) + uintptr(iSub)*16))).aList = aMerge
		(*(*struct_Sublist)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Sublist)(unsafe.Pointer(&aSub)))) + uintptr(iSub)*16))).nList = nMerge
	}
	for iSub++; iSub < uint32(int32(208/16)); iSub++ {
		if nList&int32(1<<iSub) != 0 {
			var p *struct_Sublist
			func() int {
				_ = 0
				return 0
			}()
			p = &*(*struct_Sublist)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Sublist)(unsafe.Pointer(&aSub)))) + uintptr(iSub)*16))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			walMerge(aContent, p.aList, p.nList, &aMerge, &nMerge, aBuffer)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	*pnList = nMerge
}
func walIteratorFree(p *struct_WalIterator) {
	sqlite3_free(unsafe.Pointer(p))
}
func walIteratorInit(pWal *struct_Wal, nBackfill uint32, pp **struct_WalIterator) int32 {
	var p *struct_WalIterator
	var nSegment int32
	var iLast uint32
	var nByte int64
	var i int32
	var aTmp *uint16
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	iLast = pWal.hdr.mxFrame
	nSegment = walFramePage(iLast) + 1
	nByte = int64(40 + uint(nSegment-1)*32 + uint(iLast)*2)
	p = (*struct_WalIterator)(sqlite3_malloc64(uint64(nByte)))
	if !(p != nil) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(p), 0, uint(nByte), __builtin_object_size(unsafe.Pointer(p), 0))
	p.nSegment = nSegment
	aTmp = (*uint16)(sqlite3_malloc64(uint64(2 * uint(func() uint32 {
		if iLast > uint32(4096) {
			return uint32(4096)
		} else {
			return iLast
		}
	}()))))
	if !(aTmp != nil) {
		rc = int32(7)
	}
	for i = walFramePage(nBackfill + uint32(1)); rc == 0 && i < nSegment; i++ {
		var sLoc struct_WalHashLoc
		rc = walHashGet(pWal, i, &sLoc)
		if rc == 0 {
			var j int32
			var nEntry int32
			var aIndex *uint16
			if i+1 == nSegment {
				nEntry = int32(iLast - sLoc.iZero)
			} else {
				nEntry = int32((uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(sLoc.aHash)))) - uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(sLoc.aPgno))))) * 4)
			}
			aIndex = &*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&*(*struct_WalSegment)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WalSegment)(unsafe.Pointer(&p.aSegment)))) + uintptr(p.nSegment)*32)))))) + uintptr(sLoc.iZero)*2))
			sLoc.iZero++
			for j = int32(0); j < nEntry; j++ {
				*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(aIndex)) + uintptr(j)*2)) = uint16(j)
			}
			walMergesort((*uint32)(unsafe.Pointer(sLoc.aPgno)), aTmp, aIndex, &nEntry)
			(*(*struct_WalSegment)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WalSegment)(unsafe.Pointer(&p.aSegment)))) + uintptr(i)*32))).iZero = int32(sLoc.iZero)
			(*(*struct_WalSegment)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WalSegment)(unsafe.Pointer(&p.aSegment)))) + uintptr(i)*32))).nEntry = nEntry
			(*(*struct_WalSegment)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WalSegment)(unsafe.Pointer(&p.aSegment)))) + uintptr(i)*32))).aIndex = aIndex
			(*(*struct_WalSegment)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WalSegment)(unsafe.Pointer(&p.aSegment)))) + uintptr(i)*32))).aPgno = (*uint32)(unsafe.Pointer(sLoc.aPgno))
		}
	}
	sqlite3_free(unsafe.Pointer(aTmp))
	if rc != 0 {
		walIteratorFree(p)
		p = (*struct_WalIterator)(nil)
	}
	*pp = p
	return rc
}
func walBusyLock(pWal *struct_Wal, xBusy func(unsafe.Pointer) int32, pBusyArg unsafe.Pointer, lockIdx int32, n int32) int32 {
	var rc int32
	for {
		rc = walLockExclusive(pWal, lockIdx, n)
		if !(xBusy != nil && rc == 5 && xBusy(pBusyArg) != 0) {
			break
		}
	}
	return rc
}
func walPagesize(pWal *struct_Wal) int32 {
	return int32(pWal.hdr.szPage)&65024 + int32(pWal.hdr.szPage)&1<<16
}
func walRestartHdr(pWal *struct_Wal, salt1 uint32) {
	var pInfo *struct_WalCkptInfo = walCkptInfo(pWal)
	var i int32
	var aSalt *uint32 = (*uint32)(unsafe.Pointer(&pWal.hdr.aSalt))
	pWal.nCkpt++
	pWal.hdr.mxFrame = uint32(0)
	sqlite3Put4byte((*uint8)(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aSalt)) + uintptr(0)*4)))), uint32(1)+sqlite3Get4byte((*uint8)(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aSalt)) + uintptr(0)*4))))))
	__builtin___memcpy_chk(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aSalt)))) + uintptr(1)*4))), unsafe.Pointer(&salt1), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aSalt)))) + uintptr(1)*4))), 0))
	walIndexWriteHdr(pWal)
	__atomic_store_n_u32(&pInfo.nBackfill, 0, uint32(0))
	pInfo.nBackfillAttempted = uint32(0)
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark)))) + uintptr(1)*4)) = uint32(0)
	for i = int32(2); i < 8-3; i++ {
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark)))) + uintptr(i)*4)) = uint32(4294967295)
	}
	func() int {
		_ = 0
		return 0
	}()
}
func walCheckpoint(pWal *struct_Wal, db *struct_sqlite3, eMode int32, xBusy func(unsafe.Pointer) int32, pBusyArg unsafe.Pointer, sync_flags int32, zBuf *uint8) int32 {
	var rc int32 = 0
	var szPage int32
	var pIter *struct_WalIterator = nil
	var iDbpage uint32 = uint32(0)
	var iFrame uint32 = uint32(0)
	var mxSafeFrame uint32
	var mxPage uint32
	var i int32
	var pInfo *struct_WalCkptInfo
	szPage = walPagesize(pWal)
	pInfo = walCkptInfo(pWal)
	if pInfo.nBackfill < pWal.hdr.mxFrame {
		func() int {
			_ = 0
			return 0
		}()
		mxSafeFrame = pWal.hdr.mxFrame
		mxPage = pWal.hdr.nPage
		for i = int32(1); i < 8-3; i++ {
			var y uint32 = __atomic_load_n_u32((*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark))))+uintptr(i)*4)), 0)
			if mxSafeFrame > y {
				func() int {
					_ = 0
					return 0
				}()
				rc = walBusyLock(pWal, xBusy, pBusyArg, 3+i, 1)
				if rc == 0 {
					var iMark uint32 = func() uint32 {
						if i == 1 {
							return mxSafeFrame
						} else {
							return 4294967295
						}
					}()
					__atomic_store_n_u32((*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark))))+uintptr(i)*4)), 0, iMark)
					walUnlockExclusive(pWal, 3+i, 1)
				} else if rc == 5 {
					mxSafeFrame = y
					xBusy = (func(unsafe.Pointer) int32)(nil)
				} else {
					goto walcheckpoint_out
				}
			}
		}
		if pInfo.nBackfill < mxSafeFrame {
			rc = walIteratorInit(pWal, pInfo.nBackfill, &pIter)
			func() int {
				_ = 0
				return 0
			}()
		}
		if pIter != nil && func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = walBusyLock(pWal, xBusy, pBusyArg, 3+0, 1)
			return *_cgo_addr
		}() == 0 {
			var nBackfill uint32 = pInfo.nBackfill
			pInfo.nBackfillAttempted = mxSafeFrame
			rc = sqlite3OsSync(pWal.pWalFd, sync_flags>>2&3)
			if rc == 0 {
				var nReq int64 = int64(mxPage) * int64(szPage)
				var nSize int64
				sqlite3OsFileControl(pWal.pDbFd, 39, nil)
				rc = sqlite3OsFileSize(pWal.pDbFd, &nSize)
				if rc == 0 && nSize < nReq {
					if nSize+int64(65536)+int64(pWal.hdr.mxFrame)*int64(szPage) < nReq {
						rc = sqlite3CorruptError(63070)
					} else {
						sqlite3OsFileControlHint(pWal.pDbFd, 5, unsafe.Pointer(&nReq))
					}
				}
			}
			for rc == 0 && 0 == walIteratorNext(pIter, &iDbpage, &iFrame) {
				var iOffset int64
				func() int {
					_ = 0
					return 0
				}()
				if __atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0) != 0 {
					rc = func() int32 {
						if int32(db.mallocFailed) != 0 {
							return 7
						} else {
							return 9
						}
					}()
					break
				}
				if iFrame <= nBackfill || iFrame > mxSafeFrame || iDbpage > mxPage {
					continue
				}
				iOffset = int64(32) + int64(iFrame-uint32(1))*int64(szPage+24) + int64(24)
				rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer(zBuf), szPage, iOffset)
				if rc != 0 {
					break
				}
				iOffset = int64(iDbpage-uint32(1)) * int64(szPage)
				rc = sqlite3OsWrite(pWal.pDbFd, unsafe.Pointer(zBuf), szPage, iOffset)
				if rc != 0 {
					break
				}
			}
			sqlite3OsFileControl(pWal.pDbFd, 37, nil)
			if rc == 0 {
				if mxSafeFrame == walIndexHdr(pWal).mxFrame {
					var szDb int64 = int64(pWal.hdr.nPage) * int64(szPage)
					rc = sqlite3OsTruncate(pWal.pDbFd, szDb)
					if rc == 0 {
						rc = sqlite3OsSync(pWal.pDbFd, sync_flags>>2&3)
					}
				}
				if rc == 0 {
					__atomic_store_n_u32(&pInfo.nBackfill, 0, mxSafeFrame)
				}
			}
			walUnlockExclusive(pWal, 3+0, 1)
		}
		if rc == 5 {
			rc = int32(0)
		}
	}
	if rc == 0 && eMode != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if pInfo.nBackfill < pWal.hdr.mxFrame {
			rc = int32(5)
		} else if eMode >= 2 {
			var salt1 uint32
			sqlite3_randomness(4, unsafe.Pointer(&salt1))
			func() int {
				_ = 0
				return 0
			}()
			rc = walBusyLock(pWal, xBusy, pBusyArg, 3+1, 8-3-1)
			if rc == 0 {
				if eMode == 3 {
					walRestartHdr(pWal, salt1)
					rc = sqlite3OsTruncate(pWal.pWalFd, int64(0))
				}
				walUnlockExclusive(pWal, 3+1, 8-3-1)
			}
		}
	}
walcheckpoint_out:
	walIteratorFree(pIter)
	return rc
}
func walLimitSize(pWal *struct_Wal, nMax int64) {
	var sz int64
	var rx int32
	sqlite3BeginBenignMalloc()
	rx = sqlite3OsFileSize(pWal.pWalFd, &sz)
	if rx == 0 && sz > nMax {
		rx = sqlite3OsTruncate(pWal.pWalFd, nMax)
	}
	sqlite3EndBenignMalloc()
	if rx != 0 {
		sqlite3_log(rx, (*int8)(unsafe.Pointer(&[26]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'l', 'i', 'm', 'i', 't', ' ', 'W', 'A', 'L', ' ', 's', 'i', 'z', 'e', ':', ' ', '%', 's', '\x00'})), pWal.zWalName)
	}
}
func sqlite3WalClose(pWal *struct_Wal, db *struct_sqlite3, sync_flags int32, nBuf int32, zBuf *uint8) int32 {
	var rc int32 = 0
	if pWal != nil {
		var isDelete int32 = 0
		if uintptr(unsafe.Pointer(zBuf)) != uintptr(unsafe.Pointer(nil)) && 0 == func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3OsLock(pWal.pDbFd, 4)
			return *_cgo_addr
		}() {
			if int32(pWal.exclusiveMode) == 0 {
				pWal.exclusiveMode = uint8(1)
			}
			rc = sqlite3WalCheckpoint(pWal, db, 0, nil, nil, sync_flags, nBuf, zBuf, nil, nil)
			if rc == 0 {
				var bPersist int32 = -1
				sqlite3OsFileControlHint(pWal.pDbFd, 10, unsafe.Pointer(&bPersist))
				if bPersist != 1 {
					isDelete = int32(1)
				} else if pWal.mxWalSize >= int64(0) {
					walLimitSize(pWal, int64(0))
				}
			}
		}
		walIndexClose(pWal, isDelete)
		sqlite3OsClose(pWal.pWalFd)
		if isDelete != 0 {
			sqlite3BeginBenignMalloc()
			sqlite3OsDelete(pWal.pVfs, pWal.zWalName, 0)
			sqlite3EndBenignMalloc()
		}
		sqlite3_free(unsafe.Pointer(pWal.apWiData))
		sqlite3_free(unsafe.Pointer(pWal))
	}
	return rc
}
func walIndexTryHdr(pWal *struct_Wal, pChanged *int32) int32 {
	var aCksum [2]uint32
	var h1 struct_WalIndexHdr
	var h2 struct_WalIndexHdr
	var aHdr *struct_WalIndexHdr
	func() int {
		_ = 0
		return 0
	}()
	aHdr = walIndexHdr(pWal)
	__builtin___memcpy_chk(unsafe.Pointer(&h1), unsafe.Pointer(&*(*struct_WalIndexHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(aHdr)) + uintptr(0)*48))), 48, __builtin_object_size(unsafe.Pointer(&h1), 0))
	walShmBarrier(pWal)
	__builtin___memcpy_chk(unsafe.Pointer(&h2), unsafe.Pointer(&*(*struct_WalIndexHdr)(unsafe.Pointer(uintptr(unsafe.Pointer(aHdr)) + uintptr(1)*48))), 48, __builtin_object_size(unsafe.Pointer(&h2), 0))
	if memcmp(unsafe.Pointer(&h1), unsafe.Pointer(&h2), 48) != 0 {
		return int32(1)
	}
	if int32(h1.isInit) == 0 {
		return int32(1)
	}
	walChecksumBytes(1, (*uint8)(unsafe.Pointer(&h1)), int32(48-8), nil, (*uint32)(unsafe.Pointer(&aCksum)))
	if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aCksum)))) + uintptr(0)*4)) != *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&h1.aCksum)))) + uintptr(0)*4)) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aCksum)))) + uintptr(1)*4)) != *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&h1.aCksum)))) + uintptr(1)*4)) {
		return int32(1)
	}
	if memcmp(unsafe.Pointer(&pWal.hdr), unsafe.Pointer(&h1), 48) != 0 {
		*pChanged = int32(1)
		__builtin___memcpy_chk(unsafe.Pointer(&pWal.hdr), unsafe.Pointer(&h1), 48, __builtin_object_size(unsafe.Pointer(&pWal.hdr), 0))
		pWal.szPage = uint32(int32(pWal.hdr.szPage)&65024 + int32(pWal.hdr.szPage)&1<<16)
	}
	return int32(0)
}
func walIndexReadHdr(pWal *struct_Wal, pChanged *int32) int32 {
	var rc int32
	var badHdr int32
	var page0 *uint32
	func() int {
		_ = 0
		return 0
	}()
	rc = walIndexPage(pWal, 0, &page0)
	if rc != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if rc == 8|5<<8 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pWal.bShmUnreliable = uint8(1)
			pWal.exclusiveMode = uint8(2)
			*pChanged = int32(1)
		} else {
			return rc
		}
	} else {
	}
	func() int {
		_ = 0
		return 0
	}()
	badHdr = func() int32 {
		if page0 != nil {
			return walIndexTryHdr(pWal, pChanged)
		} else {
			return 1
		}
	}()
	if badHdr != 0 {
		if int32(pWal.bShmUnreliable) == 0 && int32(pWal.readOnly)&2 != 0 {
			if 0 == func() (_cgo_ret int32) {
				_cgo_addr := &rc
				*_cgo_addr = walLockShared(pWal, 0)
				return *_cgo_addr
			}() {
				walUnlockShared(pWal, 0)
				rc = int32(8 | 1<<8)
			}
		} else {
			var bWriteLock int32 = int32(pWal.writeLock)
			if bWriteLock != 0 || 0 == func() (_cgo_ret int32) {
				_cgo_addr := &rc
				*_cgo_addr = walLockExclusive(pWal, 0, 1)
				return *_cgo_addr
			}() {
				pWal.writeLock = uint8(1)
				if 0 == func() (_cgo_ret int32) {
					_cgo_addr := &rc
					*_cgo_addr = walIndexPage(pWal, 0, &page0)
					return *_cgo_addr
				}() {
					badHdr = walIndexTryHdr(pWal, pChanged)
					if badHdr != 0 {
						rc = walIndexRecover(pWal)
						*pChanged = int32(1)
					}
				}
				if bWriteLock == 0 {
					pWal.writeLock = uint8(0)
					walUnlockExclusive(pWal, 0, 1)
				}
			}
		}
	}
	if badHdr == 0 && pWal.hdr.iVersion != uint32(3007000) {
		rc = sqlite3CantopenError(63419)
	}
	if pWal.bShmUnreliable != 0 {
		if rc != 0 {
			walIndexClose(pWal, 0)
			pWal.bShmUnreliable = uint8(0)
			func() int {
				_ = 0
				return 0
			}()
			if rc == 10|2<<8 {
				rc = int32(-1)
			}
		}
		pWal.exclusiveMode = uint8(0)
	}
	return rc
}
func walBeginShmUnreliable(pWal *struct_Wal, pChanged *int32) int32 {
	var szWal int64
	var iOffset int64
	var aBuf [32]uint8
	var aFrame *uint8 = nil
	var szFrame int32
	var aData *uint8
	var pDummy unsafe.Pointer
	var rc int32
	var aSaveCksum [2]uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = walLockShared(pWal, 3+0)
	if rc != 0 {
		if rc == 5 {
			rc = int32(-1)
		}
		goto begin_unreliable_shm_out
	}
	pWal.readLock = int16(0)
	rc = sqlite3OsShmMap(pWal.pDbFd, 0, int32(2*uint(4096*2)+uint(4096)*4), 0, &pDummy)
	func() int {
		_ = 0
		return 0
	}()
	if rc != 8|5<<8 {
		rc = func() int32 {
			if rc == 8 {
				return -1
			} else {
				return rc
			}
		}()
		goto begin_unreliable_shm_out
	}
	__builtin___memcpy_chk(unsafe.Pointer(&pWal.hdr), unsafe.Pointer(walIndexHdr(pWal)), 48, __builtin_object_size(unsafe.Pointer(&pWal.hdr), 0))
	rc = sqlite3OsFileSize(pWal.pWalFd, &szWal)
	if rc != 0 {
		goto begin_unreliable_shm_out
	}
	if szWal < int64(32) {
		*pChanged = int32(1)
		rc = func() int32 {
			if pWal.hdr.mxFrame == uint32(0) {
				return 0
			} else {
				return -1
			}
		}()
		goto begin_unreliable_shm_out
	}
	rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf))), 32, int64(0))
	if rc != 0 {
		goto begin_unreliable_shm_out
	}
	if memcmp(unsafe.Pointer(&pWal.hdr.aSalt), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aBuf)))) + uintptr(16)))), uint(8)) != 0 {
		rc = int32(-1)
		goto begin_unreliable_shm_out
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	szFrame = int32(pWal.szPage + uint32(24))
	aFrame = (*uint8)(sqlite3_malloc64(uint64(szFrame)))
	if uintptr(unsafe.Pointer(aFrame)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(7)
		goto begin_unreliable_shm_out
	}
	aData = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrame)) + uintptr(24)))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aSaveCksum)))) + uintptr(0)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aSaveCksum)))) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4))
	for iOffset = int64(32) + int64(pWal.hdr.mxFrame+uint32(1)-uint32(1))*int64(pWal.szPage+uint32(24)); iOffset+int64(szFrame) <= szWal; iOffset += int64(szFrame) {
		var pgno uint32
		var nTruncate uint32
		rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer(aFrame), szFrame, iOffset)
		if rc != 0 {
			break
		}
		if !(walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) != 0) {
			break
		}
		if nTruncate != 0 {
			rc = int32(-1)
			break
		}
	}
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aSaveCksum)))) + uintptr(0)*4))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aSaveCksum)))) + uintptr(1)*4))
begin_unreliable_shm_out:
	sqlite3_free(unsafe.Pointer(aFrame))
	if rc != 0 {
		var i int32
		for i = int32(0); i < pWal.nWiData; i++ {
			sqlite3_free(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(i)*8))))
			*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(i)*8)) = (*uint32)(nil)
		}
		pWal.bShmUnreliable = uint8(0)
		sqlite3WalEndReadTransaction(pWal)
		*pChanged = int32(1)
	}
	return rc
}
func walTryBeginRead(pWal *struct_Wal, pChanged *int32, useWal int32, cnt int32) int32 {
	var pInfo *struct_WalCkptInfo
	var mxReadMark uint32
	var mxI int32
	var i int32
	var rc int32 = 0
	var mxFrame uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if cnt > 5 {
		var nDelay int32 = 1
		if cnt > 100 {
			return int32(15)
		}
		if cnt >= 10 {
			nDelay = (cnt - 9) * (cnt - 9) * 39
		}
		sqlite3OsSleep(pWal.pVfs, nDelay)
	}
	if !(useWal != 0) {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pWal.bShmUnreliable) == 0 {
			rc = walIndexReadHdr(pWal, pChanged)
		}
		if rc == 5 {
			if uintptr(unsafe.Pointer(*(**uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pWal.apWiData)) + uintptr(0)*8)))) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(-1)
			} else if 0 == func() (_cgo_ret int32) {
				_cgo_addr := &rc
				*_cgo_addr = walLockShared(pWal, 2)
				return *_cgo_addr
			}() {
				walUnlockShared(pWal, 2)
				rc = int32(-1)
			} else if rc == 5 {
				rc = int32(5 | 1<<8)
			}
		}
		if rc != 0 {
			return rc
		} else if pWal.bShmUnreliable != 0 {
			return walBeginShmUnreliable(pWal, pChanged)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pInfo = walCkptInfo(pWal)
	if !(useWal != 0) && __atomic_load_n_u32(&pInfo.nBackfill, 0) == pWal.hdr.mxFrame {
		rc = walLockShared(pWal, 3+0)
		walShmBarrier(pWal)
		if rc == 0 {
			if memcmp(unsafe.Pointer(walIndexHdr(pWal)), unsafe.Pointer(&pWal.hdr), 48) != 0 {
				walUnlockShared(pWal, 3+0)
				return int32(-1)
			}
			pWal.readLock = int16(0)
			return int32(0)
		} else if rc != 5 {
			return rc
		}
	}
	mxReadMark = uint32(0)
	mxI = int32(0)
	mxFrame = pWal.hdr.mxFrame
	for i = int32(1); i < 8-3; i++ {
		var thisMark uint32 = __atomic_load_n_u32((*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark))))+uintptr(i)*4)), 0)
		if mxReadMark <= thisMark && thisMark <= mxFrame {
			func() int {
				_ = 0
				return 0
			}()
			mxReadMark = thisMark
			mxI = i
		}
	}
	if int32(pWal.readOnly)&2 == 0 && (mxReadMark < mxFrame || mxI == 0) {
		for i = int32(1); i < 8-3; i++ {
			rc = walLockExclusive(pWal, 3+i, 1)
			if rc == 0 {
				__atomic_store_n_u32((*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark))))+uintptr(i)*4)), 0, mxFrame)
				mxReadMark = mxFrame
				mxI = i
				walUnlockExclusive(pWal, 3+i, 1)
				break
			} else if rc != 5 {
				return rc
			}
		}
	}
	if mxI == 0 {
		func() int {
			_ = 0
			return 0
		}()
		return func() int32 {
			if rc == 5 {
				return -1
			} else {
				return 8 | 5<<8
			}
		}()
	}
	rc = walLockShared(pWal, 3+mxI)
	if rc != 0 {
		return func() int32 {
			if rc == 5 {
				return -1
			} else {
				return rc
			}
		}()
	}
	pWal.minFrame = __atomic_load_n_u32(&pInfo.nBackfill, 0) + uint32(1)
	walShmBarrier(pWal)
	if __atomic_load_n_u32((*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pInfo.aReadMark))))+uintptr(mxI)*4)), 0) != mxReadMark || memcmp(unsafe.Pointer(walIndexHdr(pWal)), unsafe.Pointer(&pWal.hdr), 48) != 0 {
		walUnlockShared(pWal, 3+mxI)
		return int32(-1)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		pWal.readLock = int16(mxI)
	}
	return rc
}
func sqlite3WalBeginReadTransaction(pWal *struct_Wal, pChanged *int32) int32 {
	var rc int32
	var cnt int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	for {
		rc = walTryBeginRead(pWal, pChanged, 0, func() (_cgo_ret int32) {
			_cgo_addr := &cnt
			*_cgo_addr++
			return *_cgo_addr
		}())
		if !(rc == -1) {
			break
		}
	}
	return rc
}
func sqlite3WalEndReadTransaction(pWal *struct_Wal) {
	sqlite3WalEndWriteTransaction(pWal)
	if int32(pWal.readLock) >= 0 {
		walUnlockShared(pWal, 3+int32(pWal.readLock))
		pWal.readLock = int16(-1)
	}
}
func sqlite3WalFindFrame(pWal *struct_Wal, pgno uint32, piRead *uint32) int32 {
	var iRead uint32 = uint32(0)
	var iLast uint32 = pWal.hdr.mxFrame
	var iHash int32
	var iMinHash int32
	func() int {
		_ = 0
		return 0
	}()
	if iLast == uint32(0) || int32(pWal.readLock) == 0 && int32(pWal.bShmUnreliable) == 0 {
		*piRead = uint32(0)
		return int32(0)
	}
	iMinHash = walFramePage(pWal.minFrame)
	for iHash = walFramePage(iLast); iHash >= iMinHash; iHash-- {
		var sLoc struct_WalHashLoc
		var iKey int32
		var nCollide int32
		var rc int32
		var iH uint32
		rc = walHashGet(pWal, iHash, &sLoc)
		if rc != 0 {
			return rc
		}
		nCollide = int32(4096 * 2)
		iKey = walHash(pgno)
		for func() (_cgo_ret uint32) {
			_cgo_addr := &iH
			*_cgo_addr = uint32(__atomic_load_n_u16(&*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aHash)) + uintptr(iKey)*2)), 0))
			return *_cgo_addr
		}() != uint32(0) {
			var iFrame uint32 = iH + sLoc.iZero
			if iFrame <= iLast && iFrame >= pWal.minFrame && *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(sLoc.aPgno)) + uintptr(iH-uint32(1))*4)) == pgno {
				func() int {
					_ = 0
					return 0
				}()
				iRead = iFrame
			}
			if func() (_cgo_ret int32) {
				_cgo_addr := &nCollide
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}() == 0 {
				return sqlite3CorruptError(64156)
			}
			iKey = walNextHash(iKey)
		}
		if iRead != 0 {
			break
		}
	}
	*piRead = iRead
	return int32(0)
}
func sqlite3WalReadFrame(pWal *struct_Wal, iRead uint32, nOut int32, pOut *uint8) int32 {
	var sz int32
	var iOffset int64
	sz = int32(pWal.hdr.szPage)
	sz = sz&65024 + sz&1<<16
	iOffset = int64(32) + int64(iRead-uint32(1))*int64(sz+24) + int64(24)
	return sqlite3OsRead(pWal.pWalFd, unsafe.Pointer(pOut), func() int32 {
		if nOut > sz {
			return sz
		} else {
			return nOut
		}
	}(), iOffset)
}
func sqlite3WalDbsize(pWal *struct_Wal) uint32 {
	if pWal != nil && int32(pWal.readLock) >= 0 {
		return pWal.hdr.nPage
	}
	return uint32(0)
}
func sqlite3WalBeginWriteTransaction(pWal *struct_Wal) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pWal.readOnly != 0 {
		return int32(8)
	}
	rc = walLockExclusive(pWal, 0, 1)
	if rc != 0 {
		return rc
	}
	pWal.writeLock = uint8(1)
	if memcmp(unsafe.Pointer(&pWal.hdr), unsafe.Pointer(walIndexHdr(pWal)), 48) != 0 {
		walUnlockExclusive(pWal, 0, 1)
		pWal.writeLock = uint8(0)
		rc = int32(5 | 2<<8)
	}
	return rc
}
func sqlite3WalEndWriteTransaction(pWal *struct_Wal) int32 {
	if pWal.writeLock != 0 {
		walUnlockExclusive(pWal, 0, 1)
		pWal.writeLock = uint8(0)
		pWal.iReCksum = uint32(0)
		pWal.truncateOnCommit = uint8(0)
	}
	return int32(0)
}
func sqlite3WalUndo(pWal *struct_Wal, xUndo func(unsafe.Pointer, uint32) int32, pUndoCtx unsafe.Pointer) int32 {
	var rc int32 = 0
	if pWal.writeLock != 0 {
		var iMax uint32 = pWal.hdr.mxFrame
		var iFrame uint32
		__builtin___memcpy_chk(unsafe.Pointer(&pWal.hdr), unsafe.Pointer(walIndexHdr(pWal)), 48, __builtin_object_size(unsafe.Pointer(&pWal.hdr), 0))
		for iFrame = pWal.hdr.mxFrame + uint32(1); rc == 0 && iFrame <= iMax; iFrame++ {
			func() int {
				_ = 0
				return 0
			}()
			rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame))
		}
		if iMax != pWal.hdr.mxFrame {
			walCleanupHash(pWal)
		}
	}
	return rc
}
func sqlite3WalSavepoint(pWal *struct_Wal, aWalData *uint32) {
	func() int {
		_ = 0
		return 0
	}()
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(0)*4)) = pWal.hdr.mxFrame
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(2)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(3)*4)) = pWal.nCkpt
}
func sqlite3WalSavepointUndo(pWal *struct_Wal, aWalData *uint32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(3)*4)) != pWal.nCkpt {
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(0)*4)) = uint32(0)
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(3)*4)) = pWal.nCkpt
	}
	if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(0)*4)) < pWal.hdr.mxFrame {
		pWal.hdr.mxFrame = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(0)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(1)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aWalData)) + uintptr(2)*4))
		walCleanupHash(pWal)
	}
	return rc
}
func walRestartLog(pWal *struct_Wal) int32 {
	var rc int32 = 0
	var cnt int32
	if int32(pWal.readLock) == 0 {
		var pInfo *struct_WalCkptInfo = walCkptInfo(pWal)
		func() int {
			_ = 0
			return 0
		}()
		if pInfo.nBackfill > uint32(0) {
			var salt1 uint32
			sqlite3_randomness(4, unsafe.Pointer(&salt1))
			rc = walLockExclusive(pWal, 3+1, 8-3-1)
			if rc == 0 {
				walRestartHdr(pWal, salt1)
				walUnlockExclusive(pWal, 3+1, 8-3-1)
			} else if rc != 5 {
				return rc
			}
		}
		walUnlockShared(pWal, 3+0)
		pWal.readLock = int16(-1)
		cnt = int32(0)
		for {
			var notUsed int32
			rc = walTryBeginRead(pWal, &notUsed, 1, func() (_cgo_ret int32) {
				_cgo_addr := &cnt
				*_cgo_addr++
				return *_cgo_addr
			}())
			if !(rc == -1) {
				break
			}
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	return rc
}

type struct_WalWriter struct {
	pWal       *struct_Wal
	pFd        *struct_sqlite3_file
	iSyncPoint int64
	syncFlags  int32
	szPage     int32
}
type WalWriter = struct_WalWriter

func walWriteToLog(p *struct_WalWriter, pContent unsafe.Pointer, iAmt int32, iOffset int64) int32 {
	var rc int32
	if iOffset < p.iSyncPoint && iOffset+int64(iAmt) >= p.iSyncPoint {
		var iFirstAmt int32 = int32(p.iSyncPoint - iOffset)
		rc = sqlite3OsWrite(p.pFd, pContent, iFirstAmt, iOffset)
		if rc != 0 {
			return rc
		}
		iOffset += int64(iFirstAmt)
		iAmt -= iFirstAmt
		pContent = unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(pContent))) + uintptr(iFirstAmt))))
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3OsSync(p.pFd, p.syncFlags&3)
		if iAmt == 0 || rc != 0 {
			return rc
		}
	}
	rc = sqlite3OsWrite(p.pFd, pContent, iAmt, iOffset)
	return rc
}
func walWriteOneFrame(p *struct_WalWriter, pPage *struct_PgHdr, nTruncate int32, iOffset int64) int32 {
	var rc int32
	var pData unsafe.Pointer
	var aFrame [24]uint8
	pData = pPage.pData
	walEncodeFrame(p.pWal, pPage.pgno, uint32(nTruncate), (*uint8)(pData), (*uint8)(unsafe.Pointer(&aFrame)))
	rc = walWriteToLog(p, unsafe.Pointer((*uint8)(unsafe.Pointer(&aFrame))), int32(24), iOffset)
	if rc != 0 {
		return rc
	}
	rc = walWriteToLog(p, pData, p.szPage, int64(uint64(iOffset)+uint64(24)))
	return rc
}
func walRewriteChecksums(pWal *struct_Wal, iLast uint32) int32 {
	var szPage int32 = int32(pWal.szPage)
	var rc int32 = 0
	var aBuf *uint8
	var aFrame [24]uint8
	var iRead uint32
	var iCksumOff int64
	aBuf = (*uint8)(sqlite3_malloc(szPage + 24))
	if uintptr(unsafe.Pointer(aBuf)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pWal.iReCksum == uint32(1) {
		iCksumOff = int64(24)
	} else {
		iCksumOff = int64(32) + int64(pWal.iReCksum-uint32(1)-uint32(1))*int64(szPage+24) + int64(16)
	}
	rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer(aBuf), int32(4*uint(2)), iCksumOff)
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4)) = sqlite3Get4byte(aBuf)
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4)) = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aBuf)) + uintptr(4))))
	iRead = pWal.iReCksum
	pWal.iReCksum = uint32(0)
	for ; rc == 0 && iRead <= iLast; iRead++ {
		var iOff int64 = int64(32) + int64(iRead-uint32(1))*int64(szPage+24)
		rc = sqlite3OsRead(pWal.pWalFd, unsafe.Pointer(aBuf), szPage+24, iOff)
		if rc == 0 {
			var iPgno uint32
			var nDbSize uint32
			iPgno = sqlite3Get4byte(aBuf)
			nDbSize = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aBuf)) + uintptr(4))))
			walEncodeFrame(pWal, iPgno, nDbSize, &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aBuf)) + uintptr(24))), (*uint8)(unsafe.Pointer(&aFrame)))
			rc = sqlite3OsWrite(pWal.pWalFd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aFrame))), int32(24), iOff)
		}
	}
	sqlite3_free(unsafe.Pointer(aBuf))
	return rc
}
func sqlite3WalFrames(pWal *struct_Wal, szPage int32, pList *struct_PgHdr, nTruncate uint32, isCommit int32, sync_flags int32) int32 {
	var rc int32
	var iFrame uint32
	var p *struct_PgHdr
	var pLast *struct_PgHdr = nil
	var nExtra int32 = 0
	var szFrame int32
	var iOffset int64
	var w struct_WalWriter
	var iFirst uint32 = uint32(0)
	var pLive *struct_WalIndexHdr
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pLive = (*struct_WalIndexHdr)(unsafe.Pointer(walIndexHdr(pWal)))
	if memcmp(unsafe.Pointer(&pWal.hdr), unsafe.Pointer(pLive), 48) != 0 {
		iFirst = pLive.mxFrame + uint32(1)
	}
	if 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = walRestartLog(pWal)
		return *_cgo_addr
	}() {
		return rc
	}
	iFrame = pWal.hdr.mxFrame
	if iFrame == uint32(0) {
		var aWalHdr [32]uint8
		var aCksum [2]uint32
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(0))), uint32(931071618|0))
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(4))), uint32(3007000))
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(8))), uint32(szPage))
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(12))), pWal.nCkpt)
		if pWal.nCkpt == uint32(0) {
			sqlite3_randomness(8, unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aSalt))))
		}
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(16)))), unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aSalt))), uint(8), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(16)))), 0))
		walChecksumBytes(1, (*uint8)(unsafe.Pointer(&aWalHdr)), 32-2*4, nil, (*uint32)(unsafe.Pointer(&aCksum)))
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(24))), *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aCksum)))) + uintptr(0)*4)))
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr)))) + uintptr(28))), *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aCksum)))) + uintptr(1)*4)))
		pWal.szPage = uint32(szPage)
		pWal.hdr.bigEndCksum = uint8(0)
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(0)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aCksum)))) + uintptr(0)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pWal.hdr.aFrameCksum)))) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aCksum)))) + uintptr(1)*4))
		pWal.truncateOnCommit = uint8(1)
		rc = sqlite3OsWrite(pWal.pWalFd, unsafe.Pointer((*uint8)(unsafe.Pointer(&aWalHdr))), int32(32), int64(0))
		if rc != 0 {
			return rc
		}
		if pWal.syncHeader != 0 {
			rc = sqlite3OsSync(pWal.pWalFd, sync_flags>>2&3)
			if rc != 0 {
				return rc
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	w.pWal = pWal
	w.pFd = pWal.pWalFd
	w.iSyncPoint = int64(0)
	w.syncFlags = sync_flags
	w.szPage = szPage
	iOffset = int64(32) + int64(iFrame+uint32(1)-uint32(1))*int64(szPage+24)
	szFrame = szPage + 24
	for p = pList; p != nil; p = p.pDirty {
		var nDbSize int32
		if iFirst != 0 && (p.pDirty != nil || isCommit == 0) {
			var iWrite uint32 = uint32(0)
			sqlite3WalFindFrame(pWal, p.pgno, &iWrite)
			func() int {
				_ = 0
				return 0
			}()
			if iWrite >= iFirst {
				var iOff int64 = int64(32) + int64(iWrite-uint32(1))*int64(szPage+24) + int64(24)
				var pData unsafe.Pointer
				if pWal.iReCksum == uint32(0) || iWrite < pWal.iReCksum {
					pWal.iReCksum = iWrite
				}
				pData = p.pData
				rc = sqlite3OsWrite(pWal.pWalFd, pData, szPage, iOff)
				if rc != 0 {
					return rc
				}
				p.flags &= uint16(^64)
				continue
			}
		}
		iFrame++
		func() int {
			_ = 0
			return 0
		}()
		nDbSize = int32(func() uint32 {
			if isCommit != 0 && uintptr(unsafe.Pointer(p.pDirty)) == uintptr(unsafe.Pointer(nil)) {
				return nTruncate
			} else {
				return uint32(0)
			}
		}())
		rc = walWriteOneFrame(&w, p, nDbSize, iOffset)
		if rc != 0 {
			return rc
		}
		pLast = p
		iOffset += int64(szFrame)
		p.flags |= uint16(64)
	}
	if isCommit != 0 && pWal.iReCksum != 0 {
		rc = walRewriteChecksums(pWal, iFrame)
		if rc != 0 {
			return rc
		}
	}
	if isCommit != 0 && sync_flags&3 != 0 {
		var bSync int32 = 1
		if pWal.padToSectorBoundary != 0 {
			var sectorSize int32 = sqlite3SectorSize(pWal.pWalFd)
			w.iSyncPoint = (iOffset + int64(sectorSize) - int64(1)) / int64(sectorSize) * int64(sectorSize)
			bSync = func() int32 {
				if w.iSyncPoint == iOffset {
					return 1
				} else {
					return 0
				}
			}()
			for iOffset < w.iSyncPoint {
				rc = walWriteOneFrame(&w, pLast, int32(nTruncate), iOffset)
				if rc != 0 {
					return rc
				}
				iOffset += int64(szFrame)
				nExtra++
				func() int {
					_ = 0
					return 0
				}()
			}
		}
		if bSync != 0 {
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3OsSync(w.pFd, sync_flags&3)
		}
	}
	if isCommit != 0 && int32(pWal.truncateOnCommit) != 0 && pWal.mxWalSize >= int64(0) {
		var sz int64 = pWal.mxWalSize
		if int64(32)+int64(iFrame+uint32(nExtra)+uint32(1)-uint32(1))*int64(szPage+24) > pWal.mxWalSize {
			sz = int64(32) + int64(iFrame+uint32(nExtra)+uint32(1)-uint32(1))*int64(szPage+24)
		}
		walLimitSize(pWal, sz)
		pWal.truncateOnCommit = uint8(0)
	}
	iFrame = pWal.hdr.mxFrame
	for p = pList; p != nil && rc == 0; p = p.pDirty {
		if int32(p.flags)&64 == 0 {
			continue
		}
		iFrame++
		rc = walIndexAppend(pWal, iFrame, p.pgno)
	}
	func() int {
		_ = 0
		return 0
	}()
	for rc == 0 && nExtra > 0 {
		iFrame++
		nExtra--
		rc = walIndexAppend(pWal, iFrame, pLast.pgno)
	}
	if rc == 0 {
		pWal.hdr.szPage = uint16(szPage&65280 | szPage>>16)
		pWal.hdr.mxFrame = iFrame
		if isCommit != 0 {
			pWal.hdr.iChange++
			pWal.hdr.nPage = nTruncate
		}
		if isCommit != 0 {
			walIndexWriteHdr(pWal)
			pWal.iCallback = iFrame
		}
	}
	return rc
}
func sqlite3WalCheckpoint(pWal *struct_Wal, db *struct_sqlite3, eMode int32, xBusy func(unsafe.Pointer) int32, pBusyArg unsafe.Pointer, sync_flags int32, nBuf int32, zBuf *uint8, pnLog *int32, pnCkpt *int32) int32 {
	var rc int32
	var isChanged int32 = 0
	var eMode2 int32 = eMode
	var xBusy2 func(unsafe.Pointer) int32 = xBusy
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pWal.readOnly != 0 {
		return int32(8)
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = walLockExclusive(pWal, 1, 1)
	if rc == 0 {
		pWal.ckptLock = uint8(1)
		if eMode != 0 {
			rc = walBusyLock(pWal, xBusy2, pBusyArg, 0, 1)
			if rc == 0 {
				pWal.writeLock = uint8(1)
			} else if rc == 5 {
				eMode2 = int32(0)
				xBusy2 = (func(unsafe.Pointer) int32)(nil)
				rc = int32(0)
			}
		}
	}
	if rc == 0 {
		rc = walIndexReadHdr(pWal, &isChanged)
		func() int {
			_ = 0
			return 0
		}()
		if isChanged != 0 && pWal.pDbFd.pMethods.iVersion >= 3 {
			sqlite3OsUnfetch(pWal.pDbFd, int64(0), nil)
		}
	}
	if rc == 0 {
		if pWal.hdr.mxFrame != 0 && walPagesize(pWal) != nBuf {
			rc = sqlite3CorruptError(64875)
		} else {
			rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf)
		}
		if rc == 0 || rc == 5 {
			if pnLog != nil {
				*pnLog = int32(pWal.hdr.mxFrame)
			}
			if pnCkpt != nil {
				*pnCkpt = int32(walCkptInfo(pWal).nBackfill)
			}
		}
	}
	if isChanged != 0 {
		__builtin___memset_chk(unsafe.Pointer(&pWal.hdr), 0, 48, __builtin_object_size(unsafe.Pointer(&pWal.hdr), 0))
	}
	sqlite3WalEndWriteTransaction(pWal)
	if pWal.ckptLock != 0 {
		walUnlockExclusive(pWal, 1, 1)
		pWal.ckptLock = uint8(0)
	}
	return func() int32 {
		if rc == 0 && eMode != eMode2 {
			return 5
		} else {
			return rc
		}
	}()
}
func sqlite3WalCallback(pWal *struct_Wal) int32 {
	var ret uint32 = uint32(0)
	if pWal != nil {
		ret = pWal.iCallback
		pWal.iCallback = uint32(0)
	}
	return int32(ret)
}
func sqlite3WalExclusiveMode(pWal *struct_Wal, op int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if op == 0 {
		if int32(pWal.exclusiveMode) != 0 {
			pWal.exclusiveMode = uint8(0)
			if walLockShared(pWal, 3+int32(pWal.readLock)) != 0 {
				pWal.exclusiveMode = uint8(1)
			}
			rc = func() int32 {
				if int32(pWal.exclusiveMode) == 0 {
					return 1
				} else {
					return 0
				}
			}()
		} else {
			rc = int32(0)
		}
	} else if op > 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		walUnlockShared(pWal, 3+int32(pWal.readLock))
		pWal.exclusiveMode = uint8(1)
		rc = int32(1)
	} else {
		rc = func() int32 {
			if int32(pWal.exclusiveMode) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	return rc
}
func sqlite3WalHeapMemory(pWal *struct_Wal) int32 {
	return func() int32 {
		if pWal != nil && int32(pWal.exclusiveMode) == 2 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3WalFile(pWal *struct_Wal) *struct_sqlite3_file {
	return pWal.pWalFd
}

type MemPage = struct_MemPage
type BtLock = struct_BtLock
type CellInfo = struct_CellInfo
type struct_MemPage struct {
	isInit          uint8
	intKey          uint8
	intKeyLeaf      uint8
	pgno            uint32
	leaf            uint8
	hdrOffset       uint8
	childPtrSize    uint8
	max1bytePayload uint8
	nOverflow       uint8
	maxLocal        uint16
	minLocal        uint16
	cellOffset      uint16
	nFree           int32
	nCell           uint16
	maskPage        uint16
	aiOvfl          [4]uint16
	apOvfl          [4]*uint8
	pBt             *struct_BtShared
	aData           *uint8
	aDataEnd        *uint8
	aCellIdx        *uint8
	aDataOfst       *uint8
	pDbPage         *struct_PgHdr
	xCellSize       func(*struct_MemPage, *uint8) uint16
	xParseCell      func(*struct_MemPage, *uint8, *struct_CellInfo)
}
type struct_BtLock struct {
	pBtree *struct_Btree
	iTable uint32
	eLock  uint8
	pNext  *struct_BtLock
}
type struct_Btree struct {
	db             *struct_sqlite3
	pBt            *struct_BtShared
	inTrans        uint8
	sharable       uint8
	locked         uint8
	hasIncrblobCur uint8
	wantToLock     int32
	nBackup        int32
	iBDataVersion  uint32
	pNext          *struct_Btree
	pPrev          *struct_Btree
	lock           struct_BtLock
}
type struct_BtShared struct {
	pPager          *struct_Pager
	db              *struct_sqlite3
	pCursor         *struct_BtCursor
	pPage1          *struct_MemPage
	openFlags       uint8
	autoVacuum      uint8
	incrVacuum      uint8
	bDoTruncate     uint8
	inTransaction   uint8
	max1bytePayload uint8
	nReserveWanted  uint8
	btsFlags        uint16
	maxLocal        uint16
	minLocal        uint16
	maxLeaf         uint16
	minLeaf         uint16
	pageSize        uint32
	usableSize      uint32
	nTransaction    int32
	nPage           uint32
	pSchema         unsafe.Pointer
	xFreeSchema     func(unsafe.Pointer)
	mutex           *struct_sqlite3_mutex
	pHasContent     *struct_Bitvec
	nRef            int32
	pNext           *struct_BtShared
	pLock           *struct_BtLock
	pWriter         *struct_Btree
	pTmpSpace       *uint8
	nPreformatSize  int32
}
type struct_CellInfo struct {
	nKey     int64
	pPayload *uint8
	nPayload uint32
	nLocal   uint16
	nSize    uint16
}
type struct_BtCursor struct {
	eState        uint8
	curFlags      uint8
	curPagerFlags uint8
	hints         uint8
	skipNext      int32
	pBtree        *struct_Btree
	aOverflow     *uint32
	pKey          unsafe.Pointer
	pBt           *struct_BtShared
	pNext         *struct_BtCursor
	info          struct_CellInfo
	nKey          int64
	pgnoRoot      uint32
	iPage         int8
	curIntKey     uint8
	ix            uint16
	aiIdx         [19]uint16
	pKeyInfo      *struct_KeyInfo
	pPage         *struct_MemPage
	apPage        [19]*struct_MemPage
}
type IntegrityCk = struct_IntegrityCk
type struct_IntegrityCk struct {
	pBt       *struct_BtShared
	pPager    *struct_Pager
	aPgRef    *uint8
	nPage     uint32
	mxErr     int32
	nErr      int32
	bOomFault int32
	zPfx      *int8
	v1        uint32
	v2        int32
	errMsg    struct_sqlite3_str
	heap      *uint32
	db        *struct_sqlite3
}

func lockBtreeMutex(p *struct_Btree) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(p.pBt.mutex)
	p.pBt.db = p.db
	p.locked = uint8(1)
}
func unlockBtreeMutex(p *struct_Btree) {
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_leave(pBt.mutex)
	p.locked = uint8(0)
}
func sqlite3BtreeEnter(p *struct_Btree) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(p.sharable != 0) {
		return
	}
	p.wantToLock++
	if p.locked != 0 {
		return
	}
	btreeLockCarefully(p)
}
func btreeLockCarefully(p *struct_Btree) {
	var pLater *struct_Btree
	if sqlite3_mutex_try(p.pBt.mutex) == 0 {
		p.pBt.db = p.db
		p.locked = uint8(1)
		return
	}
	for pLater = p.pNext; pLater != nil; pLater = pLater.pNext {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pLater.locked != 0 {
			unlockBtreeMutex(pLater)
		}
	}
	lockBtreeMutex(p)
	for pLater = p.pNext; pLater != nil; pLater = pLater.pNext {
		if pLater.wantToLock != 0 {
			lockBtreeMutex(pLater)
		}
	}
}
func sqlite3BtreeLeave(p *struct_Btree) {
	func() int {
		_ = 0
		return 0
	}()
	if p.sharable != 0 {
		func() int {
			_ = 0
			return 0
		}()
		p.wantToLock--
		if p.wantToLock == 0 {
			unlockBtreeMutex(p)
		}
	}
}
func btreeEnterAll(db *struct_sqlite3) {
	var i int32
	var skipOk int32 = 1
	var p *struct_Btree
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nDb; i++ {
		p = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if p != nil && int32(p.sharable) != 0 {
			sqlite3BtreeEnter(p)
			skipOk = int32(0)
		}
	}
	db.noSharedCache = uint8(skipOk)
}
func sqlite3BtreeEnterAll(db *struct_sqlite3) {
	if int32(db.noSharedCache) == 0 {
		btreeEnterAll(db)
	}
}
func btreeLeaveAll(db *struct_sqlite3) {
	var i int32
	var p *struct_Btree
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nDb; i++ {
		p = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if p != nil {
			sqlite3BtreeLeave(p)
		}
	}
}
func sqlite3BtreeLeaveAll(db *struct_sqlite3) {
	if int32(db.noSharedCache) == 0 {
		btreeLeaveAll(db)
	}
}
func sqlite3BtreeEnterCursor(pCur *struct_BtCursor) {
	sqlite3BtreeEnter(pCur.pBtree)
}
func sqlite3BtreeLeaveCursor(pCur *struct_BtCursor) {
	sqlite3BtreeLeave(pCur.pBtree)
}

var zMagicHeader [16]int8 = [16]int8{'S', 'Q', 'L', 'i', 't', 'e', ' ', 'f', 'o', 'r', 'm', 'a', 't', ' ', '3', '\x00'}
var sqlite3SharedCacheList *struct_BtShared = nil

func sqlite3_enable_shared_cache(enable int32) int32 {
	sqlite3Config.sharedCacheEnabled = enable
	return int32(0)
}
func querySharedCacheTableLock(p *struct_Btree, iTab uint32, eLock uint8) int32 {
	var pBt *struct_BtShared = p.pBt
	var pIter *struct_BtLock
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(p.sharable != 0) {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pBt.pWriter)) != uintptr(unsafe.Pointer(p)) && int32(pBt.btsFlags)&64 != 0 {
		return int32(6 | 1<<8)
	}
	for pIter = pBt.pLock; pIter != nil; pIter = pIter.pNext {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pIter.pBtree)) != uintptr(unsafe.Pointer(p)) && pIter.iTable == iTab && int32(pIter.eLock) != int32(eLock) {
			if int32(eLock) == 2 {
				func() int {
					_ = 0
					return 0
				}()
				pBt.btsFlags |= uint16(128)
			}
			return int32(6 | 1<<8)
		}
	}
	return int32(0)
}
func setSharedCacheTableLock(p *struct_Btree, iTable uint32, eLock uint8) int32 {
	var pBt *struct_BtShared = p.pBt
	var pLock *struct_BtLock = nil
	var pIter *struct_BtLock
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for pIter = pBt.pLock; pIter != nil; pIter = pIter.pNext {
		if pIter.iTable == iTable && uintptr(unsafe.Pointer(pIter.pBtree)) == uintptr(unsafe.Pointer(p)) {
			pLock = pIter
			break
		}
	}
	if !(pLock != nil) {
		pLock = (*struct_BtLock)(sqlite3MallocZero(uint64(24)))
		if !(pLock != nil) {
			return int32(7)
		}
		pLock.iTable = iTable
		pLock.pBtree = p
		pLock.pNext = pBt.pLock
		pBt.pLock = pLock
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(eLock) > int32(pLock.eLock) {
		pLock.eLock = eLock
	}
	return int32(0)
}
func clearAllSharedCacheTableLocks(p *struct_Btree) {
	var pBt *struct_BtShared = p.pBt
	var ppIter **struct_BtLock = &pBt.pLock
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for *ppIter != nil {
		var pLock *struct_BtLock = *ppIter
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pLock.pBtree)) == uintptr(unsafe.Pointer(p)) {
			*ppIter = pLock.pNext
			func() int {
				_ = 0
				return 0
			}()
			if pLock.iTable != uint32(1) {
				sqlite3_free(unsafe.Pointer(pLock))
			}
		} else {
			ppIter = &pLock.pNext
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pBt.pWriter)) == uintptr(unsafe.Pointer(p)) {
		pBt.pWriter = (*struct_Btree)(nil)
		pBt.btsFlags &= uint16(^(64 | 128))
	} else if pBt.nTransaction == 2 {
		pBt.btsFlags &= uint16(^128)
	}
}
func downgradeAllSharedCacheTableLocks(p *struct_Btree) {
	var pBt *struct_BtShared = p.pBt
	if uintptr(unsafe.Pointer(pBt.pWriter)) == uintptr(unsafe.Pointer(p)) {
		var pLock *struct_BtLock
		pBt.pWriter = (*struct_Btree)(nil)
		pBt.btsFlags &= uint16(^(64 | 128))
		for pLock = pBt.pLock; pLock != nil; pLock = pLock.pNext {
			func() int {
				_ = 0
				return 0
			}()
			pLock.eLock = uint8(1)
		}
	}
}
func invalidateAllOverflowCache(pBt *struct_BtShared) {
	var p *struct_BtCursor
	func() int {
		_ = 0
		return 0
	}()
	for p = pBt.pCursor; p != nil; p = p.pNext {
		p.curFlags &= uint8(^4)
	}
}
func invalidateIncrblobCursors(pBtree *struct_Btree, pgnoRoot uint32, iRow int64, isClearTable int32) {
	var p *struct_BtCursor
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pBtree.hasIncrblobCur = uint8(0)
	for p = pBtree.pBt.pCursor; p != nil; p = p.pNext {
		if int32(p.curFlags)&16 != 0 {
			pBtree.hasIncrblobCur = uint8(1)
			if p.pgnoRoot == pgnoRoot && (isClearTable != 0 || p.info.nKey == iRow) {
				p.eState = uint8(1)
			}
		}
	}
}
func btreeSetHasContent(pBt *struct_BtShared, pgno uint32) int32 {
	var rc int32 = 0
	if !(pBt.pHasContent != nil) {
		func() int {
			_ = 0
			return 0
		}()
		pBt.pHasContent = sqlite3BitvecCreate(pBt.nPage)
		if !(pBt.pHasContent != nil) {
			rc = int32(7)
		}
	}
	if rc == 0 && pgno <= sqlite3BitvecSize(pBt.pHasContent) {
		rc = sqlite3BitvecSet(pBt.pHasContent, pgno)
	}
	return rc
}
func btreeGetHasContent(pBt *struct_BtShared, pgno uint32) int32 {
	var p *struct_Bitvec = pBt.pHasContent
	return func() int32 {
		if p != nil && (pgno > sqlite3BitvecSize(p) || sqlite3BitvecTestNotNull(p, pgno) != 0) {
			return 1
		} else {
			return 0
		}
	}()
}
func btreeClearHasContent(pBt *struct_BtShared) {
	sqlite3BitvecDestroy(pBt.pHasContent)
	pBt.pHasContent = (*struct_Bitvec)(nil)
}
func btreeReleaseAllCursorPages(pCur *struct_BtCursor) {
	var i int32
	if int32(pCur.iPage) >= 0 {
		for i = int32(0); i < int32(pCur.iPage); i++ {
			releasePageNotNull(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(i)*8)))
		}
		releasePageNotNull(pCur.pPage)
		pCur.iPage = int8(-1)
	}
}
func saveCursorKey(pCur *struct_BtCursor) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pCur.curIntKey != 0 {
		pCur.nKey = sqlite3BtreeIntegerKey(pCur)
	} else {
		var pKey unsafe.Pointer
		pCur.nKey = int64(sqlite3BtreePayloadSize(pCur))
		pKey = sqlite3Malloc(uint64(pCur.nKey + int64(9) + int64(8)))
		if pKey != nil {
			rc = sqlite3BtreePayload(pCur, uint32(0), uint32(int32(pCur.nKey)), pKey)
			if rc == 0 {
				__builtin___memset_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pKey)))+uintptr(pCur.nKey)))), 0, uint(9+8), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pKey)))+uintptr(pCur.nKey)))), 0))
				pCur.pKey = pKey
			} else {
				sqlite3_free(pKey)
			}
		} else {
			rc = int32(7)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func saveCursorPosition(pCur *struct_BtCursor) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.curFlags)&64 != 0 {
		return int32(19 | 11<<8)
	}
	if int32(pCur.eState) == 2 {
		pCur.eState = uint8(0)
	} else {
		pCur.skipNext = int32(0)
	}
	rc = saveCursorKey(pCur)
	if rc == 0 {
		btreeReleaseAllCursorPages(pCur)
		pCur.eState = uint8(3)
	}
	pCur.curFlags &= uint8(^(2 | 4 | 8))
	return rc
}
func saveAllCursors(pBt *struct_BtShared, iRoot uint32, pExcept *struct_BtCursor) int32 {
	var p *struct_BtCursor
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for p = pBt.pCursor; p != nil; p = p.pNext {
		if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(pExcept)) && (uint32(0) == iRoot || p.pgnoRoot == iRoot) {
			break
		}
	}
	if p != nil {
		return saveCursorsOnList(p, iRoot, pExcept)
	}
	if pExcept != nil {
		pExcept.curFlags &= uint8(^32)
	}
	return int32(0)
}
func saveCursorsOnList(p *struct_BtCursor, iRoot uint32, pExcept *struct_BtCursor) int32 {
	for {
		if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(pExcept)) && (uint32(0) == iRoot || p.pgnoRoot == iRoot) {
			if int32(p.eState) == 0 || int32(p.eState) == 2 {
				var rc int32 = saveCursorPosition(p)
				if 0 != rc {
					return rc
				}
			} else {
				btreeReleaseAllCursorPages(p)
			}
		}
		p = p.pNext
		if !(p != nil) {
			break
		}
	}
	return int32(0)
}
func sqlite3BtreeClearCursor(pCur *struct_BtCursor) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_free(pCur.pKey)
	pCur.pKey = unsafe.Pointer(nil)
	pCur.eState = uint8(1)
}
func btreeMoveto(pCur *struct_BtCursor, pKey unsafe.Pointer, nKey int64, bias int32, pRes *int32) int32 {
	var rc int32
	var pIdxKey *struct_UnpackedRecord
	if pKey != nil {
		var pKeyInfo *struct_KeyInfo = pCur.pKeyInfo
		func() int {
			_ = 0
			return 0
		}()
		pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo)
		if uintptr(unsafe.Pointer(pIdxKey)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		sqlite3VdbeRecordUnpack(pKeyInfo, int32(nKey), pKey, pIdxKey)
		if int32(pIdxKey.nField) == 0 || int32(pIdxKey.nField) > int32(pKeyInfo.nAllField) {
			rc = sqlite3CorruptError(66984)
		} else {
			rc = sqlite3BtreeIndexMoveto(pCur, pIdxKey, pRes)
		}
		sqlite3DbFree(pCur.pKeyInfo.db, unsafe.Pointer(pIdxKey))
	} else {
		pIdxKey = (*struct_UnpackedRecord)(nil)
		rc = sqlite3BtreeTableMoveto(pCur, nKey, bias, pRes)
	}
	return rc
}
func btreeRestoreCursorPosition(pCur *struct_BtCursor) int32 {
	var rc int32
	var skipNext int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.eState) == 4 {
		return pCur.skipNext
	}
	pCur.eState = uint8(1)
	if sqlite3FaultSim(410) != 0 {
		rc = int32(10)
	} else {
		rc = btreeMoveto(pCur, pCur.pKey, pCur.nKey, 0, &skipNext)
	}
	if rc == 0 {
		sqlite3_free(pCur.pKey)
		pCur.pKey = unsafe.Pointer(nil)
		func() int {
			_ = 0
			return 0
		}()
		if skipNext != 0 {
			pCur.skipNext = skipNext
		}
		if pCur.skipNext != 0 && int32(pCur.eState) == 0 {
			pCur.eState = uint8(2)
		}
	}
	return rc
}
func sqlite3BtreeCursorHasMoved(pCur *struct_BtCursor) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if 0 != int32(*(*uint8)(unsafe.Pointer(pCur))) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3BtreeFakeValidCursor() *struct_BtCursor {
	var fakeCursor uint8 = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	return (*struct_BtCursor)(unsafe.Pointer(&fakeCursor))
}
func sqlite3BtreeCursorRestore(pCur *struct_BtCursor, pDifferentRow *int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = func() int32 {
		if int32(pCur.eState) >= 3 {
			return btreeRestoreCursorPosition(pCur)
		} else {
			return 0
		}
	}()
	if rc != 0 {
		*pDifferentRow = int32(1)
		return rc
	}
	if int32(pCur.eState) != 0 {
		*pDifferentRow = int32(1)
	} else {
		*pDifferentRow = int32(0)
	}
	return int32(0)
}
func sqlite3BtreeCursorHintFlags(pCur *struct_BtCursor, x uint32) {
	func() int {
		_ = 0
		return 0
	}()
	pCur.hints = uint8(x)
}
func ptrmapPageno(pBt *struct_BtShared, pgno uint32) uint32 {
	var nPagesPerMapPage int32
	var iPtrMap uint32
	var ret uint32
	func() int {
		_ = 0
		return 0
	}()
	if pgno < uint32(2) {
		return uint32(0)
	}
	nPagesPerMapPage = int32(pBt.usableSize/uint32(5) + uint32(1))
	iPtrMap = (pgno - uint32(2)) / uint32(nPagesPerMapPage)
	ret = iPtrMap*uint32(nPagesPerMapPage) + uint32(2)
	if ret == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
		ret++
	}
	return ret
}
func ptrmapPut(pBt *struct_BtShared, key uint32, eType uint8, parent uint32, pRC *int32) {
	var pDbPage *struct_PgHdr
	var pPtrmap *uint8
	var iPtrmap uint32
	var offset int32
	var rc int32
	if *pRC != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if key == uint32(0) {
		*pRC = sqlite3CorruptError(67165)
		return
	}
	iPtrmap = ptrmapPageno(pBt, key)
	rc = sqlite3PagerGet(pBt.pPager, iPtrmap, &pDbPage, 0)
	if rc != 0 {
		*pRC = rc
		return
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(sqlite3PagerGetExtra(pDbPage)))) + uintptr(0)))) != 0 {
		*pRC = sqlite3CorruptError(67178)
		goto ptrmap_exit
	}
	offset = int32(uint32(5) * (key - iPtrmap - uint32(1)))
	if offset < 0 {
		*pRC = sqlite3CorruptError(67183)
		goto ptrmap_exit
	}
	func() int {
		_ = 0
		return 0
	}()
	pPtrmap = (*uint8)(sqlite3PagerGetData(pDbPage))
	if int32(eType) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPtrmap)) + uintptr(offset)))) || sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPtrmap)) + uintptr(offset+1)))) != parent {
		*pRC = func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3PagerWrite(pDbPage)
			return *_cgo_addr
		}()
		if rc == 0 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPtrmap)) + uintptr(offset))) = eType
			sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPtrmap)) + uintptr(offset+1))), parent)
		}
	}
ptrmap_exit:
	sqlite3PagerUnref(pDbPage)
}
func ptrmapGet(pBt *struct_BtShared, key uint32, pEType *uint8, pPgno *uint32) int32 {
	var pDbPage *struct_PgHdr
	var iPtrmap int32
	var pPtrmap *uint8
	var offset int32
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	iPtrmap = int32(ptrmapPageno(pBt, key))
	rc = sqlite3PagerGet(pBt.pPager, uint32(iPtrmap), &pDbPage, 0)
	if rc != 0 {
		return rc
	}
	pPtrmap = (*uint8)(sqlite3PagerGetData(pDbPage))
	offset = int32(uint32(5) * (key - uint32(iPtrmap) - uint32(1)))
	if offset < 0 {
		sqlite3PagerUnref(pDbPage)
		return sqlite3CorruptError(67228)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*pEType = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPtrmap)) + uintptr(offset)))
	if pPgno != nil {
		*pPgno = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPtrmap)) + uintptr(offset+1))))
	}
	sqlite3PagerUnref(pDbPage)
	if int32(*pEType) < 1 || int32(*pEType) > 5 {
		return sqlite3CorruptError(67236)
	}
	return int32(0)
}
func btreeParseCellAdjustSizeForOverflow(pPage *struct_MemPage, pCell *uint8, pInfo *struct_CellInfo) {
	var minLocal int32
	var maxLocal int32
	var surplus int32
	minLocal = int32(pPage.minLocal)
	maxLocal = int32(pPage.maxLocal)
	surplus = int32(uint32(minLocal) + (pInfo.nPayload-uint32(minLocal))%(pPage.pBt.usableSize-uint32(4)))
	if surplus <= maxLocal {
		pInfo.nLocal = uint16(surplus)
	} else {
		pInfo.nLocal = uint16(minLocal)
	}
	pInfo.nSize = uint16(int32(uint16(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pInfo.pPayload)) + uintptr(pInfo.nLocal)))))-uintptr(unsafe.Pointer(pCell)))) + 4)
}
func btreePayloadToLocal(pPage *struct_MemPage, nPayload int64) int32 {
	var maxLocal int32
	maxLocal = int32(pPage.maxLocal)
	if nPayload <= int64(maxLocal) {
		return int32(nPayload)
	} else {
		var minLocal int32
		var surplus int32
		minLocal = int32(pPage.minLocal)
		surplus = int32(int64(minLocal) + (nPayload-int64(minLocal))%int64(pPage.pBt.usableSize-uint32(4)))
		return func() int32 {
			if surplus <= maxLocal {
				return surplus
			} else {
				return minLocal
			}
		}()
	}
}
func btreeParseCellPtrNoPayload(pPage *struct_MemPage, pCell *uint8, pInfo *struct_CellInfo) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = pPage
		return 0
	}()
	pInfo.nSize = uint16(4 + int32(sqlite3GetVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(4))), (*uint64)(unsafe.Pointer(&pInfo.nKey)))))
	pInfo.nPayload = uint32(0)
	pInfo.nLocal = uint16(0)
	pInfo.pPayload = (*uint8)(nil)
	return
}
func btreeParseCellPtr(pPage *struct_MemPage, pCell *uint8, pInfo *struct_CellInfo) {
	var pIter *uint8
	var nPayload uint32
	var iKey uint64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pIter = pCell
	nPayload = uint32(*pIter)
	if nPayload >= uint32(128) {
		var pEnd *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter)) + uintptr(8)))
		nPayload &= uint32(127)
		for {
			nPayload = nPayload<<7 | uint32(int32(*func() (_cgo_ret *uint8) {
				_cgo_addr := &pIter
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return *_cgo_addr
			}())&127)
			if !(int32(*pIter) >= 128 && uintptr(unsafe.Pointer(pIter)) < uintptr(unsafe.Pointer(pEnd))) {
				break
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(&pIter))++
	iKey = uint64(*pIter)
	if iKey >= uint64(128) {
		var x uint8
		iKey = iKey&uint64(127)<<7 | uint64(int32(func() (_cgo_ret uint8) {
			_cgo_addr := &x
			*_cgo_addr = *func() (_cgo_ret *uint8) {
				_cgo_addr := &pIter
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return *_cgo_addr
			}()
			return *_cgo_addr
		}())&127)
		if int32(x) >= 128 {
			iKey = iKey<<7 | uint64(int32(func() (_cgo_ret uint8) {
				_cgo_addr := &x
				*_cgo_addr = *func() (_cgo_ret *uint8) {
					_cgo_addr := &pIter
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return *_cgo_addr
				}()
				return *_cgo_addr
			}())&127)
			if int32(x) >= 128 {
				iKey = iKey<<7 | uint64(int32(func() (_cgo_ret uint8) {
					_cgo_addr := &x
					*_cgo_addr = *func() (_cgo_ret *uint8) {
						_cgo_addr := &pIter
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return *_cgo_addr
					}()
					return *_cgo_addr
				}())&127)
				if int32(x) >= 128 {
					iKey = iKey<<7 | uint64(int32(func() (_cgo_ret uint8) {
						_cgo_addr := &x
						*_cgo_addr = *func() (_cgo_ret *uint8) {
							_cgo_addr := &pIter
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return *_cgo_addr
						}()
						return *_cgo_addr
					}())&127)
					if int32(x) >= 128 {
						iKey = iKey<<7 | uint64(int32(func() (_cgo_ret uint8) {
							_cgo_addr := &x
							*_cgo_addr = *func() (_cgo_ret *uint8) {
								_cgo_addr := &pIter
								*(*uintptr)(unsafe.Pointer(_cgo_addr))++
								return *_cgo_addr
							}()
							return *_cgo_addr
						}())&127)
						if int32(x) >= 128 {
							iKey = iKey<<7 | uint64(int32(func() (_cgo_ret uint8) {
								_cgo_addr := &x
								*_cgo_addr = *func() (_cgo_ret *uint8) {
									_cgo_addr := &pIter
									*(*uintptr)(unsafe.Pointer(_cgo_addr))++
									return *_cgo_addr
								}()
								return *_cgo_addr
							}())&127)
							if int32(x) >= 128 {
								iKey = iKey<<7 | uint64(int32(func() (_cgo_ret uint8) {
									_cgo_addr := &x
									*_cgo_addr = *func() (_cgo_ret *uint8) {
										_cgo_addr := &pIter
										*(*uintptr)(unsafe.Pointer(_cgo_addr))++
										return *_cgo_addr
									}()
									return *_cgo_addr
								}())&127)
								if int32(x) >= 128 {
									iKey = iKey<<8 | uint64(*func() (_cgo_ret *uint8) {
										_cgo_addr := &pIter
										*(*uintptr)(unsafe.Pointer(_cgo_addr))++
										return *_cgo_addr
									}())
								}
							}
						}
					}
				}
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(&pIter))++
	pInfo.nKey = *(*int64)(unsafe.Pointer(&iKey))
	pInfo.nPayload = nPayload
	pInfo.pPayload = pIter
	if nPayload <= uint32(pPage.maxLocal) {
		pInfo.nSize = uint16(nPayload + uint32(uint16(uintptr(unsafe.Pointer(pIter))-uintptr(unsafe.Pointer(pCell)))))
		if int32(pInfo.nSize) < 4 {
			pInfo.nSize = uint16(4)
		}
		pInfo.nLocal = uint16(nPayload)
	} else {
		btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo)
	}
}
func btreeParseCellPtrIndex(pPage *struct_MemPage, pCell *uint8, pInfo *struct_CellInfo) {
	var pIter *uint8
	var nPayload uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pIter = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(int32(pPage.childPtrSize))))
	nPayload = uint32(*pIter)
	if nPayload >= uint32(128) {
		var pEnd *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter)) + uintptr(8)))
		nPayload &= uint32(127)
		for {
			nPayload = nPayload<<7 | uint32(int32(*func() (_cgo_ret *uint8) {
				_cgo_addr := &pIter
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return *_cgo_addr
			}())&127)
			if !(int32(*pIter) >= 128 && uintptr(unsafe.Pointer(pIter)) < uintptr(unsafe.Pointer(pEnd))) {
				break
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(&pIter))++
	pInfo.nKey = int64(nPayload)
	pInfo.nPayload = nPayload
	pInfo.pPayload = pIter
	if nPayload <= uint32(pPage.maxLocal) {
		pInfo.nSize = uint16(nPayload + uint32(uint16(uintptr(unsafe.Pointer(pIter))-uintptr(unsafe.Pointer(pCell)))))
		if int32(pInfo.nSize) < 4 {
			pInfo.nSize = uint16(4)
		}
		pInfo.nLocal = uint16(nPayload)
	} else {
		btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo)
	}
}
func btreeParseCell(pPage *struct_MemPage, iCell int32, pInfo *struct_CellInfo) {
	pPage.xParseCell(pPage, (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*iCell))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*iCell))))) + uintptr(1)))))))), pInfo)
}
func cellSizePtr(pPage *struct_MemPage, pCell *uint8) uint16 {
	var pIter *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(int32(pPage.childPtrSize))))
	var pEnd *uint8
	var nSize uint32
	nSize = uint32(*pIter)
	if nSize >= uint32(128) {
		pEnd = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter)) + uintptr(8)))
		nSize &= uint32(127)
		for {
			nSize = nSize<<7 | uint32(int32(*func() (_cgo_ret *uint8) {
				_cgo_addr := &pIter
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return *_cgo_addr
			}())&127)
			if !(int32(*pIter) >= 128 && uintptr(unsafe.Pointer(pIter)) < uintptr(unsafe.Pointer(pEnd))) {
				break
			}
		}
	}
	*(*uintptr)(unsafe.Pointer(&pIter))++
	if pPage.intKey != 0 {
		pEnd = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter)) + uintptr(9)))
		for int32(*func() (_cgo_ret *uint8) {
			_cgo_addr := &pIter
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr))++
			return
		}())&128 != 0 && uintptr(unsafe.Pointer(pIter)) < uintptr(unsafe.Pointer(pEnd)) {
		}
	}
	if nSize <= uint32(pPage.maxLocal) {
		nSize += uint32(uintptr(unsafe.Pointer(pIter)) - uintptr(unsafe.Pointer(pCell)))
		if nSize < uint32(4) {
			nSize = uint32(4)
		}
	} else {
		var minLocal int32 = int32(pPage.minLocal)
		nSize = uint32(minLocal) + (nSize-uint32(minLocal))%(pPage.pBt.usableSize-uint32(4))
		if nSize > uint32(pPage.maxLocal) {
			nSize = uint32(minLocal)
		}
		nSize += uint32(4 + int32(uint16(uintptr(unsafe.Pointer(pIter))-uintptr(unsafe.Pointer(pCell)))))
	}
	func() int {
		_ = 0
		return 0
	}()
	return uint16(nSize)
}
func cellSizePtrNoPayload(pPage *struct_MemPage, pCell *uint8) uint16 {
	var pIter *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(4)))
	var pEnd *uint8
	func() int {
		_ = pPage
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pEnd = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter)) + uintptr(9)))
	for int32(*func() (_cgo_ret *uint8) {
		_cgo_addr := &pIter
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr))++
		return
	}())&128 != 0 && uintptr(unsafe.Pointer(pIter)) < uintptr(unsafe.Pointer(pEnd)) {
	}
	func() int {
		_ = 0
		return 0
	}()
	return uint16(uintptr(unsafe.Pointer(pIter)) - uintptr(unsafe.Pointer(pCell)))
}
func ptrmapPutOvflPtr(pPage *struct_MemPage, pSrc *struct_MemPage, pCell *uint8, pRC *int32) {
	var info struct_CellInfo
	if *pRC != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	pPage.xParseCell(pPage, pCell, &info)
	if uint32(info.nLocal) < info.nPayload {
		var ovfl uint32
		if uint64(uintptr(unsafe.Pointer(pSrc.aDataEnd))) >= uint64(uintptr(unsafe.Pointer(pCell))) && uint64(uintptr(unsafe.Pointer(pSrc.aDataEnd))) < uint64(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(info.nLocal))))))) {
			*pRC = sqlite3CorruptError(67582)
			return
		}
		ovfl = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(int32(info.nSize)-4))))
		ptrmapPut(pPage.pBt, ovfl, uint8(3), pPage.pgno, pRC)
	}
}
func defragmentPage(pPage *struct_MemPage, nMaxFrag int32) int32 {
	var i int32
	var pc int32
	var hdr int32
	var size int32
	var usableSize int32
	var cellOffset int32
	var cbrk int32
	var nCell int32
	var data *uint8
	var temp *uint8
	var src *uint8
	var iCellFirst int32
	var iCellLast int32
	var iCellStart int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	temp = (*uint8)(nil)
	src = func() (_cgo_ret *uint8) {
		_cgo_addr := &data
		*_cgo_addr = pPage.aData
		return *_cgo_addr
	}()
	hdr = int32(pPage.hdrOffset)
	cellOffset = int32(pPage.cellOffset)
	nCell = int32(pPage.nCell)
	func() int {
		_ = 0
		return 0
	}()
	iCellFirst = cellOffset + 2*nCell
	usableSize = int32(pPage.pBt.usableSize)
	if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+7)))) <= nMaxFrag {
		var iFree int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1))))) + uintptr(1))))
		if iFree > usableSize-4 {
			return sqlite3CorruptError(67641)
		}
		if iFree != 0 {
			var iFree2 int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree))))) + uintptr(1))))
			if iFree2 > usableSize-4 {
				return sqlite3CorruptError(67644)
			}
			if 0 == iFree2 || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree2)))) == 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree2+1)))) == 0 {
				var pEnd *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellOffset+nCell*2)))
				var pAddr *uint8
				var sz2 int32 = 0
				var sz int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree+2))))) + uintptr(1))))
				var top int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1))))
				if top >= iFree {
					return sqlite3CorruptError(67652)
				}
				if iFree2 != 0 {
					if iFree+sz > iFree2 {
						return sqlite3CorruptError(67655)
					}
					sz2 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree2+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree2+2))))) + uintptr(1))))
					if iFree2+sz2 > usableSize {
						return sqlite3CorruptError(67657)
					}
					__builtin___memmove_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree+sz+sz2)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree+sz)))), uint(iFree2-(iFree+sz)), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFree+sz+sz2)))), 0))
					sz += sz2
				} else if iFree+sz > usableSize {
					return sqlite3CorruptError(67661)
				}
				cbrk = top + sz
				func() int {
					_ = 0
					return 0
				}()
				__builtin___memmove_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cbrk)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(top)))), uint(iFree-top), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cbrk)))), 0))
				for pAddr = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellOffset))); uintptr(unsafe.Pointer(pAddr)) < uintptr(unsafe.Pointer(pEnd)); *(*uintptr)(unsafe.Pointer(&pAddr)) += uintptr(2) {
					pc = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(1))))
					if pc < iFree {
						func() uint8 {
							*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(0))) = uint8((pc + sz) >> 8)
							return func() (_cgo_ret uint8) {
								_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(1)))
								*_cgo_addr = uint8(pc + sz)
								return *_cgo_addr
							}()
						}()
					} else if pc < iFree2 {
						func() uint8 {
							*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(0))) = uint8((pc + sz2) >> 8)
							return func() (_cgo_ret uint8) {
								_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(1)))
								*_cgo_addr = uint8(pc + sz2)
								return *_cgo_addr
							}()
						}()
					}
				}
				goto defragment_out
			}
		}
	}
	cbrk = usableSize
	iCellLast = usableSize - 4
	iCellStart = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1))))
	for i = int32(0); i < nCell; i++ {
		var pAddr *uint8
		pAddr = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellOffset+i*2)))
		pc = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(1))))
		if pc < iCellStart || pc > iCellLast {
			return sqlite3CorruptError(67690)
		}
		func() int {
			_ = 0
			return 0
		}()
		size = int32(pPage.xCellSize(pPage, &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(src)) + uintptr(pc)))))
		cbrk -= size
		if cbrk < iCellStart || pc+size > usableSize {
			return sqlite3CorruptError(67696)
		}
		func() int {
			_ = 0
			return 0
		}()
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(0))) = uint8(cbrk >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pAddr)) + uintptr(1)))
				*_cgo_addr = uint8(cbrk)
				return *_cgo_addr
			}()
		}()
		if uintptr(unsafe.Pointer(temp)) == uintptr(unsafe.Pointer(nil)) {
			if cbrk == pc {
				continue
			}
			temp = (*uint8)(sqlite3PagerTempSpace(pPage.pBt.pPager))
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + uintptr(iCellStart)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iCellStart)))), uint(usableSize-iCellStart), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(temp)) + uintptr(iCellStart)))), 0))
			src = temp
		}
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cbrk)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(src)) + uintptr(pc)))), uint(size), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cbrk)))), 0))
	}
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+7))) = uint8(0)
defragment_out:
	func() int {
		_ = 0
		return 0
	}()
	if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+7))))+cbrk-iCellFirst != pPage.nFree {
		return sqlite3CorruptError(67715)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))) = uint8(cbrk >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1)))
			*_cgo_addr = uint8(cbrk)
			return *_cgo_addr
		}()
	}()
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1))) = uint8(0)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+2))) = uint8(0)
	__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iCellFirst)))), 0, uint(cbrk-iCellFirst), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iCellFirst)))), 0))
	func() int {
		_ = 0
		return 0
	}()
	return int32(0)
}
func pageFindSlot(pPg *struct_MemPage, nByte int32, pRc *int32) *uint8 {
	var hdr int32 = int32(pPg.hdrOffset)
	var aData *uint8 = pPg.aData
	var iAddr int32 = hdr + 1
	var pc int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(iAddr))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(iAddr))))) + uintptr(1))))
	var x int32
	var maxPC int32 = int32(pPg.pBt.usableSize - uint32(nByte))
	var size int32
	func() int {
		_ = 0
		return 0
	}()
	for pc <= maxPC {
		size = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc+2))))) + uintptr(1))))
		if func() (_cgo_ret int32) {
			_cgo_addr := &x
			*_cgo_addr = size - nByte
			return *_cgo_addr
		}() >= 0 {
			if x < 4 {
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+7)))) > 57 {
					return (*uint8)(nil)
				}
				__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(iAddr)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc)))), uint(2), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(iAddr)))), 0))
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+7))) += uint8(int32(uint8(x)))
			} else if x+pc > maxPC {
				*pRc = sqlite3CorruptError(67769)
				return (*uint8)(nil)
			} else {
				func() uint8 {
					*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc+2))))) + uintptr(0))) = uint8(x >> 8)
					return func() (_cgo_ret uint8) {
						_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc+2))))) + uintptr(1)))
						*_cgo_addr = uint8(x)
						return *_cgo_addr
					}()
				}()
			}
			return &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc+x)))
		}
		iAddr = pc
		pc = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pc))))) + uintptr(1))))
		if pc <= iAddr+size {
			if pc != 0 {
				*pRc = sqlite3CorruptError(67783)
			}
			return (*uint8)(nil)
		}
	}
	if pc > maxPC+nByte-4 {
		*pRc = sqlite3CorruptError(67790)
	}
	return (*uint8)(nil)
}
func allocateSpace(pPage *struct_MemPage, nByte int32, pIdx *int32) int32 {
	var hdr int32 = int32(pPage.hdrOffset)
	var data *uint8 = pPage.aData
	var top int32
	var rc int32 = 0
	var gap int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	gap = int32(pPage.cellOffset) + 2*int32(pPage.nCell)
	func() int {
		_ = 0
		return 0
	}()
	top = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1))))
	func() int {
		_ = 0
		return 0
	}()
	if gap > top {
		if top == 0 && pPage.pBt.usableSize == uint32(65536) {
			top = int32(65536)
		} else {
			return sqlite3CorruptError(67837)
		}
	}
	if (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+2)))) != 0 || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1)))) != 0) && gap+2 <= top {
		var pSpace *uint8 = pageFindSlot(pPage, nByte, &rc)
		if pSpace != nil {
			var g2 int32
			func() int {
				_ = 0
				return 0
			}()
			*pIdx = func() (_cgo_ret int32) {
				_cgo_addr := &g2
				*_cgo_addr = int32(uintptr(unsafe.Pointer(pSpace)) - uintptr(unsafe.Pointer(data)))
				return *_cgo_addr
			}()
			if g2 <= gap {
				return sqlite3CorruptError(67855)
			} else {
				return int32(0)
			}
		} else if rc != 0 {
			return rc
		}
	}
	if gap+2+nByte > top {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		rc = defragmentPage(pPage, func() int32 {
			if 4 < pPage.nFree-(2+nByte) {
				return 4
			} else {
				return pPage.nFree - (2 + nByte)
			}
		}())
		if rc != 0 {
			return rc
		}
		top = (int32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1)))))-1)&65535 + 1
		func() int {
			_ = 0
			return 0
		}()
	}
	top -= nByte
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))) = uint8(top >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1)))
			*_cgo_addr = uint8(top)
			return *_cgo_addr
		}()
	}()
	func() int {
		_ = 0
		return 0
	}()
	*pIdx = top
	return int32(0)
}
func freeSpace(pPage *struct_MemPage, iStart uint16, iSize uint16) int32 {
	var iPtr uint16
	var iFreeBlk uint16
	var hdr uint8
	var nFrag uint8 = uint8(0)
	var iOrigSize uint16 = iSize
	var x uint16
	var iEnd uint32 = uint32(int32(iStart) + int32(iSize))
	var data *uint8 = pPage.aData
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	hdr = pPage.hdrOffset
	iPtr = uint16(int32(hdr) + 1)
	if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iPtr)+1)))) == 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iPtr)))) == 0 {
		iFreeBlk = uint16(0)
	} else {
		for int32(func() (_cgo_ret uint16) {
			_cgo_addr := &iFreeBlk
			*_cgo_addr = uint16(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iPtr))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iPtr))))) + uintptr(1)))))
			return *_cgo_addr
		}()) < int32(iStart) {
			if int32(iFreeBlk) < int32(iPtr)+4 {
				if int32(iFreeBlk) == 0 {
					break
				}
				return sqlite3CorruptError(67933)
			}
			iPtr = iFreeBlk
		}
		if uint32(iFreeBlk) > pPage.pBt.usableSize-uint32(4) {
			return sqlite3CorruptError(67938)
		}
		func() int {
			_ = 0
			return 0
		}()
		if int32(iFreeBlk) != 0 && iEnd+uint32(3) >= uint32(iFreeBlk) {
			nFrag = uint8(uint32(iFreeBlk) - iEnd)
			if iEnd > uint32(iFreeBlk) {
				return sqlite3CorruptError(67950)
			}
			iEnd = uint32(int32(iFreeBlk) + (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iFreeBlk)+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iFreeBlk)+2))))) + uintptr(1))))))
			if iEnd > pPage.pBt.usableSize {
				return sqlite3CorruptError(67953)
			}
			iSize = uint16(iEnd - uint32(iStart))
			iFreeBlk = uint16(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFreeBlk))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iFreeBlk))))) + uintptr(1)))))
		}
		if int32(iPtr) > int32(hdr)+1 {
			var iPtrEnd int32 = int32(iPtr) + (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iPtr)+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iPtr)+2))))) + uintptr(1)))))
			if iPtrEnd+3 >= int32(iStart) {
				if iPtrEnd > int32(iStart) {
					return sqlite3CorruptError(67966)
				}
				nFrag += uint8(int32(iStart) - iPtrEnd)
				iSize = uint16(iEnd - uint32(iPtr))
				iStart = iPtr
			}
		}
		if int32(nFrag) > int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+7)))) {
			return sqlite3CorruptError(67972)
		}
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+7))) -= uint8(int32(nFrag))
	}
	x = uint16(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(1)))))
	if int32(iStart) <= int32(x) {
		if int32(iStart) < int32(x) {
			return sqlite3CorruptError(67980)
		}
		if int32(iPtr) != int32(hdr)+1 {
			return sqlite3CorruptError(67981)
		}
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+1))))) + uintptr(0))) = uint8(int32(iFreeBlk) >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+1))))) + uintptr(1)))
				*_cgo_addr = uint8(iFreeBlk)
				return *_cgo_addr
			}()
		}()
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(0))) = uint8(iEnd >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(1)))
				*_cgo_addr = uint8(iEnd)
				return *_cgo_addr
			}()
		}()
	} else {
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iPtr))))) + uintptr(0))) = uint8(int32(iStart) >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iPtr))))) + uintptr(1)))
				*_cgo_addr = uint8(iStart)
				return *_cgo_addr
			}()
		}()
	}
	if int32(pPage.pBt.btsFlags)&12 != 0 {
		__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iStart)))), 0, uint(iSize), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iStart)))), 0))
	}
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iStart))))) + uintptr(0))) = uint8(int32(iFreeBlk) >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(iStart))))) + uintptr(1)))
			*_cgo_addr = uint8(iFreeBlk)
			return *_cgo_addr
		}()
	}()
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iStart)+2))))) + uintptr(0))) = uint8(int32(iSize) >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(iStart)+2))))) + uintptr(1)))
			*_cgo_addr = uint8(iSize)
			return *_cgo_addr
		}()
	}()
	pPage.nFree += int32(iOrigSize)
	return int32(0)
}
func decodeFlags(pPage *struct_MemPage, flagByte int32) int32 {
	var pBt *struct_BtShared
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPage.leaf = uint8(flagByte >> 3)
	func() int {
		_ = 0
		return 0
	}()
	flagByte &= int32(^8)
	pPage.childPtrSize = uint8(4 - 4*int32(pPage.leaf))
	pPage.xCellSize = cellSizePtr
	pBt = pPage.pBt
	if flagByte == 4|1 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pPage.intKey = uint8(1)
		if pPage.leaf != 0 {
			pPage.intKeyLeaf = uint8(1)
			pPage.xParseCell = btreeParseCellPtr
		} else {
			pPage.intKeyLeaf = uint8(0)
			pPage.xCellSize = cellSizePtrNoPayload
			pPage.xParseCell = btreeParseCellPtrNoPayload
		}
		pPage.maxLocal = pBt.maxLeaf
		pPage.minLocal = pBt.minLeaf
	} else if flagByte == 2 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pPage.intKey = uint8(0)
		pPage.intKeyLeaf = uint8(0)
		pPage.xParseCell = btreeParseCellPtrIndex
		pPage.maxLocal = pBt.maxLocal
		pPage.minLocal = pBt.minLocal
	} else {
		return sqlite3CorruptError(68054)
	}
	pPage.max1bytePayload = pBt.max1bytePayload
	return int32(0)
}
func btreeComputeFreeSpace(pPage *struct_MemPage) int32 {
	var pc int32
	var hdr uint8
	var data *uint8
	var usableSize int32
	var nFree int32
	var top int32
	var iCellFirst int32
	var iCellLast int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	usableSize = int32(pPage.pBt.usableSize)
	hdr = pPage.hdrOffset
	data = pPage.aData
	top = (int32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(1)))))-1)&65535 + 1
	iCellFirst = int32(hdr) + 8 + int32(pPage.childPtrSize) + 2*int32(pPage.nCell)
	iCellLast = usableSize - 4
	pc = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+1))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+1))))) + uintptr(1))))
	nFree = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+7)))) + top
	if pc > 0 {
		var next uint32
		var size uint32
		if pc < top {
			return sqlite3CorruptError(68105)
		}
		for 1 != 0 {
			if pc > iCellLast {
				return sqlite3CorruptError(68110)
			}
			next = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc))))) + uintptr(1)))))
			size = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc+2))))) + uintptr(1)))))
			nFree = int32(uint32(nFree) + size)
			if next <= uint32(pc)+size+uint32(3) {
				break
			}
			pc = int32(next)
		}
		if next > uint32(0) {
			return sqlite3CorruptError(68120)
		}
		if uint32(pc)+size > uint32(usableSize) {
			return sqlite3CorruptError(68124)
		}
	}
	if nFree > usableSize || nFree < iCellFirst {
		return sqlite3CorruptError(68136)
	}
	pPage.nFree = int32(uint16(nFree - iCellFirst))
	return int32(0)
}
func btreeCellSizeCheck(pPage *struct_MemPage) int32 {
	var iCellFirst int32
	var iCellLast int32
	var i int32
	var sz int32
	var pc int32
	var data *uint8
	var usableSize int32
	var cellOffset int32
	iCellFirst = int32(pPage.cellOffset) + 2*int32(pPage.nCell)
	usableSize = int32(pPage.pBt.usableSize)
	iCellLast = usableSize - 4
	data = pPage.aData
	cellOffset = int32(pPage.cellOffset)
	if !(pPage.leaf != 0) {
		iCellLast--
	}
	for i = int32(0); i < int32(pPage.nCell); i++ {
		pc = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellOffset+i*2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellOffset+i*2))))) + uintptr(1))))
		if pc < iCellFirst || pc > iCellLast {
			return sqlite3CorruptError(68167)
		}
		sz = int32(pPage.xCellSize(pPage, &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc)))))
		if pc+sz > usableSize {
			return sqlite3CorruptError(68172)
		}
	}
	return int32(0)
}
func btreeInitPage(pPage *struct_MemPage) int32 {
	var data *uint8
	var pBt *struct_BtShared
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pBt = pPage.pBt
	data = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset))))
	if decodeFlags(pPage, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(0))))) != 0 {
		return sqlite3CorruptError(68204)
	}
	func() int {
		_ = 0
		return 0
	}()
	pPage.maskPage = uint16(pBt.pageSize - uint32(1))
	pPage.nOverflow = uint8(0)
	pPage.cellOffset = uint16(int32(pPage.hdrOffset) + 8 + int32(pPage.childPtrSize))
	pPage.aCellIdx = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data))+uintptr(int32(pPage.childPtrSize)))))) + uintptr(8)))
	pPage.aDataEnd = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(pBt.pageSize)))
	pPage.aDataOfst = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.childPtrSize))))
	pPage.nCell = uint16(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(3))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(3))))) + uintptr(1)))))
	if uint32(pPage.nCell) > (pBt.pageSize-uint32(8))/uint32(6) {
		return sqlite3CorruptError(68218)
	}
	func() int {
		_ = 0
		return 0
	}()
	pPage.nFree = int32(-1)
	pPage.isInit = uint8(1)
	if pBt.db.flags&uint64(2097152) != 0 {
		return btreeCellSizeCheck(pPage)
	}
	return int32(0)
}
func zeroPage(pPage *struct_MemPage, flags int32) {
	var data *uint8 = pPage.aData
	var pBt *struct_BtShared = pPage.pBt
	var hdr uint8 = pPage.hdrOffset
	var first uint16
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pBt.btsFlags)&12 != 0 {
		__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr)))), 0, uint(pBt.usableSize-uint32(hdr)), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr)))), 0))
	}
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr))) = uint8(int8(flags))
	first = uint16(int32(hdr) + func() int32 {
		if flags&8 == 0 {
			return 12
		} else {
			return 8
		}
	}())
	__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+1)))), 0, uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+1)))), 0))
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+7))) = uint8(0)
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(0))) = uint8(pBt.usableSize >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(hdr)+5))))) + uintptr(1)))
			*_cgo_addr = uint8(pBt.usableSize)
			return *_cgo_addr
		}()
	}()
	pPage.nFree = int32(uint16(pBt.usableSize - uint32(first)))
	decodeFlags(pPage, flags)
	pPage.cellOffset = first
	pPage.aDataEnd = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pBt.pageSize)))
	pPage.aCellIdx = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(first)))
	pPage.aDataOfst = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pPage.childPtrSize)))
	pPage.nOverflow = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	pPage.maskPage = uint16(pBt.pageSize - uint32(1))
	pPage.nCell = uint16(0)
	pPage.isInit = uint8(1)
}
func btreePageFromDbPage(pDbPage *struct_PgHdr, pgno uint32, pBt *struct_BtShared) *struct_MemPage {
	var pPage *struct_MemPage = (*struct_MemPage)(sqlite3PagerGetExtra(pDbPage))
	if pgno != pPage.pgno {
		pPage.aData = (*uint8)(sqlite3PagerGetData(pDbPage))
		pPage.pDbPage = pDbPage
		pPage.pBt = pBt
		pPage.pgno = pgno
		pPage.hdrOffset = uint8(func() int32 {
			if pgno == uint32(1) {
				return 100
			} else {
				return 0
			}
		}())
	}
	func() int {
		_ = 0
		return 0
	}()
	return pPage
}
func btreeGetPage(pBt *struct_BtShared, pgno uint32, ppPage **struct_MemPage, flags int32) int32 {
	var rc int32
	var pDbPage *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3PagerGet(pBt.pPager, pgno, (**struct_PgHdr)(unsafe.Pointer(&pDbPage)), flags)
	if rc != 0 {
		return rc
	}
	*ppPage = btreePageFromDbPage(pDbPage, pgno, pBt)
	return int32(0)
}
func btreePageLookup(pBt *struct_BtShared, pgno uint32) *struct_MemPage {
	var pDbPage *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	pDbPage = sqlite3PagerLookup(pBt.pPager, pgno)
	if pDbPage != nil {
		return btreePageFromDbPage(pDbPage, pgno, pBt)
	}
	return (*struct_MemPage)(nil)
}
func btreePagecount(pBt *struct_BtShared) uint32 {
	return pBt.nPage
}
func sqlite3BtreeLastPage(p *struct_Btree) uint32 {
	func() int {
		_ = 0
		return 0
	}()
	return btreePagecount(p.pBt)
}
func getAndInitPage(pBt *struct_BtShared, pgno uint32, ppPage **struct_MemPage, pCur *struct_BtCursor, bReadOnly int32) int32 {
	var rc int32
	var pDbPage *struct_PgHdr
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pgno > btreePagecount(pBt) {
		rc = sqlite3CorruptError(68373)
		goto getAndInitPage_error1
	}
	rc = sqlite3PagerGet(pBt.pPager, pgno, (**struct_PgHdr)(unsafe.Pointer(&pDbPage)), bReadOnly)
	if rc != 0 {
		goto getAndInitPage_error1
	}
	*ppPage = (*struct_MemPage)(sqlite3PagerGetExtra(pDbPage))
	if int32((*ppPage).isInit) == 0 {
		btreePageFromDbPage(pDbPage, pgno, pBt)
		rc = btreeInitPage(*ppPage)
		if rc != 0 {
			goto getAndInitPage_error2
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pCur != nil && (int32((*ppPage).nCell) < 1 || int32((*ppPage).intKey) != int32(pCur.curIntKey)) {
		rc = sqlite3CorruptError(68394)
		goto getAndInitPage_error2
	}
	return int32(0)
getAndInitPage_error2:
	releasePage(*ppPage)
getAndInitPage_error1:
	if pCur != nil {
		pCur.iPage--
		pCur.pPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(pCur.iPage)*8))
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func releasePageNotNull(pPage *struct_MemPage) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3PagerUnrefNotNull(pPage.pDbPage)
}
func releasePage(pPage *struct_MemPage) {
	if pPage != nil {
		releasePageNotNull(pPage)
	}
}
func releasePageOne(pPage *struct_MemPage) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3PagerUnrefPageOne(pPage.pDbPage)
}
func btreeGetUnusedPage(pBt *struct_BtShared, pgno uint32, ppPage **struct_MemPage, flags int32) int32 {
	var rc int32 = btreeGetPage(pBt, pgno, ppPage, flags)
	if rc == 0 {
		if sqlite3PagerPageRefcount((*ppPage).pDbPage) > 1 {
			releasePage(*ppPage)
			*ppPage = (*struct_MemPage)(nil)
			return sqlite3CorruptError(68460)
		}
		(*ppPage).isInit = uint8(0)
	} else {
		*ppPage = (*struct_MemPage)(nil)
	}
	return rc
}
func pageReinit(pData *struct_PgHdr) {
	var pPage *struct_MemPage
	pPage = (*struct_MemPage)(sqlite3PagerGetExtra(pData))
	func() int {
		_ = 0
		return 0
	}()
	if pPage.isInit != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pPage.isInit = uint8(0)
		if sqlite3PagerPageRefcount(pData) > 1 {
			btreeInitPage(pPage)
		}
	}
}
func btreeInvokeBusyHandler(pArg unsafe.Pointer) int32 {
	var pBt *struct_BtShared = (*struct_BtShared)(pArg)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3InvokeBusyHandler(&pBt.db.busyHandler)
}
func sqlite3BtreeOpen(pVfs *struct_sqlite3_vfs, zFilename *int8, db *struct_sqlite3, ppBtree **struct_Btree, flags int32, vfsFlags int32) int32 {
	var pBt *struct_BtShared = nil
	var p *struct_Btree
	var mutexOpen *struct_sqlite3_mutex = nil
	var rc int32 = 0
	var nReserve uint8
	var zDbHeader [100]uint8
	var isTempDb int32 = func() int32 {
		if uintptr(unsafe.Pointer(zFilename)) == uintptr(unsafe.Pointer(nil)) || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) == 0 {
			return 1
		} else {
			return 0
		}
	}()
	var isMemdb int32 = func() int32 {
		if zFilename != nil && strcmp(zFilename, (*int8)(unsafe.Pointer(&[9]int8{':', 'm', 'e', 'm', 'o', 'r', 'y', ':', '\x00'}))) == 0 || isTempDb != 0 && sqlite3TempInMemory(db) != 0 || vfsFlags&128 != 0 {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if isMemdb != 0 {
		flags |= int32(2)
	}
	if vfsFlags&256 != 0 && (isMemdb != 0 || isTempDb != 0) {
		vfsFlags = vfsFlags & ^256 | 512
	}
	p = (*struct_Btree)(sqlite3MallocZero(uint64(72)))
	if !(p != nil) {
		return int32(7)
	}
	p.inTrans = uint8(0)
	p.db = db
	p.lock.pBtree = p
	p.lock.iTable = uint32(1)
	if isTempDb == 0 && (isMemdb == 0 || vfsFlags&64 != 0) {
		if vfsFlags&131072 != 0 {
			var nFilename int32 = sqlite3Strlen30(zFilename) + 1
			var nFullPathname int32 = pVfs.mxPathname + 1
			var zFullPathname *int8 = (*int8)(sqlite3Malloc(uint64(func() int32 {
				if nFullPathname > nFilename {
					return nFullPathname
				} else {
					return nFilename
				}
			}())))
			var mutexShared *struct_sqlite3_mutex
			p.sharable = uint8(1)
			if !(zFullPathname != nil) {
				sqlite3_free(unsafe.Pointer(p))
				return int32(7)
			}
			if isMemdb != 0 {
				__builtin___memcpy_chk(unsafe.Pointer(zFullPathname), unsafe.Pointer(zFilename), uint(nFilename), __builtin_object_size(unsafe.Pointer(zFullPathname), 0))
			} else {
				rc = sqlite3OsFullPathname(pVfs, zFilename, nFullPathname, zFullPathname)
				if rc != 0 {
					if rc == 0|2<<8 {
						rc = int32(0)
					} else {
						sqlite3_free(unsafe.Pointer(zFullPathname))
						sqlite3_free(unsafe.Pointer(p))
						return rc
					}
				}
			}
			mutexOpen = sqlite3MutexAlloc(4)
			sqlite3_mutex_enter(mutexOpen)
			mutexShared = sqlite3MutexAlloc(2)
			sqlite3_mutex_enter(mutexShared)
			for pBt = sqlite3SharedCacheList; pBt != nil; pBt = pBt.pNext {
				func() int {
					_ = 0
					return 0
				}()
				if 0 == strcmp(zFullPathname, sqlite3PagerFilename(pBt.pPager, 0)) && uintptr(unsafe.Pointer(sqlite3PagerVfs(pBt.pPager))) == uintptr(unsafe.Pointer(pVfs)) {
					var iDb int32
					for iDb = db.nDb - 1; iDb >= 0; iDb-- {
						var pExisting *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt
						if pExisting != nil && uintptr(unsafe.Pointer(pExisting.pBt)) == uintptr(unsafe.Pointer(pBt)) {
							sqlite3_mutex_leave(mutexShared)
							sqlite3_mutex_leave(mutexOpen)
							sqlite3_free(unsafe.Pointer(zFullPathname))
							sqlite3_free(unsafe.Pointer(p))
							return int32(19)
						}
					}
					p.pBt = pBt
					pBt.nRef++
					break
				}
			}
			sqlite3_mutex_leave(mutexShared)
			sqlite3_free(unsafe.Pointer(zFullPathname))
		}
	}
	if uintptr(unsafe.Pointer(pBt)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pBt = (*struct_BtShared)(sqlite3MallocZero(uint64(148)))
		if uintptr(unsafe.Pointer(pBt)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
			goto btree_open_out
		}
		rc = sqlite3PagerOpen(pVfs, &pBt.pPager, zFilename, int32(136), flags, vfsFlags, pageReinit)
		if rc == 0 {
			sqlite3PagerSetMmapLimit(pBt.pPager, db.szMmap)
			rc = sqlite3PagerReadFileheader(pBt.pPager, int32(100), (*uint8)(unsafe.Pointer(&zDbHeader)))
		}
		if rc != 0 {
			goto btree_open_out
		}
		pBt.openFlags = uint8(flags)
		pBt.db = db
		sqlite3PagerSetBusyHandler(pBt.pPager, btreeInvokeBusyHandler, unsafe.Pointer(pBt))
		p.pBt = pBt
		pBt.pCursor = (*struct_BtCursor)(nil)
		pBt.pPage1 = (*struct_MemPage)(nil)
		if sqlite3PagerIsreadonly(pBt.pPager) != 0 {
			pBt.btsFlags |= uint16(1)
		}
		pBt.pageSize = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&zDbHeader)))) + uintptr(16))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&zDbHeader)))) + uintptr(17))))<<16)
		if pBt.pageSize < uint32(512) || pBt.pageSize > uint32(65536) || (pBt.pageSize-uint32(1))&pBt.pageSize != uint32(0) {
			pBt.pageSize = uint32(0)
			if zFilename != nil && !(isMemdb != 0) {
				pBt.autoVacuum = uint8(func() int32 {
					if 0 != 0 {
						return 1
					} else {
						return 0
					}
				}())
				pBt.incrVacuum = uint8(func() int32 {
					if 0 == 2 {
						return 1
					} else {
						return 0
					}
				}())
			}
			nReserve = uint8(0)
		} else {
			nReserve = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&zDbHeader)))) + uintptr(20)))
			pBt.btsFlags |= uint16(2)
			pBt.autoVacuum = uint8(func() int32 {
				if sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&zDbHeader)))) + uintptr(36+4*4)))) != 0 {
					return 1
				} else {
					return 0
				}
			}())
			pBt.incrVacuum = uint8(func() int32 {
				if sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&zDbHeader)))) + uintptr(36+7*4)))) != 0 {
					return 1
				} else {
					return 0
				}
			}())
		}
		rc = sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, int32(nReserve))
		if rc != 0 {
			goto btree_open_out
		}
		pBt.usableSize = pBt.pageSize - uint32(nReserve)
		func() int {
			_ = 0
			return 0
		}()
		pBt.nRef = int32(1)
		if p.sharable != 0 {
			var mutexShared *struct_sqlite3_mutex
			mutexShared = sqlite3MutexAlloc(2)
			if 1 != 0 && int32(sqlite3Config.bCoreMutex) != 0 {
				pBt.mutex = sqlite3MutexAlloc(0)
				if uintptr(unsafe.Pointer(pBt.mutex)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
					goto btree_open_out
				}
			}
			sqlite3_mutex_enter(mutexShared)
			pBt.pNext = sqlite3SharedCacheList
			sqlite3SharedCacheList = pBt
			sqlite3_mutex_leave(mutexShared)
		}
	}
	if p.sharable != 0 {
		var i int32
		var pSib *struct_Btree
		for i = int32(0); i < db.nDb; i++ {
			if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Btree) {
				_cgo_addr := &pSib
				*_cgo_addr = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) && int32(pSib.sharable) != 0 {
				for pSib.pPrev != nil {
					pSib = pSib.pPrev
				}
				if uint64(uintptr(unsafe.Pointer(p.pBt))) < uint64(uintptr(unsafe.Pointer(pSib.pBt))) {
					p.pNext = pSib
					p.pPrev = (*struct_Btree)(nil)
					pSib.pPrev = p
				} else {
					for pSib.pNext != nil && uint64(uintptr(unsafe.Pointer(pSib.pNext.pBt))) < uint64(uintptr(unsafe.Pointer(p.pBt))) {
						pSib = pSib.pNext
					}
					p.pNext = pSib.pNext
					p.pPrev = pSib
					if p.pNext != nil {
						p.pNext.pPrev = p
					}
					pSib.pNext = p
				}
				break
			}
		}
	}
	*ppBtree = p
btree_open_out:
	if rc != 0 {
		if pBt != nil && pBt.pPager != nil {
			sqlite3PagerClose(pBt.pPager, nil)
		}
		sqlite3_free(unsafe.Pointer(pBt))
		sqlite3_free(unsafe.Pointer(p))
		*ppBtree = (*struct_Btree)(nil)
	} else {
		var pFile *struct_sqlite3_file
		if uintptr(unsafe.Pointer(sqlite3BtreeSchema(p, 0, nil))) == uintptr(unsafe.Pointer(nil)) {
			sqlite3BtreeSetCacheSize(p, -2000)
		}
		pFile = sqlite3PagerFile(pBt.pPager)
		if pFile.pMethods != nil {
			sqlite3OsFileControlHint(pFile, 30, unsafe.Pointer(&pBt.db))
		}
	}
	if mutexOpen != nil {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_mutex_leave(mutexOpen)
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func removeFromSharingList(pBt *struct_BtShared) int32 {
	var pMainMtx *struct_sqlite3_mutex
	var pList *struct_BtShared
	var removed int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	pMainMtx = sqlite3MutexAlloc(2)
	sqlite3_mutex_enter(pMainMtx)
	pBt.nRef--
	if pBt.nRef <= 0 {
		if uintptr(unsafe.Pointer(sqlite3SharedCacheList)) == uintptr(unsafe.Pointer(pBt)) {
			sqlite3SharedCacheList = pBt.pNext
		} else {
			pList = sqlite3SharedCacheList
			for pList != nil && uintptr(unsafe.Pointer(pList.pNext)) != uintptr(unsafe.Pointer(pBt)) {
				pList = pList.pNext
			}
			if pList != nil {
				pList.pNext = pBt.pNext
			}
		}
		if 1 != 0 {
			sqlite3_mutex_free(pBt.mutex)
		}
		removed = int32(1)
	}
	sqlite3_mutex_leave(pMainMtx)
	return removed
}
func allocateTempSpace(pBt *struct_BtShared) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pBt.pTmpSpace = (*uint8)(sqlite3PageMalloc(int32(pBt.pageSize)))
	if uintptr(unsafe.Pointer(pBt.pTmpSpace)) == uintptr(unsafe.Pointer(nil)) {
		var pCur *struct_BtCursor = pBt.pCursor
		pBt.pCursor = pCur.pNext
		__builtin___memset_chk(unsafe.Pointer(pCur), 0, 296, __builtin_object_size(unsafe.Pointer(pCur), 0))
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(pBt.pTmpSpace), 0, uint(8), __builtin_object_size(unsafe.Pointer(pBt.pTmpSpace), 0))
	*(*uintptr)(unsafe.Pointer(&pBt.pTmpSpace)) += uintptr(4)
	return int32(0)
}
func freeTempSpace(pBt *struct_BtShared) {
	if pBt.pTmpSpace != nil {
		*(*uintptr)(unsafe.Pointer(&pBt.pTmpSpace)) -= uintptr(4)
		sqlite3PageFree(unsafe.Pointer(pBt.pTmpSpace))
		pBt.pTmpSpace = (*uint8)(nil)
	}
}
func sqlite3BtreeClose(p *struct_Btree) int32 {
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	sqlite3BtreeRollback(p, 0, 0)
	sqlite3BtreeLeave(p)
	func() int {
		_ = 0
		return 0
	}()
	if !(p.sharable != 0) || removeFromSharingList(pBt) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3PagerClose(pBt.pPager, p.db)
		if pBt.xFreeSchema != nil && pBt.pSchema != nil {
			pBt.xFreeSchema(pBt.pSchema)
		}
		sqlite3DbFree(nil, pBt.pSchema)
		freeTempSpace(pBt)
		sqlite3_free(unsafe.Pointer(pBt))
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.pPrev != nil {
		p.pPrev.pNext = p.pNext
	}
	if p.pNext != nil {
		p.pNext.pPrev = p.pPrev
	}
	sqlite3_free(unsafe.Pointer(p))
	return int32(0)
}
func sqlite3BtreeSetCacheSize(p *struct_Btree, mxPage int32) int32 {
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	sqlite3PagerSetCachesize(pBt.pPager, mxPage)
	sqlite3BtreeLeave(p)
	return int32(0)
}
func sqlite3BtreeSetSpillSize(p *struct_Btree, mxPage int32) int32 {
	var pBt *struct_BtShared = p.pBt
	var res int32
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	res = sqlite3PagerSetSpillsize(pBt.pPager, mxPage)
	sqlite3BtreeLeave(p)
	return res
}
func sqlite3BtreeSetMmapLimit(p *struct_Btree, szMmap int64) int32 {
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	sqlite3PagerSetMmapLimit(pBt.pPager, szMmap)
	sqlite3BtreeLeave(p)
	return int32(0)
}
func sqlite3BtreeSetPagerFlags(p *struct_Btree, pgFlags uint32) int32 {
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	sqlite3PagerSetFlags(pBt.pPager, pgFlags)
	sqlite3BtreeLeave(p)
	return int32(0)
}
func sqlite3BtreeSetPageSize(p *struct_Btree, pageSize int32, nReserve int32, iFix int32) int32 {
	var rc int32 = 0
	var x int32
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	pBt.nReserveWanted = uint8(nReserve)
	x = int32(pBt.pageSize - pBt.usableSize)
	if nReserve < x {
		nReserve = x
	}
	if int32(pBt.btsFlags)&2 != 0 {
		sqlite3BtreeLeave(p)
		return int32(8)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pageSize >= 512 && pageSize <= 65536 && (pageSize-1)&pageSize == 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if nReserve > 32 && pageSize == 512 {
			pageSize = int32(1024)
		}
		pBt.pageSize = uint32(pageSize)
		freeTempSpace(pBt)
	}
	rc = sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, nReserve)
	pBt.usableSize = pBt.pageSize - uint32(uint16(nReserve))
	if iFix != 0 {
		pBt.btsFlags |= uint16(2)
	}
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeGetPageSize(p *struct_Btree) int32 {
	return int32(p.pBt.pageSize)
}
func sqlite3BtreeGetReserveNoMutex(p *struct_Btree) int32 {
	var n int32
	func() int {
		_ = 0
		return 0
	}()
	n = int32(p.pBt.pageSize - p.pBt.usableSize)
	return n
}
func sqlite3BtreeGetRequestedReserve(p *struct_Btree) int32 {
	var n1 int32
	var n2 int32
	sqlite3BtreeEnter(p)
	n1 = int32(p.pBt.nReserveWanted)
	n2 = sqlite3BtreeGetReserveNoMutex(p)
	sqlite3BtreeLeave(p)
	return func() int32 {
		if n1 > n2 {
			return n1
		} else {
			return n2
		}
	}()
}
func sqlite3BtreeMaxPageCount(p *struct_Btree, mxPage uint32) uint32 {
	var n uint32
	sqlite3BtreeEnter(p)
	n = sqlite3PagerMaxPageCount(p.pBt.pPager, mxPage)
	sqlite3BtreeLeave(p)
	return n
}
func sqlite3BtreeSecureDelete(p *struct_Btree, newFlag int32) int32 {
	var b int32
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if newFlag >= 0 {
		p.pBt.btsFlags &= uint16(^12)
		p.pBt.btsFlags |= uint16(4 * newFlag)
	}
	b = int32(p.pBt.btsFlags) & 12 / 4
	sqlite3BtreeLeave(p)
	return b
}
func sqlite3BtreeSetAutoVacuum(p *struct_Btree, autoVacuum int32) int32 {
	var pBt *struct_BtShared = p.pBt
	var rc int32 = 0
	var av uint8 = uint8(autoVacuum)
	sqlite3BtreeEnter(p)
	if int32(pBt.btsFlags)&2 != 0 && func() int32 {
		if int32(av) != 0 {
			return 1
		} else {
			return 0
		}
	}() != int32(pBt.autoVacuum) {
		rc = int32(8)
	} else {
		pBt.autoVacuum = uint8(func() int32 {
			if int32(av) != 0 {
				return 1
			} else {
				return 0
			}
		}())
		pBt.incrVacuum = uint8(func() int32 {
			if int32(av) == 2 {
				return 1
			} else {
				return 0
			}
		}())
	}
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeGetAutoVacuum(p *struct_Btree) int32 {
	var rc int32
	sqlite3BtreeEnter(p)
	rc = func() int32 {
		if !(p.pBt.autoVacuum != 0) {
			return 0
		} else {
			return func() int32 {
				if !(p.pBt.incrVacuum != 0) {
					return 1
				} else {
					return 2
				}
			}()
		}
	}()
	sqlite3BtreeLeave(p)
	return rc
}
func lockBtree(pBt *struct_BtShared) int32 {
	var rc int32
	var pPage1 *struct_MemPage
	var nPage uint32
	var nPageFile uint32 = uint32(0)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3PagerSharedLock(pBt.pPager)
	if rc != 0 {
		return rc
	}
	rc = btreeGetPage(pBt, uint32(1), &pPage1, 0)
	if rc != 0 {
		return rc
	}
	nPage = sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pPage1.aData)))) + uintptr(28))))
	sqlite3PagerPagecount(pBt.pPager, (*int32)(unsafe.Pointer(&nPageFile)))
	if nPage == uint32(0) || memcmp(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pPage1.aData))))+uintptr(24)))), unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pPage1.aData))))+uintptr(92)))), uint(4)) != 0 {
		nPage = nPageFile
	}
	if pBt.db.flags&uint64(33554432) != uint64(0) {
		nPage = uint32(0)
	}
	if nPage > uint32(0) {
		var pageSize uint32
		var usableSize uint32
		var page1 *uint8 = pPage1.aData
		rc = int32(26)
		if memcmp(unsafe.Pointer(page1), unsafe.Pointer((*int8)(unsafe.Pointer(&zMagicHeader))), uint(16)) != 0 {
			goto page1_init_failed
		}
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(18)))) > 2 {
			pBt.btsFlags |= uint16(1)
		}
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(19)))) > 2 {
			goto page1_init_failed
		}
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(19)))) == 2 && int32(pBt.btsFlags)&32 == 0 {
			var isOpen int32 = 0
			rc = sqlite3PagerOpenWal(pBt.pPager, &isOpen)
			if rc != 0 {
				goto page1_init_failed
			} else if isOpen == 0 {
				releasePageOne(pPage1)
				return int32(0)
			}
			rc = int32(26)
		} else {
		}
		if memcmp(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(21)))), unsafe.Pointer((*int8)(unsafe.Pointer(&[4]int8{'@', ' ', ' ', '\x00'}))), uint(3)) != 0 {
			goto page1_init_failed
		}
		pageSize = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(16))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(17))))<<16)
		if (pageSize-uint32(1))&pageSize != uint32(0) || pageSize > uint32(65536) || pageSize <= uint32(256) {
			goto page1_init_failed
		}
		pBt.btsFlags |= uint16(2)
		func() int {
			_ = 0
			return 0
		}()
		usableSize = pageSize - uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(20))))
		if uint32(pageSize) != pBt.pageSize {
			releasePageOne(pPage1)
			pBt.usableSize = usableSize
			pBt.pageSize = pageSize
			freeTempSpace(pBt)
			rc = sqlite3PagerSetPagesize(pBt.pPager, &pBt.pageSize, int32(pageSize-usableSize))
			return rc
		}
		if nPage > nPageFile {
			if sqlite3WritableSchema(pBt.db) == 0 {
				rc = sqlite3CorruptError(69395)
				goto page1_init_failed
			} else {
				nPage = nPageFile
			}
		}
		if usableSize < uint32(480) {
			goto page1_init_failed
		}
		pBt.pageSize = pageSize
		pBt.usableSize = usableSize
		pBt.autoVacuum = uint8(func() int32 {
			if sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(36+4*4)))) != 0 {
				return 1
			} else {
				return 0
			}
		}())
		pBt.incrVacuum = uint8(func() int32 {
			if sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(page1)) + uintptr(36+7*4)))) != 0 {
				return 1
			} else {
				return 0
			}
		}())
	}
	pBt.maxLocal = uint16((pBt.usableSize-uint32(12))*uint32(64)/uint32(255) - uint32(23))
	pBt.minLocal = uint16((pBt.usableSize-uint32(12))*uint32(32)/uint32(255) - uint32(23))
	pBt.maxLeaf = uint16(pBt.usableSize - uint32(35))
	pBt.minLeaf = uint16((pBt.usableSize-uint32(12))*uint32(32)/uint32(255) - uint32(23))
	if int32(pBt.maxLocal) > 127 {
		pBt.max1bytePayload = uint8(127)
	} else {
		pBt.max1bytePayload = uint8(pBt.maxLocal)
	}
	func() int {
		_ = 0
		return 0
	}()
	pBt.pPage1 = pPage1
	pBt.nPage = nPage
	return int32(0)
page1_init_failed:
	releasePageOne(pPage1)
	pBt.pPage1 = (*struct_MemPage)(nil)
	return rc
}
func unlockBtreeIfUnused(pBt *struct_BtShared) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pBt.inTransaction) == 0 && uintptr(unsafe.Pointer(pBt.pPage1)) != uintptr(unsafe.Pointer(nil)) {
		var pPage1 *struct_MemPage = pBt.pPage1
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pBt.pPage1 = (*struct_MemPage)(nil)
		releasePageOne(pPage1)
	}
}
func newDatabase(pBt *struct_BtShared) int32 {
	var pP1 *struct_MemPage
	var data *uint8
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if pBt.nPage > uint32(0) {
		return int32(0)
	}
	pP1 = pBt.pPage1
	func() int {
		_ = 0
		return 0
	}()
	data = pP1.aData
	rc = sqlite3PagerWrite(pP1.pDbPage)
	if rc != 0 {
		return rc
	}
	__builtin___memcpy_chk(unsafe.Pointer(data), unsafe.Pointer((*int8)(unsafe.Pointer(&zMagicHeader))), 16, __builtin_object_size(unsafe.Pointer(data), 0))
	func() int {
		_ = 0
		return 0
	}()
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(16))) = uint8(pBt.pageSize >> 8 & uint32(255))
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(17))) = uint8(pBt.pageSize >> 16 & uint32(255))
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(18))) = uint8(1)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(19))) = uint8(1)
	func() int {
		_ = 0
		return 0
	}()
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(20))) = uint8(pBt.pageSize - pBt.usableSize)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(21))) = uint8(64)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(22))) = uint8(32)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(23))) = uint8(32)
	__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(24)))), 0, uint(100-24), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(24)))), 0))
	zeroPage(pP1, 1|8|4)
	pBt.btsFlags |= uint16(2)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(36+4*4))), uint32(pBt.autoVacuum))
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(36+7*4))), uint32(pBt.incrVacuum))
	pBt.nPage = uint32(1)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(31))) = uint8(1)
	return int32(0)
}
func sqlite3BtreeNewDb(p *struct_Btree) int32 {
	var rc int32
	sqlite3BtreeEnter(p)
	p.pBt.nPage = uint32(0)
	rc = newDatabase(p.pBt)
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeBeginTrans(p *struct_Btree, wrflag int32, pSchemaVersion *int32) int32 {
	var pBt *struct_BtShared = p.pBt
	var pPager *struct_Pager = pBt.pPager
	var rc int32 = 0
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.inTrans) == 2 || int32(p.inTrans) == 1 && !(wrflag != 0) {
		goto trans_begun
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.db.flags&uint64(33554432) != 0 && int32(sqlite3PagerIsreadonly(pPager)) == 0 {
		pBt.btsFlags &= uint16(^1)
	}
	if int32(pBt.btsFlags)&1 != 0 && wrflag != 0 {
		rc = int32(8)
		goto trans_begun
	}
	{
		var pBlock *struct_sqlite3 = nil
		if wrflag != 0 && int32(pBt.inTransaction) == 2 || int32(pBt.btsFlags)&128 != 0 {
			pBlock = pBt.pWriter.db
		} else if wrflag > 1 {
			var pIter *struct_BtLock
			for pIter = pBt.pLock; pIter != nil; pIter = pIter.pNext {
				if uintptr(unsafe.Pointer(pIter.pBtree)) != uintptr(unsafe.Pointer(p)) {
					pBlock = pIter.pBtree.db
					break
				}
			}
		}
		if pBlock != nil {
			rc = int32(6 | 1<<8)
			goto trans_begun
		}
	}
	rc = querySharedCacheTableLock(p, uint32(1), uint8(1))
	if 0 != rc {
		goto trans_begun
	}
	pBt.btsFlags &= uint16(^16)
	if pBt.nPage == uint32(0) {
		pBt.btsFlags |= uint16(16)
	}
	for {
		for uintptr(unsafe.Pointer(pBt.pPage1)) == uintptr(unsafe.Pointer(nil)) && 0 == func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = lockBtree(pBt)
			return *_cgo_addr
		}() {
		}
		if rc == 0 && wrflag != 0 {
			if int32(pBt.btsFlags)&1 != 0 {
				rc = int32(8)
			} else {
				rc = sqlite3PagerBegin(pPager, func() int32 {
					if wrflag > 1 {
						return 1
					} else {
						return 0
					}
				}(), sqlite3TempInMemory(p.db))
				if rc == 0 {
					rc = newDatabase(pBt)
				} else if rc == 5|2<<8 && int32(pBt.inTransaction) == 0 {
					rc = int32(5)
				}
			}
		}
		if rc != 0 {
			func() int {
				_ = 0
				return 0
			}()
			unlockBtreeIfUnused(pBt)
		}
		if !(rc&255 == 5 && int32(pBt.inTransaction) == 0 && btreeInvokeBusyHandler(unsafe.Pointer(pBt)) != 0) {
			break
		}
	}
	if rc == 0 {
		if int32(p.inTrans) == 0 {
			pBt.nTransaction++
			if p.sharable != 0 {
				func() int {
					_ = 0
					return 0
				}()
				p.lock.eLock = uint8(1)
				p.lock.pNext = pBt.pLock
				pBt.pLock = &p.lock
			}
		}
		p.inTrans = uint8(func() int32 {
			if wrflag != 0 {
				return 2
			} else {
				return 1
			}
		}())
		if int32(p.inTrans) > int32(pBt.inTransaction) {
			pBt.inTransaction = p.inTrans
		}
		if wrflag != 0 {
			var pPage1 *struct_MemPage = pBt.pPage1
			func() int {
				_ = 0
				return 0
			}()
			pBt.pWriter = p
			pBt.btsFlags &= uint16(^64)
			if wrflag > 1 {
				pBt.btsFlags |= uint16(64)
			}
			if pBt.nPage != sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(28)))) {
				rc = sqlite3PagerWrite(pPage1.pDbPage)
				if rc == 0 {
					sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(28))), pBt.nPage)
				}
			}
		}
	}
trans_begun:
	if rc == 0 {
		if pSchemaVersion != nil {
			*pSchemaVersion = int32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(40)))))
		}
		if wrflag != 0 {
			rc = sqlite3PagerOpenSavepoint(pPager, p.db.nSavepoint)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeLeave(p)
	return rc
}
func setChildPtrmaps(pPage *struct_MemPage) int32 {
	var i int32
	var nCell int32
	var rc int32
	var pBt *struct_BtShared = pPage.pBt
	var pgno uint32 = pPage.pgno
	func() int {
		_ = 0
		return 0
	}()
	rc = func() int32 {
		if int32(pPage.isInit) != 0 {
			return 0
		} else {
			return btreeInitPage(pPage)
		}
	}()
	if rc != 0 {
		return rc
	}
	nCell = int32(pPage.nCell)
	for i = int32(0); i < nCell; i++ {
		var pCell *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*i))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*i))))) + uintptr(1))))))))
		ptrmapPutOvflPtr(pPage, pPage, pCell, &rc)
		if !(pPage.leaf != 0) {
			var childPgno uint32 = sqlite3Get4byte(pCell)
			ptrmapPut(pBt, childPgno, uint8(5), pgno, &rc)
		}
	}
	if !(pPage.leaf != 0) {
		var childPgno uint32 = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8))))
		ptrmapPut(pBt, childPgno, uint8(5), pgno, &rc)
	}
	return rc
}
func modifyPagePointer(pPage *struct_MemPage, iFrom uint32, iTo uint32, eType uint8) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(eType) == 4 {
		if sqlite3Get4byte(pPage.aData) != iFrom {
			return sqlite3CorruptError(69816)
		}
		sqlite3Put4byte(pPage.aData, iTo)
	} else {
		var i int32
		var nCell int32
		var rc int32
		rc = func() int32 {
			if int32(pPage.isInit) != 0 {
				return 0
			} else {
				return btreeInitPage(pPage)
			}
		}()
		if rc != 0 {
			return rc
		}
		nCell = int32(pPage.nCell)
		for i = int32(0); i < nCell; i++ {
			var pCell *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*i))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*i))))) + uintptr(1))))))))
			if int32(eType) == 3 {
				var info struct_CellInfo
				pPage.xParseCell(pPage, pCell, &info)
				if uint32(info.nLocal) < info.nPayload {
					if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(info.nSize)))))) > uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(pPage.pBt.usableSize))))) {
						return sqlite3CorruptError(69835)
					}
					if iFrom == sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(info.nSize))))))-uintptr(4)))) {
						sqlite3Put4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(info.nSize))))))-uintptr(4))), iTo)
						break
					}
				}
			} else if sqlite3Get4byte(pCell) == iFrom {
				sqlite3Put4byte(pCell, iTo)
				break
			}
		}
		if i == nCell {
			if int32(eType) != 5 || sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8)))) != iFrom {
				return sqlite3CorruptError(69853)
			}
			sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8))), iTo)
		}
	}
	return int32(0)
}
func relocatePage(pBt *struct_BtShared, pDbPage *struct_MemPage, eType uint8, iPtrPage uint32, iFreePage uint32, isCommit int32) int32 {
	var pPtrPage *struct_MemPage
	var iDbPage uint32 = pDbPage.pgno
	var pPager *struct_Pager = pBt.pPager
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if iDbPage < uint32(3) {
		return sqlite3CorruptError(69888)
	}
	rc = sqlite3PagerMovepage(pPager, pDbPage.pDbPage, iFreePage, isCommit)
	if rc != 0 {
		return rc
	}
	pDbPage.pgno = iFreePage
	if int32(eType) == 5 || int32(eType) == 1 {
		rc = setChildPtrmaps(pDbPage)
		if rc != 0 {
			return rc
		}
	} else {
		var nextOvfl uint32 = sqlite3Get4byte(pDbPage.aData)
		if nextOvfl != uint32(0) {
			ptrmapPut(pBt, nextOvfl, uint8(4), iFreePage, &rc)
			if rc != 0 {
				return rc
			}
		}
	}
	if int32(eType) != 1 {
		rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0)
		if rc != 0 {
			return rc
		}
		rc = sqlite3PagerWrite(pPtrPage.pDbPage)
		if rc != 0 {
			releasePage(pPtrPage)
			return rc
		}
		rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType)
		releasePage(pPtrPage)
		if rc == 0 {
			ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc)
		}
	}
	return rc
}
func incrVacuumStep(pBt *struct_BtShared, nFin uint32, iLastPg uint32, bCommit int32) int32 {
	var nFreeList uint32
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(ptrmapPageno(pBt, iLastPg) == iLastPg) && iLastPg != uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
		var eType uint8
		var iPtrPage uint32
		nFreeList = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(36))))
		if nFreeList == uint32(0) {
			return int32(101)
		}
		rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage)
		if rc != 0 {
			return rc
		}
		if int32(eType) == 1 {
			return sqlite3CorruptError(69986)
		}
		if int32(eType) == 2 {
			if bCommit == 0 {
				var iFreePg uint32
				var pFreePg *struct_MemPage
				rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, uint8(1))
				if rc != 0 {
					return rc
				}
				func() int {
					_ = 0
					return 0
				}()
				releasePage(pFreePg)
			}
		} else {
			var iFreePg uint32
			var pLastPg *struct_MemPage
			var eMode uint8 = uint8(0)
			var iNear uint32 = uint32(0)
			rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0)
			if rc != 0 {
				return rc
			}
			if bCommit == 0 {
				eMode = uint8(2)
				iNear = nFin
			}
			for {
				var pFreePg *struct_MemPage
				rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode)
				if rc != 0 {
					releasePage(pLastPg)
					return rc
				}
				releasePage(pFreePg)
				if !(bCommit != 0 && iFreePg > nFin) {
					break
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit)
			releasePage(pLastPg)
			if rc != 0 {
				return rc
			}
		}
	}
	if bCommit == 0 {
		for {
			iLastPg--
			if !(iLastPg == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) || ptrmapPageno(pBt, iLastPg) == iLastPg) {
				break
			}
		}
		pBt.bDoTruncate = uint8(1)
		pBt.nPage = iLastPg
	}
	return int32(0)
}
func finalDbSize(pBt *struct_BtShared, nOrig uint32, nFree uint32) uint32 {
	var nEntry int32
	var nPtrmap uint32
	var nFin uint32
	nEntry = int32(pBt.usableSize / uint32(5))
	nPtrmap = (nFree - nOrig + ptrmapPageno(pBt, nOrig) + uint32(nEntry)) / uint32(nEntry)
	nFin = nOrig - nFree - nPtrmap
	if nOrig > uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) && nFin < uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
		nFin--
	}
	for ptrmapPageno(pBt, nFin) == nFin || nFin == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
		nFin--
	}
	return nFin
}
func sqlite3BtreeIncrVacuum(p *struct_Btree) int32 {
	var rc int32
	var pBt *struct_BtShared = p.pBt
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	if !(pBt.autoVacuum != 0) {
		rc = int32(101)
	} else {
		var nOrig uint32 = btreePagecount(pBt)
		var nFree uint32 = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(36))))
		var nFin uint32 = finalDbSize(pBt, nOrig, nFree)
		if nOrig < nFin || nFree >= nOrig {
			rc = sqlite3CorruptError(70101)
		} else if nFree > uint32(0) {
			rc = saveAllCursors(pBt, uint32(0), nil)
			if rc == 0 {
				invalidateAllOverflowCache(pBt)
				rc = incrVacuumStep(pBt, nFin, nOrig, 0)
			}
			if rc == 0 {
				rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
				sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(28))), pBt.nPage)
			}
		} else {
			rc = int32(101)
		}
	}
	sqlite3BtreeLeave(p)
	return rc
}
func autoVacuumCommit(p *struct_Btree) int32 {
	var rc int32 = 0
	var pPager *struct_Pager
	var pBt *struct_BtShared
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	pBt = p.pBt
	pPager = pBt.pPager
	func() int {
		_ = 0
		return 0
	}()
	invalidateAllOverflowCache(pBt)
	func() int {
		_ = 0
		return 0
	}()
	if !(pBt.incrVacuum != 0) {
		var nFin uint32
		var nFree uint32
		var nVac uint32
		var iFree uint32
		var nOrig uint32
		nOrig = btreePagecount(pBt)
		if ptrmapPageno(pBt, nOrig) == nOrig || nOrig == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
			return sqlite3CorruptError(70152)
		}
		nFree = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(36))))
		db = p.db
		if db.xAutovacPages != nil {
			var iDb int32
			for iDb = int32(0); iDb < db.nDb; iDb++ {
				if uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt)) == uintptr(unsafe.Pointer(p)) {
					break
				}
			}
			nVac = db.xAutovacPages(db.pAutovacPagesArg, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, nOrig, nFree, pBt.pageSize)
			if nVac > nFree {
				nVac = nFree
			}
			if nVac == uint32(0) {
				return int32(0)
			}
		} else {
			nVac = nFree
		}
		nFin = finalDbSize(pBt, nOrig, nVac)
		if nFin > nOrig {
			return sqlite3CorruptError(70179)
		}
		if nFin < nOrig {
			rc = saveAllCursors(pBt, uint32(0), nil)
		}
		for iFree = nOrig; iFree > nFin && rc == 0; iFree-- {
			rc = incrVacuumStep(pBt, nFin, iFree, func() int32 {
				if nVac == nFree {
					return 1
				} else {
					return 0
				}
			}())
		}
		if (rc == 101 || rc == 0) && nFree > uint32(0) {
			rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
			if nVac == nFree {
				sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(32))), uint32(0))
				sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(36))), uint32(0))
			}
			sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(28))), nFin)
			pBt.bDoTruncate = uint8(1)
			pBt.nPage = nFin
		}
		if rc != 0 {
			sqlite3PagerRollback(pPager)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3BtreeCommitPhaseOne(p *struct_Btree, zSuperJrnl *int8) int32 {
	var rc int32 = 0
	if int32(p.inTrans) == 2 {
		var pBt *struct_BtShared = p.pBt
		sqlite3BtreeEnter(p)
		if pBt.autoVacuum != 0 {
			rc = autoVacuumCommit(p)
			if rc != 0 {
				sqlite3BtreeLeave(p)
				return rc
			}
		}
		if pBt.bDoTruncate != 0 {
			sqlite3PagerTruncateImage(pBt.pPager, pBt.nPage)
		}
		rc = sqlite3PagerCommitPhaseOne(pBt.pPager, zSuperJrnl, 0)
		sqlite3BtreeLeave(p)
	}
	return rc
}
func btreeEndTransaction(p *struct_Btree) {
	var pBt *struct_BtShared = p.pBt
	var db *struct_sqlite3 = p.db
	func() int {
		_ = 0
		return 0
	}()
	pBt.bDoTruncate = uint8(0)
	if int32(p.inTrans) > 0 && db.nVdbeRead > 1 {
		downgradeAllSharedCacheTableLocks(p)
		p.inTrans = uint8(1)
	} else {
		if int32(p.inTrans) != 0 {
			clearAllSharedCacheTableLocks(p)
			pBt.nTransaction--
			if 0 == pBt.nTransaction {
				pBt.inTransaction = uint8(0)
			}
		}
		p.inTrans = uint8(0)
		unlockBtreeIfUnused(pBt)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
}
func sqlite3BtreeCommitPhaseTwo(p *struct_Btree, bCleanup int32) int32 {
	if int32(p.inTrans) == 0 {
		return int32(0)
	}
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.inTrans) == 2 {
		var rc int32
		var pBt *struct_BtShared = p.pBt
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3PagerCommitPhaseTwo(pBt.pPager)
		if rc != 0 && bCleanup == 0 {
			sqlite3BtreeLeave(p)
			return rc
		}
		p.iBDataVersion--
		pBt.inTransaction = uint8(1)
		btreeClearHasContent(pBt)
	}
	btreeEndTransaction(p)
	sqlite3BtreeLeave(p)
	return int32(0)
}
func sqlite3BtreeCommit(p *struct_Btree) int32 {
	var rc int32
	sqlite3BtreeEnter(p)
	rc = sqlite3BtreeCommitPhaseOne(p, nil)
	if rc == 0 {
		rc = sqlite3BtreeCommitPhaseTwo(p, 0)
	}
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeTripAllCursors(pBtree *struct_Btree, errCode int32, writeOnly int32) int32 {
	var p *struct_BtCursor
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if pBtree != nil {
		sqlite3BtreeEnter(pBtree)
		for p = pBtree.pBt.pCursor; p != nil; p = p.pNext {
			if writeOnly != 0 && int32(p.curFlags)&1 == 0 {
				if int32(p.eState) == 0 || int32(p.eState) == 2 {
					rc = saveCursorPosition(p)
					if rc != 0 {
						func() int {
							_ = sqlite3BtreeTripAllCursors(pBtree, rc, 0)
							return 0
						}()
						break
					}
				}
			} else {
				sqlite3BtreeClearCursor(p)
				p.eState = uint8(4)
				p.skipNext = errCode
			}
			btreeReleaseAllCursorPages(p)
		}
		sqlite3BtreeLeave(pBtree)
	}
	return rc
}
func btreeSetNPage(pBt *struct_BtShared, pPage1 *struct_MemPage) {
	var nPage int32 = int32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(28)))))
	if nPage == 0 {
		sqlite3PagerPagecount(pBt.pPager, &nPage)
	}
	pBt.nPage = uint32(nPage)
}
func sqlite3BtreeRollback(p *struct_Btree, tripCode int32, writeOnly int32) int32 {
	var rc int32
	var pBt *struct_BtShared = p.pBt
	var pPage1 *struct_MemPage
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	if tripCode == 0 {
		rc = func() (_cgo_ret int32) {
			_cgo_addr := &tripCode
			*_cgo_addr = saveAllCursors(pBt, uint32(0), nil)
			return *_cgo_addr
		}()
		if rc != 0 {
			writeOnly = int32(0)
		}
	} else {
		rc = int32(0)
	}
	if tripCode != 0 {
		var rc2 int32 = sqlite3BtreeTripAllCursors(p, tripCode, writeOnly)
		func() int {
			_ = 0
			return 0
		}()
		if rc2 != 0 {
			rc = rc2
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.inTrans) == 2 {
		var rc2 int32
		func() int {
			_ = 0
			return 0
		}()
		rc2 = sqlite3PagerRollback(pBt.pPager)
		if rc2 != 0 {
			rc = rc2
		}
		if btreeGetPage(pBt, uint32(1), &pPage1, 0) == 0 {
			btreeSetNPage(pBt, pPage1)
			releasePageOne(pPage1)
		}
		func() int {
			_ = 0
			return 0
		}()
		pBt.inTransaction = uint8(1)
		btreeClearHasContent(pBt)
	}
	btreeEndTransaction(p)
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeBeginStmt(p *struct_Btree, iStatement int32) int32 {
	var rc int32
	var pBt *struct_BtShared = p.pBt
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3PagerOpenSavepoint(pBt.pPager, iStatement)
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeSavepoint(p *struct_Btree, op int32, iSavepoint int32) int32 {
	var rc int32 = 0
	if p != nil && int32(p.inTrans) == 2 {
		var pBt *struct_BtShared = p.pBt
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3BtreeEnter(p)
		if op == 2 {
			rc = saveAllCursors(pBt, uint32(0), nil)
		}
		if rc == 0 {
			rc = sqlite3PagerSavepoint(pBt.pPager, op, iSavepoint)
		}
		if rc == 0 {
			if iSavepoint < 0 && int32(pBt.btsFlags)&16 != 0 {
				pBt.nPage = uint32(0)
			}
			rc = newDatabase(pBt)
			btreeSetNPage(pBt, pBt.pPage1)
			func() int {
				_ = 0
				return 0
			}()
		}
		sqlite3BtreeLeave(p)
	}
	return rc
}
func btreeCursor(p *struct_Btree, iTable uint32, wrFlag int32, pKeyInfo *struct_KeyInfo, pCur *struct_BtCursor) int32 {
	var pBt *struct_BtShared = p.pBt
	var pX *struct_BtCursor
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if iTable <= uint32(1) {
		if iTable < uint32(1) {
			return sqlite3CorruptError(70643)
		} else if btreePagecount(pBt) == uint32(0) {
			func() int {
				_ = 0
				return 0
			}()
			iTable = uint32(0)
		}
	}
	pCur.pgnoRoot = iTable
	pCur.iPage = int8(-1)
	pCur.pKeyInfo = pKeyInfo
	pCur.pBtree = p
	pCur.pBt = pBt
	pCur.curFlags = uint8(0)
	for pX = pBt.pCursor; pX != nil; pX = pX.pNext {
		if pX.pgnoRoot == iTable {
			pX.curFlags |= uint8(32)
			pCur.curFlags = uint8(32)
		}
	}
	pCur.eState = uint8(1)
	pCur.pNext = pBt.pCursor
	pBt.pCursor = pCur
	if wrFlag != 0 {
		pCur.curFlags |= uint8(1)
		pCur.curPagerFlags = uint8(0)
		if uintptr(unsafe.Pointer(pBt.pTmpSpace)) == uintptr(unsafe.Pointer(nil)) {
			return allocateTempSpace(pBt)
		}
	} else {
		pCur.curPagerFlags = uint8(2)
	}
	return int32(0)
}
func btreeCursorWithLock(p *struct_Btree, iTable uint32, wrFlag int32, pKeyInfo *struct_KeyInfo, pCur *struct_BtCursor) int32 {
	var rc int32
	sqlite3BtreeEnter(p)
	rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur)
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeCursor(p *struct_Btree, iTable uint32, wrFlag int32, pKeyInfo *struct_KeyInfo, pCur *struct_BtCursor) int32 {
	if p.sharable != 0 {
		return btreeCursorWithLock(p, iTable, wrFlag, pKeyInfo, pCur)
	} else {
		return btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur)
	}
}
func sqlite3BtreeCursorSize() int32 {
	return int32((296 + uint(7)) & uint(18446744073709551608))
}
func sqlite3BtreeCursorZero(p *struct_BtCursor) {
	__builtin___memset_chk(unsafe.Pointer(p), 0, 32, __builtin_object_size(unsafe.Pointer(p), 0))
}
func sqlite3BtreeCloseCursor(pCur *struct_BtCursor) int32 {
	var pBtree *struct_Btree = pCur.pBtree
	if pBtree != nil {
		var pBt *struct_BtShared = pCur.pBt
		sqlite3BtreeEnter(pBtree)
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pBt.pCursor)) == uintptr(unsafe.Pointer(pCur)) {
			pBt.pCursor = pCur.pNext
		} else {
			var pPrev *struct_BtCursor = pBt.pCursor
			for {
				if uintptr(unsafe.Pointer(pPrev.pNext)) == uintptr(unsafe.Pointer(pCur)) {
					pPrev.pNext = pCur.pNext
					break
				}
				pPrev = pPrev.pNext
				if !(pPrev != nil) {
					break
				}
			}
		}
		btreeReleaseAllCursorPages(pCur)
		unlockBtreeIfUnused(pBt)
		sqlite3_free(unsafe.Pointer(pCur.aOverflow))
		sqlite3_free(pCur.pKey)
		if int32(pBt.openFlags)&4 != 0 && uintptr(unsafe.Pointer(pBt.pCursor)) == uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3BtreeClose(pBtree)
		} else {
			sqlite3BtreeLeave(pBtree)
		}
		pCur.pBtree = (*struct_Btree)(nil)
	}
	return int32(0)
}
func getCellInfo(pCur *struct_BtCursor) {
	if int32(pCur.info.nSize) == 0 {
		pCur.curFlags |= uint8(2)
		btreeParseCell(pCur.pPage, int32(pCur.ix), &pCur.info)
	} else {
	}
}
func sqlite3BtreeCursorIsValidNN(pCur *struct_BtCursor) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if int32(pCur.eState) == 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3BtreeIntegerKey(pCur *struct_BtCursor) int64 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	getCellInfo(pCur)
	return pCur.info.nKey
}
func sqlite3BtreeCursorPin(pCur *struct_BtCursor) {
	func() int {
		_ = 0
		return 0
	}()
	pCur.curFlags |= uint8(64)
}
func sqlite3BtreeCursorUnpin(pCur *struct_BtCursor) {
	func() int {
		_ = 0
		return 0
	}()
	pCur.curFlags &= uint8(^64)
}
func sqlite3BtreePayloadSize(pCur *struct_BtCursor) uint32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	getCellInfo(pCur)
	return pCur.info.nPayload
}
func sqlite3BtreeMaxRecordSize(pCur *struct_BtCursor) int64 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return int64(pCur.pBt.pageSize) * int64(pCur.pBt.nPage)
}
func getOverflowPage(pBt *struct_BtShared, ovfl uint32, ppPage **struct_MemPage, pPgnoNext *uint32) int32 {
	var next uint32 = uint32(0)
	var pPage *struct_MemPage = nil
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pBt.autoVacuum != 0 {
		var pgno uint32
		var iGuess uint32 = ovfl + uint32(1)
		var eType uint8
		for ptrmapPageno(pBt, iGuess) == iGuess || iGuess == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
			iGuess++
		}
		if iGuess <= btreePagecount(pBt) {
			rc = ptrmapGet(pBt, iGuess, &eType, &pgno)
			if rc == 0 && int32(eType) == 4 && pgno == ovfl {
				next = iGuess
				rc = int32(101)
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if rc == 0 {
		rc = btreeGetPage(pBt, ovfl, &pPage, func() int32 {
			if uintptr(unsafe.Pointer(ppPage)) == uintptr(unsafe.Pointer(nil)) {
				return 2
			} else {
				return 0
			}
		}())
		func() int {
			_ = 0
			return 0
		}()
		if rc == 0 {
			next = sqlite3Get4byte(pPage.aData)
		}
	}
	*pPgnoNext = next
	if ppPage != nil {
		*ppPage = pPage
	} else {
		releasePage(pPage)
	}
	return func() int32 {
		if rc == 101 {
			return 0
		} else {
			return rc
		}
	}()
}
func copyPayload(pPayload unsafe.Pointer, pBuf unsafe.Pointer, nByte int32, eOp int32, pDbPage *struct_PgHdr) int32 {
	if eOp != 0 {
		var rc int32 = sqlite3PagerWrite(pDbPage)
		if rc != 0 {
			return rc
		}
		__builtin___memcpy_chk(pPayload, pBuf, uint(nByte), __builtin_object_size(pPayload, 0))
	} else {
		__builtin___memcpy_chk(pBuf, pPayload, uint(nByte), __builtin_object_size(pBuf, 0))
	}
	return int32(0)
}
func accessPayload(pCur *struct_BtCursor, offset uint32, amt uint32, pBuf *uint8, eOp int32) int32 {
	var aPayload *uint8
	var rc int32 = 0
	var iIdx int32 = 0
	var pPage *struct_MemPage = pCur.pPage
	var pBt *struct_BtShared = pCur.pBt
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.ix) >= int32(pPage.nCell) {
		return sqlite3CorruptError(71050)
	}
	func() int {
		_ = 0
		return 0
	}()
	getCellInfo(pCur)
	aPayload = pCur.info.pPayload
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uint64(uintptr(unsafe.Pointer(aPayload))-uintptr(unsafe.Pointer(pPage.aData))) > uint64(pBt.usableSize-uint32(pCur.info.nLocal)) {
		return sqlite3CorruptError(71065)
	}
	if offset < uint32(pCur.info.nLocal) {
		var a int32 = int32(amt)
		if uint32(a)+offset > uint32(pCur.info.nLocal) {
			a = int32(uint32(pCur.info.nLocal) - offset)
		}
		rc = copyPayload(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aPayload)) + uintptr(offset)))), unsafe.Pointer(pBuf), a, eOp, pPage.pDbPage)
		offset = uint32(0)
		*(*uintptr)(unsafe.Pointer(&pBuf)) += uintptr(a)
		amt -= uint32(a)
	} else {
		offset -= uint32(pCur.info.nLocal)
	}
	if rc == 0 && amt > uint32(0) {
		var ovflSize uint32 = pBt.usableSize - uint32(4)
		var nextPage uint32
		nextPage = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aPayload)) + uintptr(pCur.info.nLocal))))
		if int32(pCur.curFlags)&4 == 0 {
			var nOvfl int32 = int32((pCur.info.nPayload - uint32(pCur.info.nLocal) + ovflSize - uint32(1)) / ovflSize)
			if uintptr(unsafe.Pointer(pCur.aOverflow)) == uintptr(unsafe.Pointer(nil)) || nOvfl*int32(4) > sqlite3MallocSize(unsafe.Pointer(pCur.aOverflow)) {
				var aNew *uint32 = (*uint32)(sqlite3Realloc(unsafe.Pointer(pCur.aOverflow), uint64(uint(nOvfl*2)*4)))
				if uintptr(unsafe.Pointer(aNew)) == uintptr(unsafe.Pointer(nil)) {
					return int32(7)
				} else {
					pCur.aOverflow = aNew
				}
			}
			__builtin___memset_chk(unsafe.Pointer(pCur.aOverflow), 0, uint(nOvfl)*4, __builtin_object_size(unsafe.Pointer(pCur.aOverflow), 0))
			pCur.curFlags |= uint8(4)
		} else if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.aOverflow)) + uintptr(offset/ovflSize)*4)) != 0 {
			iIdx = int32(offset / ovflSize)
			nextPage = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.aOverflow)) + uintptr(iIdx)*4))
			offset = offset % ovflSize
		}
		func() int {
			_ = 0
			return 0
		}()
		for nextPage != 0 {
			if nextPage > pBt.nPage {
				return sqlite3CorruptError(71127)
			}
			func() int {
				_ = 0
				return 0
			}()
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.aOverflow)) + uintptr(iIdx)*4)) = nextPage
			if offset >= ovflSize {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.aOverflow)) + uintptr(iIdx+1)*4)) != 0 {
					nextPage = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.aOverflow)) + uintptr(iIdx+1)*4))
				} else {
					rc = getOverflowPage(pBt, nextPage, nil, &nextPage)
				}
				offset -= ovflSize
			} else {
				var a int32 = int32(amt)
				if uint32(a)+offset > ovflSize {
					a = int32(ovflSize - offset)
				}
				{
					var pDbPage *struct_PgHdr
					rc = sqlite3PagerGet(pBt.pPager, nextPage, &pDbPage, func() int32 {
						if eOp == 0 {
							return 2
						} else {
							return 0
						}
					}())
					if rc == 0 {
						aPayload = (*uint8)(sqlite3PagerGetData(pDbPage))
						nextPage = sqlite3Get4byte(aPayload)
						rc = copyPayload(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aPayload)) + uintptr(offset+uint32(4))))), unsafe.Pointer(pBuf), a, eOp, pDbPage)
						sqlite3PagerUnref(pDbPage)
						offset = uint32(0)
					}
				}
				amt -= uint32(a)
				if amt == uint32(0) {
					return rc
				}
				*(*uintptr)(unsafe.Pointer(&pBuf)) += uintptr(a)
			}
			if rc != 0 {
				break
			}
			iIdx++
		}
	}
	if rc == 0 && amt > uint32(0) {
		return sqlite3CorruptError(71212)
	}
	return rc
}
func sqlite3BtreePayload(pCur *struct_BtCursor, offset uint32, amt uint32, pBuf unsafe.Pointer) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return accessPayload(pCur, offset, amt, (*uint8)(pBuf), 0)
}
func accessPayloadChecked(pCur *struct_BtCursor, offset uint32, amt uint32, pBuf unsafe.Pointer) int32 {
	var rc int32
	if int32(pCur.eState) == 1 {
		return int32(4)
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = btreeRestoreCursorPosition(pCur)
	return func() int32 {
		if rc != 0 {
			return rc
		} else {
			return accessPayload(pCur, offset, amt, (*uint8)(pBuf), 0)
		}
	}()
}
func sqlite3BtreePayloadChecked(pCur *struct_BtCursor, offset uint32, amt uint32, pBuf unsafe.Pointer) int32 {
	if int32(pCur.eState) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		return accessPayload(pCur, offset, amt, (*uint8)(pBuf), 0)
	} else {
		return accessPayloadChecked(pCur, offset, amt, pBuf)
	}
}
func fetchPayload(pCur *struct_BtCursor, pAmt *uint32) unsafe.Pointer {
	var amt int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	amt = int32(pCur.info.nLocal)
	if amt > int32(uintptr(unsafe.Pointer(pCur.pPage.aDataEnd))-uintptr(unsafe.Pointer(pCur.info.pPayload))) {
		func() int {
			_ = 0
			return 0
		}()
		amt = func() int32 {
			if 0 > int32(uintptr(unsafe.Pointer(pCur.pPage.aDataEnd))-uintptr(unsafe.Pointer(pCur.info.pPayload))) {
				return 0
			} else {
				return int32(uintptr(unsafe.Pointer(pCur.pPage.aDataEnd)) - uintptr(unsafe.Pointer(pCur.info.pPayload)))
			}
		}()
	}
	*pAmt = uint32(amt)
	return unsafe.Pointer(pCur.info.pPayload)
}
func sqlite3BtreePayloadFetch(pCur *struct_BtCursor, pAmt *uint32) unsafe.Pointer {
	return fetchPayload(pCur, pAmt)
}
func moveToChild(pCur *struct_BtCursor, newPgno uint32) int32 {
	var pBt *struct_BtShared = pCur.pBt
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.iPage) >= 20-1 {
		return sqlite3CorruptError(71351)
	}
	pCur.info.nSize = uint16(0)
	pCur.curFlags &= uint8(^(2 | 4))
	*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pCur.aiIdx)))) + uintptr(pCur.iPage)*2)) = pCur.ix
	*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(pCur.iPage)*8)) = pCur.pPage
	pCur.ix = uint16(0)
	pCur.iPage++
	return getAndInitPage(pBt, newPgno, &pCur.pPage, pCur, int32(pCur.curPagerFlags))
}
func moveToParent(pCur *struct_BtCursor) {
	var pLeaf *struct_MemPage
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pCur.info.nSize = uint16(0)
	pCur.curFlags &= uint8(^(2 | 4))
	pCur.ix = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pCur.aiIdx)))) + uintptr(int32(pCur.iPage)-1)*2))
	pLeaf = pCur.pPage
	pCur.pPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(func() (_cgo_ret int8) {
		_cgo_addr := &pCur.iPage
		*_cgo_addr--
		return *_cgo_addr
	}())*8))
	releasePageNotNull(pLeaf)
}
func moveToRoot(pCur *struct_BtCursor) int32 {
	var pRoot *struct_MemPage
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.iPage) >= 0 {
		if pCur.iPage != 0 {
			releasePageNotNull(pCur.pPage)
			for func() (_cgo_ret int8) {
				_cgo_addr := &pCur.iPage
				*_cgo_addr--
				return *_cgo_addr
			}() != 0 {
				releasePageNotNull(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(pCur.iPage)*8)))
			}
			pRoot = func() (_cgo_ret *struct_MemPage) {
				_cgo_addr := &pCur.pPage
				*_cgo_addr = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(0)*8))
				return *_cgo_addr
			}()
			goto skip_init
		}
	} else if pCur.pgnoRoot == uint32(0) {
		pCur.eState = uint8(1)
		return int32(16)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pCur.eState) >= 3 {
			if int32(pCur.eState) == 4 {
				func() int {
					_ = 0
					return 0
				}()
				return pCur.skipNext
			}
			sqlite3BtreeClearCursor(pCur)
		}
		rc = getAndInitPage(pCur.pBtree.pBt, pCur.pgnoRoot, &pCur.pPage, nil, int32(pCur.curPagerFlags))
		if rc != 0 {
			pCur.eState = uint8(1)
			return rc
		}
		pCur.iPage = int8(0)
		pCur.curIntKey = pCur.pPage.intKey
	}
	pRoot = pCur.pPage
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pRoot.isInit) == 0 || func() int32 {
		if uintptr(unsafe.Pointer(pCur.pKeyInfo)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}() != int32(pRoot.intKey) {
		return sqlite3CorruptError(71489)
	}
skip_init:
	pCur.ix = uint16(0)
	pCur.info.nSize = uint16(0)
	pCur.curFlags &= uint8(^(8 | 2 | 4))
	if int32(pRoot.nCell) > 0 {
		pCur.eState = uint8(0)
	} else if !(pRoot.leaf != 0) {
		var subpage uint32
		if pRoot.pgno != uint32(1) {
			return sqlite3CorruptError(71501)
		}
		subpage = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot.aData)) + uintptr(int32(pRoot.hdrOffset)+8))))
		pCur.eState = uint8(0)
		rc = moveToChild(pCur, subpage)
	} else {
		pCur.eState = uint8(1)
		rc = int32(16)
	}
	return rc
}
func moveToLeftmost(pCur *struct_BtCursor) int32 {
	var pgno uint32
	var rc int32 = 0
	var pPage *struct_MemPage
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for rc == 0 && !(func() (_cgo_ret *struct_MemPage) {
		_cgo_addr := &pPage
		*_cgo_addr = pCur.pPage
		return *_cgo_addr
	}().leaf != 0) {
		func() int {
			_ = 0
			return 0
		}()
		pgno = sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*int32(pCur.ix)))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*int32(pCur.ix)))))) + uintptr(1)))))))))
		rc = moveToChild(pCur, pgno)
	}
	return rc
}
func moveToRightmost(pCur *struct_BtCursor) int32 {
	var pgno uint32
	var rc int32 = 0
	var pPage *struct_MemPage = nil
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for !(func() (_cgo_ret *struct_MemPage) {
		_cgo_addr := &pPage
		*_cgo_addr = pCur.pPage
		return *_cgo_addr
	}().leaf != 0) {
		pgno = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8))))
		pCur.ix = pPage.nCell
		rc = moveToChild(pCur, pgno)
		if rc != 0 {
			return rc
		}
	}
	pCur.ix = uint16(int32(pPage.nCell) - 1)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return int32(0)
}
func sqlite3BtreeFirst(pCur *struct_BtCursor, pRes *int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = moveToRoot(pCur)
	if rc == 0 {
		func() int {
			_ = 0
			return 0
		}()
		*pRes = int32(0)
		rc = moveToLeftmost(pCur)
	} else if rc == 16 {
		func() int {
			_ = 0
			return 0
		}()
		*pRes = int32(1)
		rc = int32(0)
	}
	return rc
}
func sqlite3BtreeLast(pCur *struct_BtCursor, pRes *int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if 0 == int32(pCur.eState) && int32(pCur.curFlags)&8 != 0 {
		*pRes = int32(0)
		return int32(0)
	}
	rc = moveToRoot(pCur)
	if rc == 0 {
		func() int {
			_ = 0
			return 0
		}()
		*pRes = int32(0)
		rc = moveToRightmost(pCur)
		if rc == 0 {
			pCur.curFlags |= uint8(8)
		} else {
			pCur.curFlags &= uint8(^8)
		}
	} else if rc == 16 {
		func() int {
			_ = 0
			return 0
		}()
		*pRes = int32(1)
		rc = int32(0)
	}
	return rc
}
func sqlite3BtreeTableMoveto(pCur *struct_BtCursor, intKey int64, biasRight int32, pRes *int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.eState) == 0 && int32(pCur.curFlags)&2 != 0 {
		if pCur.info.nKey == intKey {
			*pRes = int32(0)
			return int32(0)
		}
		if pCur.info.nKey < intKey {
			if int32(pCur.curFlags)&8 != 0 {
				*pRes = int32(-1)
				return int32(0)
			}
			if pCur.info.nKey+int64(1) == intKey {
				*pRes = int32(0)
				rc = sqlite3BtreeNext(pCur, 0)
				if rc == 0 {
					getCellInfo(pCur)
					if pCur.info.nKey == intKey {
						return int32(0)
					}
				} else if rc != 101 {
					return rc
				}
			}
		}
	}
	rc = moveToRoot(pCur)
	if rc != 0 {
		if rc == 16 {
			func() int {
				_ = 0
				return 0
			}()
			*pRes = int32(-1)
			return int32(0)
		}
		return rc
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for {
		var lwr int32
		var upr int32
		var idx int32
		var c int32
		var chldPg uint32
		var pPage *struct_MemPage = pCur.pPage
		var pCell *uint8
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		lwr = int32(0)
		upr = int32(pPage.nCell) - 1
		func() int {
			_ = 0
			return 0
		}()
		idx = upr >> (1 - biasRight)
		for {
			var nCellKey int64
			pCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aDataOfst)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(1))))))))
			if pPage.intKeyLeaf != 0 {
				for 128 <= int32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &pCell
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) {
					if uintptr(unsafe.Pointer(pCell)) >= uintptr(unsafe.Pointer(pPage.aDataEnd)) {
						return sqlite3CorruptError(71743)
					}
				}
			}
			sqlite3GetVarint(pCell, (*uint64)(unsafe.Pointer(&nCellKey)))
			if nCellKey < intKey {
				lwr = idx + 1
				if lwr > upr {
					c = int32(-1)
					break
				}
			} else if nCellKey > intKey {
				upr = idx - 1
				if lwr > upr {
					c = int32(1)
					break
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				pCur.ix = uint16(idx)
				if !(pPage.leaf != 0) {
					lwr = idx
					goto moveto_table_next_layer
				} else {
					pCur.curFlags |= uint8(2)
					pCur.info.nKey = nCellKey
					pCur.info.nSize = uint16(0)
					*pRes = int32(0)
					return int32(0)
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			idx = (lwr + upr) >> 1
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pPage.leaf != 0 {
			func() int {
				_ = 0
				return 0
			}()
			pCur.ix = uint16(idx)
			*pRes = c
			rc = int32(0)
			goto moveto_table_finish
		}
	moveto_table_next_layer:
		if lwr >= int32(pPage.nCell) {
			chldPg = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8))))
		} else {
			chldPg = sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*lwr))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*lwr))))) + uintptr(1)))))))))
		}
		pCur.ix = uint16(lwr)
		rc = moveToChild(pCur, chldPg)
		if rc != 0 {
			break
		}
	}
moveto_table_finish:
	pCur.info.nSize = uint16(0)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3BtreeIndexMoveto(pCur *struct_BtCursor, pIdxKey *struct_UnpackedRecord, pRes *int32) int32 {
	var rc int32
	var xRecordCompare func(int32, unsafe.Pointer, *struct_UnpackedRecord) int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	xRecordCompare = sqlite3VdbeFindCompare(pIdxKey)
	pIdxKey.errCode = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	rc = moveToRoot(pCur)
	if rc != 0 {
		if rc == 16 {
			func() int {
				_ = 0
				return 0
			}()
			*pRes = int32(-1)
			return int32(0)
		}
		return rc
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for {
		var lwr int32
		var upr int32
		var idx int32
		var c int32
		var chldPg uint32
		var pPage *struct_MemPage = pCur.pPage
		var pCell *uint8
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		lwr = int32(0)
		upr = int32(pPage.nCell) - 1
		idx = upr >> 1
		for {
			var nCell int32
			pCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aDataOfst)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(1))))))))
			nCell = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(0))))
			if nCell <= int32(pPage.max1bytePayload) {
				c = xRecordCompare(nCell, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(1)))), pIdxKey)
			} else if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(1))))&128 != 0) && func() (_cgo_ret int32) {
				_cgo_addr := &nCell
				*_cgo_addr = nCell&127<<7 + int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(1))))
				return *_cgo_addr
			}() <= int32(pPage.maxLocal) {
				c = xRecordCompare(nCell, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(2)))), pIdxKey)
			} else {
				var pCellKey unsafe.Pointer
				var pCellBody *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) - uintptr(int32(pPage.childPtrSize))))
				const nOverrun int32 = 18
				pPage.xParseCell(pPage, pCellBody, &pCur.info)
				nCell = int32(pCur.info.nKey)
				if nCell < 2 || uint32(nCell)/pCur.pBt.usableSize > pCur.pBt.nPage {
					rc = sqlite3CorruptError(71924)
					goto moveto_index_finish
				}
				pCellKey = sqlite3Malloc(uint64(nCell + nOverrun))
				if uintptr(unsafe.Pointer(pCellKey)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
					goto moveto_index_finish
				}
				pCur.ix = uint16(idx)
				rc = accessPayload(pCur, uint32(0), uint32(nCell), (*uint8)(pCellKey), 0)
				__builtin___memset_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pCellKey)))+uintptr(nCell)))), 0, uint(nOverrun), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pCellKey)))+uintptr(nCell)))), 0))
				pCur.curFlags &= uint8(^4)
				if rc != 0 {
					sqlite3_free(pCellKey)
					goto moveto_index_finish
				}
				c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey)
				sqlite3_free(pCellKey)
			}
			func() int {
				_ = 0
				return 0
			}()
			if c < 0 {
				lwr = idx + 1
			} else if c > 0 {
				upr = idx - 1
			} else {
				func() int {
					_ = 0
					return 0
				}()
				*pRes = int32(0)
				rc = int32(0)
				pCur.ix = uint16(idx)
				if pIdxKey.errCode != 0 {
					rc = sqlite3CorruptError(71956)
				}
				goto moveto_index_finish
			}
			if lwr > upr {
				break
			}
			func() int {
				_ = 0
				return 0
			}()
			idx = (lwr + upr) >> 1
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pPage.leaf != 0 {
			func() int {
				_ = 0
				return 0
			}()
			pCur.ix = uint16(idx)
			*pRes = c
			rc = int32(0)
			goto moveto_index_finish
		}
		if lwr >= int32(pPage.nCell) {
			chldPg = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8))))
		} else {
			chldPg = sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*lwr))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*lwr))))) + uintptr(1)))))))))
		}
		pCur.ix = uint16(lwr)
		rc = moveToChild(pCur, chldPg)
		if rc != 0 {
			break
		}
	}
moveto_index_finish:
	pCur.info.nSize = uint16(0)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3BtreeEof(pCur *struct_BtCursor) int32 {
	return func() int32 {
		if 0 != int32(pCur.eState) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3BtreeRowCountEst(pCur *struct_BtCursor) int64 {
	var n int64
	var i uint8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.eState) != 0 {
		return int64(-1)
	}
	if int32(pCur.pPage.leaf) == 0 {
		return int64(-1)
	}
	n = int64(pCur.pPage.nCell)
	for i = uint8(0); int32(i) < int32(pCur.iPage); i++ {
		n *= int64((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(i)*8))).nCell)
	}
	return n
}
func btreeNext(pCur *struct_BtCursor) int32 {
	var rc int32
	var idx int32
	var pPage *struct_MemPage
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.eState) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		rc = func() int32 {
			if int32(pCur.eState) >= 3 {
				return btreeRestoreCursorPosition(pCur)
			} else {
				return 0
			}
		}()
		if rc != 0 {
			return rc
		}
		if 1 == int32(pCur.eState) {
			return int32(101)
		}
		if int32(pCur.eState) == 2 {
			pCur.eState = uint8(0)
			if pCur.skipNext > 0 {
				return int32(0)
			}
		}
	}
	pPage = pCur.pPage
	idx = int32(func() (_cgo_ret uint16) {
		_cgo_addr := &pCur.ix
		*_cgo_addr++
		return *_cgo_addr
	}())
	if !(pPage.isInit != 0) || sqlite3FaultSim(412) != 0 {
		return sqlite3CorruptError(72079)
	}
	if idx >= int32(pPage.nCell) {
		if !(pPage.leaf != 0) {
			rc = moveToChild(pCur, sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8)))))
			if rc != 0 {
				return rc
			}
			return moveToLeftmost(pCur)
		}
		for {
			if int32(pCur.iPage) == 0 {
				pCur.eState = uint8(1)
				return int32(101)
			}
			moveToParent(pCur)
			pPage = pCur.pPage
			if !(int32(pCur.ix) >= int32(pPage.nCell)) {
				break
			}
		}
		if pPage.intKey != 0 {
			return sqlite3BtreeNext(pCur, 0)
		} else {
			return int32(0)
		}
	}
	if pPage.leaf != 0 {
		return int32(0)
	} else {
		return moveToLeftmost(pCur)
	}
}
func sqlite3BtreeNext(pCur *struct_BtCursor, flags int32) int32 {
	var pPage *struct_MemPage
	func() int {
		_ = flags
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pCur.info.nSize = uint16(0)
	pCur.curFlags &= uint8(^(2 | 4))
	if int32(pCur.eState) != 0 {
		return btreeNext(pCur)
	}
	pPage = pCur.pPage
	if int32(func() (_cgo_ret uint16) {
		_cgo_addr := &pCur.ix
		*_cgo_addr++
		return *_cgo_addr
	}()) >= int32(pPage.nCell) {
		pCur.ix--
		return btreeNext(pCur)
	}
	if pPage.leaf != 0 {
		return int32(0)
	} else {
		return moveToLeftmost(pCur)
	}
}
func btreePrevious(pCur *struct_BtCursor) int32 {
	var rc int32
	var pPage *struct_MemPage
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.eState) != 0 {
		rc = func() int32 {
			if int32(pCur.eState) >= 3 {
				return btreeRestoreCursorPosition(pCur)
			} else {
				return 0
			}
		}()
		if rc != 0 {
			return rc
		}
		if 1 == int32(pCur.eState) {
			return int32(101)
		}
		if 2 == int32(pCur.eState) {
			pCur.eState = uint8(0)
			if pCur.skipNext < 0 {
				return int32(0)
			}
		}
	}
	pPage = pCur.pPage
	func() int {
		_ = 0
		return 0
	}()
	if !(pPage.leaf != 0) {
		var idx int32 = int32(pCur.ix)
		rc = moveToChild(pCur, sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(1))))))))))
		if rc != 0 {
			return rc
		}
		rc = moveToRightmost(pCur)
	} else {
		for int32(pCur.ix) == 0 {
			if int32(pCur.iPage) == 0 {
				pCur.eState = uint8(1)
				return int32(101)
			}
			moveToParent(pCur)
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pCur.ix--
		pPage = pCur.pPage
		if int32(pPage.intKey) != 0 && !(pPage.leaf != 0) {
			rc = sqlite3BtreePrevious(pCur, 0)
		} else {
			rc = int32(0)
		}
	}
	return rc
}
func sqlite3BtreePrevious(pCur *struct_BtCursor, flags int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = flags
		return 0
	}()
	pCur.curFlags &= uint8(^(8 | 4 | 2))
	pCur.info.nSize = uint16(0)
	if int32(pCur.eState) != 0 || int32(pCur.ix) == 0 || int32(pCur.pPage.leaf) == 0 {
		return btreePrevious(pCur)
	}
	pCur.ix--
	return int32(0)
}
func allocateBtreePage(pBt *struct_BtShared, ppPage **struct_MemPage, pPgno *uint32, nearby uint32, eMode uint8) int32 {
	var pPage1 *struct_MemPage
	var rc int32
	var n uint32
	var k uint32
	var pTrunk *struct_MemPage = nil
	var pPrevTrunk *struct_MemPage = nil
	var mxPage uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPage1 = pBt.pPage1
	mxPage = btreePagecount(pBt)
	n = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(36))))
	if n >= mxPage {
		return sqlite3CorruptError(72259)
	}
	if n > uint32(0) {
		var iTrunk uint32
		var searchList uint8 = uint8(0)
		var nSearch uint32 = uint32(0)
		if int32(eMode) == 1 {
			if nearby <= mxPage {
				var eType uint8
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				rc = ptrmapGet(pBt, nearby, &eType, nil)
				if rc != 0 {
					return rc
				}
				if int32(eType) == 2 {
					searchList = uint8(1)
				}
			}
		} else if int32(eMode) == 2 {
			searchList = uint8(1)
		}
		rc = sqlite3PagerWrite(pPage1.pDbPage)
		if rc != 0 {
			return rc
		}
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(36))), n-uint32(1))
		for {
			pPrevTrunk = pTrunk
			if pPrevTrunk != nil {
				iTrunk = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPrevTrunk.aData)) + uintptr(0))))
			} else {
				iTrunk = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32))))
			}
			if iTrunk > mxPage || func() (_cgo_ret uint32) {
				_cgo_addr := &nSearch
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}() > n {
				rc = sqlite3CorruptError(72315)
			} else {
				rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0)
			}
			if rc != 0 {
				pTrunk = (*struct_MemPage)(nil)
				goto end_allocate_page
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			k = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(4))))
			if k == uint32(0) && !(searchList != 0) {
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3PagerWrite(pTrunk.pDbPage)
				if rc != 0 {
					goto end_allocate_page
				}
				*pPgno = iTrunk
				__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(0)))), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32)))), 0))
				*ppPage = pTrunk
				pTrunk = (*struct_MemPage)(nil)
			} else if k > uint32(pBt.usableSize/uint32(4)-uint32(2)) {
				rc = sqlite3CorruptError(72344)
				goto end_allocate_page
			} else if int32(searchList) != 0 && (nearby == iTrunk || iTrunk < nearby && int32(eMode) == 2) {
				*pPgno = iTrunk
				*ppPage = pTrunk
				searchList = uint8(0)
				rc = sqlite3PagerWrite(pTrunk.pDbPage)
				if rc != 0 {
					goto end_allocate_page
				}
				if k == uint32(0) {
					if !(pPrevTrunk != nil) {
						__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(0)))), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32)))), 0))
					} else {
						rc = sqlite3PagerWrite(pPrevTrunk.pDbPage)
						if rc != 0 {
							goto end_allocate_page
						}
						__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPrevTrunk.aData)) + uintptr(0)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(0)))), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPrevTrunk.aData)) + uintptr(0)))), 0))
					}
				} else {
					var pNewTrunk *struct_MemPage
					var iNewTrunk uint32 = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(8))))
					if iNewTrunk > mxPage {
						rc = sqlite3CorruptError(72378)
						goto end_allocate_page
					}
					rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0)
					if rc != 0 {
						goto end_allocate_page
					}
					rc = sqlite3PagerWrite(pNewTrunk.pDbPage)
					if rc != 0 {
						releasePage(pNewTrunk)
						goto end_allocate_page
					}
					__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNewTrunk.aData)) + uintptr(0)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(0)))), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNewTrunk.aData)) + uintptr(0)))), 0))
					sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNewTrunk.aData)) + uintptr(4))), k-uint32(1))
					__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNewTrunk.aData)) + uintptr(8)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(12)))), uint((k-uint32(1))*uint32(4)), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNewTrunk.aData)) + uintptr(8)))), 0))
					releasePage(pNewTrunk)
					if !(pPrevTrunk != nil) {
						func() int {
							_ = 0
							return 0
						}()
						sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32))), iNewTrunk)
					} else {
						rc = sqlite3PagerWrite(pPrevTrunk.pDbPage)
						if rc != 0 {
							goto end_allocate_page
						}
						sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPrevTrunk.aData)) + uintptr(0))), iNewTrunk)
					}
				}
				pTrunk = (*struct_MemPage)(nil)
			} else if k > uint32(0) {
				var closest uint32
				var iPage uint32
				var aData *uint8 = pTrunk.aData
				if nearby > uint32(0) {
					var i uint32
					closest = uint32(0)
					if int32(eMode) == 2 {
						for i = uint32(0); i < k; i++ {
							iPage = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(uint32(8)+i*uint32(4)))))
							if iPage <= nearby {
								closest = i
								break
							}
						}
					} else {
						var dist int32
						dist = sqlite3AbsInt32(int32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(8)))) - nearby))
						for i = uint32(1); i < k; i++ {
							var d2 int32 = sqlite3AbsInt32(int32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(uint32(8)+i*uint32(4))))) - nearby))
							if d2 < dist {
								closest = i
								dist = d2
							}
						}
					}
				} else {
					closest = uint32(0)
				}
				iPage = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(uint32(8)+closest*uint32(4)))))
				if iPage > mxPage || iPage < uint32(2) {
					rc = sqlite3CorruptError(72443)
					goto end_allocate_page
				}
				if !(searchList != 0) || (iPage == nearby || iPage < nearby && int32(eMode) == 2) {
					var noContent int32
					*pPgno = iPage
					rc = sqlite3PagerWrite(pTrunk.pDbPage)
					if rc != 0 {
						goto end_allocate_page
					}
					if closest < k-uint32(1) {
						__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(uint32(8)+closest*uint32(4))))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(uint32(4)+k*uint32(4))))), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(uint32(8)+closest*uint32(4))))), 0))
					}
					sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(4))), k-uint32(1))
					noContent = func() int32 {
						if !(btreeGetHasContent(pBt, *pPgno) != 0) {
							return 1
						} else {
							return 0
						}
					}()
					rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent)
					if rc == 0 {
						rc = sqlite3PagerWrite((*ppPage).pDbPage)
						if rc != 0 {
							releasePage(*ppPage)
							*ppPage = (*struct_MemPage)(nil)
						}
					}
					searchList = uint8(0)
				}
			}
			releasePage(pPrevTrunk)
			pPrevTrunk = (*struct_MemPage)(nil)
			if !(searchList != 0) {
				break
			}
		}
	} else {
		var bNoContent int32 = func() int32 {
			if 0 == int32(pBt.bDoTruncate) {
				return 1
			} else {
				return 0
			}
		}()
		rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
		if rc != 0 {
			return rc
		}
		pBt.nPage++
		if pBt.nPage == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
			pBt.nPage++
		}
		if int32(pBt.autoVacuum) != 0 && ptrmapPageno(pBt, pBt.nPage) == pBt.nPage {
			var pPg *struct_MemPage = nil
			func() int {
				_ = 0
				return 0
			}()
			rc = btreeGetUnusedPage(pBt, pBt.nPage, &pPg, bNoContent)
			if rc == 0 {
				rc = sqlite3PagerWrite(pPg.pDbPage)
				releasePage(pPg)
			}
			if rc != 0 {
				return rc
			}
			pBt.nPage++
			if pBt.nPage == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
				pBt.nPage++
			}
		}
		sqlite3Put4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pBt.pPage1.aData))))+uintptr(28))), pBt.nPage)
		*pPgno = pBt.nPage
		func() int {
			_ = 0
			return 0
		}()
		rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent)
		if rc != 0 {
			return rc
		}
		rc = sqlite3PagerWrite((*ppPage).pDbPage)
		if rc != 0 {
			releasePage(*ppPage)
			*ppPage = (*struct_MemPage)(nil)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
end_allocate_page:
	releasePage(pTrunk)
	releasePage(pPrevTrunk)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func freePage2(pBt *struct_BtShared, pMemPage *struct_MemPage, iPage uint32) int32 {
	var pTrunk *struct_MemPage = nil
	var iTrunk uint32 = uint32(0)
	var pPage1 *struct_MemPage = pBt.pPage1
	var pPage *struct_MemPage
	var rc int32
	var nFree uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if iPage < uint32(2) || iPage > pBt.nPage {
		return sqlite3CorruptError(72570)
	}
	if pMemPage != nil {
		pPage = pMemPage
		sqlite3PagerRef(pPage.pDbPage)
	} else {
		pPage = btreePageLookup(pBt, iPage)
	}
	rc = sqlite3PagerWrite(pPage1.pDbPage)
	if rc != 0 {
		goto freepage_out
	}
	nFree = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(36))))
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(36))), nFree+uint32(1))
	if int32(pBt.btsFlags)&4 != 0 {
		if !(pPage != nil) && func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = btreeGetPage(pBt, iPage, &pPage, 0)
			return *_cgo_addr
		}() != 0 || func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3PagerWrite(pPage.pDbPage)
			return *_cgo_addr
		}() != 0 {
			goto freepage_out
		}
		__builtin___memset_chk(unsafe.Pointer(pPage.aData), 0, uint(pPage.pBt.pageSize), __builtin_object_size(unsafe.Pointer(pPage.aData), 0))
	}
	if pBt.autoVacuum != 0 {
		ptrmapPut(pBt, iPage, uint8(2), uint32(0), &rc)
		if rc != 0 {
			goto freepage_out
		}
	}
	if nFree != uint32(0) {
		var nLeaf uint32
		iTrunk = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32))))
		if iTrunk > btreePagecount(pBt) {
			rc = sqlite3CorruptError(72617)
			goto freepage_out
		}
		rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0)
		if rc != 0 {
			goto freepage_out
		}
		nLeaf = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(4))))
		func() int {
			_ = 0
			return 0
		}()
		if nLeaf > uint32(pBt.usableSize)/uint32(4)-uint32(2) {
			rc = sqlite3CorruptError(72628)
			goto freepage_out
		}
		if nLeaf < uint32(pBt.usableSize)/uint32(4)-uint32(8) {
			rc = sqlite3PagerWrite(pTrunk.pDbPage)
			if rc == 0 {
				sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(4))), nLeaf+uint32(1))
				sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrunk.aData)) + uintptr(uint32(8)+nLeaf*uint32(4)))), iPage)
				if pPage != nil && int32(pBt.btsFlags)&4 == 0 {
					sqlite3PagerDontWrite(pPage.pDbPage)
				}
				rc = btreeSetHasContent(pBt, iPage)
			}
			goto freepage_out
		}
	}
	if uintptr(unsafe.Pointer(pPage)) == uintptr(unsafe.Pointer(nil)) && 0 != func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = btreeGetPage(pBt, iPage, &pPage, 0)
		return *_cgo_addr
	}() {
		goto freepage_out
	}
	rc = sqlite3PagerWrite(pPage.pDbPage)
	if rc != 0 {
		goto freepage_out
	}
	sqlite3Put4byte(pPage.aData, iTrunk)
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(4))), uint32(0))
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage1.aData)) + uintptr(32))), iPage)
freepage_out:
	if pPage != nil {
		pPage.isInit = uint8(0)
	}
	releasePage(pPage)
	releasePage(pTrunk)
	return rc
}
func freePage(pPage *struct_MemPage, pRC *int32) {
	if *pRC == 0 {
		*pRC = freePage2(pPage.pBt, pPage, pPage.pgno)
	}
}
func clearCellOverflow(pPage *struct_MemPage, pCell *uint8, pInfo *struct_CellInfo) int32 {
	var pBt *struct_BtShared
	var ovflPgno uint32
	var rc int32
	var nOvfl int32
	var ovflPageSize uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(pInfo.nSize)))))) > uintptr(unsafe.Pointer(pPage.aDataEnd)) {
		return sqlite3CorruptError(72717)
	}
	ovflPgno = sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(pInfo.nSize)))))) - uintptr(4))))
	pBt = pPage.pBt
	func() int {
		_ = 0
		return 0
	}()
	ovflPageSize = pBt.usableSize - uint32(4)
	nOvfl = int32((pInfo.nPayload - uint32(pInfo.nLocal) + ovflPageSize - uint32(1)) / ovflPageSize)
	func() int {
		_ = 0
		return 0
	}()
	for func() (_cgo_ret int32) {
		_cgo_addr := &nOvfl
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() != 0 {
		var iNext uint32 = uint32(0)
		var pOvfl *struct_MemPage = nil
		if ovflPgno < uint32(2) || ovflPgno > btreePagecount(pBt) {
			return sqlite3CorruptError(72734)
		}
		if nOvfl != 0 {
			rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext)
			if rc != 0 {
				return rc
			}
		}
		if (pOvfl != nil || uintptr(unsafe.Pointer(func() (_cgo_ret *struct_MemPage) {
			_cgo_addr := &pOvfl
			*_cgo_addr = btreePageLookup(pBt, ovflPgno)
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil))) && sqlite3PagerPageRefcount(pOvfl.pDbPage) != 1 {
			rc = sqlite3CorruptError(72754)
		} else {
			rc = freePage2(pBt, pOvfl, ovflPgno)
		}
		if pOvfl != nil {
			sqlite3PagerUnref(pOvfl.pDbPage)
		}
		if rc != 0 {
			return rc
		}
		ovflPgno = iNext
	}
	return int32(0)
}
func fillInCell(pPage *struct_MemPage, pCell *uint8, pX *struct_BtreePayload, pnSize *int32) int32 {
	var nPayload int32
	var pSrc *uint8
	var nSrc int32
	var n int32
	var rc int32
	var mn int32
	var spaceLeft int32
	var pToRelease *struct_MemPage
	var pPrior *uint8
	var pPayload *uint8
	var pBt *struct_BtShared
	var pgnoOvfl uint32
	var nHeader int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nHeader = int32(pPage.childPtrSize)
	if pPage.intKey != 0 {
		nPayload = pX.nData + pX.nZero
		pSrc = (*uint8)(pX.pData)
		nSrc = pX.nData
		func() int {
			_ = 0
			return 0
		}()
		nHeader += int32(uint8(func() int32 {
			if uint32(nPayload) < uint32(128) {
				return int32(func() int {
					*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader))) = uint8(nPayload)
					return 1
				}())
			} else {
				return sqlite3PutVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader))), uint64(nPayload))
			}
		}()))
		nHeader += sqlite3PutVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader))), *(*uint64)(unsafe.Pointer(&pX.nKey)))
	} else {
		func() int {
			_ = 0
			return 0
		}()
		nSrc = func() (_cgo_ret int32) {
			_cgo_addr := &nPayload
			*_cgo_addr = int32(pX.nKey)
			return *_cgo_addr
		}()
		pSrc = (*uint8)(pX.pKey)
		nHeader += int32(uint8(func() int32 {
			if uint32(nPayload) < uint32(128) {
				return int32(func() int {
					*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader))) = uint8(nPayload)
					return 1
				}())
			} else {
				return sqlite3PutVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader))), uint64(nPayload))
			}
		}()))
	}
	pPayload = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader)))
	if nPayload <= int32(pPage.maxLocal) {
		n = nHeader + nPayload
		if n < 4 {
			n = int32(4)
		}
		*pnSize = n
		func() int {
			_ = 0
			return 0
		}()
		__builtin___memcpy_chk(unsafe.Pointer(pPayload), unsafe.Pointer(pSrc), uint(nSrc), __builtin_object_size(unsafe.Pointer(pPayload), 0))
		__builtin___memset_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPayload))+uintptr(nSrc)))), 0, uint(nPayload-nSrc), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPayload))+uintptr(nSrc)))), 0))
		return int32(0)
	}
	mn = int32(pPage.minLocal)
	n = int32(uint32(mn) + uint32(nPayload-mn)%(pPage.pBt.usableSize-uint32(4)))
	if n > int32(pPage.maxLocal) {
		n = mn
	}
	spaceLeft = n
	*pnSize = n + nHeader + 4
	pPrior = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(nHeader+n)))
	pToRelease = (*struct_MemPage)(nil)
	pgnoOvfl = uint32(0)
	pBt = pPage.pBt
	for 1 != 0 {
		n = nPayload
		if n > spaceLeft {
			n = spaceLeft
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if nSrc >= n {
			__builtin___memcpy_chk(unsafe.Pointer(pPayload), unsafe.Pointer(pSrc), uint(n), __builtin_object_size(unsafe.Pointer(pPayload), 0))
		} else if nSrc > 0 {
			n = nSrc
			__builtin___memcpy_chk(unsafe.Pointer(pPayload), unsafe.Pointer(pSrc), uint(n), __builtin_object_size(unsafe.Pointer(pPayload), 0))
		} else {
			__builtin___memset_chk(unsafe.Pointer(pPayload), 0, uint(n), __builtin_object_size(unsafe.Pointer(pPayload), 0))
		}
		nPayload -= n
		if nPayload <= 0 {
			break
		}
		*(*uintptr)(unsafe.Pointer(&pPayload)) += uintptr(n)
		*(*uintptr)(unsafe.Pointer(&pSrc)) += uintptr(n)
		nSrc -= n
		spaceLeft -= n
		if spaceLeft == 0 {
			var pOvfl *struct_MemPage = nil
			var pgnoPtrmap uint32 = pgnoOvfl
			if pBt.autoVacuum != 0 {
				for {
					pgnoOvfl++
					if !(ptrmapPageno(pBt, pgnoOvfl) == pgnoOvfl || pgnoOvfl == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1))) {
						break
					}
				}
			}
			rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, uint8(0))
			if int32(pBt.autoVacuum) != 0 && rc == 0 {
				var eType uint8 = uint8(func() int32 {
					if pgnoPtrmap != 0 {
						return 4
					} else {
						return 3
					}
				}())
				ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc)
				if rc != 0 {
					releasePage(pOvfl)
				}
			}
			if rc != 0 {
				releasePage(pToRelease)
				return rc
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3Put4byte(pPrior, pgnoOvfl)
			releasePage(pToRelease)
			pToRelease = pOvfl
			pPrior = pOvfl.aData
			sqlite3Put4byte(pPrior, uint32(0))
			pPayload = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOvfl.aData)) + uintptr(4)))
			spaceLeft = int32(pBt.usableSize - uint32(4))
		}
	}
	releasePage(pToRelease)
	return int32(0)
}
func dropCell(pPage *struct_MemPage, idx int32, sz int32, pRC *int32) {
	var pc uint32
	var data *uint8
	var ptr *uint8
	var rc int32
	var hdr int32
	if *pRC != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	data = pPage.aData
	ptr = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx)))
	func() int {
		_ = 0
		return 0
	}()
	pc = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + uintptr(1)))))
	hdr = int32(pPage.hdrOffset)
	if pc+uint32(sz) > pPage.pBt.usableSize {
		*pRC = sqlite3CorruptError(73013)
		return
	}
	rc = freeSpace(pPage, uint16(pc), uint16(sz))
	if rc != 0 {
		*pRC = rc
		return
	}
	pPage.nCell--
	if int32(pPage.nCell) == 0 {
		__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1)))), 0, uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1)))), 0))
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+7))) = uint8(0)
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))) = uint8(pPage.pBt.usableSize >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1)))
				*_cgo_addr = uint8(pPage.pBt.usableSize)
				return *_cgo_addr
			}()
		}()
		pPage.nFree = int32(pPage.pBt.usableSize - uint32(pPage.hdrOffset) - uint32(pPage.childPtrSize) - uint32(8))
	} else {
		__builtin___memmove_chk(unsafe.Pointer(ptr), unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr))+uintptr(2)))), uint(2*(int32(pPage.nCell)-idx)), __builtin_object_size(unsafe.Pointer(ptr), 0))
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+3))))) + uintptr(0))) = uint8(int32(pPage.nCell) >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+3))))) + uintptr(1)))
				*_cgo_addr = uint8(pPage.nCell)
				return *_cgo_addr
			}()
		}()
		pPage.nFree += int32(2)
	}
}
func insertCell(pPage *struct_MemPage, i int32, pCell *uint8, sz int32, pTemp *uint8, iChild uint32, pRC *int32) {
	var idx int32 = 0
	var j int32
	var data *uint8
	var pIns *uint8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPage.nOverflow) != 0 || sz+2 > pPage.nFree {
		if pTemp != nil {
			__builtin___memcpy_chk(unsafe.Pointer(pTemp), unsafe.Pointer(pCell), uint(sz), __builtin_object_size(unsafe.Pointer(pTemp), 0))
			pCell = pTemp
		}
		if iChild != 0 {
			sqlite3Put4byte(pCell, iChild)
		}
		j = int32(func() (_cgo_ret uint8) {
			_cgo_addr := &pPage.nOverflow
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())
		func() int {
			_ = 0
			return 0
		}()
		*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pPage.apOvfl)))) + uintptr(j)*8)) = pCell
		*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pPage.aiOvfl)))) + uintptr(j)*2)) = uint16(i)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	} else {
		var rc int32 = sqlite3PagerWrite(pPage.pDbPage)
		if rc != 0 {
			*pRC = rc
			return
		}
		func() int {
			_ = 0
			return 0
		}()
		data = pPage.aData
		func() int {
			_ = 0
			return 0
		}()
		rc = allocateSpace(pPage, sz, &idx)
		if rc != 0 {
			*pRC = rc
			return
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pPage.nFree -= int32(uint16(2 + sz))
		if iChild != 0 {
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(idx+4)))), unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(4)))), uint(sz-4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(idx+4)))), 0))
			sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(idx))), iChild)
		} else {
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(idx)))), unsafe.Pointer(pCell), uint(sz), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(idx)))), 0))
		}
		pIns = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(i*2)))
		__builtin___memmove_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIns))+uintptr(2)))), unsafe.Pointer(pIns), uint(2*(int32(pPage.nCell)-i)), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIns))+uintptr(2)))), 0))
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIns)) + uintptr(0))) = uint8(idx >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIns)) + uintptr(1)))
				*_cgo_addr = uint8(idx)
				return *_cgo_addr
			}()
		}()
		pPage.nCell++
		if int32(func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(pPage.hdrOffset)+4)))
			*_cgo_addr++
			return *_cgo_addr
		}()) == 0 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(int32(pPage.hdrOffset)+3)))++
		}
		func() int {
			_ = 0
			return 0
		}()
		if pPage.pBt.autoVacuum != 0 {
			ptrmapPutOvflPtr(pPage, pPage, pCell, pRC)
		}
	}
}

type CellArray = struct_CellArray
type struct_CellArray struct {
	nCell  int32
	pRef   *struct_MemPage
	apCell **uint8
	szCell *uint16
	apEnd  [6]*uint8
	ixNx   [6]int32
}

func populateCellCache(p *struct_CellArray, idx int32, N int32) {
	func() int {
		_ = 0
		return 0
	}()
	for N > 0 {
		func() int {
			_ = 0
			return 0
		}()
		if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(p.szCell)) + uintptr(idx)*2))) == 0 {
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(p.szCell)) + uintptr(idx)*2)) = p.pRef.xCellSize(p.pRef, *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCell)) + uintptr(idx)*8)))
		} else {
			func() int {
				_ = 0
				return 0
			}()
		}
		idx++
		N--
	}
}
func computeCellSize(p *struct_CellArray, N int32) uint16 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(p.szCell)) + uintptr(N)*2)) = p.pRef.xCellSize(p.pRef, *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCell)) + uintptr(N)*8)))
	return *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(p.szCell)) + uintptr(N)*2))
}
func cachedCellSize(p *struct_CellArray, N int32) uint16 {
	func() int {
		_ = 0
		return 0
	}()
	if *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(p.szCell)) + uintptr(N)*2)) != 0 {
		return *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(p.szCell)) + uintptr(N)*2))
	}
	return computeCellSize(p, N)
}
func rebuildPage(pCArray *struct_CellArray, iFirst int32, nCell int32, pPg *struct_MemPage) int32 {
	var hdr int32 = int32(pPg.hdrOffset)
	var aData *uint8 = pPg.aData
	var usableSize int32 = int32(pPg.pBt.usableSize)
	var pEnd *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(usableSize)))
	var i int32 = iFirst
	var j uint32
	var iEnd int32 = i + nCell
	var pCellptr *uint8 = pPg.aCellIdx
	var pTmp *uint8 = (*uint8)(sqlite3PagerTempSpace(pPg.pBt.pPager))
	var pData *uint8
	var k int32
	var pSrcEnd *uint8
	func() int {
		_ = 0
		return 0
	}()
	j = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(1)))))
	if j > uint32(usableSize) {
		j = uint32(0)
	}
	__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTmp)) + uintptr(j)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(j)))), uint(uint32(usableSize)-j), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTmp)) + uintptr(j)))), 0))
	for k = int32(0); *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pCArray.ixNx)))) + uintptr(k)*4)) <= i && k < 3*2; k++ {
	}
	pSrcEnd = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pCArray.apEnd)))) + uintptr(k)*8))
	pData = pEnd
	for 1 != 0 {
		var pCell *uint8 = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.apCell)) + uintptr(i)*8))
		var sz uint16 = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.szCell)) + uintptr(i)*2))
		func() int {
			_ = 0
			return 0
		}()
		if uint64(uintptr(unsafe.Pointer(pCell))) >= uint64(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData))+uintptr(j)))))) && uint64(uintptr(unsafe.Pointer(pCell))) < uint64(uintptr(unsafe.Pointer(pEnd))) {
			if uint64(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(sz))))))) > uint64(uintptr(unsafe.Pointer(pEnd))) {
				return sqlite3CorruptError(73314)
			}
			pCell = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTmp)) + (uintptr(unsafe.Pointer(pCell)) - uintptr(unsafe.Pointer(aData)))))
		} else if uint64(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(int32(sz))))))) > uint64(uintptr(unsafe.Pointer(pSrcEnd))) && uint64(uintptr(unsafe.Pointer(pCell))) < uint64(uintptr(unsafe.Pointer(pSrcEnd))) {
			return sqlite3CorruptError(73319)
		}
		*(*uintptr)(unsafe.Pointer(&pData)) -= uintptr(int32(sz))
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(0))) = uint8((uintptr(unsafe.Pointer(pData)) - uintptr(unsafe.Pointer(aData))) >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(1)))
				*_cgo_addr = uint8(uintptr(unsafe.Pointer(pData)) - uintptr(unsafe.Pointer(aData)))
				return *_cgo_addr
			}()
		}()
		*(*uintptr)(unsafe.Pointer(&pCellptr)) += uintptr(2)
		if uintptr(unsafe.Pointer(pData)) < uintptr(unsafe.Pointer(pCellptr)) {
			return sqlite3CorruptError(73325)
		}
		__builtin___memmove_chk(unsafe.Pointer(pData), unsafe.Pointer(pCell), uint(sz), __builtin_object_size(unsafe.Pointer(pData), 0))
		func() int {
			_ = 0
			return 0
		}()
		i++
		if i >= iEnd {
			break
		}
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pCArray.ixNx)))) + uintptr(k)*4)) <= i {
			k++
			pSrcEnd = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pCArray.apEnd)))) + uintptr(k)*8))
		}
	}
	pPg.nCell = uint16(nCell)
	pPg.nOverflow = uint8(0)
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+1))))) + uintptr(0))) = uint8(0 >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+1))))) + uintptr(1)))
			*_cgo_addr = uint8(0)
			return *_cgo_addr
		}()
	}()
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+3))))) + uintptr(0))) = uint8(int32(pPg.nCell) >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+3))))) + uintptr(1)))
			*_cgo_addr = uint8(pPg.nCell)
			return *_cgo_addr
		}()
	}()
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(0))) = uint8((uintptr(unsafe.Pointer(pData)) - uintptr(unsafe.Pointer(aData))) >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(1)))
			*_cgo_addr = uint8(uintptr(unsafe.Pointer(pData)) - uintptr(unsafe.Pointer(aData)))
			return *_cgo_addr
		}()
	}()
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+7))) = uint8(0)
	return int32(0)
}
func pageInsertArray(pPg *struct_MemPage, pBegin *uint8, ppData **uint8, pCellptr *uint8, iFirst int32, nCell int32, pCArray *struct_CellArray) int32 {
	var i int32 = iFirst
	var aData *uint8 = pPg.aData
	var pData *uint8 = *ppData
	var iEnd int32 = iFirst + nCell
	var k int32
	var pEnd *uint8
	func() int {
		_ = 0
		return 0
	}()
	if iEnd <= iFirst {
		return int32(0)
	}
	for k = int32(0); *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pCArray.ixNx)))) + uintptr(k)*4)) <= i && k < 3*2; k++ {
	}
	pEnd = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pCArray.apEnd)))) + uintptr(k)*8))
	for 1 != 0 {
		var sz int32
		var rc int32
		var pSlot *uint8
		func() int {
			_ = 0
			return 0
		}()
		sz = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.szCell)) + uintptr(i)*2)))
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(1)))) == 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(2)))) == 0 || uintptr(unsafe.Pointer(func() (_cgo_ret *uint8) {
			_cgo_addr := &pSlot
			*_cgo_addr = pageFindSlot(pPg, sz, &rc)
			return *_cgo_addr
		}())) == uintptr(unsafe.Pointer(nil)) {
			if uintptr(unsafe.Pointer(pData))-uintptr(unsafe.Pointer(pBegin)) < uintptr(int(sz)) {
				return int32(1)
			}
			*(*uintptr)(unsafe.Pointer(&pData)) -= uintptr(sz)
			pSlot = pData
		}
		func() int {
			_ = 0
			return 0
		}()
		if uint64(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.apCell)) + uintptr(i)*8))))+uintptr(sz)))))) > uint64(uintptr(unsafe.Pointer(pEnd))) && uint64(uintptr(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.apCell)) + uintptr(i)*8))))) < uint64(uintptr(unsafe.Pointer(pEnd))) {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = sqlite3CorruptError(73410)
				return 0
			}()
			return int32(1)
		}
		__builtin___memmove_chk(unsafe.Pointer(pSlot), unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.apCell)) + uintptr(i)*8))), uint(sz), __builtin_object_size(unsafe.Pointer(pSlot), 0))
		func() uint8 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(0))) = uint8((uintptr(unsafe.Pointer(pSlot)) - uintptr(unsafe.Pointer(aData))) >> 8)
			return func() (_cgo_ret uint8) {
				_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(1)))
				*_cgo_addr = uint8(uintptr(unsafe.Pointer(pSlot)) - uintptr(unsafe.Pointer(aData)))
				return *_cgo_addr
			}()
		}()
		*(*uintptr)(unsafe.Pointer(&pCellptr)) += uintptr(2)
		i++
		if i >= iEnd {
			break
		}
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pCArray.ixNx)))) + uintptr(k)*4)) <= i {
			k++
			pEnd = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pCArray.apEnd)))) + uintptr(k)*8))
		}
	}
	*ppData = pData
	return int32(0)
}
func pageFreeArray(pPg *struct_MemPage, iFirst int32, nCell int32, pCArray *struct_CellArray) int32 {
	var aData *uint8 = pPg.aData
	var pEnd *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(pPg.pBt.usableSize)))
	var pStart *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(int32(pPg.hdrOffset)+8+int32(pPg.childPtrSize))))
	var nRet int32 = 0
	var i int32
	var iEnd int32 = iFirst + nCell
	var pFree *uint8 = nil
	var szFree int32 = 0
	for i = iFirst; i < iEnd; i++ {
		var pCell *uint8 = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.apCell)) + uintptr(i)*8))
		if uint64(uintptr(unsafe.Pointer(pCell))) >= uint64(uintptr(unsafe.Pointer(pStart))) && uint64(uintptr(unsafe.Pointer(pCell))) < uint64(uintptr(unsafe.Pointer(pEnd))) {
			var sz int32
			sz = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(pCArray.szCell)) + uintptr(i)*2)))
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pFree)) != uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(sz))))) {
				if pFree != nil {
					func() int {
						_ = 0
						return 0
					}()
					freeSpace(pPg, uint16(uintptr(unsafe.Pointer(pFree))-uintptr(unsafe.Pointer(aData))), uint16(szFree))
				}
				pFree = pCell
				szFree = sz
				if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pFree))+uintptr(sz))))) > uintptr(unsafe.Pointer(pEnd)) {
					return int32(0)
				}
			} else {
				pFree = pCell
				szFree += sz
			}
			nRet++
		}
	}
	if pFree != nil {
		func() int {
			_ = 0
			return 0
		}()
		freeSpace(pPg, uint16(uintptr(unsafe.Pointer(pFree))-uintptr(unsafe.Pointer(aData))), uint16(szFree))
	}
	return nRet
}
func editPage(pPg *struct_MemPage, iOld int32, iNew int32, nNew int32, pCArray *struct_CellArray) int32 {
	var aData *uint8 = pPg.aData
	var hdr int32 = int32(pPg.hdrOffset)
	var pBegin *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPg.aCellIdx)) + uintptr(nNew*2)))
	var nCell int32 = int32(pPg.nCell)
	var pData *uint8
	var pCellptr *uint8
	var i int32
	var iOldEnd int32 = iOld + int32(pPg.nCell) + int32(pPg.nOverflow)
	var iNewEnd int32 = iNew + nNew
	func() int {
		_ = 0
		return 0
	}()
	if iOld < iNew {
		var nShift int32 = pageFreeArray(pPg, iOld, iNew-iOld, pCArray)
		if nShift > nCell {
			return sqlite3CorruptError(73521)
		}
		__builtin___memmove_chk(unsafe.Pointer(pPg.aCellIdx), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPg.aCellIdx)) + uintptr(nShift*2)))), uint(nCell*2), __builtin_object_size(unsafe.Pointer(pPg.aCellIdx), 0))
		nCell -= nShift
	}
	if iNewEnd < iOldEnd {
		var nTail int32 = pageFreeArray(pPg, iNewEnd, iOldEnd-iNewEnd, pCArray)
		func() int {
			_ = 0
			return 0
		}()
		nCell -= nTail
	}
	pData = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr((int32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(1)))))-1)&65535+1)))
	if uintptr(unsafe.Pointer(pData)) < uintptr(unsafe.Pointer(pBegin)) {
		goto editpage_fail
	}
	if uintptr(unsafe.Pointer(pData)) > uintptr(unsafe.Pointer(pPg.aDataEnd)) {
		goto editpage_fail
	}
	if iNew < iOld {
		var nAdd int32 = func() int32 {
			if nNew < iOld-iNew {
				return nNew
			} else {
				return iOld - iNew
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pCellptr = pPg.aCellIdx
		__builtin___memmove_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(nAdd*2)))), unsafe.Pointer(pCellptr), uint(nCell*2), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(nAdd*2)))), 0))
		if pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew, nAdd, pCArray) != 0 {
			goto editpage_fail
		}
		nCell += nAdd
	}
	for i = int32(0); i < int32(pPg.nOverflow); i++ {
		var iCell int32 = iOld + int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pPg.aiOvfl)))) + uintptr(i)*2))) - iNew
		if iCell >= 0 && iCell < nNew {
			pCellptr = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPg.aCellIdx)) + uintptr(iCell*2)))
			if nCell > iCell {
				__builtin___memmove_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(2)))), unsafe.Pointer(pCellptr), uint((nCell-iCell)*2), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellptr)) + uintptr(2)))), 0))
			}
			nCell++
			cachedCellSize(pCArray, iCell+iNew)
			if pageInsertArray(pPg, pBegin, &pData, pCellptr, iCell+iNew, 1, pCArray) != 0 {
				goto editpage_fail
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	pCellptr = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPg.aCellIdx)) + uintptr(nCell*2)))
	if pageInsertArray(pPg, pBegin, &pData, pCellptr, iNew+nCell, nNew-nCell, pCArray) != 0 {
		goto editpage_fail
	}
	pPg.nCell = uint16(nNew)
	pPg.nOverflow = uint8(0)
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+3))))) + uintptr(0))) = uint8(int32(pPg.nCell) >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+3))))) + uintptr(1)))
			*_cgo_addr = uint8(pPg.nCell)
			return *_cgo_addr
		}()
	}()
	func() uint8 {
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(0))) = uint8((uintptr(unsafe.Pointer(pData)) - uintptr(unsafe.Pointer(aData))) >> 8)
		return func() (_cgo_ret uint8) {
			_cgo_addr := &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(hdr+5))))) + uintptr(1)))
			*_cgo_addr = uint8(uintptr(unsafe.Pointer(pData)) - uintptr(unsafe.Pointer(aData)))
			return *_cgo_addr
		}()
	}()
	return int32(0)
editpage_fail:
	populateCellCache(pCArray, iNew, nNew)
	return rebuildPage(pCArray, iNew, nNew, pPg)
}
func balance_quick(pParent *struct_MemPage, pPage *struct_MemPage, pSpace *uint8) int32 {
	var pBt *struct_BtShared = pPage.pBt
	var pNew *struct_MemPage
	var rc int32
	var pgnoNew uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pPage.nCell) == 0 {
		return sqlite3CorruptError(73634)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = allocateBtreePage(pBt, &pNew, &pgnoNew, uint32(0), uint8(0))
	if rc == 0 {
		var pOut *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pSpace)) + uintptr(4)))
		var pCell *uint8 = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pPage.apOvfl)))) + uintptr(0)*8))
		var szCell uint16 = pPage.xCellSize(pPage, pCell)
		var pStop *uint8
		var b struct_CellArray
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		zeroPage(pNew, 1|4|8)
		b.nCell = int32(1)
		b.pRef = pPage
		b.apCell = &pCell
		b.szCell = &szCell
		*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&b.apEnd)))) + uintptr(0)*8)) = pPage.aDataEnd
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&b.ixNx)))) + uintptr(0)*4)) = int32(2)
		rc = rebuildPage(&b, 0, 1, pNew)
		if rc != 0 {
			releasePage(pNew)
			return rc
		}
		pNew.nFree = int32(pBt.usableSize - uint32(pNew.cellOffset) - uint32(2) - uint32(szCell))
		if pBt.autoVacuum != 0 {
			ptrmapPut(pBt, pgnoNew, uint8(5), pParent.pgno, &rc)
			if int32(szCell) > int32(pNew.minLocal) {
				ptrmapPutOvflPtr(pNew, pNew, pCell, &rc)
			}
		}
		pCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*(int32(pPage.nCell)-1)))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*(int32(pPage.nCell)-1)))))) + uintptr(1))))))))
		pStop = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(9)))
		for int32(*func() (_cgo_ret *uint8) {
			_cgo_addr := &pCell
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr))++
			return
		}())&128 != 0 && uintptr(unsafe.Pointer(pCell)) < uintptr(unsafe.Pointer(pStop)) {
		}
		pStop = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(9)))
		for int32(func() (_cgo_ret uint8) {
			_cgo_addr := &*func() (_cgo_ret *uint8) {
				_cgo_addr := &pOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()
			*_cgo_addr = *func() (_cgo_ret *uint8) {
				_cgo_addr := &pCell
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()
			return *_cgo_addr
		}())&128 != 0 && uintptr(unsafe.Pointer(pCell)) < uintptr(unsafe.Pointer(pStop)) {
		}
		if rc == 0 {
			insertCell(pParent, int32(pParent.nCell), pSpace, int32(uintptr(unsafe.Pointer(pOut))-uintptr(unsafe.Pointer(pSpace))), nil, pPage.pgno, &rc)
		}
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aData)) + uintptr(int32(pParent.hdrOffset)+8))), pgnoNew)
		releasePage(pNew)
	}
	return rc
}
func copyNodeContent(pFrom *struct_MemPage, pTo *struct_MemPage, pRC *int32) {
	if *pRC == 0 {
		var pBt *struct_BtShared = pFrom.pBt
		var aFrom *uint8 = pFrom.aData
		var aTo *uint8 = pTo.aData
		var iFromHdr int32 = int32(pFrom.hdrOffset)
		var iToHdr int32 = func() int32 {
			if pTo.pgno == uint32(1) {
				return 100
			} else {
				return 0
			}
		}()
		var rc int32
		var iData int32
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		iData = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(iFromHdr+5))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(iFromHdr+5))))) + uintptr(1))))
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(iData)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(iData)))), uint(pBt.usableSize-uint32(iData)), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(iData)))), 0))
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(iToHdr)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(iFromHdr)))), uint(int32(pFrom.cellOffset)+2*int32(pFrom.nCell)), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(iToHdr)))), 0))
		pTo.isInit = uint8(0)
		rc = btreeInitPage(pTo)
		if rc == 0 {
			rc = btreeComputeFreeSpace(pTo)
		}
		if rc != 0 {
			*pRC = rc
			return
		}
		if pBt.autoVacuum != 0 {
			*pRC = setChildPtrmaps(pTo)
		}
	}
}
func balance_nonroot(pParent *struct_MemPage, iParentIdx int32, aOvflSpace *uint8, isRoot int32, bBulk int32) int32 {
	var pBt *struct_BtShared
	var nMaxCells int32 = 0
	var nNew int32 = 0
	var nOld int32
	var i int32
	var j int32
	var k int32
	var nxDiv int32
	var rc int32 = 0
	var leafCorrection uint16
	var leafData int32
	var usableSpace int32
	var pageFlags int32
	var iSpace1 int32 = 0
	var iOvflSpace int32 = 0
	var szScratch int32
	var apOld [3]*struct_MemPage
	var apNew [5]*struct_MemPage
	var pRight *uint8
	var apDiv [2]*uint8
	var cntNew [5]int32
	var cntOld [5]int32
	var szNew [5]int32
	var aSpace1 *uint8
	var pgno uint32
	var abDone [5]uint8
	var aPgno [5]uint32
	var aPgOrder [5]uint32
	var aPgFlags [5]uint16
	var b struct_CellArray
	__builtin___memset_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(&abDone))), 0, 5, __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(&abDone))), 0))
	__builtin___memset_chk(unsafe.Pointer(&b), 0, 104, __builtin_object_size(unsafe.Pointer(&b), 0))
	pBt = pParent.pBt
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(aOvflSpace != nil) {
		return int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	i = int32(pParent.nOverflow) + int32(pParent.nCell)
	if i < 2 {
		nxDiv = int32(0)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if iParentIdx == 0 {
			nxDiv = int32(0)
		} else if iParentIdx == i {
			nxDiv = i - 2 + bBulk
		} else {
			nxDiv = iParentIdx - 1
		}
		i = 2 - bBulk
	}
	nOld = i + 1
	if i+nxDiv-int32(pParent.nOverflow) == int32(pParent.nCell) {
		pRight = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aData)) + uintptr(int32(pParent.hdrOffset)+8)))
	} else {
		pRight = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aData)) + uintptr(int32(pParent.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCellIdx)) + uintptr(2*(i+nxDiv-int32(pParent.nOverflow))))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCellIdx)) + uintptr(2*(i+nxDiv-int32(pParent.nOverflow))))))) + uintptr(1))))))))
	}
	pgno = sqlite3Get4byte(pRight)
	for 1 != 0 {
		if rc == 0 {
			rc = getAndInitPage(pBt, pgno, &*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8)), nil, 0)
		}
		if rc != 0 {
			__builtin___memset_chk(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld))), 0, uint(i+1)*8, __builtin_object_size(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld))), 0))
			goto balance_cleanup
		}
		if (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8))).nFree < 0 {
			rc = btreeComputeFreeSpace(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8)))
			if rc != 0 {
				__builtin___memset_chk(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld))), 0, uint(i)*8, __builtin_object_size(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld))), 0))
				goto balance_cleanup
			}
		}
		nMaxCells += int32((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8))).nCell) + int32(32/8)
		if func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}() == 0 {
			break
		}
		if int32(pParent.nOverflow) != 0 && i+nxDiv == int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pParent.aiOvfl)))) + uintptr(0)*2))) {
			*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)) = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pParent.apOvfl)))) + uintptr(0)*8))
			pgno = sqlite3Get4byte(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)))
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) = int32(pParent.xCellSize(pParent, *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8))))
			pParent.nOverflow = uint8(0)
		} else {
			*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)) = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aData)) + uintptr(int32(pParent.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCellIdx)) + uintptr(2*(i+nxDiv-int32(pParent.nOverflow))))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCellIdx)) + uintptr(2*(i+nxDiv-int32(pParent.nOverflow))))))) + uintptr(1))))))))
			pgno = sqlite3Get4byte(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)))
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) = int32(pParent.xCellSize(pParent, *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8))))
			if int32(pBt.btsFlags)&12 != 0 {
				var iOff int32
				iOff = int32(int(uintptr(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)))))) - int32(int(uintptr(unsafe.Pointer(pParent.aData))))
				if iOff+*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) <= int32(pBt.usableSize) {
					__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aOvflSpace)) + uintptr(iOff)))), unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8))), uint(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4))), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aOvflSpace)) + uintptr(iOff)))), 0))
					*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)) = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aOvflSpace)) + (uintptr(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8)))) - uintptr(unsafe.Pointer(pParent.aData)))))
				}
			}
			dropCell(pParent, i+nxDiv-int32(pParent.nOverflow), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)), &rc)
		}
	}
	nMaxCells = (nMaxCells + 3) & ^3
	szScratch = int32(uint(nMaxCells)*8 + uint(nMaxCells)*2 + uint(pBt.pageSize))
	func() int {
		_ = 0
		return 0
	}()
	b.apCell = (**uint8)(sqlite3DbMallocRaw(nil, uint64(szScratch)))
	if uintptr(unsafe.Pointer(b.apCell)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(7)
		goto balance_cleanup
	}
	b.szCell = (*uint16)(unsafe.Pointer(&*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(nMaxCells)*8))))
	aSpace1 = (*uint8)(unsafe.Pointer(&*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(nMaxCells)*2))))
	func() int {
		_ = 0
		return 0
	}()
	b.pRef = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(0)*8))
	leafCorrection = uint16(int32(b.pRef.leaf) * 4)
	leafData = int32(b.pRef.intKeyLeaf)
	for i = int32(0); i < nOld; i++ {
		var pOld *struct_MemPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8))
		var limit int32 = int32(pOld.nCell)
		var aData *uint8 = pOld.aData
		var maskPage uint16 = pOld.maskPage
		var piCell *uint8 = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(int32(pOld.cellOffset))))
		var piEnd *uint8
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOld.aData)) + uintptr(0)))) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(0)*8))).aData)) + uintptr(0)))) {
			rc = sqlite3CorruptError(74057)
			goto balance_cleanup
		}
		__builtin___memset_chk(unsafe.Pointer(&*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2))), 0, 2*uint(limit+int32(pOld.nOverflow)), __builtin_object_size(unsafe.Pointer(&*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2))), 0))
		if int32(pOld.nOverflow) > 0 {
			if limit < int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pOld.aiOvfl)))) + uintptr(0)*2))) {
				rc = sqlite3CorruptError(74081)
				goto balance_cleanup
			}
			limit = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pOld.aiOvfl)))) + uintptr(0)*2)))
			for j = int32(0); j < limit; j++ {
				*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(b.nCell)*8)) = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(int32(maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(piCell)) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(piCell)) + uintptr(1))))))))
				*(*uintptr)(unsafe.Pointer(&piCell)) += uintptr(2)
				b.nCell++
			}
			for k = int32(0); k < int32(pOld.nOverflow); k++ {
				func() int {
					_ = 0
					return 0
				}()
				*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(b.nCell)*8)) = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&pOld.apOvfl)))) + uintptr(k)*8))
				b.nCell++
			}
		}
		piEnd = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData))+uintptr(int32(pOld.cellOffset)))))) + uintptr(2*int32(pOld.nCell))))
		for uintptr(unsafe.Pointer(piCell)) < uintptr(unsafe.Pointer(piEnd)) {
			func() int {
				_ = 0
				return 0
			}()
			*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(b.nCell)*8)) = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(int32(maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(piCell)) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(piCell)) + uintptr(1))))))))
			*(*uintptr)(unsafe.Pointer(&piCell)) += uintptr(2)
			b.nCell++
		}
		func() int {
			_ = 0
			return 0
		}()
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(i)*4)) = b.nCell
		if i < nOld-1 && !(leafData != 0) {
			var sz uint16 = uint16(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)))
			var pTemp *uint8
			func() int {
				_ = 0
				return 0
			}()
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2)) = sz
			pTemp = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aSpace1)) + uintptr(iSpace1)))
			iSpace1 += int32(sz)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memcpy_chk(unsafe.Pointer(pTemp), unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&apDiv)))) + uintptr(i)*8))), uint(sz), __builtin_object_size(unsafe.Pointer(pTemp), 0))
			*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(b.nCell)*8)) = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTemp)) + uintptr(int32(leafCorrection))))
			func() int {
				_ = 0
				return 0
			}()
			*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2)) = uint16(int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2))) - int32(leafCorrection))
			if !(pOld.leaf != 0) {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				__builtin___memcpy_chk(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(b.nCell)*8))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOld.aData)) + uintptr(8)))), uint(4), __builtin_object_size(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(b.nCell)*8))), 0))
			} else {
				func() int {
					_ = 0
					return 0
				}()
				for int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2))) < 4 {
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aSpace1)) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &iSpace1
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()))) = uint8(0)
					*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(b.nCell)*2))++
				}
			}
			b.nCell++
		}
	}
	usableSpace = int32(pBt.usableSize - uint32(12) + uint32(leafCorrection))
	for i = func() (_cgo_ret int32) {
		_cgo_addr := &k
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}(); i < nOld; func() int32 {
		i++
		return func() (_cgo_ret int32) {
			_cgo_addr := &k
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		var p *struct_MemPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8))
		*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&b.apEnd)))) + uintptr(k)*8)) = p.aDataEnd
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&b.ixNx)))) + uintptr(k)*4)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(i)*4))
		if k != 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&b.ixNx)))) + uintptr(k)*4)) == *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&b.ixNx)))) + uintptr(k-1)*4)) {
			k--
		}
		if !(leafData != 0) {
			k++
			*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&b.apEnd)))) + uintptr(k)*8)) = pParent.aDataEnd
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&b.ixNx)))) + uintptr(k)*4)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(i)*4)) + 1
		}
		func() int {
			_ = 0
			return 0
		}()
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) = usableSpace - p.nFree
		for j = int32(0); j < int32(p.nOverflow); j++ {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) += 2 + int32(p.xCellSize(p, *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&p.apOvfl)))) + uintptr(j)*8))))
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4)) = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(i)*4))
	}
	k = nOld
	for i = int32(0); i < k; i++ {
		var sz int32
		for *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) > usableSpace {
			if i+1 >= k {
				k = i + 2
				if k > 3+2 {
					rc = sqlite3CorruptError(74182)
					goto balance_cleanup
				}
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(k-1)*4)) = int32(0)
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(k-1)*4)) = b.nCell
			}
			sz = 2 + int32(cachedCellSize(&b, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))-1))
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) -= sz
			if !(leafData != 0) {
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4)) < b.nCell {
					sz = 2 + int32(cachedCellSize(&b, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))))
				} else {
					sz = int32(0)
				}
			}
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i+1)*4)) += sz
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))--
		}
		for *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4)) < b.nCell {
			sz = 2 + int32(cachedCellSize(&b, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))))
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4))+sz > usableSpace {
				break
			}
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) += sz
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))++
			if !(leafData != 0) {
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4)) < b.nCell {
					sz = 2 + int32(cachedCellSize(&b, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))))
				} else {
					sz = int32(0)
				}
			}
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i+1)*4)) -= sz
		}
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4)) >= b.nCell {
			k = i + 1
		} else if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4)) <= func() int32 {
			if i > 0 {
				return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i-1)*4))
			} else {
				return 0
			}
		}() {
			rc = sqlite3CorruptError(74215)
			goto balance_cleanup
		}
	}
	for i = k - 1; i > 0; i-- {
		var szRight int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4))
		var szLeft int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i-1)*4))
		var r int32
		var d int32
		r = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i-1)*4)) - 1
		d = r + 1 - leafData
		func() int {
			_ = cachedCellSize(&b, d)
			return 0
		}()
		for {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = cachedCellSize(&b, r)
				return 0
			}()
			if szRight != 0 && (bBulk != 0 || szRight+int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(d)*2)))+2 > szLeft-(int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(r)*2)))+func() int32 {
				if i == k-1 {
					return 0
				} else {
					return 2
				}
			}())) {
				break
			}
			szRight += int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(d)*2))) + 2
			szLeft -= int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(r)*2))) + 2
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i-1)*4)) = r
			r--
			d--
			if !(r >= 0) {
				break
			}
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i)*4)) = szRight
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(i-1)*4)) = szLeft
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i-1)*4)) <= func() int32 {
			if i > 1 {
				return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i-2)*4))
			} else {
				return 0
			}
		}() {
			rc = sqlite3CorruptError(74257)
			goto balance_cleanup
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	pageFlags = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(0)*8))).aData)) + uintptr(0))))
	for i = int32(0); i < k; i++ {
		var pNew *struct_MemPage
		if i < nOld {
			pNew = func() (_cgo_ret *struct_MemPage) {
				_cgo_addr := &*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))
				*_cgo_addr = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8))
				return *_cgo_addr
			}()
			*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8)) = (*struct_MemPage)(nil)
			rc = sqlite3PagerWrite(pNew.pDbPage)
			nNew++
			if sqlite3PagerPageRefcount(pNew.pDbPage) != 1+func() int32 {
				if i == iParentIdx-nxDiv {
					return 1
				} else {
					return 0
				}
			}() && rc == 0 {
				rc = sqlite3CorruptError(74290)
			}
			if rc != 0 {
				goto balance_cleanup
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			rc = allocateBtreePage(pBt, &pNew, &pgno, func() uint32 {
				if bBulk != 0 {
					return uint32(1)
				} else {
					return pgno
				}
			}(), uint8(0))
			if rc != 0 {
				goto balance_cleanup
			}
			zeroPage(pNew, pageFlags)
			*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8)) = pNew
			nNew++
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(i)*4)) = b.nCell
			if pBt.autoVacuum != 0 {
				ptrmapPut(pBt, pNew.pgno, uint8(5), pParent.pgno, &rc)
				if rc != 0 {
					goto balance_cleanup
				}
			}
		}
	}
	for i = int32(0); i < nNew; i++ {
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgOrder)))) + uintptr(i)*4)) = func() (_cgo_ret uint32) {
			_cgo_addr := &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgno)))) + uintptr(i)*4))
			*_cgo_addr = (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))).pgno
			return *_cgo_addr
		}()
		*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aPgFlags)))) + uintptr(i)*2)) = (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))).pDbPage.flags
		for j = int32(0); j < i; j++ {
			if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgno)))) + uintptr(j)*4)) == *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgno)))) + uintptr(i)*4)) {
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3CorruptError(74336)
				goto balance_cleanup
			}
		}
	}
	for i = int32(0); i < nNew; i++ {
		var iBest int32 = 0
		for j = int32(1); j < nNew; j++ {
			if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgOrder)))) + uintptr(j)*4)) < *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgOrder)))) + uintptr(iBest)*4)) {
				iBest = j
			}
		}
		pgno = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgOrder)))) + uintptr(iBest)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgOrder)))) + uintptr(iBest)*4)) = uint32(4294967295)
		if iBest != i {
			if iBest > i {
				sqlite3PagerRekey((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(iBest)*8))).pDbPage, pBt.nPage+uint32(iBest)+uint32(1), uint16(0))
			}
			sqlite3PagerRekey((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))).pDbPage, pgno, *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aPgFlags)))) + uintptr(iBest)*2)))
			(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))).pgno = pgno
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3Put4byte(pRight, (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(nNew-1)*8))).pgno)
	if pageFlags&8 == 0 && nOld != nNew {
		var pOld *struct_MemPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer(func() **struct_MemPage {
			if nNew > nOld {
				return (**struct_MemPage)(unsafe.Pointer(&apNew))
			} else {
				return (**struct_MemPage)(unsafe.Pointer(&apOld))
			}
		}())) + uintptr(nOld-1)*8))
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(nNew-1)*8))).aData)) + uintptr(8)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOld.aData)) + uintptr(8)))), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(nNew-1)*8))).aData)) + uintptr(8)))), 0))
	}
	if pBt.autoVacuum != 0 {
		var pOld *struct_MemPage
		var pNew *struct_MemPage = func() (_cgo_ret *struct_MemPage) {
			_cgo_addr := &pOld
			*_cgo_addr = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(0)*8))
			return *_cgo_addr
		}()
		var cntOldNext int32 = int32(pNew.nCell) + int32(pNew.nOverflow)
		var iNew int32 = 0
		var iOld int32 = 0
		for i = int32(0); i < b.nCell; i++ {
			var pCell *uint8 = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(i)*8))
			for i == cntOldNext {
				iOld++
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pOld = func() *struct_MemPage {
					if iOld < nNew {
						return *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(iOld)*8))
					} else {
						return *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(iOld)*8))
					}
				}()
				cntOldNext += int32(pOld.nCell) + int32(pOld.nOverflow) + func() int32 {
					if !(leafData != 0) {
						return 1
					} else {
						return 0
					}
				}()
			}
			if i == *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(iNew)*4)) {
				pNew = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &iNew
					*_cgo_addr++
					return *_cgo_addr
				}())*8))
				if !(leafData != 0) {
					continue
				}
			}
			if iOld >= nNew || pNew.pgno != *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aPgno)))) + uintptr(iOld)*4)) || !(uint64(uintptr(unsafe.Pointer(pCell))) >= uint64(uintptr(unsafe.Pointer(pOld.aData))) && uint64(uintptr(unsafe.Pointer(pCell))) < uint64(uintptr(unsafe.Pointer(pOld.aDataEnd)))) {
				if !(leafCorrection != 0) {
					ptrmapPut(pBt, sqlite3Get4byte(pCell), uint8(5), pNew.pgno, &rc)
				}
				if int32(cachedCellSize(&b, i)) > int32(pNew.minLocal) {
					ptrmapPutOvflPtr(pNew, pOld, pCell, &rc)
				}
				if rc != 0 {
					goto balance_cleanup
				}
			}
		}
	}
	for i = int32(0); i < nNew-1; i++ {
		var pCell *uint8
		var pTemp *uint8
		var sz int32
		var pSrcEnd *uint8
		var pNew *struct_MemPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))
		j = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(i)*4))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pCell = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(j)*8))
		sz = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(j)*2))) + int32(leafCorrection)
		pTemp = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aOvflSpace)) + uintptr(iOvflSpace)))
		if !(pNew.leaf != 0) {
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aData)) + uintptr(8)))), unsafe.Pointer(pCell), uint(4), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aData)) + uintptr(8)))), 0))
		} else if leafData != 0 {
			var info struct_CellInfo
			j--
			pNew.xParseCell(pNew, *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(b.apCell)) + uintptr(j)*8)), &info)
			pCell = pTemp
			sz = 4 + sqlite3PutVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(4))), uint64(info.nKey))
			pTemp = (*uint8)(nil)
		} else {
			*(*uintptr)(unsafe.Pointer(&pCell)) -= uintptr(4)
			if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer(b.szCell)) + uintptr(j)*2))) == 4 {
				func() int {
					_ = 0
					return 0
				}()
				sz = int32(pParent.xCellSize(pParent, pCell))
			}
		}
		iOvflSpace += sz
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		for k = int32(0); *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&b.ixNx)))) + uintptr(k)*4)) <= i && k < 3*2; k++ {
		}
		pSrcEnd = *(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((**uint8)(unsafe.Pointer(&b.apEnd)))) + uintptr(k)*8))
		if uint64(uintptr(unsafe.Pointer(pSrcEnd))) >= uint64(uintptr(unsafe.Pointer(pCell))) && uint64(uintptr(unsafe.Pointer(pSrcEnd))) < uint64(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))+uintptr(sz)))))) {
			rc = sqlite3CorruptError(74493)
			goto balance_cleanup
		}
		insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew.pgno, &rc)
		if rc != 0 {
			goto balance_cleanup
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	for i = 1 - nNew; i < nNew; i++ {
		var iPg int32 = func() int32 {
			if i < 0 {
				return -i
			} else {
				return i
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&abDone)))) + uintptr(iPg))) != 0 {
			continue
		}
		if i >= 0 || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(iPg-1)*4)) >= *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(iPg-1)*4)) {
			var iNew int32
			var iOld int32
			var nNewCell int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if iPg == 0 {
				iNew = func() (_cgo_ret int32) {
					_cgo_addr := &iOld
					*_cgo_addr = int32(0)
					return *_cgo_addr
				}()
				nNewCell = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(0)*4))
			} else {
				iOld = func() int32 {
					if iPg < nOld {
						return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntOld)))) + uintptr(iPg-1)*4)) + func() int32 {
							if !(leafData != 0) {
								return 1
							} else {
								return 0
							}
						}()
					} else {
						return b.nCell
					}
				}()
				iNew = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(iPg-1)*4)) + func() int32 {
					if !(leafData != 0) {
						return 1
					} else {
						return 0
					}
				}()
				nNewCell = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&cntNew)))) + uintptr(iPg)*4)) - iNew
			}
			rc = editPage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(iPg)*8)), iOld, iNew, nNewCell, &b)
			if rc != 0 {
				goto balance_cleanup
			}
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&abDone)))) + uintptr(iPg)))++
			(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(iPg)*8))).nFree = usableSpace - *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&szNew)))) + uintptr(iPg)*4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if isRoot != 0 && int32(pParent.nCell) == 0 && int32(pParent.hdrOffset) <= (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(0)*8))).nFree {
		func() int {
			_ = 0
			return 0
		}()
		rc = defragmentPage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(0)*8)), -1)
		func() int {
			_ = 0
			return 0
		}()
		copyNodeContent(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(0)*8)), pParent, &rc)
		freePage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(0)*8)), &rc)
	} else if int32(pBt.autoVacuum) != 0 && !(leafCorrection != 0) {
		for i = int32(0); i < nNew; i++ {
			var key uint32 = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))).aData)) + uintptr(8))))
			ptrmapPut(pBt, key, uint8(5), (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8))).pgno, &rc)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	for i = nNew; i < nOld; i++ {
		freePage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8)), &rc)
	}
balance_cleanup:
	sqlite3DbFree(nil, unsafe.Pointer(b.apCell))
	for i = int32(0); i < nOld; i++ {
		releasePage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apOld)))) + uintptr(i)*8)))
	}
	for i = int32(0); i < nNew; i++ {
		releasePage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&apNew)))) + uintptr(i)*8)))
	}
	return rc
}
func balance_deeper(pRoot *struct_MemPage, ppChild **struct_MemPage) int32 {
	var rc int32
	var pChild *struct_MemPage = nil
	var pgnoChild uint32 = uint32(0)
	var pBt *struct_BtShared = pRoot.pBt
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3PagerWrite(pRoot.pDbPage)
	if rc == 0 {
		rc = allocateBtreePage(pBt, &pChild, &pgnoChild, pRoot.pgno, uint8(0))
		copyNodeContent(pRoot, pChild, &rc)
		if pBt.autoVacuum != 0 {
			ptrmapPut(pBt, pgnoChild, uint8(5), pRoot.pgno, &rc)
		}
	}
	if rc != 0 {
		*ppChild = (*struct_MemPage)(nil)
		releasePage(pChild)
		return rc
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memcpy_chk(unsafe.Pointer((*uint16)(unsafe.Pointer(&pChild.aiOvfl))), unsafe.Pointer((*uint16)(unsafe.Pointer(&pRoot.aiOvfl))), uint(pRoot.nOverflow)*2, __builtin_object_size(unsafe.Pointer((*uint16)(unsafe.Pointer(&pChild.aiOvfl))), 0))
	__builtin___memcpy_chk(unsafe.Pointer((**uint8)(unsafe.Pointer(&pChild.apOvfl))), unsafe.Pointer((**uint8)(unsafe.Pointer(&pRoot.apOvfl))), uint(pRoot.nOverflow)*8, __builtin_object_size(unsafe.Pointer((**uint8)(unsafe.Pointer(&pChild.apOvfl))), 0))
	pChild.nOverflow = pRoot.nOverflow
	zeroPage(pRoot, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pChild.aData)) + uintptr(0)))) & ^8)
	sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot.aData)) + uintptr(int32(pRoot.hdrOffset)+8))), pgnoChild)
	*ppChild = pChild
	return int32(0)
}
func anotherValidCursor(pCur *struct_BtCursor) int32 {
	var pOther *struct_BtCursor
	for pOther = pCur.pBt.pCursor; pOther != nil; pOther = pOther.pNext {
		if uintptr(unsafe.Pointer(pOther)) != uintptr(unsafe.Pointer(pCur)) && int32(pOther.eState) == 0 && uintptr(unsafe.Pointer(pOther.pPage)) == uintptr(unsafe.Pointer(pCur.pPage)) {
			return sqlite3CorruptError(74723)
		}
	}
	return int32(0)
}
func balance(pCur *struct_BtCursor) int32 {
	var rc int32 = 0
	var nMin int32 = int32(pCur.pBt.usableSize * uint32(2) / uint32(3))
	var aBalanceQuickSpace [13]uint8
	var pFree *uint8 = nil
	for {
		var iPage int32
		var pPage *struct_MemPage = pCur.pPage
		if pPage.nFree < 0 && btreeComputeFreeSpace(pPage) != 0 {
			break
		}
		if int32(pPage.nOverflow) == 0 && pPage.nFree <= nMin {
			break
		} else if func() (_cgo_ret int32) {
			_cgo_addr := &iPage
			*_cgo_addr = int32(pCur.iPage)
			return *_cgo_addr
		}() == 0 {
			if int32(pPage.nOverflow) != 0 && func() (_cgo_ret int32) {
				_cgo_addr := &rc
				*_cgo_addr = anotherValidCursor(pCur)
				return *_cgo_addr
			}() == 0 {
				func() int {
					_ = 0
					return 0
				}()
				rc = balance_deeper(pPage, &*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(1)*8)))
				if rc == 0 {
					pCur.iPage = int8(1)
					pCur.ix = uint16(0)
					*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pCur.aiIdx)))) + uintptr(0)*2)) = uint16(0)
					*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(0)*8)) = pPage
					pCur.pPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(1)*8))
					func() int {
						_ = 0
						return 0
					}()
				}
			} else {
				break
			}
		} else {
			var pParent *struct_MemPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(iPage-1)*8))
			var iIdx int32 = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pCur.aiIdx)))) + uintptr(iPage-1)*2)))
			rc = sqlite3PagerWrite(pParent.pDbPage)
			if rc == 0 && pParent.nFree < 0 {
				rc = btreeComputeFreeSpace(pParent)
			}
			if rc == 0 {
				if int32(pPage.intKeyLeaf) != 0 && int32(pPage.nOverflow) == 1 && int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&pPage.aiOvfl)))) + uintptr(0)*2))) == int32(pPage.nCell) && pParent.pgno != uint32(1) && int32(pParent.nCell) == iIdx {
					func() int {
						_ = 0
						return 0
					}()
					rc = balance_quick(pParent, pPage, (*uint8)(unsafe.Pointer(&aBalanceQuickSpace)))
				} else {
					var pSpace *uint8 = (*uint8)(sqlite3PageMalloc(int32(pCur.pBt.pageSize)))
					rc = balance_nonroot(pParent, iIdx, pSpace, func() int32 {
						if iPage == 1 {
							return 1
						} else {
							return 0
						}
					}(), int32(pCur.hints)&1)
					if pFree != nil {
						sqlite3PageFree(unsafe.Pointer(pFree))
					}
					pFree = pSpace
				}
			}
			pPage.nOverflow = uint8(0)
			releasePage(pPage)
			pCur.iPage--
			func() int {
				_ = 0
				return 0
			}()
			pCur.pPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(pCur.iPage)*8))
		}
		if !(rc == 0) {
			break
		}
	}
	if pFree != nil {
		sqlite3PageFree(unsafe.Pointer(pFree))
	}
	return rc
}
func btreeOverwriteContent(pPage *struct_MemPage, pDest *uint8, pX *struct_BtreePayload, iOffset int32, iAmt int32) int32 {
	var nData int32 = pX.nData - iOffset
	if nData <= 0 {
		var i int32
		for i = int32(0); i < iAmt && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest)) + uintptr(i)))) == 0; i++ {
		}
		if i < iAmt {
			var rc int32 = sqlite3PagerWrite(pPage.pDbPage)
			if rc != 0 {
				return rc
			}
			__builtin___memset_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest))+uintptr(i)))), 0, uint(iAmt-i), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest))+uintptr(i)))), 0))
		}
	} else {
		if nData < iAmt {
			var rc int32 = btreeOverwriteContent(pPage, (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest))+uintptr(nData))), pX, iOffset+nData, iAmt-nData)
			if rc != 0 {
				return rc
			}
			iAmt = nData
		}
		if memcmp(unsafe.Pointer(pDest), unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pX.pData)))+uintptr(iOffset)))), uint(iAmt)) != 0 {
			var rc int32 = sqlite3PagerWrite(pPage.pDbPage)
			if rc != 0 {
				return rc
			}
			__builtin___memmove_chk(unsafe.Pointer(pDest), unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pX.pData)))+uintptr(iOffset)))), uint(iAmt), __builtin_object_size(unsafe.Pointer(pDest), 0))
		}
	}
	return int32(0)
}
func btreeOverwriteCell(pCur *struct_BtCursor, pX *struct_BtreePayload) int32 {
	var iOffset int32
	var nTotal int32 = pX.nData + pX.nZero
	var rc int32
	var pPage *struct_MemPage = pCur.pPage
	var pBt *struct_BtShared
	var ovflPgno uint32
	var ovflPageSize uint32
	if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.info.pPayload))+uintptr(int32(pCur.info.nLocal)))))) > uintptr(unsafe.Pointer(pPage.aDataEnd)) || uintptr(unsafe.Pointer(pCur.info.pPayload)) < uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(int32(pPage.cellOffset)))))) {
		return sqlite3CorruptError(74920)
	}
	rc = btreeOverwriteContent(pPage, pCur.info.pPayload, pX, 0, int32(pCur.info.nLocal))
	if rc != 0 {
		return rc
	}
	if int32(pCur.info.nLocal) == nTotal {
		return int32(0)
	}
	iOffset = int32(pCur.info.nLocal)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	ovflPgno = sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCur.info.pPayload)) + uintptr(iOffset))))
	pBt = pPage.pBt
	ovflPageSize = pBt.usableSize - uint32(4)
	for {
		rc = btreeGetPage(pBt, ovflPgno, &pPage, 0)
		if rc != 0 {
			return rc
		}
		if sqlite3PagerPageRefcount(pPage.pDbPage) != 1 || int32(pPage.isInit) != 0 {
			rc = sqlite3CorruptError(74939)
		} else {
			if uint32(iOffset)+ovflPageSize < uint32(nTotal) {
				ovflPgno = sqlite3Get4byte(pPage.aData)
			} else {
				ovflPageSize = uint32(nTotal - iOffset)
			}
			rc = btreeOverwriteContent(pPage, (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(4))), pX, iOffset, int32(ovflPageSize))
		}
		sqlite3PagerUnref(pPage.pDbPage)
		if rc != 0 {
			return rc
		}
		iOffset += int32(ovflPageSize)
		if !(iOffset < nTotal) {
			break
		}
	}
	return int32(0)
}
func sqlite3BtreeInsert(pCur *struct_BtCursor, pX *struct_BtreePayload, flags int32, seekResult int32) int32 {
	var rc int32
	var loc int32 = seekResult
	var szNew int32 = 0
	var idx int32
	var pPage *struct_MemPage
	var p *struct_Btree = pCur.pBtree
	var pBt *struct_BtShared = p.pBt
	var oldCell *uint8
	var newCell *uint8 = nil
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.curFlags)&32 != 0 {
		rc = saveAllCursors(pBt, pCur.pgnoRoot, pCur)
		if rc != 0 {
			return rc
		}
		if loc != 0 && int32(pCur.iPage) < 0 {
			return sqlite3CorruptError(75026)
		}
	}
	if int32(pCur.eState) >= 3 {
		rc = moveToRoot(pCur)
		if rc != 0 && rc != 16 {
			return rc
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pCur.pKeyInfo)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		if p.hasIncrblobCur != 0 {
			invalidateIncrblobCursors(p, pCur.pgnoRoot, pX.nKey, 0)
		}
		if int32(pCur.curFlags)&2 != 0 && pX.nKey == pCur.info.nKey {
			func() int {
				_ = 0
				return 0
			}()
			if int32(pCur.info.nSize) != 0 && pCur.info.nPayload == uint32(pX.nData)+uint32(pX.nZero) {
				return btreeOverwriteCell(pCur, pX)
			}
			func() int {
				_ = 0
				return 0
			}()
		} else if loc == 0 {
			rc = sqlite3BtreeTableMoveto(pCur, pX.nKey, func() int32 {
				if flags&8 != 0 {
					return 1
				} else {
					return 0
				}
			}(), &loc)
			if rc != 0 {
				return rc
			}
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if loc == 0 && flags&2 == 0 {
			if pX.nMem != 0 {
				var r struct_UnpackedRecord
				r.pKeyInfo = pCur.pKeyInfo
				r.aMem = pX.aMem
				r.nField = pX.nMem
				r.default_rc = int8(0)
				r.eqSeen = uint8(0)
				rc = sqlite3BtreeIndexMoveto(pCur, &r, &loc)
			} else {
				rc = btreeMoveto(pCur, pX.pKey, pX.nKey, func() int32 {
					if flags&8 != 0 {
						return 1
					} else {
						return 0
					}
				}(), &loc)
			}
			if rc != 0 {
				return rc
			}
		}
		if loc == 0 {
			getCellInfo(pCur)
			if pCur.info.nKey == pX.nKey {
				var x2 struct_BtreePayload
				x2.pData = pX.pKey
				x2.nData = int32(pX.nKey)
				x2.nZero = int32(0)
				return btreeOverwriteCell(pCur, &x2)
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	pPage = pCur.pPage
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pPage.nFree < 0 {
		if int32(pCur.eState) > 1 {
			rc = sqlite3CorruptError(75143)
		} else {
			rc = btreeComputeFreeSpace(pPage)
		}
		if rc != 0 {
			return rc
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	newCell = pBt.pTmpSpace
	func() int {
		_ = 0
		return 0
	}()
	if flags&128 != 0 {
		rc = int32(0)
		szNew = pBt.nPreformatSize
		if szNew < 4 {
			szNew = int32(4)
		}
		if int32(pBt.autoVacuum) != 0 && szNew > int32(pPage.maxLocal) {
			var info struct_CellInfo
			pPage.xParseCell(pPage, newCell, &info)
			if info.nPayload != uint32(info.nLocal) {
				var ovfl uint32 = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(newCell)) + uintptr(szNew-4))))
				ptrmapPut(pBt, ovfl, uint8(3), pPage.pgno, &rc)
			}
		}
	} else {
		rc = fillInCell(pPage, newCell, pX, &szNew)
	}
	if rc != 0 {
		goto end_insert
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	idx = int32(pCur.ix)
	if loc == 0 {
		var info struct_CellInfo
		func() int {
			_ = 0
			return 0
		}()
		if idx >= int32(pPage.nCell) {
			return sqlite3CorruptError(75179)
		}
		rc = sqlite3PagerWrite(pPage.pDbPage)
		if rc != 0 {
			goto end_insert
		}
		oldCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*idx))))) + uintptr(1))))))))
		if !(pPage.leaf != 0) {
			__builtin___memcpy_chk(unsafe.Pointer(newCell), unsafe.Pointer(oldCell), uint(4), __builtin_object_size(unsafe.Pointer(newCell), 0))
		}
		pPage.xParseCell(pPage, oldCell, &info)
		if uint32(info.nLocal) != info.nPayload {
			rc = clearCellOverflow(pPage, oldCell, &info)
		} else {
			rc = int32(0)
		}
		pCur.curFlags &= uint8(^4)
		if int32(info.nSize) == szNew && uint32(info.nLocal) == info.nPayload && (!(pBt.autoVacuum != 0) || szNew < int32(pPage.minLocal)) {
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(oldCell)) < uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(int32(pPage.hdrOffset))))))+uintptr(10))))) {
				return sqlite3CorruptError(75206)
			}
			if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(oldCell))+uintptr(szNew))))) > uintptr(unsafe.Pointer(pPage.aDataEnd)) {
				return sqlite3CorruptError(75209)
			}
			__builtin___memcpy_chk(unsafe.Pointer(oldCell), unsafe.Pointer(newCell), uint(szNew), __builtin_object_size(unsafe.Pointer(oldCell), 0))
			return int32(0)
		}
		dropCell(pPage, idx, int32(info.nSize), &rc)
		if rc != 0 {
			goto end_insert
		}
	} else if loc < 0 && int32(pPage.nCell) > 0 {
		func() int {
			_ = 0
			return 0
		}()
		idx = int32(func() (_cgo_ret uint16) {
			_cgo_addr := &pCur.ix
			*_cgo_addr++
			return *_cgo_addr
		}())
		pCur.curFlags &= uint8(^2)
	} else {
		func() int {
			_ = 0
			return 0
		}()
	}
	insertCell(pPage, idx, newCell, szNew, nil, uint32(0), &rc)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pCur.info.nSize = uint16(0)
	if pPage.nOverflow != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pCur.curFlags &= uint8(^2)
		rc = balance(pCur)
		pCur.pPage.nOverflow = uint8(0)
		pCur.eState = uint8(1)
		if flags&2 != 0 && rc == 0 {
			btreeReleaseAllCursorPages(pCur)
			if pCur.pKeyInfo != nil {
				func() int {
					_ = 0
					return 0
				}()
				pCur.pKey = sqlite3Malloc(uint64(pX.nKey))
				if uintptr(unsafe.Pointer(pCur.pKey)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
				} else {
					__builtin___memcpy_chk(pCur.pKey, pX.pKey, uint(pX.nKey), __builtin_object_size(pCur.pKey, 0))
				}
			}
			pCur.eState = uint8(3)
			pCur.nKey = pX.nKey
		}
	}
	func() int {
		_ = 0
		return 0
	}()
end_insert:
	return rc
}
func sqlite3BtreeTransferRow(pDest *struct_BtCursor, pSrc *struct_BtCursor, iKey int64) int32 {
	var rc int32 = 0
	var pBt *struct_BtShared = pDest.pBt
	var aOut *uint8 = pBt.pTmpSpace
	var aIn *uint8
	var nIn uint32
	var nRem uint32
	getCellInfo(pSrc)
	*(*uintptr)(unsafe.Pointer(&aOut)) += uintptr(int32(uint8(func() int32 {
		if uint32(pSrc.info.nPayload) < uint32(128) {
			return int32(func() int {
				*aOut = uint8(pSrc.info.nPayload)
				return 1
			}())
		} else {
			return sqlite3PutVarint(aOut, uint64(pSrc.info.nPayload))
		}
	}())))
	if uintptr(unsafe.Pointer(pDest.pKeyInfo)) == uintptr(unsafe.Pointer(nil)) {
		*(*uintptr)(unsafe.Pointer(&aOut)) += uintptr(sqlite3PutVarint(aOut, uint64(iKey)))
	}
	nIn = uint32(pSrc.info.nLocal)
	aIn = pSrc.info.pPayload
	if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aIn))+uintptr(nIn))))) > uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pSrc.pPage.aDataEnd)))) {
		return sqlite3CorruptError(75309)
	}
	nRem = pSrc.info.nPayload
	if nIn == nRem && nIn < uint32(pDest.pPage.maxLocal) {
		__builtin___memcpy_chk(unsafe.Pointer(aOut), unsafe.Pointer(aIn), uint(nIn), __builtin_object_size(unsafe.Pointer(aOut), 0))
		pBt.nPreformatSize = int32(int(nIn) + int(uintptr(unsafe.Pointer(aOut))-uintptr(unsafe.Pointer(pBt.pTmpSpace))))
	} else {
		var pSrcPager *struct_Pager = pSrc.pBt.pPager
		var pPgnoOut *uint8 = nil
		var ovflIn uint32 = uint32(0)
		var pPageIn *struct_PgHdr = nil
		var pPageOut *struct_MemPage = nil
		var nOut uint32
		nOut = uint32(btreePayloadToLocal(pDest.pPage, int64(pSrc.info.nPayload)))
		pBt.nPreformatSize = int32(int(nOut) + int(uintptr(unsafe.Pointer(aOut))-uintptr(unsafe.Pointer(pBt.pTmpSpace))))
		if nOut < pSrc.info.nPayload {
			pPgnoOut = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aOut)) + uintptr(nOut)))
			pBt.nPreformatSize += int32(4)
		}
		if nRem > nIn {
			if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aIn))+uintptr(nIn)))))+uintptr(4))))) > uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pSrc.pPage.aDataEnd)))) {
				return sqlite3CorruptError(75332)
			}
			ovflIn = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.info.pPayload)) + uintptr(nIn))))
		}
		for {
			nRem -= nOut
			for {
				func() int {
					_ = 0
					return 0
				}()
				if nIn > uint32(0) {
					var nCopy int32 = int32(func() uint32 {
						if nOut < nIn {
							return nOut
						} else {
							return nIn
						}
					}())
					__builtin___memcpy_chk(unsafe.Pointer(aOut), unsafe.Pointer(aIn), uint(nCopy), __builtin_object_size(unsafe.Pointer(aOut), 0))
					nOut -= uint32(nCopy)
					nIn -= uint32(nCopy)
					*(*uintptr)(unsafe.Pointer(&aOut)) += uintptr(nCopy)
					*(*uintptr)(unsafe.Pointer(&aIn)) += uintptr(nCopy)
				}
				if nOut > uint32(0) {
					sqlite3PagerUnref(pPageIn)
					pPageIn = (*struct_PgHdr)(nil)
					rc = sqlite3PagerGet(pSrcPager, ovflIn, &pPageIn, 2)
					if rc == 0 {
						aIn = (*uint8)(sqlite3PagerGetData(pPageIn))
						ovflIn = sqlite3Get4byte(aIn)
						*(*uintptr)(unsafe.Pointer(&aIn)) += uintptr(4)
						nIn = pSrc.pBt.usableSize - uint32(4)
					}
				}
				if !(rc == 0 && nOut > uint32(0)) {
					break
				}
			}
			if rc == 0 && nRem > uint32(0) && pPgnoOut != nil {
				var pgnoNew uint32
				var pNew *struct_MemPage = nil
				rc = allocateBtreePage(pBt, &pNew, &pgnoNew, uint32(0), uint8(0))
				sqlite3Put4byte(pPgnoOut, pgnoNew)
				if int32(pBt.autoVacuum) != 0 && pPageOut != nil {
					ptrmapPut(pBt, pgnoNew, uint8(4), pPageOut.pgno, &rc)
				}
				releasePage(pPageOut)
				pPageOut = pNew
				if pPageOut != nil {
					pPgnoOut = pPageOut.aData
					sqlite3Put4byte(pPgnoOut, uint32(0))
					aOut = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPgnoOut)) + uintptr(4)))
					nOut = func() uint32 {
						if pBt.usableSize-uint32(4) < nRem {
							return pBt.usableSize - uint32(4)
						} else {
							return nRem
						}
					}()
				}
			}
			if !(nRem > uint32(0) && rc == 0) {
				break
			}
		}
		releasePage(pPageOut)
		sqlite3PagerUnref(pPageIn)
	}
	return rc
}
func sqlite3BtreeDelete(pCur *struct_BtCursor, flags uint8) int32 {
	var p *struct_Btree = pCur.pBtree
	var pBt *struct_BtShared = p.pBt
	var rc int32
	var pPage *struct_MemPage
	var pCell *uint8
	var iCellIdx int32
	var iCellDepth int32
	var info struct_CellInfo
	var bPreserve uint8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCur.eState) != 0 {
		if int32(pCur.eState) >= 3 {
			rc = btreeRestoreCursorPosition(pCur)
			func() int {
				_ = 0
				return 0
			}()
			if rc != 0 || int32(pCur.eState) != 0 {
				return rc
			}
		} else {
			return sqlite3CorruptError(75429)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	iCellDepth = int32(pCur.iPage)
	iCellIdx = int32(pCur.ix)
	pPage = pCur.pPage
	if int32(pPage.nCell) <= iCellIdx {
		return sqlite3CorruptError(75438)
	}
	pCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*iCellIdx))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*iCellIdx))))) + uintptr(1))))))))
	if pPage.nFree < 0 && btreeComputeFreeSpace(pPage) != 0 {
		return sqlite3CorruptError(75442)
	}
	bPreserve = func() uint8 {
		if int32(flags)&2 != 0 {
			return 1
		} else {
			return 0
		}
	}()
	if bPreserve != 0 {
		if !(pPage.leaf != 0) || pPage.nFree+int32(cellSizePtr(pPage, pCell))+2 > int32(pBt.usableSize*uint32(2)/uint32(3)) || int32(pPage.nCell) == 1 {
			rc = saveCursorKey(pCur)
			if rc != 0 {
				return rc
			}
		} else {
			bPreserve = uint8(2)
		}
	}
	if !(pPage.leaf != 0) {
		rc = sqlite3BtreePrevious(pCur, 0)
		func() int {
			_ = 0
			return 0
		}()
		if rc != 0 {
			return rc
		}
	}
	if int32(pCur.curFlags)&32 != 0 {
		rc = saveAllCursors(pBt, pCur.pgnoRoot, pCur)
		if rc != 0 {
			return rc
		}
	}
	if uintptr(unsafe.Pointer(pCur.pKeyInfo)) == uintptr(unsafe.Pointer(nil)) && int32(p.hasIncrblobCur) != 0 {
		invalidateIncrblobCursors(p, pCur.pgnoRoot, pCur.info.nKey, 0)
	}
	rc = sqlite3PagerWrite(pPage.pDbPage)
	if rc != 0 {
		return rc
	}
	pPage.xParseCell(pPage, pCell, &info)
	if uint32(info.nLocal) != info.nPayload {
		rc = clearCellOverflow(pPage, pCell, &info)
	} else {
		rc = int32(0)
	}
	dropCell(pPage, iCellIdx, int32(info.nSize), &rc)
	if rc != 0 {
		return rc
	}
	if !(pPage.leaf != 0) {
		var pLeaf *struct_MemPage = pCur.pPage
		var nCell int32
		var n uint32
		var pTmp *uint8
		if pLeaf.nFree < 0 {
			rc = btreeComputeFreeSpace(pLeaf)
			if rc != 0 {
				return rc
			}
		}
		if iCellDepth < int32(pCur.iPage)-1 {
			n = (*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(iCellDepth+1)*8))).pgno
		} else {
			n = pCur.pPage.pgno
		}
		pCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pLeaf.aData)) + uintptr(int32(pLeaf.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pLeaf.aCellIdx)) + uintptr(2*(int32(pLeaf.nCell)-1)))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pLeaf.aCellIdx)) + uintptr(2*(int32(pLeaf.nCell)-1)))))) + uintptr(1))))))))
		if uintptr(unsafe.Pointer(pCell)) < uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pLeaf.aData)) + uintptr(4))))) {
			return sqlite3CorruptError(75532)
		}
		nCell = int32(pLeaf.xCellSize(pLeaf, pCell))
		func() int {
			_ = 0
			return 0
		}()
		pTmp = pBt.pTmpSpace
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3PagerWrite(pLeaf.pDbPage)
		if rc == 0 {
			insertCell(pPage, iCellIdx, (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell))-uintptr(4))), nCell+4, pTmp, n, &rc)
		}
		dropCell(pLeaf, int32(pLeaf.nCell)-1, nCell, &rc)
		if rc != 0 {
			return rc
		}
	}
	rc = balance(pCur)
	if rc == 0 && int32(pCur.iPage) > iCellDepth {
		releasePageNotNull(pCur.pPage)
		pCur.iPage--
		for int32(pCur.iPage) > iCellDepth {
			releasePage(*(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(func() (_cgo_ret int8) {
				_cgo_addr := &pCur.iPage
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}())*8)))
		}
		pCur.pPage = *(**struct_MemPage)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_MemPage)(unsafe.Pointer(&pCur.apPage)))) + uintptr(pCur.iPage)*8))
		rc = balance(pCur)
	}
	if rc == 0 {
		if int32(bPreserve) > 1 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCur.eState = uint8(2)
			if iCellIdx >= int32(pPage.nCell) {
				pCur.skipNext = int32(-1)
				pCur.ix = uint16(int32(pPage.nCell) - 1)
			} else {
				pCur.skipNext = int32(1)
			}
		} else {
			rc = moveToRoot(pCur)
			if bPreserve != 0 {
				btreeReleaseAllCursorPages(pCur)
				pCur.eState = uint8(3)
			}
			if rc == 16 {
				rc = int32(0)
			}
		}
	}
	return rc
}
func btreeCreateTable(p *struct_Btree, piTable *uint32, createTabFlags int32) int32 {
	var pBt *struct_BtShared = p.pBt
	var pRoot *struct_MemPage
	var pgnoRoot uint32
	var rc int32
	var ptfFlags int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pBt.autoVacuum != 0 {
		var pgnoMove uint32
		var pPageMove *struct_MemPage
		invalidateAllOverflowCache(pBt)
		sqlite3BtreeGetMeta(p, 4, &pgnoRoot)
		if pgnoRoot > btreePagecount(pBt) {
			return sqlite3CorruptError(75640)
		}
		pgnoRoot++
		for pgnoRoot == ptrmapPageno(pBt, pgnoRoot) || pgnoRoot == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) {
			pgnoRoot++
		}
		func() int {
			_ = 0
			return 0
		}()
		rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, uint8(1))
		if rc != 0 {
			return rc
		}
		if pgnoMove != pgnoRoot {
			var eType uint8 = uint8(0)
			var iPtrPage uint32 = uint32(0)
			rc = saveAllCursors(pBt, uint32(0), nil)
			releasePage(pPageMove)
			if rc != 0 {
				return rc
			}
			rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0)
			if rc != 0 {
				return rc
			}
			rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage)
			if int32(eType) == 1 || int32(eType) == 2 {
				rc = sqlite3CorruptError(75688)
			}
			if rc != 0 {
				releasePage(pRoot)
				return rc
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0)
			releasePage(pRoot)
			if rc != 0 {
				return rc
			}
			rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0)
			if rc != 0 {
				return rc
			}
			rc = sqlite3PagerWrite(pRoot.pDbPage)
			if rc != 0 {
				releasePage(pRoot)
				return rc
			}
		} else {
			pRoot = pPageMove
		}
		ptrmapPut(pBt, pgnoRoot, uint8(1), uint32(0), &rc)
		if rc != 0 {
			releasePage(pRoot)
			return rc
		}
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot)
		if rc != 0 {
			releasePage(pRoot)
			return rc
		}
	} else {
		rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, uint32(1), uint8(0))
		if rc != 0 {
			return rc
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if createTabFlags&1 != 0 {
		ptfFlags = int32(1 | 4 | 8)
	} else {
		ptfFlags = int32(2 | 8)
	}
	zeroPage(pRoot, ptfFlags)
	sqlite3PagerUnref(pRoot.pDbPage)
	func() int {
		_ = 0
		return 0
	}()
	*piTable = pgnoRoot
	return int32(0)
}
func sqlite3BtreeCreateTable(p *struct_Btree, piTable *uint32, flags int32) int32 {
	var rc int32
	sqlite3BtreeEnter(p)
	rc = btreeCreateTable(p, piTable, flags)
	sqlite3BtreeLeave(p)
	return rc
}
func clearDatabasePage(pBt *struct_BtShared, pgno uint32, freePageFlag int32, pnChange *int64) int32 {
	var pPage *struct_MemPage
	var rc int32
	var pCell *uint8
	var i int32
	var hdr int32
	var info struct_CellInfo
	func() int {
		_ = 0
		return 0
	}()
	if pgno > btreePagecount(pBt) {
		return sqlite3CorruptError(75778)
	}
	rc = getAndInitPage(pBt, pgno, &pPage, nil, 0)
	if rc != 0 {
		return rc
	}
	if int32(pBt.openFlags)&4 == 0 && sqlite3PagerPageRefcount(pPage.pDbPage) != 1+func() int32 {
		if pgno == uint32(1) {
			return 1
		} else {
			return 0
		}
	}() {
		rc = sqlite3CorruptError(75785)
		goto cleardatabasepage_out
	}
	hdr = int32(pPage.hdrOffset)
	for i = int32(0); i < int32(pPage.nCell); i++ {
		pCell = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*i))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*i))))) + uintptr(1))))))))
		if !(pPage.leaf != 0) {
			rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange)
			if rc != 0 {
				goto cleardatabasepage_out
			}
		}
		pPage.xParseCell(pPage, pCell, &info)
		if uint32(info.nLocal) != info.nPayload {
			rc = clearCellOverflow(pPage, pCell, &info)
		} else {
			rc = int32(0)
		}
		if rc != 0 {
			goto cleardatabasepage_out
		}
	}
	if !(pPage.leaf != 0) {
		rc = clearDatabasePage(pBt, sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(hdr+8)))), 1, pnChange)
		if rc != 0 {
			goto cleardatabasepage_out
		}
		if pPage.intKey != 0 {
			pnChange = (*int64)(nil)
		}
	}
	if pnChange != nil {
		*pnChange += int64(pPage.nCell)
	}
	if freePageFlag != 0 {
		freePage(pPage, &rc)
	} else if func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3PagerWrite(pPage.pDbPage)
		return *_cgo_addr
	}() == 0 {
		zeroPage(pPage, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(hdr))))|8)
	}
cleardatabasepage_out:
	releasePage(pPage)
	return rc
}
func sqlite3BtreeClearTable(p *struct_Btree, iTable int32, pnChange *int64) int32 {
	var rc int32
	var pBt *struct_BtShared = p.pBt
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	rc = saveAllCursors(pBt, uint32(iTable), nil)
	if 0 == rc {
		if p.hasIncrblobCur != 0 {
			invalidateIncrblobCursors(p, uint32(iTable), int64(0), 1)
		}
		rc = clearDatabasePage(pBt, uint32(iTable), 0, pnChange)
	}
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeClearTableOfCursor(pCur *struct_BtCursor) int32 {
	return sqlite3BtreeClearTable(pCur.pBtree, int32(pCur.pgnoRoot), nil)
}
func btreeDropTable(p *struct_Btree, iTable uint32, piMoved *int32) int32 {
	var rc int32
	var pPage *struct_MemPage = nil
	var pBt *struct_BtShared = p.pBt
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if iTable > btreePagecount(pBt) {
		return sqlite3CorruptError(75889)
	}
	rc = sqlite3BtreeClearTable(p, int32(iTable), nil)
	if rc != 0 {
		return rc
	}
	rc = btreeGetPage(pBt, uint32(iTable), &pPage, 0)
	if rc != 0 {
		releasePage(pPage)
		return rc
	}
	*piMoved = int32(0)
	if pBt.autoVacuum != 0 {
		var maxRootPgno uint32
		sqlite3BtreeGetMeta(p, 4, &maxRootPgno)
		if iTable == maxRootPgno {
			freePage(pPage, &rc)
			releasePage(pPage)
			if rc != 0 {
				return rc
			}
		} else {
			var pMove *struct_MemPage
			releasePage(pPage)
			rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0)
			if rc != 0 {
				return rc
			}
			rc = relocatePage(pBt, pMove, uint8(1), uint32(0), iTable, 0)
			releasePage(pMove)
			if rc != 0 {
				return rc
			}
			pMove = (*struct_MemPage)(nil)
			rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0)
			freePage(pMove, &rc)
			releasePage(pMove)
			if rc != 0 {
				return rc
			}
			*piMoved = int32(maxRootPgno)
		}
		maxRootPgno--
		for maxRootPgno == uint32(uint32(sqlite3PendingByte)/pBt.pageSize+uint32(1)) || ptrmapPageno(pBt, maxRootPgno) == maxRootPgno {
			maxRootPgno--
		}
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno)
	} else {
		freePage(pPage, &rc)
		releasePage(pPage)
	}
	return rc
}
func sqlite3BtreeDropTable(p *struct_Btree, iTable int32, piMoved *int32) int32 {
	var rc int32
	sqlite3BtreeEnter(p)
	rc = btreeDropTable(p, uint32(iTable), piMoved)
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeGetMeta(p *struct_Btree, idx int32, pMeta *uint32) {
	var pBt *struct_BtShared = p.pBt
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if idx == 15 {
		*pMeta = sqlite3PagerDataVersion(pBt.pPager) + p.iBDataVersion
	} else {
		*pMeta = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(36+idx*4))))
	}
	sqlite3BtreeLeave(p)
}
func sqlite3BtreeUpdateMeta(p *struct_Btree, idx int32, iMeta uint32) int32 {
	var pBt *struct_BtShared = p.pBt
	var pP1 *uint8
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pP1 = pBt.pPage1.aData
	rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
	if rc == 0 {
		sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pP1)) + uintptr(36+idx*4))), iMeta)
		if idx == 7 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pBt.incrVacuum = uint8(iMeta)
		}
	}
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeCount(db *struct_sqlite3, pCur *struct_BtCursor, pnEntry *int64) int32 {
	var nEntry int64 = int64(0)
	var rc int32
	rc = moveToRoot(pCur)
	if rc == 16 {
		*pnEntry = int64(0)
		return int32(0)
	}
	for rc == 0 && !(__atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0) != 0) {
		var iIdx int32
		var pPage *struct_MemPage
		pPage = pCur.pPage
		if int32(pPage.leaf) != 0 || !(pPage.intKey != 0) {
			nEntry += int64(pPage.nCell)
		}
		if pPage.leaf != 0 {
			for {
				if int32(pCur.iPage) == 0 {
					*pnEntry = nEntry
					return moveToRoot(pCur)
				}
				moveToParent(pCur)
				if !(int32(pCur.ix) >= int32(pCur.pPage.nCell)) {
					break
				}
			}
			pCur.ix++
			pPage = pCur.pPage
		}
		iIdx = int32(pCur.ix)
		if iIdx == int32(pPage.nCell) {
			rc = moveToChild(pCur, sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData)) + uintptr(int32(pPage.hdrOffset)+8)))))
		} else {
			rc = moveToChild(pCur, sqlite3Get4byte((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aData))+uintptr(int32(pPage.maskPage)&(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*iIdx))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPage.aCellIdx)) + uintptr(2*iIdx))))) + uintptr(1))))))))))
		}
	}
	return rc
}
func sqlite3BtreePager(p *struct_Btree) *struct_Pager {
	return p.pBt.pPager
}
func checkAppendMsg(pCheck *struct_IntegrityCk, zFormat *int8, __cgo_args ...interface {
}) {
	if !(pCheck.mxErr != 0) {
		return
	}
	pCheck.mxErr--
	pCheck.nErr++
	if pCheck.errMsg.nChar != 0 {
		sqlite3_str_append(&pCheck.errMsg, (*int8)(unsafe.Pointer(&[2]int8{'\n', '\x00'})), 1)
	}
	if pCheck.zPfx != nil {
		sqlite3_str_appendf(&pCheck.errMsg, pCheck.zPfx, pCheck.v1, pCheck.v2)
	}
	sqlite3_str_vappendf(&pCheck.errMsg, zFormat, __cgo_args...)
	if int32(pCheck.errMsg.accError) == 7 {
		pCheck.bOomFault = int32(1)
	}
}
func getPageReferenced(pCheck *struct_IntegrityCk, iPg uint32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCheck.aPgRef)) + uintptr(iPg/uint32(8))))) & int32(1<<(iPg&uint32(7)))
}
func setPageReferenced(pCheck *struct_IntegrityCk, iPg uint32) {
	func() int {
		_ = 0
		return 0
	}()
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCheck.aPgRef)) + uintptr(iPg/uint32(8)))) |= uint8(1 << (iPg & uint32(7)))
}
func checkRef(pCheck *struct_IntegrityCk, iPage uint32) int32 {
	if iPage > pCheck.nPage || iPage == uint32(0) {
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[23]int8{'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'p', 'a', 'g', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', '%', 'd', '\x00'})), iPage)
		return int32(1)
	}
	if getPageReferenced(pCheck, iPage) != 0 {
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[25]int8{'2', 'n', 'd', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 't', 'o', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'd', '\x00'})), iPage)
		return int32(1)
	}
	if __atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&pCheck.db.u1)), 0) != 0 {
		return int32(1)
	}
	setPageReferenced(pCheck, iPage)
	return int32(0)
}
func checkPtrmap(pCheck *struct_IntegrityCk, iChild uint32, eType uint8, iParent uint32) {
	var rc int32
	var ePtrmapType uint8
	var iPtrmapParent uint32
	rc = ptrmapGet(pCheck.pBt, iChild, &ePtrmapType, &iPtrmapParent)
	if rc != 0 {
		if rc == 7 || rc == 10|12<<8 {
			pCheck.bOomFault = int32(1)
		}
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[29]int8{'F', 'a', 'i', 'l', 'e', 'd', ' ', 't', 'o', ' ', 'r', 'e', 'a', 'd', ' ', 'p', 't', 'r', 'm', 'a', 'p', ' ', 'k', 'e', 'y', '=', '%', 'd', '\x00'})), iChild)
		return
	}
	if int32(ePtrmapType) != int32(eType) || iPtrmapParent != iParent {
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[54]int8{'B', 'a', 'd', ' ', 'p', 't', 'r', ' ', 'm', 'a', 'p', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'k', 'e', 'y', '=', '%', 'd', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', '=', '(', '%', 'd', ',', '%', 'd', ')', ' ', 'g', 'o', 't', '=', '(', '%', 'd', ',', '%', 'd', ')', '\x00'})), iChild, int32(eType), iParent, int32(ePtrmapType), iPtrmapParent)
	}
}
func checkList(pCheck *struct_IntegrityCk, isFreeList int32, iPage uint32, N uint32) {
	var i int32
	var expected uint32 = N
	var nErrAtStart int32 = pCheck.nErr
	for iPage != uint32(0) && pCheck.mxErr != 0 {
		var pOvflPage *struct_PgHdr
		var pOvflData *uint8
		if checkRef(pCheck, iPage) != 0 {
			break
		}
		N--
		if sqlite3PagerGet(pCheck.pPager, uint32(iPage), &pOvflPage, 0) != 0 {
			checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[22]int8{'f', 'a', 'i', 'l', 'e', 'd', ' ', 't', 'o', ' ', 'g', 'e', 't', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'd', '\x00'})), iPage)
			break
		}
		pOvflData = (*uint8)(sqlite3PagerGetData(pOvflPage))
		if isFreeList != 0 {
			var n uint32 = uint32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOvflData)) + uintptr(4)))))
			if pCheck.pBt.autoVacuum != 0 {
				checkPtrmap(pCheck, iPage, uint8(2), uint32(0))
			}
			if n > pCheck.pBt.usableSize/uint32(4)-uint32(2) {
				checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[39]int8{'f', 'r', 'e', 'e', 'l', 'i', 's', 't', ' ', 'l', 'e', 'a', 'f', ' ', 'c', 'o', 'u', 'n', 't', ' ', 't', 'o', 'o', ' ', 'b', 'i', 'g', ' ', 'o', 'n', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'd', '\x00'})), iPage)
				N--
			} else {
				for i = int32(0); i < int32(n); i++ {
					var iFreePage uint32 = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOvflData)) + uintptr(8+i*4))))
					if pCheck.pBt.autoVacuum != 0 {
						checkPtrmap(pCheck, iFreePage, uint8(2), uint32(0))
					}
					checkRef(pCheck, iFreePage)
				}
				N -= n
			}
		} else if int32(pCheck.pBt.autoVacuum) != 0 && N > uint32(0) {
			i = int32(sqlite3Get4byte(pOvflData))
			checkPtrmap(pCheck, uint32(i), uint8(4), iPage)
		}
		iPage = sqlite3Get4byte(pOvflData)
		sqlite3PagerUnref(pOvflPage)
	}
	if N != 0 && nErrAtStart == pCheck.nErr {
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[26]int8{'%', 's', ' ', 'i', 's', ' ', '%', 'd', ' ', 'b', 'u', 't', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' ', '%', 'd', '\x00'})), func() *int8 {
			if isFreeList != 0 {
				return (*int8)(unsafe.Pointer(&[5]int8{'s', 'i', 'z', 'e', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[21]int8{'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', ' ', 'l', 'i', 's', 't', ' ', 'l', 'e', 'n', 'g', 't', 'h', '\x00'}))
			}
		}(), expected-N, expected)
	}
}
func btreeHeapInsert(aHeap *uint32, x uint32) {
	var j uint32
	var i uint32 = func() (_cgo_ret uint32) {
		_cgo_addr := &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(0)*4))
		*_cgo_addr++
		return *_cgo_addr
	}()
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4)) = x
	for func() (_cgo_ret uint32) {
		_cgo_addr := &j
		*_cgo_addr = i / uint32(2)
		return *_cgo_addr
	}() > uint32(0) && *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4)) > *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4)) {
		x = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4)) = x
		i = j
	}
}
func btreeHeapPull(aHeap *uint32, pOut *uint32) int32 {
	var j uint32
	var i uint32
	var x uint32
	if func() (_cgo_ret uint32) {
		_cgo_addr := &x
		*_cgo_addr = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(0)*4))
		return *_cgo_addr
	}() == uint32(0) {
		return int32(0)
	}
	*pOut = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(1)*4))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(1)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(x)*4))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(x)*4)) = uint32(4294967295)
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(0)*4))--
	i = uint32(1)
	for func() (_cgo_ret uint32) {
		_cgo_addr := &j
		*_cgo_addr = i * uint32(2)
		return *_cgo_addr
	}() <= *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(0)*4)) {
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4)) > *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j+uint32(1))*4)) {
			j++
		}
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4)) < *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4)) {
			break
		}
		x = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(i)*4)) = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4))
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aHeap)) + uintptr(j)*4)) = x
		i = j
	}
	return int32(1)
}
func checkTreePage(pCheck *struct_IntegrityCk, iPage uint32, piMinKey *int64, maxKey int64) int32 {
	var pPage *struct_MemPage = nil
	var i int32
	var rc int32
	var depth int32 = -1
	var d2 int32
	var pgno int32
	var nFrag int32
	var hdr int32
	var cellStart int32
	var nCell int32
	var doCoverageCheck int32 = 1
	var keyCanBeEqual int32 = 1
	var data *uint8
	var pCell *uint8
	var pCellIdx *uint8
	var pBt *struct_BtShared
	var pc uint32
	var usableSize uint32
	var contentOffset uint32
	var heap *uint32 = nil
	var x uint32
	var prev uint32 = uint32(0)
	var saved_zPfx *int8 = pCheck.zPfx
	var saved_v1 int32 = int32(pCheck.v1)
	var saved_v2 int32 = pCheck.v2
	var savedIsInit uint8 = uint8(0)
	pBt = pCheck.pBt
	usableSize = pBt.usableSize
	if iPage == uint32(0) {
		return int32(0)
	}
	if checkRef(pCheck, iPage) != 0 {
		return int32(0)
	}
	pCheck.zPfx = (*int8)(unsafe.Pointer(&[10]int8{'P', 'a', 'g', 'e', ' ', '%', 'u', ':', ' ', '\x00'}))
	pCheck.v1 = iPage
	if func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = btreeGetPage(pBt, iPage, &pPage, 0)
		return *_cgo_addr
	}() != 0 {
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[38]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'g', 'e', 't', ' ', 't', 'h', 'e', ' ', 'p', 'a', 'g', 'e', '.', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', '=', '%', 'd', '\x00'})), rc)
		goto end_of_check
	}
	savedIsInit = pPage.isInit
	pPage.isInit = uint8(0)
	if func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = btreeInitPage(pPage)
		return *_cgo_addr
	}() != 0 {
		func() int {
			_ = 0
			return 0
		}()
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[38]int8{'b', 't', 'r', 'e', 'e', 'I', 'n', 'i', 't', 'P', 'a', 'g', 'e', '(', ')', ' ', 'r', 'e', 't', 'u', 'r', 'n', 's', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'c', 'o', 'd', 'e', ' ', '%', 'd', '\x00'})), rc)
		goto end_of_check
	}
	if func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = btreeComputeFreeSpace(pPage)
		return *_cgo_addr
	}() != 0 {
		func() int {
			_ = 0
			return 0
		}()
		checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[22]int8{'f', 'r', 'e', 'e', ' ', 's', 'p', 'a', 'c', 'e', ' ', 'c', 'o', 'r', 'r', 'u', 'p', 't', 'i', 'o', 'n', '\x00'})), rc)
		goto end_of_check
	}
	data = pPage.aData
	hdr = int32(pPage.hdrOffset)
	pCheck.zPfx = (*int8)(unsafe.Pointer(&[26]int8{'O', 'n', ' ', 't', 'r', 'e', 'e', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'u', ' ', 'c', 'e', 'l', 'l', ' ', '%', 'd', ':', ' ', '\x00'}))
	contentOffset = uint32((int32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(0))))<<8|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+5))))) + uintptr(1)))))-1)&65535 + 1)
	func() int {
		_ = 0
		return 0
	}()
	nCell = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+3))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+3))))) + uintptr(1))))
	func() int {
		_ = 0
		return 0
	}()
	cellStart = hdr + 12 - 4*int32(pPage.leaf)
	func() int {
		_ = 0
		return 0
	}()
	pCellIdx = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellStart+2*(nCell-1))))
	if !(pPage.leaf != 0) {
		pgno = int32(sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+8)))))
		if pBt.autoVacuum != 0 {
			pCheck.zPfx = (*int8)(unsafe.Pointer(&[28]int8{'O', 'n', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'u', ' ', 'a', 't', ' ', 'r', 'i', 'g', 'h', 't', ' ', 'c', 'h', 'i', 'l', 'd', ':', ' ', '\x00'}))
			checkPtrmap(pCheck, uint32(pgno), uint8(5), iPage)
		}
		depth = checkTreePage(pCheck, uint32(pgno), &maxKey, maxKey)
		keyCanBeEqual = int32(0)
	} else {
		heap = pCheck.heap
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(heap)) + uintptr(0)*4)) = uint32(0)
	}
	for i = nCell - 1; i >= 0 && pCheck.mxErr != 0; i-- {
		var info struct_CellInfo
		pCheck.v2 = i
		func() int {
			_ = 0
			return 0
		}()
		pc = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellIdx)) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCellIdx)) + uintptr(1)))))
		*(*uintptr)(unsafe.Pointer(&pCellIdx)) -= uintptr(2)
		if pc < contentOffset || pc > usableSize-uint32(4) {
			checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[30]int8{'O', 'f', 'f', 's', 'e', 't', ' ', '%', 'd', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'r', 'a', 'n', 'g', 'e', ' ', '%', 'd', '.', '.', '%', 'd', '\x00'})), pc, contentOffset, usableSize-uint32(4))
			doCoverageCheck = int32(0)
			continue
		}
		pCell = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc)))
		pPage.xParseCell(pPage, pCell, &info)
		if pc+uint32(info.nSize) > usableSize {
			checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[24]int8{'E', 'x', 't', 'e', 'n', 'd', 's', ' ', 'o', 'f', 'f', ' ', 'e', 'n', 'd', ' ', 'o', 'f', ' ', 'p', 'a', 'g', 'e', '\x00'})))
			doCoverageCheck = int32(0)
			continue
		}
		if pPage.intKey != 0 {
			if func() int32 {
				if keyCanBeEqual != 0 {
					return func() int32 {
						if info.nKey > maxKey {
							return 1
						} else {
							return 0
						}
					}()
				} else {
					return func() int32 {
						if info.nKey >= maxKey {
							return 1
						} else {
							return 0
						}
					}()
				}
			}() != 0 {
				checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[24]int8{'R', 'o', 'w', 'i', 'd', ' ', '%', 'l', 'l', 'd', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'o', 'r', 'd', 'e', 'r', '\x00'})), info.nKey)
			}
			maxKey = info.nKey
			keyCanBeEqual = int32(0)
		}
		if info.nPayload > uint32(info.nLocal) {
			var nPage uint32
			var pgnoOvfl uint32
			func() int {
				_ = 0
				return 0
			}()
			nPage = (info.nPayload - uint32(info.nLocal) + usableSize - uint32(5)) / (usableSize - uint32(4))
			pgnoOvfl = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCell)) + uintptr(int32(info.nSize)-4))))
			if pBt.autoVacuum != 0 {
				checkPtrmap(pCheck, pgnoOvfl, uint8(3), iPage)
			}
			checkList(pCheck, 0, pgnoOvfl, nPage)
		}
		if !(pPage.leaf != 0) {
			pgno = int32(sqlite3Get4byte(pCell))
			if pBt.autoVacuum != 0 {
				checkPtrmap(pCheck, uint32(pgno), uint8(5), iPage)
			}
			d2 = checkTreePage(pCheck, uint32(pgno), &maxKey, maxKey)
			keyCanBeEqual = int32(0)
			if d2 != depth {
				checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[25]int8{'C', 'h', 'i', 'l', 'd', ' ', 'p', 'a', 'g', 'e', ' ', 'd', 'e', 'p', 't', 'h', ' ', 'd', 'i', 'f', 'f', 'e', 'r', 's', '\x00'})))
				depth = d2
			}
		} else {
			btreeHeapInsert(heap, pc<<16|(pc+uint32(info.nSize)-uint32(1)))
		}
	}
	*piMinKey = maxKey
	pCheck.zPfx = (*int8)(nil)
	if doCoverageCheck != 0 && pCheck.mxErr > 0 {
		if !(pPage.leaf != 0) {
			heap = pCheck.heap
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(heap)) + uintptr(0)*4)) = uint32(0)
			for i = nCell - 1; i >= 0; i-- {
				var size uint32
				pc = uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellStart+i*2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(cellStart+i*2))))) + uintptr(1)))))
				size = uint32(pPage.xCellSize(pPage, &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(pc)))))
				btreeHeapInsert(heap, pc<<16|(pc+size-uint32(1)))
			}
		}
		i = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+1))))) + uintptr(1))))
		for i > 0 {
			var size int32
			var j int32
			func() int {
				_ = 0
				return 0
			}()
			size = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(i+2))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(i+2))))) + uintptr(1))))
			func() int {
				_ = 0
				return 0
			}()
			btreeHeapInsert(heap, uint32(i)<<16|uint32(i+size-1))
			j = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(i))))) + uintptr(0))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(i))))) + uintptr(1))))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			i = j
		}
		nFrag = int32(0)
		prev = contentOffset - uint32(1)
		for btreeHeapPull(heap, &x) != 0 {
			if prev&uint32(65535) >= x>>16 {
				checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[37]int8{'M', 'u', 'l', 't', 'i', 'p', 'l', 'e', ' ', 'u', 's', 'e', 's', ' ', 'f', 'o', 'r', ' ', 'b', 'y', 't', 'e', ' ', '%', 'u', ' ', 'o', 'f', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'u', '\x00'})), x>>16, iPage)
				break
			} else {
				nFrag += int32(x>>16 - prev&uint32(65535) - uint32(1))
				prev = x
			}
		}
		nFrag += int32(usableSize - prev&uint32(65535) - uint32(1))
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(heap)) + uintptr(0)*4)) == uint32(0) && nFrag != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+7)))) {
			checkAppendMsg(pCheck, (*int8)(unsafe.Pointer(&[52]int8{'F', 'r', 'a', 'g', 'm', 'e', 'n', 't', 'a', 't', 'i', 'o', 'n', ' ', 'o', 'f', ' ', '%', 'd', ' ', 'b', 'y', 't', 'e', 's', ' ', 'r', 'e', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'a', 's', ' ', '%', 'd', ' ', 'o', 'n', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'u', '\x00'})), nFrag, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(data)) + uintptr(hdr+7)))), iPage)
		}
	}
end_of_check:
	if !(doCoverageCheck != 0) {
		pPage.isInit = savedIsInit
	}
	releasePage(pPage)
	pCheck.zPfx = saved_zPfx
	pCheck.v1 = uint32(saved_v1)
	pCheck.v2 = saved_v2
	return depth + 1
}
func sqlite3BtreeIntegrityCheck(db *struct_sqlite3, p *struct_Btree, aRoot *uint32, nRoot int32, mxErr int32, pnErr *int32) *int8 {
	var i uint32
	var sCheck struct_IntegrityCk
	var pBt *struct_BtShared = p.pBt
	var savedDbFlags uint64 = pBt.db.flags
	var zErr [100]int8
	var bPartial int32 = 0
	var bCkFreelist int32 = 1
	func() int {
		_ = 0
		return 0
	}()
	if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(0)*4)) == uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		bPartial = int32(1)
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(1)*4)) != uint32(1) {
			bCkFreelist = int32(0)
		}
	}
	sqlite3BtreeEnter(p)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sCheck.db = db
	sCheck.pBt = pBt
	sCheck.pPager = pBt.pPager
	sCheck.nPage = btreePagecount(sCheck.pBt)
	sCheck.mxErr = mxErr
	sCheck.nErr = int32(0)
	sCheck.bOomFault = int32(0)
	sCheck.zPfx = (*int8)(nil)
	sCheck.v1 = uint32(0)
	sCheck.v2 = int32(0)
	sCheck.aPgRef = (*uint8)(nil)
	sCheck.heap = (*uint32)(nil)
	sqlite3StrAccumInit(&sCheck.errMsg, nil, (*int8)(unsafe.Pointer(&zErr)), int32(100), 1000000000)
	sCheck.errMsg.printfFlags = uint8(1)
	if sCheck.nPage == uint32(0) {
		goto integrity_ck_cleanup
	}
	sCheck.aPgRef = (*uint8)(sqlite3MallocZero(uint64(sCheck.nPage/uint32(8) + uint32(1))))
	if !(sCheck.aPgRef != nil) {
		sCheck.bOomFault = int32(1)
		goto integrity_ck_cleanup
	}
	sCheck.heap = (*uint32)(sqlite3PageMalloc(int32(pBt.pageSize)))
	if uintptr(unsafe.Pointer(sCheck.heap)) == uintptr(unsafe.Pointer(nil)) {
		sCheck.bOomFault = int32(1)
		goto integrity_ck_cleanup
	}
	i = uint32(uint32(sqlite3PendingByte)/pBt.pageSize + uint32(1))
	if i <= sCheck.nPage {
		setPageReferenced(&sCheck, i)
	}
	if bCkFreelist != 0 {
		sCheck.zPfx = (*int8)(unsafe.Pointer(&[16]int8{'M', 'a', 'i', 'n', ' ', 'f', 'r', 'e', 'e', 'l', 'i', 's', 't', ':', ' ', '\x00'}))
		checkList(&sCheck, 1, sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(32)))), sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(36)))))
		sCheck.zPfx = (*int8)(nil)
	}
	if !(bPartial != 0) {
		if pBt.autoVacuum != 0 {
			var mx uint32 = uint32(0)
			var mxInHdr uint32
			for i = uint32(0); int32(i) < nRoot; i++ {
				if mx < *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(i)*4)) {
					mx = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(i)*4))
				}
			}
			mxInHdr = sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(52))))
			if mx != mxInHdr {
				checkAppendMsg(&sCheck, (*int8)(unsafe.Pointer(&[45]int8{'m', 'a', 'x', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', ' ', '(', '%', 'd', ')', ' ', 'd', 'i', 's', 'a', 'g', 'r', 'e', 'e', 's', ' ', 'w', 'i', 't', 'h', ' ', 'h', 'e', 'a', 'd', 'e', 'r', ' ', '(', '%', 'd', ')', '\x00'})), mx, mxInHdr)
			}
		} else if sqlite3Get4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBt.pPage1.aData)) + uintptr(64)))) != uint32(0) {
			checkAppendMsg(&sCheck, (*int8)(unsafe.Pointer(&[55]int8{'i', 'n', 'c', 'r', 'e', 'm', 'e', 'n', 't', 'a', 'l', '_', 'v', 'a', 'c', 'u', 'u', 'm', ' ', 'e', 'n', 'a', 'b', 'l', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 'a', ' ', 'm', 'a', 'x', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', ' ', 'o', 'f', ' ', 'z', 'e', 'r', 'o', '\x00'})))
		}
	}
	pBt.db.flags &= ^uint64(2097152)
	for i = uint32(0); int32(i) < nRoot && sCheck.mxErr != 0; i++ {
		var notUsed int64
		if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(i)*4)) == uint32(0) {
			continue
		}
		if int32(pBt.autoVacuum) != 0 && *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(i)*4)) > uint32(1) && !(bPartial != 0) {
			checkPtrmap(&sCheck, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(i)*4)), uint8(1), uint32(0))
		}
		checkTreePage(&sCheck, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(i)*4)), &notUsed, int64(4294967295)|int64(2147483647)<<32)
	}
	pBt.db.flags = savedDbFlags
	if !(bPartial != 0) {
		for i = uint32(1); i <= sCheck.nPage && sCheck.mxErr != 0; i++ {
			if getPageReferenced(&sCheck, i) == 0 && (ptrmapPageno(pBt, i) != i || !(pBt.autoVacuum != 0)) {
				checkAppendMsg(&sCheck, (*int8)(unsafe.Pointer(&[22]int8{'P', 'a', 'g', 'e', ' ', '%', 'd', ' ', 'i', 's', ' ', 'n', 'e', 'v', 'e', 'r', ' ', 'u', 's', 'e', 'd', '\x00'})), i)
			}
			if getPageReferenced(&sCheck, i) != 0 && (ptrmapPageno(pBt, i) == i && int32(pBt.autoVacuum) != 0) {
				checkAppendMsg(&sCheck, (*int8)(unsafe.Pointer(&[34]int8{'P', 'o', 'i', 'n', 't', 'e', 'r', ' ', 'm', 'a', 'p', ' ', 'p', 'a', 'g', 'e', ' ', '%', 'd', ' ', 'i', 's', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 'd', '\x00'})), i)
			}
		}
	}
integrity_ck_cleanup:
	sqlite3PageFree(unsafe.Pointer(sCheck.heap))
	sqlite3_free(unsafe.Pointer(sCheck.aPgRef))
	if sCheck.bOomFault != 0 {
		sqlite3_str_reset(&sCheck.errMsg)
		sCheck.nErr++
	}
	*pnErr = sCheck.nErr
	if sCheck.nErr == 0 {
		sqlite3_str_reset(&sCheck.errMsg)
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeLeave(p)
	return sqlite3StrAccumFinish(&sCheck.errMsg)
}
func sqlite3BtreeGetFilename(p *struct_Btree) *int8 {
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3PagerFilename(p.pBt.pPager, 1)
}
func sqlite3BtreeGetJournalname(p *struct_Btree) *int8 {
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3PagerJournalname(p.pBt.pPager)
}
func sqlite3BtreeTxnState(p *struct_Btree) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if p != nil {
			return int32(p.inTrans)
		} else {
			return 0
		}
	}()
}
func sqlite3BtreeCheckpoint(p *struct_Btree, eMode int32, pnLog *int32, pnCkpt *int32) int32 {
	var rc int32 = 0
	if p != nil {
		var pBt *struct_BtShared = p.pBt
		sqlite3BtreeEnter(p)
		if int32(pBt.inTransaction) != 0 {
			rc = int32(6)
		} else {
			rc = sqlite3PagerCheckpoint(pBt.pPager, p.db, eMode, pnLog, pnCkpt)
		}
		sqlite3BtreeLeave(p)
	}
	return rc
}
func sqlite3BtreeIsInBackup(p *struct_Btree) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if p.nBackup != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3BtreeSchema(p *struct_Btree, nBytes int32, xFree func(unsafe.Pointer)) unsafe.Pointer {
	var pBt *struct_BtShared = p.pBt
	sqlite3BtreeEnter(p)
	if !(pBt.pSchema != nil) && nBytes != 0 {
		pBt.pSchema = sqlite3DbMallocZero(nil, uint64(nBytes))
		pBt.xFreeSchema = xFree
	}
	sqlite3BtreeLeave(p)
	return pBt.pSchema
}
func sqlite3BtreeSchemaLocked(p *struct_Btree) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeEnter(p)
	rc = querySharedCacheTableLock(p, uint32(1), uint8(1))
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BtreeLeave(p)
	return rc
}
func sqlite3BtreeLockTable(p *struct_Btree, iTab int32, isWriteLock uint8) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if p.sharable != 0 {
		var lockType uint8 = uint8(1 + int32(isWriteLock))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3BtreeEnter(p)
		rc = querySharedCacheTableLock(p, uint32(iTab), lockType)
		if rc == 0 {
			rc = setSharedCacheTableLock(p, uint32(iTab), lockType)
		}
		sqlite3BtreeLeave(p)
	}
	return rc
}
func sqlite3BtreePutData(pCsr *struct_BtCursor, offset uint32, amt uint32, z unsafe.Pointer) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = func() int32 {
		if int32(pCsr.eState) >= 3 {
			return btreeRestoreCursorPosition(pCsr)
		} else {
			return 0
		}
	}()
	if rc != 0 {
		return rc
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCsr.eState) != 0 {
		return int32(4)
	}
	saveAllCursors(pCsr.pBt, pCsr.pgnoRoot, pCsr)
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCsr.curFlags)&1 == 0 {
		return int32(8)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return accessPayload(pCsr, offset, amt, (*uint8)(z), 1)
}
func sqlite3BtreeIncrblobCursor(pCur *struct_BtCursor) {
	pCur.curFlags |= uint8(16)
	pCur.pBtree.hasIncrblobCur = uint8(1)
}
func sqlite3BtreeSetVersion(pBtree *struct_Btree, iVersion int32) int32 {
	var pBt *struct_BtShared = pBtree.pBt
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	pBt.btsFlags &= uint16(^32)
	if iVersion == 1 {
		pBt.btsFlags |= uint16(32)
	}
	rc = sqlite3BtreeBeginTrans(pBtree, 0, nil)
	if rc == 0 {
		var aData *uint8 = pBt.pPage1.aData
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(18)))) != int32(uint8(iVersion)) || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(19)))) != int32(uint8(iVersion)) {
			rc = sqlite3BtreeBeginTrans(pBtree, 2, nil)
			if rc == 0 {
				rc = sqlite3PagerWrite(pBt.pPage1.pDbPage)
				if rc == 0 {
					*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(18))) = uint8(iVersion)
					*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aData)) + uintptr(19))) = uint8(iVersion)
				}
			}
		}
	}
	pBt.btsFlags &= uint16(^32)
	return rc
}
func sqlite3BtreeCursorHasHint(pCsr *struct_BtCursor, mask uint32) int32 {
	return func() int32 {
		if uint32(pCsr.hints)&mask != uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3BtreeIsReadonly(p *struct_Btree) int32 {
	return func() int32 {
		if int32(p.pBt.btsFlags)&1 != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3HeaderSizeBtree() int32 {
	return int32((136 + uint(7)) & uint(18446744073709551608))
}
func sqlite3BtreeSharable(p *struct_Btree) int32 {
	return int32(p.sharable)
}
func sqlite3BtreeConnectionCount(p *struct_Btree) int32 {
	return p.pBt.nRef
}

type struct_sqlite3_backup struct {
	pDestDb     *struct_sqlite3
	pDest       *struct_Btree
	iDestSchema uint32
	bDestLocked int32
	iNext       uint32
	pSrcDb      *struct_sqlite3
	pSrc        *struct_Btree
	rc          int32
	nRemaining  uint32
	nPagecount  uint32
	isAttached  int32
	pNext       *struct_sqlite3_backup
}

func findBtree(pErrorDb *struct_sqlite3, pDb *struct_sqlite3, zDb *int8) *struct_Btree {
	var i int32 = sqlite3FindDbName(pDb, zDb)
	if i == 1 {
		var sParse struct_Parse
		var rc int32 = 0
		sqlite3ParseObjectInit(&sParse, pDb)
		if sqlite3OpenTempDatabase(&sParse) != 0 {
			sqlite3ErrorWithMsg(pErrorDb, sParse.rc, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sParse.zErrMsg)
			rc = int32(1)
		}
		sqlite3DbFree(pErrorDb, unsafe.Pointer(sParse.zErrMsg))
		sqlite3ParseObjectReset(&sParse)
		if rc != 0 {
			return (*struct_Btree)(nil)
		}
	}
	if i < 0 {
		sqlite3ErrorWithMsg(pErrorDb, 1, (*int8)(unsafe.Pointer(&[20]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 's', '\x00'})), zDb)
		return (*struct_Btree)(nil)
	}
	return (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pDb.aDb)) + uintptr(i)*32))).pBt
}
func setDestPgsz(p *struct_sqlite3_backup) int32 {
	var rc int32
	rc = sqlite3BtreeSetPageSize(p.pDest, sqlite3BtreeGetPageSize(p.pSrc), 0, 0)
	return rc
}
func checkReadTransaction(db *struct_sqlite3, p *struct_Btree) int32 {
	if sqlite3BtreeTxnState(p) != 0 {
		sqlite3ErrorWithMsg(db, 1, (*int8)(unsafe.Pointer(&[31]int8{'d', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'i', 's', ' ', 'i', 'n', ' ', 'u', 's', 'e', '\x00'})))
		return int32(1)
	}
	return int32(0)
}
func sqlite3_backup_init(pDestDb *struct_sqlite3, zDestDb *int8, pSrcDb *struct_sqlite3, zSrcDb *int8) *struct_sqlite3_backup {
	var p *struct_sqlite3_backup
	sqlite3_mutex_enter(pSrcDb.mutex)
	sqlite3_mutex_enter(pDestDb.mutex)
	if uintptr(unsafe.Pointer(pSrcDb)) == uintptr(unsafe.Pointer(pDestDb)) {
		sqlite3ErrorWithMsg(pDestDb, 1, (*int8)(unsafe.Pointer(&[40]int8{'s', 'o', 'u', 'r', 'c', 'e', ' ', 'a', 'n', 'd', ' ', 'd', 'e', 's', 't', 'i', 'n', 'a', 't', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'd', 'i', 's', 't', 'i', 'n', 'c', 't', '\x00'})))
		p = (*struct_sqlite3_backup)(nil)
	} else {
		p = (*struct_sqlite3_backup)(sqlite3MallocZero(uint64(72)))
		if !(p != nil) {
			sqlite3Error(pDestDb, 7)
		}
	}
	if p != nil {
		p.pSrc = findBtree(pDestDb, pSrcDb, zSrcDb)
		p.pDest = findBtree(pDestDb, pDestDb, zDestDb)
		p.pDestDb = pDestDb
		p.pSrcDb = pSrcDb
		p.iNext = uint32(1)
		p.isAttached = int32(0)
		if nil == p.pSrc || nil == p.pDest || checkReadTransaction(pDestDb, p.pDest) != 0 {
			sqlite3_free(unsafe.Pointer(p))
			p = (*struct_sqlite3_backup)(nil)
		}
	}
	if p != nil {
		p.pSrc.nBackup++
	}
	sqlite3_mutex_leave(pDestDb.mutex)
	sqlite3_mutex_leave(pSrcDb.mutex)
	return p
}
func isFatalError(rc int32) int32 {
	return func() int32 {
		if rc != 0 && rc != 5 && rc != 6 {
			return 1
		} else {
			return 0
		}
	}()
}
func backupOnePage(p *struct_sqlite3_backup, iSrcPg uint32, zSrcData *uint8, bUpdate int32) int32 {
	var pDestPager *struct_Pager = sqlite3BtreePager(p.pDest)
	var nSrcPgsz int32 = sqlite3BtreeGetPageSize(p.pSrc)
	var nDestPgsz int32 = sqlite3BtreeGetPageSize(p.pDest)
	var nCopy int32 = func() int32 {
		if nSrcPgsz < nDestPgsz {
			return nSrcPgsz
		} else {
			return nDestPgsz
		}
	}()
	var iEnd int64 = int64(iSrcPg) * int64(nSrcPgsz)
	var rc int32 = 0
	var iOff int64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nSrcPgsz != nDestPgsz && sqlite3PagerIsMemdb(pDestPager) != 0 {
		rc = int32(8)
	}
	for iOff = iEnd - int64(nSrcPgsz); rc == 0 && iOff < iEnd; iOff += int64(nDestPgsz) {
		var pDestPg *struct_PgHdr = nil
		var iDest uint32 = uint32(iOff/int64(nDestPgsz)) + uint32(1)
		if iDest == uint32(uint32(sqlite3PendingByte)/p.pDest.pBt.pageSize+uint32(1)) {
			continue
		}
		if 0 == func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0)
			return *_cgo_addr
		}() && 0 == func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3PagerWrite(pDestPg)
			return *_cgo_addr
		}() {
			var zIn *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSrcData)) + uintptr(iOff%int64(nSrcPgsz))))
			var zDestData *uint8 = (*uint8)(sqlite3PagerGetData(pDestPg))
			var zOut *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDestData)) + uintptr(iOff%int64(nDestPgsz))))
			__builtin___memcpy_chk(unsafe.Pointer(zOut), unsafe.Pointer(zIn), uint(nCopy), __builtin_object_size(unsafe.Pointer(zOut), 0))
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(sqlite3PagerGetExtra(pDestPg)))) + uintptr(0))) = uint8(0)
			if iOff == int64(0) && bUpdate == 0 {
				sqlite3Put4byte(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(28))), sqlite3BtreeLastPage(p.pSrc))
			}
		}
		sqlite3PagerUnref(pDestPg)
	}
	return rc
}
func backupTruncateFile(pFile *struct_sqlite3_file, iSize int64) int32 {
	var iCurrent int64
	var rc int32 = sqlite3OsFileSize(pFile, &iCurrent)
	if rc == 0 && iCurrent > iSize {
		rc = sqlite3OsTruncate(pFile, iSize)
	}
	return rc
}
func attachBackupObject(p *struct_sqlite3_backup) {
	var pp **struct_sqlite3_backup
	func() int {
		_ = 0
		return 0
	}()
	pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p.pSrc))
	p.pNext = *pp
	*pp = p
	p.isAttached = int32(1)
}
func sqlite3_backup_step(p *struct_sqlite3_backup, nPage int32) int32 {
	var rc int32
	var destMode int32
	var pgszSrc int32 = 0
	var pgszDest int32 = 0
	sqlite3_mutex_enter(p.pSrcDb.mutex)
	sqlite3BtreeEnter(p.pSrc)
	if p.pDestDb != nil {
		sqlite3_mutex_enter(p.pDestDb.mutex)
	}
	rc = p.rc
	if !(isFatalError(rc) != 0) {
		var pSrcPager *struct_Pager = sqlite3BtreePager(p.pSrc)
		var pDestPager *struct_Pager = sqlite3BtreePager(p.pDest)
		var ii int32
		var nSrcPage int32 = -1
		var bCloseTrans int32 = 0
		if p.pDestDb != nil && int32(p.pSrc.pBt.inTransaction) == 2 {
			rc = int32(5)
		} else {
			rc = int32(0)
		}
		if rc == 0 && 0 == sqlite3BtreeTxnState(p.pSrc) {
			rc = sqlite3BtreeBeginTrans(p.pSrc, 0, nil)
			bCloseTrans = int32(1)
		}
		if p.bDestLocked == 0 && rc == 0 && setDestPgsz(p) == 7 {
			rc = int32(7)
		}
		if 0 == rc && p.bDestLocked == 0 && 0 == func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3BtreeBeginTrans(p.pDest, 2, (*int32)(unsafe.Pointer(&p.iDestSchema)))
			return *_cgo_addr
		}() {
			p.bDestLocked = int32(1)
		}
		pgszSrc = sqlite3BtreeGetPageSize(p.pSrc)
		pgszDest = sqlite3BtreeGetPageSize(p.pDest)
		destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p.pDest))
		if 0 == rc && destMode == 5 && pgszSrc != pgszDest {
			rc = int32(8)
		}
		nSrcPage = int32(sqlite3BtreeLastPage(p.pSrc))
		func() int {
			_ = 0
			return 0
		}()
		for ii = int32(0); (nPage < 0 || ii < nPage) && p.iNext <= uint32(nSrcPage) && !(rc != 0); ii++ {
			var iSrcPg uint32 = p.iNext
			if iSrcPg != uint32(uint32(sqlite3PendingByte)/p.pSrc.pBt.pageSize+uint32(1)) {
				var pSrcPg *struct_PgHdr
				rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 2)
				if rc == 0 {
					rc = backupOnePage(p, iSrcPg, (*uint8)(sqlite3PagerGetData(pSrcPg)), 0)
					sqlite3PagerUnref(pSrcPg)
				}
			}
			p.iNext++
		}
		if rc == 0 {
			p.nPagecount = uint32(nSrcPage)
			p.nRemaining = uint32(nSrcPage+1) - p.iNext
			if p.iNext > uint32(nSrcPage) {
				rc = int32(101)
			} else if !(p.isAttached != 0) {
				attachBackupObject(p)
			}
		}
		if rc == 101 {
			if nSrcPage == 0 {
				rc = sqlite3BtreeNewDb(p.pDest)
				nSrcPage = int32(1)
			}
			if rc == 0 || rc == 101 {
				rc = sqlite3BtreeUpdateMeta(p.pDest, 1, p.iDestSchema+uint32(1))
			}
			if rc == 0 {
				if p.pDestDb != nil {
					sqlite3ResetAllSchemasOfConnection(p.pDestDb)
				}
				if destMode == 5 {
					rc = sqlite3BtreeSetVersion(p.pDest, 2)
				}
			}
			if rc == 0 {
				var nDestTruncate int32
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if pgszSrc < pgszDest {
					var ratio int32 = pgszDest / pgszSrc
					nDestTruncate = (nSrcPage + ratio - 1) / ratio
					if nDestTruncate == int32(uint32(uint32(sqlite3PendingByte)/p.pDest.pBt.pageSize+uint32(1))) {
						nDestTruncate--
					}
				} else {
					nDestTruncate = nSrcPage * (pgszSrc / pgszDest)
				}
				func() int {
					_ = 0
					return 0
				}()
				if pgszSrc < pgszDest {
					var iSize int64 = int64(pgszSrc) * int64(nSrcPage)
					var pFile *struct_sqlite3_file = sqlite3PagerFile(pDestPager)
					var iPg uint32
					var nDstPage int32
					var iOff int64
					var iEnd int64
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					sqlite3PagerPagecount(pDestPager, &nDstPage)
					for iPg = uint32(nDestTruncate); rc == 0 && iPg <= uint32(nDstPage); iPg++ {
						if iPg != uint32(uint32(sqlite3PendingByte)/p.pDest.pBt.pageSize+uint32(1)) {
							var pPg *struct_PgHdr
							rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0)
							if rc == 0 {
								rc = sqlite3PagerWrite(pPg)
								sqlite3PagerUnref(pPg)
							}
						}
					}
					if rc == 0 {
						rc = sqlite3PagerCommitPhaseOne(pDestPager, nil, 1)
					}
					iEnd = func() int64 {
						if int64(sqlite3PendingByte+pgszDest) < iSize {
							return int64(sqlite3PendingByte + pgszDest)
						} else {
							return iSize
						}
					}()
					for iOff = int64(sqlite3PendingByte + pgszSrc); rc == 0 && iOff < iEnd; iOff += int64(pgszSrc) {
						var pSrcPg *struct_PgHdr = nil
						var iSrcPg uint32 = uint32(iOff/int64(pgszSrc) + int64(1))
						rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0)
						if rc == 0 {
							var zData *uint8 = (*uint8)(sqlite3PagerGetData(pSrcPg))
							rc = sqlite3OsWrite(pFile, unsafe.Pointer(zData), pgszSrc, iOff)
						}
						sqlite3PagerUnref(pSrcPg)
					}
					if rc == 0 {
						rc = backupTruncateFile(pFile, iSize)
					}
					if rc == 0 {
						rc = sqlite3PagerSync(pDestPager, nil)
					}
				} else {
					sqlite3PagerTruncateImage(pDestPager, uint32(nDestTruncate))
					rc = sqlite3PagerCommitPhaseOne(pDestPager, nil, 0)
				}
				if 0 == rc && 0 == func() (_cgo_ret int32) {
					_cgo_addr := &rc
					*_cgo_addr = sqlite3BtreeCommitPhaseTwo(p.pDest, 0)
					return *_cgo_addr
				}() {
					rc = int32(101)
				}
			}
		}
		if bCloseTrans != 0 {
			sqlite3BtreeCommitPhaseOne(p.pSrc, nil)
			sqlite3BtreeCommitPhaseTwo(p.pSrc, 0)
			func() int {
				_ = 0
				return 0
			}()
		}
		if rc == 10|12<<8 {
			rc = int32(7)
		}
		p.rc = rc
	}
	if p.pDestDb != nil {
		sqlite3_mutex_leave(p.pDestDb.mutex)
	}
	sqlite3BtreeLeave(p.pSrc)
	sqlite3_mutex_leave(p.pSrcDb.mutex)
	return rc
}
func sqlite3_backup_finish(p *struct_sqlite3_backup) int32 {
	var pp **struct_sqlite3_backup
	var pSrcDb *struct_sqlite3
	var rc int32
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	pSrcDb = p.pSrcDb
	sqlite3_mutex_enter(pSrcDb.mutex)
	sqlite3BtreeEnter(p.pSrc)
	if p.pDestDb != nil {
		sqlite3_mutex_enter(p.pDestDb.mutex)
	}
	if p.pDestDb != nil {
		p.pSrc.nBackup--
	}
	if p.isAttached != 0 {
		pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p.pSrc))
		func() int {
			_ = 0
			return 0
		}()
		for uintptr(unsafe.Pointer(*pp)) != uintptr(unsafe.Pointer(p)) {
			pp = &(*pp).pNext
			func() int {
				_ = 0
				return 0
			}()
		}
		*pp = p.pNext
	}
	sqlite3BtreeRollback(p.pDest, 0, 0)
	rc = func() int32 {
		if p.rc == 101 {
			return 0
		} else {
			return p.rc
		}
	}()
	if p.pDestDb != nil {
		sqlite3Error(p.pDestDb, rc)
		sqlite3LeaveMutexAndCloseZombie(p.pDestDb)
	}
	sqlite3BtreeLeave(p.pSrc)
	if p.pDestDb != nil {
		sqlite3_free(unsafe.Pointer(p))
	}
	sqlite3LeaveMutexAndCloseZombie(pSrcDb)
	return rc
}
func sqlite3_backup_remaining(p *struct_sqlite3_backup) int32 {
	return int32(p.nRemaining)
}
func sqlite3_backup_pagecount(p *struct_sqlite3_backup) int32 {
	return int32(p.nPagecount)
}
func backupUpdate(p *struct_sqlite3_backup, iPage uint32, aData *uint8) {
	func() int {
		_ = 0
		return 0
	}()
	for {
		func() int {
			_ = 0
			return 0
		}()
		if !(isFatalError(p.rc) != 0) && iPage < p.iNext {
			var rc int32
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_mutex_enter(p.pDestDb.mutex)
			rc = backupOnePage(p, iPage, aData, 1)
			sqlite3_mutex_leave(p.pDestDb.mutex)
			func() int {
				_ = 0
				return 0
			}()
			if rc != 0 {
				p.rc = rc
			}
		}
		if !(uintptr(unsafe.Pointer(func() (_cgo_ret *struct_sqlite3_backup) {
			_cgo_addr := &p
			*_cgo_addr = p.pNext
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil))) {
			break
		}
	}
}
func sqlite3BackupUpdate(pBackup *struct_sqlite3_backup, iPage uint32, aData *uint8) {
	if pBackup != nil {
		backupUpdate(pBackup, iPage, aData)
	}
}
func sqlite3BackupRestart(pBackup *struct_sqlite3_backup) {
	var p *struct_sqlite3_backup
	for p = pBackup; p != nil; p = p.pNext {
		func() int {
			_ = 0
			return 0
		}()
		p.iNext = uint32(1)
	}
}
func sqlite3BtreeCopyFile(pTo *struct_Btree, pFrom *struct_Btree) int32 {
	var rc int32
	var pFd *struct_sqlite3_file
	var b struct_sqlite3_backup
	sqlite3BtreeEnter(pTo)
	sqlite3BtreeEnter(pFrom)
	func() int {
		_ = 0
		return 0
	}()
	pFd = sqlite3PagerFile(sqlite3BtreePager(pTo))
	if pFd.pMethods != nil {
		var nByte int64 = int64(sqlite3BtreeGetPageSize(pFrom)) * int64(sqlite3BtreeLastPage(pFrom))
		rc = sqlite3OsFileControl(pFd, 11, unsafe.Pointer(&nByte))
		if rc == 12 {
			rc = int32(0)
		}
		if rc != 0 {
			goto copy_finished
		}
	}
	__builtin___memset_chk(unsafe.Pointer(&b), 0, 72, __builtin_object_size(unsafe.Pointer(&b), 0))
	b.pSrcDb = pFrom.db
	b.pSrc = pFrom
	b.pDest = pTo
	b.iNext = uint32(1)
	sqlite3_backup_step(&b, 2147483647)
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3_backup_finish(&b)
	if rc == 0 {
		pTo.pBt.btsFlags &= uint16(^2)
	} else {
		sqlite3PagerClearCache(sqlite3BtreePager(b.pDest))
	}
	func() int {
		_ = 0
		return 0
	}()
copy_finished:
	sqlite3BtreeLeave(pFrom)
	sqlite3BtreeLeave(pTo)
	return rc
}
func vdbeMemRenderNum(sz int32, zBuf *int8, p *struct_sqlite3_value) {
	var acc struct_sqlite3_str
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&4 != 0 {
		sqlite3Int64ToText(*(*int64)(unsafe.Pointer(&p.u)), zBuf)
	} else {
		sqlite3StrAccumInit(&acc, nil, zBuf, sz, 0)
		sqlite3_str_appendf(&acc, (*int8)(unsafe.Pointer(&[7]int8{'%', '!', '.', '1', '5', 'g', '\x00'})), func() float64 {
			if int32(p.flags)&32 != 0 {
				return float64(*(*int64)(unsafe.Pointer(&p.u)))
			} else {
				return p.u.r
			}
		}())
		func() int {
			_ = 0
			return 0
		}()
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(acc.nChar))) = int8(0)
	}
}
func sqlite3VdbeChangeEncoding(pMem *struct_sqlite3_value, desiredEnc int32) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(int32(pMem.flags)&2 != 0) || int32(pMem.enc) == desiredEnc {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3VdbeMemTranslate(pMem, uint8(desiredEnc))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3VdbeMemGrow(pMem *struct_sqlite3_value, n int32, bPreserve int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pMem.szMalloc > 0 && bPreserve != 0 && uintptr(unsafe.Pointer(pMem.z)) == uintptr(unsafe.Pointer(pMem.zMalloc)) {
		if pMem.db != nil {
			pMem.z = func() (_cgo_ret *int8) {
				_cgo_addr := &pMem.zMalloc
				*_cgo_addr = (*int8)(sqlite3DbReallocOrFree(pMem.db, unsafe.Pointer(pMem.z), uint64(n)))
				return *_cgo_addr
			}()
		} else {
			pMem.zMalloc = (*int8)(sqlite3Realloc(unsafe.Pointer(pMem.z), uint64(n)))
			if uintptr(unsafe.Pointer(pMem.zMalloc)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3_free(unsafe.Pointer(pMem.z))
			}
			pMem.z = pMem.zMalloc
		}
		bPreserve = int32(0)
	} else {
		if pMem.szMalloc > 0 {
			sqlite3DbFreeNN(pMem.db, unsafe.Pointer(pMem.zMalloc))
		}
		pMem.zMalloc = (*int8)(sqlite3DbMallocRaw(pMem.db, uint64(n)))
	}
	if uintptr(unsafe.Pointer(pMem.zMalloc)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3VdbeMemSetNull(pMem)
		pMem.z = (*int8)(nil)
		pMem.szMalloc = int32(0)
		return int32(7)
	} else {
		pMem.szMalloc = sqlite3DbMallocSize(pMem.db, unsafe.Pointer(pMem.zMalloc))
	}
	if bPreserve != 0 && pMem.z != nil {
		func() int {
			_ = 0
			return 0
		}()
		__builtin___memcpy_chk(unsafe.Pointer(pMem.zMalloc), unsafe.Pointer(pMem.z), uint(pMem.n), __builtin_object_size(unsafe.Pointer(pMem.zMalloc), 0))
	}
	if int32(pMem.flags)&1024 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pMem.xDel(unsafe.Pointer(pMem.z))
	}
	pMem.z = pMem.zMalloc
	pMem.flags &= uint16(^(1024 | 4096 | 2048))
	return int32(0)
}
func sqlite3VdbeMemClearAndResize(pMem *struct_sqlite3_value, szNew int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pMem.szMalloc < szNew {
		return sqlite3VdbeMemGrow(pMem, szNew, 0)
	}
	func() int {
		_ = 0
		return 0
	}()
	pMem.z = pMem.zMalloc
	pMem.flags &= uint16(1 | 4 | 8 | 32)
	return int32(0)
}
func vdbeMemAddTerminator(pMem *struct_sqlite3_value) int32 {
	if sqlite3VdbeMemGrow(pMem, pMem.n+3, 1) != 0 {
		return int32(7)
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n))) = int8(0)
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n+1))) = int8(0)
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n+2))) = int8(0)
	pMem.flags |= uint16(512)
	return int32(0)
}
func sqlite3VdbeMemMakeWriteable(pMem *struct_sqlite3_value) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pMem.flags)&(2|16) != 0 {
		if func() int32 {
			if int32(pMem.flags)&16384 != 0 {
				return sqlite3VdbeMemExpandBlob(pMem)
			} else {
				return 0
			}
		}() != 0 {
			return int32(7)
		}
		if pMem.szMalloc == 0 || uintptr(unsafe.Pointer(pMem.z)) != uintptr(unsafe.Pointer(pMem.zMalloc)) {
			var rc int32 = vdbeMemAddTerminator(pMem)
			if rc != 0 {
				return rc
			}
		}
	}
	pMem.flags &= uint16(^4096)
	return int32(0)
}
func sqlite3VdbeMemExpandBlob(pMem *struct_sqlite3_value) int32 {
	var nByte int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nByte = pMem.n + *(*int32)(unsafe.Pointer(&pMem.u))
	if nByte <= 0 {
		if int32(pMem.flags)&16 == 0 {
			return int32(0)
		}
		nByte = int32(1)
	}
	if sqlite3VdbeMemGrow(pMem, nByte, 1) != 0 {
		return int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n)))), 0, uint(*(*int32)(unsafe.Pointer(&pMem.u))), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(pMem.n)))), 0))
	pMem.n += *(*int32)(unsafe.Pointer(&pMem.u))
	pMem.flags &= uint16(^(16384 | 512))
	return int32(0)
}
func sqlite3VdbeMemNulTerminate(pMem *struct_sqlite3_value) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pMem.flags)&(512|2) != 2 {
		return int32(0)
	} else {
		return vdbeMemAddTerminator(pMem)
	}
}
func sqlite3VdbeMemStringify(pMem *struct_sqlite3_value, enc uint8, bForce uint8) int32 {
	const nByte int32 = 32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3VdbeMemClearAndResize(pMem, nByte) != 0 {
		pMem.enc = uint8(0)
		return int32(7)
	}
	vdbeMemRenderNum(nByte, pMem.z, pMem)
	func() int {
		_ = 0
		return 0
	}()
	pMem.n = int32(strlen(pMem.z) & uint(1073741823))
	pMem.enc = uint8(1)
	pMem.flags |= uint16(2 | 512)
	if bForce != 0 {
		pMem.flags &= uint16(^(4 | 8 | 32))
	}
	sqlite3VdbeChangeEncoding(pMem, int32(enc))
	return int32(0)
}
func sqlite3VdbeMemFinalize(pMem *struct_sqlite3_value, pFunc *struct_FuncDef) int32 {
	var ctx struct_sqlite3_context
	var t struct_sqlite3_value
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&ctx), 0, 56, __builtin_object_size(unsafe.Pointer(&ctx), 0))
	__builtin___memset_chk(unsafe.Pointer(&t), 0, 56, __builtin_object_size(unsafe.Pointer(&t), 0))
	t.flags = uint16(1)
	t.db = pMem.db
	ctx.pOut = &t
	ctx.pMem = pMem
	ctx.pFunc = pFunc
	pFunc.xFinalize(&ctx)
	func() int {
		_ = 0
		return 0
	}()
	if pMem.szMalloc > 0 {
		sqlite3DbFreeNN(pMem.db, unsafe.Pointer(pMem.zMalloc))
	}
	__builtin___memcpy_chk(unsafe.Pointer(pMem), unsafe.Pointer(&t), 56, __builtin_object_size(unsafe.Pointer(pMem), 0))
	return ctx.isError
}
func sqlite3VdbeMemAggValue(pAccum *struct_sqlite3_value, pOut *struct_sqlite3_value, pFunc *struct_FuncDef) int32 {
	var ctx struct_sqlite3_context
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&ctx), 0, 56, __builtin_object_size(unsafe.Pointer(&ctx), 0))
	sqlite3VdbeMemSetNull(pOut)
	ctx.pOut = pOut
	ctx.pMem = pAccum
	ctx.pFunc = pFunc
	pFunc.xValue(&ctx)
	return ctx.isError
}
func vdbeMemClearExternAndSetNull(p *struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&8192 != 0 {
		sqlite3VdbeMemFinalize(p, *(**struct_FuncDef)(unsafe.Pointer(&p.u)))
		func() int {
			_ = 0
			return 0
		}()
	}
	if int32(p.flags)&1024 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		p.xDel(unsafe.Pointer(p.z))
	}
	p.flags = uint16(1)
}
func vdbeMemClear(p *struct_sqlite3_value) {
	if int32(p.flags)&(8192|1024) != 0 {
		vdbeMemClearExternAndSetNull(p)
	}
	if p.szMalloc != 0 {
		sqlite3DbFreeNN(p.db, unsafe.Pointer(p.zMalloc))
		p.szMalloc = int32(0)
	}
	p.z = (*int8)(nil)
}
func sqlite3VdbeMemRelease(p *struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&(8192|1024) != 0 || p.szMalloc != 0 {
		vdbeMemClear(p)
	}
}
func doubleToInt64(r float64) int64 {
	var maxInt int64 = int64(4294967295) | int64(2147483647)<<32
	var minInt int64 = int64(-1) - (int64(4294967295) | int64(2147483647)<<32)
	if r <= float64(minInt) {
		return minInt
	} else if r >= float64(maxInt) {
		return maxInt
	} else {
		return int64(r)
	}
}
func memIntValue(pMem *struct_sqlite3_value) int64 {
	var value int64 = int64(0)
	sqlite3Atoi64(pMem.z, &value, pMem.n, pMem.enc)
	return value
}
func sqlite3VdbeIntValue(pMem *struct_sqlite3_value) int64 {
	var flags int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	flags = int32(pMem.flags)
	if flags&(4|32) != 0 {
		return *(*int64)(unsafe.Pointer(&pMem.u))
	} else if flags&8 != 0 {
		return doubleToInt64(pMem.u.r)
	} else if flags&(2|16) != 0 && uintptr(unsafe.Pointer(pMem.z)) != uintptr(unsafe.Pointer(nil)) {
		return memIntValue(pMem)
	} else {
		return int64(0)
	}
}
func memRealValue(pMem *struct_sqlite3_value) float64 {
	var val float64 = float64(0)
	sqlite3AtoF(pMem.z, &val, pMem.n, pMem.enc)
	return val
}
func sqlite3VdbeRealValue(pMem *struct_sqlite3_value) float64 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pMem.flags)&8 != 0 {
		return pMem.u.r
	} else if int32(pMem.flags)&(4|32) != 0 {
		return float64(*(*int64)(unsafe.Pointer(&pMem.u)))
	} else if int32(pMem.flags)&(2|16) != 0 {
		return memRealValue(pMem)
	} else {
		return float64(0)
	}
}
func sqlite3VdbeBooleanValue(pMem *struct_sqlite3_value, ifNull int32) int32 {
	if int32(pMem.flags)&(4|32) != 0 {
		return func() int32 {
			if *(*int64)(unsafe.Pointer(&pMem.u)) != int64(0) {
				return 1
			} else {
				return 0
			}
		}()
	}
	if int32(pMem.flags)&1 != 0 {
		return ifNull
	}
	return func() int32 {
		if sqlite3VdbeRealValue(pMem) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3VdbeIntegerAffinity(pMem *struct_sqlite3_value) {
	var ix int64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	ix = doubleToInt64(pMem.u.r)
	if pMem.u.r == float64(ix) && ix > int64(-1)-(int64(4294967295)|int64(2147483647)<<32) && ix < int64(4294967295)|int64(2147483647)<<32 {
		*(*int64)(unsafe.Pointer(&pMem.u)) = ix
		pMem.flags = uint16(int32(pMem.flags) & ^(49599|16384) | 4)
	}
}
func sqlite3VdbeMemIntegerify(pMem *struct_sqlite3_value) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*(*int64)(unsafe.Pointer(&pMem.u)) = sqlite3VdbeIntValue(pMem)
	pMem.flags = uint16(int32(pMem.flags) & ^(49599|16384) | 4)
	return int32(0)
}
func sqlite3VdbeMemRealify(pMem *struct_sqlite3_value) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pMem.u.r = sqlite3VdbeRealValue(pMem)
	pMem.flags = uint16(int32(pMem.flags) & ^(49599|16384) | 8)
	return int32(0)
}
func sqlite3RealSameAsInt(r1 float64, i int64) int32 {
	var r2 float64 = float64(i)
	return func() int32 {
		if r1 == 0 || memcmp(unsafe.Pointer(&r1), unsafe.Pointer(&r2), 8) == 0 && i >= -2251799813685248 && i < 2251799813685248 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3VdbeMemNumerify(pMem *struct_sqlite3_value) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pMem.flags)&(4|8|32|1) == 0 {
		var rc int32
		var ix int64
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3AtoF(pMem.z, &pMem.u.r, pMem.n, pMem.enc)
		if (rc == 0 || rc == 1) && sqlite3Atoi64(pMem.z, &ix, pMem.n, pMem.enc) <= 1 || sqlite3RealSameAsInt(pMem.u.r, func() (_cgo_ret int64) {
			_cgo_addr := &ix
			*_cgo_addr = int64(pMem.u.r)
			return *_cgo_addr
		}()) != 0 {
			*(*int64)(unsafe.Pointer(&pMem.u)) = ix
			pMem.flags = uint16(int32(pMem.flags) & ^(49599|16384) | 4)
		} else {
			pMem.flags = uint16(int32(pMem.flags) & ^(49599|16384) | 8)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	pMem.flags &= uint16(^(2 | 16 | 16384))
	return int32(0)
}
func sqlite3VdbeMemCast(pMem *struct_sqlite3_value, aff uint8, encoding uint8) int32 {
	if int32(pMem.flags)&1 != 0 {
		return int32(0)
	}
	switch int32(aff) {
	case 65:
		{
			if int32(pMem.flags)&16 == 0 {
				sqlite3ValueApplyAffinity(pMem, uint8(66), encoding)
				func() int {
					_ = 0
					return 0
				}()
				if int32(pMem.flags)&2 != 0 {
					pMem.flags = uint16(int32(pMem.flags) & ^(49599|16384) | 16)
				}
			} else {
				pMem.flags &= uint16(^(49599 & ^16))
			}
			break
		}
	case 67:
		{
			sqlite3VdbeMemNumerify(pMem)
			break
		}
	case 68:
		{
			sqlite3VdbeMemIntegerify(pMem)
			break
		}
	case 69:
		{
			sqlite3VdbeMemRealify(pMem)
			break
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pMem.flags |= uint16(int32(pMem.flags) & 16 >> 3)
			sqlite3ValueApplyAffinity(pMem, uint8(66), encoding)
			func() int {
				_ = 0
				return 0
			}()
			pMem.flags &= uint16(^(4 | 8 | 32 | 16 | 16384))
			return sqlite3VdbeChangeEncoding(pMem, int32(encoding))
		}
	}
	return int32(0)
}
func sqlite3VdbeMemInit(pMem *struct_sqlite3_value, db *struct_sqlite3, flags uint16) {
	func() int {
		_ = 0
		return 0
	}()
	pMem.flags = flags
	pMem.db = db
	pMem.szMalloc = int32(0)
}
func sqlite3VdbeMemSetNull(pMem *struct_sqlite3_value) {
	if int32(pMem.flags)&(8192|1024) != 0 {
		vdbeMemClearExternAndSetNull(pMem)
	} else {
		pMem.flags = uint16(1)
	}
}
func sqlite3ValueSetNull(p *struct_sqlite3_value) {
	sqlite3VdbeMemSetNull((*struct_sqlite3_value)(unsafe.Pointer(p)))
}
func sqlite3VdbeMemSetZeroBlob(pMem *struct_sqlite3_value, n int32) {
	sqlite3VdbeMemRelease(pMem)
	pMem.flags = uint16(16 | 16384)
	pMem.n = int32(0)
	if n < 0 {
		n = int32(0)
	}
	*(*int32)(unsafe.Pointer(&pMem.u)) = n
	pMem.enc = uint8(1)
	pMem.z = (*int8)(nil)
}
func vdbeReleaseAndSetInt64(pMem *struct_sqlite3_value, val int64) {
	sqlite3VdbeMemSetNull(pMem)
	*(*int64)(unsafe.Pointer(&pMem.u)) = val
	pMem.flags = uint16(4)
}
func sqlite3VdbeMemSetInt64(pMem *struct_sqlite3_value, val int64) {
	if int32(pMem.flags)&(8192|1024) != 0 {
		vdbeReleaseAndSetInt64(pMem, val)
	} else {
		*(*int64)(unsafe.Pointer(&pMem.u)) = val
		pMem.flags = uint16(4)
	}
}
func sqlite3NoopDestructor(p unsafe.Pointer) {
	func() int {
		_ = p
		return 0
	}()
}
func sqlite3VdbeMemSetPointer(pMem *struct_sqlite3_value, pPtr unsafe.Pointer, zPType *int8, xDestructor func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	vdbeMemClear(pMem)
	*(**int8)(unsafe.Pointer(&pMem.u)) = func() *int8 {
		if zPType != nil {
			return zPType
		} else {
			return (*int8)(unsafe.Pointer((*int8)(unsafe.Pointer(&[1]int8{'\x00'}))))
		}
	}()
	pMem.z = (*int8)(pPtr)
	pMem.flags = uint16(1 | 1024 | 32768 | 512)
	pMem.eSubtype = uint8('p')
	pMem.xDel = func() func(unsafe.Pointer) {
		if xDestructor != nil {
			return xDestructor
		} else {
			return sqlite3NoopDestructor
		}
	}()
}
func sqlite3VdbeMemSetDouble(pMem *struct_sqlite3_value, val float64) {
	sqlite3VdbeMemSetNull(pMem)
	if !(sqlite3IsNaN(val) != 0) {
		pMem.u.r = val
		pMem.flags = uint16(8)
	}
}
func sqlite3VdbeMemSetRowSet(pMem *struct_sqlite3_value) int32 {
	var db *struct_sqlite3 = pMem.db
	var p *struct_RowSet
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemRelease(pMem)
	p = sqlite3RowSetInit(db)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	pMem.z = (*int8)(unsafe.Pointer(p))
	pMem.flags = uint16(16 | 1024)
	pMem.xDel = sqlite3RowSetDelete
	return int32(0)
}
func sqlite3VdbeMemTooBig(p *struct_sqlite3_value) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&(2|16) != 0 {
		var n int32 = p.n
		if int32(p.flags)&16384 != 0 {
			n += *(*int32)(unsafe.Pointer(&p.u))
		}
		return func() int32 {
			if n > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.db.aLimit)))) + uintptr(0)*4)) {
				return 1
			} else {
				return 0
			}
		}()
	}
	return int32(0)
}
func vdbeClrCopy(pTo *struct_sqlite3_value, pFrom *struct_sqlite3_value, eType int32) {
	vdbeMemClearExternAndSetNull(pTo)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemShallowCopy(pTo, pFrom, eType)
}
func sqlite3VdbeMemShallowCopy(pTo *struct_sqlite3_value, pFrom *struct_sqlite3_value, srcType int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTo.flags)&(8192|1024) != 0 {
		vdbeClrCopy(pTo, pFrom, srcType)
		return
	}
	__builtin___memcpy_chk(unsafe.Pointer(pTo), unsafe.Pointer(pFrom), 24, __builtin_object_size(unsafe.Pointer(pTo), 0))
	if int32(pFrom.flags)&2048 == 0 {
		pTo.flags &= uint16(^(1024 | 2048 | 4096))
		func() int {
			_ = 0
			return 0
		}()
		pTo.flags |= uint16(srcType)
	}
}
func sqlite3VdbeMemCopy(pTo *struct_sqlite3_value, pFrom *struct_sqlite3_value) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTo.flags)&(8192|1024) != 0 {
		vdbeMemClearExternAndSetNull(pTo)
	}
	__builtin___memcpy_chk(unsafe.Pointer(pTo), unsafe.Pointer(pFrom), 24, __builtin_object_size(unsafe.Pointer(pTo), 0))
	pTo.flags &= uint16(^1024)
	if int32(pTo.flags)&(2|16) != 0 {
		if 0 == int32(pFrom.flags)&2048 {
			pTo.flags |= uint16(4096)
			rc = sqlite3VdbeMemMakeWriteable(pTo)
		}
	}
	return rc
}
func sqlite3VdbeMemMove(pTo *struct_sqlite3_value, pFrom *struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemRelease(pTo)
	__builtin___memcpy_chk(unsafe.Pointer(pTo), unsafe.Pointer(pFrom), 56, __builtin_object_size(unsafe.Pointer(pTo), 0))
	pFrom.flags = uint16(1)
	pFrom.szMalloc = int32(0)
}
func sqlite3VdbeMemSetStr(pMem *struct_sqlite3_value, z *int8, n int64, enc uint8, xDel func(unsafe.Pointer)) int32 {
	var nByte int64 = n
	var iLimit int32
	var flags uint16 = uint16(0)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(z != nil) {
		sqlite3VdbeMemSetNull(pMem)
		return int32(0)
	}
	if pMem.db != nil {
		iLimit = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pMem.db.aLimit)))) + uintptr(0)*4))
	} else {
		iLimit = int32(1000000000)
	}
	flags = uint16(func() int32 {
		if int32(enc) == 0 {
			return 16
		} else {
			return 2
		}
	}())
	if nByte < int64(0) {
		func() int {
			_ = 0
			return 0
		}()
		if int32(enc) == 1 {
			nByte = int64(strlen(z))
		} else {
			for nByte = int64(0); nByte <= int64(iLimit) && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(nByte))))|int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(nByte+int64(1))))) != 0; nByte += int64(2) {
			}
		}
		flags |= uint16(512)
	}
	if uintptr(unsafe.Pointer(xDel)) == uintptr(unsafe.Pointer((func(unsafe.Pointer))(-1))) {
		var nAlloc int64 = nByte
		if int32(flags)&512 != 0 {
			nAlloc += int64(func() int32 {
				if int32(enc) == 1 {
					return 1
				} else {
					return 2
				}
			}())
		}
		if nByte > int64(iLimit) {
			return sqlite3ErrorToParser(pMem.db, 18)
		}
		if sqlite3VdbeMemClearAndResize(pMem, int32(func() int64 {
			if nAlloc > int64(32) {
				return nAlloc
			} else {
				return int64(32)
			}
		}())) != 0 {
			return int32(7)
		}
		__builtin___memcpy_chk(unsafe.Pointer(pMem.z), unsafe.Pointer(z), uint(nAlloc), __builtin_object_size(unsafe.Pointer(pMem.z), 0))
	} else {
		sqlite3VdbeMemRelease(pMem)
		pMem.z = (*int8)(unsafe.Pointer(z))
		if uintptr(unsafe.Pointer(xDel)) == uintptr(unsafe.Pointer((func(unsafe.Pointer))(sqlite3OomFault))) {
			pMem.zMalloc = pMem.z
			pMem.szMalloc = sqlite3DbMallocSize(pMem.db, unsafe.Pointer(pMem.zMalloc))
		} else {
			pMem.xDel = xDel
			flags |= uint16(func() int32 {
				if uintptr(unsafe.Pointer(xDel)) == uintptr(unsafe.Pointer((func(unsafe.Pointer))(0))) {
					return 2048
				} else {
					return 1024
				}
			}())
		}
	}
	pMem.n = int32(nByte & int64(2147483647))
	pMem.flags = flags
	if enc != 0 {
		pMem.enc = enc
	} else {
		func() int {
			_ = 0
			return 0
		}()
		pMem.enc = pMem.db.enc
	}
	if int32(enc) > 1 && sqlite3VdbeMemHandleBom(pMem) != 0 {
		return int32(7)
	}
	if nByte > int64(iLimit) {
		return sqlite3ErrorToParser(pMem.db, 18)
	}
	return int32(0)
}
func sqlite3VdbeMemFromBtree(pCur *struct_BtCursor, offset uint32, amt uint32, pMem *struct_sqlite3_value) int32 {
	var rc int32
	pMem.flags = uint16(1)
	if sqlite3BtreeMaxRecordSize(pCur) < int64(offset+amt) {
		return sqlite3CorruptError(79069)
	}
	if 0 == func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3VdbeMemClearAndResize(pMem, int32(amt+uint32(1)))
		return *_cgo_addr
	}() {
		rc = sqlite3BtreePayload(pCur, offset, amt, unsafe.Pointer(pMem.z))
		if rc == 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr(amt))) = int8(0)
			pMem.flags = uint16(16)
			pMem.n = int32(amt)
		} else {
			sqlite3VdbeMemRelease(pMem)
		}
	}
	return rc
}
func sqlite3VdbeMemFromBtreeZeroOffset(pCur *struct_BtCursor, amt uint32, pMem *struct_sqlite3_value) int32 {
	var available uint32 = uint32(0)
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pMem.z = (*int8)(sqlite3BtreePayloadFetch(pCur, &available))
	func() int {
		_ = 0
		return 0
	}()
	if amt <= available {
		pMem.flags = uint16(16 | 4096)
		pMem.n = int32(amt)
	} else {
		rc = sqlite3VdbeMemFromBtree(pCur, uint32(0), amt, pMem)
	}
	return rc
}
func valueToText(pVal *struct_sqlite3_value, enc uint8) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pVal.flags)&(16|2) != 0 {
		if func() int32 {
			if int32(pVal.flags)&16384 != 0 {
				return sqlite3VdbeMemExpandBlob(pVal)
			} else {
				return 0
			}
		}() != 0 {
			return unsafe.Pointer(nil)
		}
		pVal.flags |= uint16(2)
		if int32(pVal.enc) != int32(enc) & ^8 {
			sqlite3VdbeChangeEncoding(pVal, int32(enc) & ^8)
		}
		if int32(enc)&8 != 0 && 1 == 1&int32(int(uintptr(unsafe.Pointer(pVal.z)))) {
			func() int {
				_ = 0
				return 0
			}()
			if sqlite3VdbeMemMakeWriteable(pVal) != 0 {
				return unsafe.Pointer(nil)
			}
		}
		sqlite3VdbeMemNulTerminate(pVal)
	} else {
		sqlite3VdbeMemStringify(pVal, enc, uint8(0))
		func() int {
			_ = 0
			return 0
		}()
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(pVal.enc) == int32(enc) & ^8 {
		func() int {
			_ = 0
			return 0
		}()
		return unsafe.Pointer(pVal.z)
	} else {
		return unsafe.Pointer(nil)
	}
}
func sqlite3ValueText(pVal *struct_sqlite3_value, enc uint8) unsafe.Pointer {
	if !(pVal != nil) {
		return unsafe.Pointer(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pVal.flags)&(2|512) == 2|512 && int32(pVal.enc) == int32(enc) {
		func() int {
			_ = 0
			return 0
		}()
		return unsafe.Pointer(pVal.z)
	}
	if int32(pVal.flags)&1 != 0 {
		return unsafe.Pointer(nil)
	}
	return valueToText(pVal, enc)
}
func sqlite3ValueNew(db *struct_sqlite3) *struct_sqlite3_value {
	var p *struct_sqlite3_value = (*struct_sqlite3_value)(sqlite3DbMallocZero(db, uint64(56)))
	if p != nil {
		p.flags = uint16(1)
		p.db = db
	}
	return p
}

type struct_ValueNewStat4Ctx struct {
	pParse *struct_Parse
	pIdx   *struct_Index
	ppRec  **struct_UnpackedRecord
	iVal   int32
}

func valueNew(db *struct_sqlite3, p *struct_ValueNewStat4Ctx) *struct_sqlite3_value {
	func() int {
		_ = p
		return 0
	}()
	return sqlite3ValueNew(db)
}
func valueFromExpr(db *struct_sqlite3, pExpr *struct_Expr, enc uint8, affinity uint8, ppVal **struct_sqlite3_value, pCtx *struct_ValueNewStat4Ctx) int32 {
	var op int32
	var zVal *int8 = nil
	var pVal *struct_sqlite3_value = nil
	var negInt int32 = 1
	var zNeg *int8 = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	for func() (_cgo_ret int32) {
		_cgo_addr := &op
		*_cgo_addr = int32(pExpr.op)
		return *_cgo_addr
	}() == 174 || op == 181 {
		pExpr = pExpr.pLeft
	}
	if op == 176 {
		op = int32(pExpr.op2)
	}
	func() int {
		_ = 0
		return 0
	}()
	if op == 36 {
		var aff uint8
		func() int {
			_ = 0
			return 0
		}()
		aff = uint8(sqlite3AffinityType(pExpr.u.zToken, nil))
		rc = valueFromExpr(db, pExpr.pLeft, enc, aff, ppVal, pCtx)
		if *ppVal != nil {
			sqlite3VdbeMemCast(*ppVal, aff, uint8(1))
			sqlite3ValueApplyAffinity(*ppVal, affinity, uint8(1))
		}
		return rc
	}
	if op == 173 && (int32(pExpr.pLeft.op) == 155 || int32(pExpr.pLeft.op) == 153) {
		pExpr = pExpr.pLeft
		op = int32(pExpr.op)
		negInt = int32(-1)
		zNeg = (*int8)(unsafe.Pointer(&[2]int8{'-', '\x00'}))
	}
	if op == 117 || op == 153 || op == 155 {
		pVal = valueNew(db, pCtx)
		if uintptr(unsafe.Pointer(pVal)) == uintptr(unsafe.Pointer(nil)) {
			goto no_mem
		}
		if pExpr.flags&uint32(1024) != uint32(0) {
			sqlite3VdbeMemSetInt64(pVal, int64(*(*int32)(unsafe.Pointer(&pExpr.u)))*int64(negInt))
		} else {
			zVal = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[5]int8{'%', 's', '%', 's', '\x00'})), zNeg, pExpr.u.zToken)
			if uintptr(unsafe.Pointer(zVal)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			sqlite3ValueSetStr(pVal, -1, unsafe.Pointer(zVal), uint8(1), (func(unsafe.Pointer))(sqlite3OomFault))
		}
		if (op == 155 || op == 153) && int32(affinity) == 65 {
			sqlite3ValueApplyAffinity(pVal, uint8(67), uint8(1))
		} else {
			sqlite3ValueApplyAffinity(pVal, affinity, uint8(1))
		}
		func() int {
			_ = 0
			return 0
		}()
		if int32(pVal.flags)&(4|32|8) != 0 {
			pVal.flags &= uint16(^2)
		}
		if int32(enc) != 1 {
			rc = sqlite3VdbeChangeEncoding(pVal, int32(enc))
		}
	} else if op == 173 {
		if 0 == valueFromExpr(db, pExpr.pLeft, enc, affinity, &pVal, pCtx) && uintptr(unsafe.Pointer(pVal)) != uintptr(unsafe.Pointer(nil)) {
			sqlite3VdbeMemNumerify(pVal)
			if int32(pVal.flags)&8 != 0 {
				pVal.u.r = -pVal.u.r
			} else if *(*int64)(unsafe.Pointer(&pVal.u)) == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
				pVal.u.r = -float64(int64(-1) - (int64(4294967295) | int64(2147483647)<<32))
				pVal.flags = uint16(int32(pVal.flags) & ^(49599|16384) | 8)
			} else {
				*(*int64)(unsafe.Pointer(&pVal.u)) = -*(*int64)(unsafe.Pointer(&pVal.u))
			}
			sqlite3ValueApplyAffinity(pVal, affinity, enc)
		}
	} else if op == 121 {
		pVal = valueNew(db, pCtx)
		if uintptr(unsafe.Pointer(pVal)) == uintptr(unsafe.Pointer(nil)) {
			goto no_mem
		}
		sqlite3VdbeMemSetNull(pVal)
	} else if op == 154 {
		var nVal int32
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pVal = valueNew(db, pCtx)
		if !(pVal != nil) {
			goto no_mem
		}
		zVal = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pExpr.u.zToken)) + uintptr(2)))
		nVal = sqlite3Strlen30(zVal) - 1
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeMemSetStr(pVal, (*int8)(sqlite3HexToBlob(db, zVal, nVal)), int64(nVal/2), uint8(0), (func(unsafe.Pointer))(sqlite3OomFault))
	} else if op == 170 {
		func() int {
			_ = 0
			return 0
		}()
		pVal = valueNew(db, pCtx)
		if pVal != nil {
			pVal.flags = uint16(4)
			*(*int64)(unsafe.Pointer(&pVal.u)) = func() int64 {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pExpr.u.zToken)) + uintptr(4)))) == 0 {
					return 1
				} else {
					return 0
				}
			}()
		}
	}
	*ppVal = pVal
	return rc
no_mem:
	sqlite3OomFault(db)
	sqlite3DbFree(db, unsafe.Pointer(zVal))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ValueFree(pVal)
	return int32(7)
}
func sqlite3ValueFromExpr(db *struct_sqlite3, pExpr *struct_Expr, enc uint8, affinity uint8, ppVal **struct_sqlite3_value) int32 {
	return func() int32 {
		if pExpr != nil {
			return valueFromExpr(db, pExpr, enc, affinity, ppVal, nil)
		} else {
			return 0
		}
	}()
}
func sqlite3ValueSetStr(v *struct_sqlite3_value, n int32, z unsafe.Pointer, enc uint8, xDel func(unsafe.Pointer)) {
	if v != nil {
		sqlite3VdbeMemSetStr((*struct_sqlite3_value)(unsafe.Pointer(v)), (*int8)(z), int64(n), enc, xDel)
	}
}
func sqlite3ValueFree(v *struct_sqlite3_value) {
	if !(v != nil) {
		return
	}
	sqlite3VdbeMemRelease((*struct_sqlite3_value)(unsafe.Pointer(v)))
	sqlite3DbFreeNN((*struct_sqlite3_value)(unsafe.Pointer(v)).db, unsafe.Pointer(v))
}
func valueBytes(pVal *struct_sqlite3_value, enc uint8) int32 {
	return func() int32 {
		if uintptr(unsafe.Pointer(valueToText(pVal, enc))) != uintptr(unsafe.Pointer(nil)) {
			return pVal.n
		} else {
			return 0
		}
	}()
}
func sqlite3ValueBytes(pVal *struct_sqlite3_value, enc uint8) int32 {
	var p *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(pVal))
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.flags)&2 != 0 && int32(pVal.enc) == int32(enc) {
		return p.n
	}
	if int32(p.flags)&16 != 0 {
		if int32(p.flags)&16384 != 0 {
			return p.n + *(*int32)(unsafe.Pointer(&p.u))
		} else {
			return p.n
		}
	}
	if int32(p.flags)&1 != 0 {
		return int32(0)
	}
	return valueBytes(pVal, enc)
}
func sqlite3VdbeCreate(pParse *struct_Parse) *struct_Vdbe {
	var db *struct_sqlite3 = pParse.db
	var p *struct_Vdbe
	p = (*struct_Vdbe)(sqlite3DbMallocRawNN(db, uint64(312)))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_Vdbe)(nil)
	}
	__builtin___memset_chk(unsafe.Pointer(&p.aOp), 0, 312-144, __builtin_object_size(unsafe.Pointer(&p.aOp), 0))
	p.db = db
	if db.pVdbe != nil {
		db.pVdbe.pPrev = p
	}
	p.pNext = db.pVdbe
	p.pPrev = (*struct_Vdbe)(nil)
	db.pVdbe = p
	p.iVdbeMagic = uint32(381479589)
	p.pParse = pParse
	pParse.pVdbe = p
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeAddOp2(p, 64, 0, 1)
	return p
}
func sqlite3VdbeParser(p *struct_Vdbe) *struct_Parse {
	return p.pParse
}
func sqlite3VdbeError(p *struct_Vdbe, zFormat *int8, __cgo_args ...interface {
}) {
	sqlite3DbFree(p.db, unsafe.Pointer(p.zErrMsg))
	p.zErrMsg = sqlite3VMPrintf(p.db, zFormat, __cgo_args...)
}
func sqlite3VdbeSetSql(p *struct_Vdbe, z *int8, n int32, prepFlags uint8) {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	p.prepFlags = prepFlags
	if int32(prepFlags)&128 == 0 {
		p.expmask = uint32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	p.zSql = sqlite3DbStrNDup(p.db, z, uint64(n))
}
func sqlite3VdbeSwap(pA *struct_Vdbe, pB *struct_Vdbe) {
	var tmp struct_Vdbe
	var pTmp *struct_Vdbe
	var zTmp *int8
	func() int {
		_ = 0
		return 0
	}()
	tmp = *pA
	*pA = *pB
	*pB = tmp
	pTmp = pA.pNext
	pA.pNext = pB.pNext
	pB.pNext = pTmp
	pTmp = pA.pPrev
	pA.pPrev = pB.pPrev
	pB.pPrev = pTmp
	zTmp = pA.zSql
	pA.zSql = pB.zSql
	pB.zSql = zTmp
	pB.expmask = pA.expmask
	pB.prepFlags = pA.prepFlags
	__builtin___memcpy_chk(unsafe.Pointer((*uint32)(unsafe.Pointer(&pB.aCounter))), unsafe.Pointer((*uint32)(unsafe.Pointer(&pA.aCounter))), 36, __builtin_object_size(unsafe.Pointer((*uint32)(unsafe.Pointer(&pB.aCounter))), 0))
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pB.aCounter)))) + uintptr(5)*4))++
}
func growOpArray(v *struct_Vdbe, nOp int32) int32 {
	var pNew *struct_VdbeOp
	var p *struct_Parse = v.pParse
	var nNew int64 = func() int64 {
		if v.nOpAlloc != 0 {
			return int64(2) * int64(v.nOpAlloc)
		} else {
			return int64(uint(1024) / 24)
		}
	}()
	func() int {
		_ = nOp
		return 0
	}()
	if nNew > int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.db.aLimit)))) + uintptr(5)*4))) {
		sqlite3OomFault(p.db)
		return int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pNew = (*struct_VdbeOp)(sqlite3DbRealloc(p.db, unsafe.Pointer(v.aOp), uint64(nNew)*uint64(24)))
	if pNew != nil {
		p.szOpAlloc = sqlite3DbMallocSize(p.db, unsafe.Pointer(pNew))
		v.nOpAlloc = int32(uint(p.szOpAlloc) / 24)
		v.aOp = pNew
	}
	return func() int32 {
		if pNew != nil {
			return 0
		} else {
			return 7
		}
	}()
}
func growOp3(p *struct_Vdbe, op int32, p1 int32, p2 int32, p3 int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if growOpArray(p, 1) != 0 {
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3VdbeAddOp3(p, op, p1, p2, p3)
}
func sqlite3VdbeAddOp3(p *struct_Vdbe, op int32, p1 int32, p2 int32, p3 int32) int32 {
	var i int32
	var pOp *struct_VdbeOp
	i = p.nOp
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.nOpAlloc <= i {
		return growOp3(p, op, p1, p2, p3)
	}
	func() int {
		_ = 0
		return 0
	}()
	p.nOp++
	pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(i)*24))
	func() int {
		_ = 0
		return 0
	}()
	pOp.opcode = uint8(op)
	pOp.p5 = uint16(0)
	pOp.p1 = p1
	pOp.p2 = p2
	pOp.p3 = p3
	pOp.p4.p = unsafe.Pointer(nil)
	pOp.p4type = int8(0)
	return i
}
func sqlite3VdbeAddOp0(p *struct_Vdbe, op int32) int32 {
	return sqlite3VdbeAddOp3(p, op, 0, 0, 0)
}
func sqlite3VdbeAddOp1(p *struct_Vdbe, op int32, p1 int32) int32 {
	return sqlite3VdbeAddOp3(p, op, p1, 0, 0)
}
func sqlite3VdbeAddOp2(p *struct_Vdbe, op int32, p1 int32, p2 int32) int32 {
	return sqlite3VdbeAddOp3(p, op, p1, p2, 0)
}
func sqlite3VdbeGoto(p *struct_Vdbe, iDest int32) int32 {
	return sqlite3VdbeAddOp3(p, 11, 0, iDest, 0)
}
func sqlite3VdbeLoadString(p *struct_Vdbe, iDest int32, zStr *int8) int32 {
	return sqlite3VdbeAddOp4(p, 117, 0, iDest, 0, zStr, 0)
}
func sqlite3VdbeMultiLoad(p *struct_Vdbe, iDest int32, zTypes *int8, __cgo_args ...interface {
}) {
	var i int32
	var c int8
	for i = int32(0); int32(func() (_cgo_ret int8) {
		_cgo_addr := &c
		*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zTypes)) + uintptr(i)))
		return *_cgo_addr
	}()) != 0; i++ {
		if int32(c) == 's' {
			var z *int8 = func() (_cgo_ret *int8) {
				_cgo_ret = __cgo_args[0].(*int8)
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3VdbeAddOp4(p, func() int32 {
				if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
					return 74
				} else {
					return 117
				}
			}(), 0, iDest+i, 0, z, 0)
		} else if int32(c) == 'i' {
			sqlite3VdbeAddOp2(p, 71, func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}(), iDest+i)
		} else {
			goto skip_op_resultrow
		}
	}
	sqlite3VdbeAddOp2(p, 83, iDest, i)
skip_op_resultrow:
}
func sqlite3VdbeAddOp4(p *struct_Vdbe, op int32, p1 int32, p2 int32, p3 int32, zP4 *int8, p4type int32) int32 {
	var addr int32 = sqlite3VdbeAddOp3(p, op, p1, p2, p3)
	sqlite3VdbeChangeP4(p, addr, zP4, p4type)
	return addr
}
func sqlite3VdbeAddFunctionCall(pParse *struct_Parse, p1 int32, p2 int32, p3 int32, nArg int32, pFunc *struct_FuncDef, eCallCtx int32) int32 {
	var v *struct_Vdbe = pParse.pVdbe
	var nByte int32
	var addr int32
	var pCtx *struct_sqlite3_context
	func() int {
		_ = 0
		return 0
	}()
	nByte = int32(56 + uint(nArg-1)*8)
	pCtx = (*struct_sqlite3_context)(sqlite3DbMallocRawNN(pParse.db, uint64(nByte)))
	if uintptr(unsafe.Pointer(pCtx)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		freeEphemeralFunction(pParse.db, (*struct_FuncDef)(unsafe.Pointer(pFunc)))
		return int32(0)
	}
	pCtx.pOut = (*struct_sqlite3_value)(nil)
	pCtx.pFunc = (*struct_FuncDef)(unsafe.Pointer(pFunc))
	pCtx.pVdbe = (*struct_Vdbe)(nil)
	pCtx.isError = int32(0)
	pCtx.argc = uint8(nArg)
	pCtx.iOp = sqlite3VdbeCurrentAddr(v)
	addr = sqlite3VdbeAddOp4(v, func() int32 {
		if eCallCtx != 0 {
			return 65
		} else {
			return 66
		}
	}(), p1, p2, p3, (*int8)(unsafe.Pointer(pCtx)), -16)
	sqlite3VdbeChangeP5(v, uint16(eCallCtx&46))
	return addr
}
func sqlite3VdbeAddOp4Dup8(p *struct_Vdbe, op int32, p1 int32, p2 int32, p3 int32, zP4 *uint8, p4type int32) int32 {
	var p4copy *int8 = (*int8)(sqlite3DbMallocRawNN(sqlite3VdbeDb(p), uint64(8)))
	if p4copy != nil {
		__builtin___memcpy_chk(unsafe.Pointer(p4copy), unsafe.Pointer(zP4), uint(8), __builtin_object_size(unsafe.Pointer(p4copy), 0))
	}
	return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type)
}
func sqlite3VdbeExplainParent(pParse *struct_Parse) int32 {
	var pOp *struct_VdbeOp
	if pParse.addrExplain == 0 {
		return int32(0)
	}
	pOp = sqlite3VdbeGetOp(pParse.pVdbe, pParse.addrExplain)
	return pOp.p2
}
func sqlite3VdbeExplain(pParse *struct_Parse, bPush uint8, zFmt *int8, __cgo_args ...interface {
}) {
	if int32(pParse.explain) == 2 {
		var zMsg *int8
		var v *struct_Vdbe
		var iThis int32
		zMsg = sqlite3VMPrintf(pParse.db, zFmt, __cgo_args...)
		v = pParse.pVdbe
		iThis = v.nOp
		sqlite3VdbeAddOp4(v, 183, iThis, pParse.addrExplain, 0, zMsg, -7)
		if bPush != 0 {
			pParse.addrExplain = iThis
		}
	}
}
func sqlite3VdbeExplainPop(pParse *struct_Parse) {
	pParse.addrExplain = sqlite3VdbeExplainParent(pParse)
}
func sqlite3VdbeAddParseSchemaOp(p *struct_Vdbe, iDb int32, zWhere *int8, p5 uint16) {
	var j int32
	sqlite3VdbeAddOp4(p, 148, iDb, 0, 0, zWhere, -7)
	sqlite3VdbeChangeP5(p, p5)
	for j = int32(0); j < p.db.nDb; j++ {
		sqlite3VdbeUsesBtree(p, j)
	}
	sqlite3MayAbort(p.pParse)
}
func sqlite3VdbeAddOp4Int(p *struct_Vdbe, op int32, p1 int32, p2 int32, p3 int32, p4 int32) int32 {
	var addr int32 = sqlite3VdbeAddOp3(p, op, p1, p2, p3)
	if int32(p.db.mallocFailed) == 0 {
		var pOp *struct_VdbeOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(addr)*24))
		pOp.p4type = int8(-3)
		*(*int32)(unsafe.Pointer(&pOp.p4)) = p4
	}
	return addr
}
func sqlite3VdbeEndCoroutine(v *struct_Vdbe, regYield int32) {
	sqlite3VdbeAddOp1(v, 68, regYield)
	v.pParse.nTempReg = uint8(0)
	v.pParse.nRangeReg = int32(0)
}
func sqlite3VdbeMakeLabel(pParse *struct_Parse) int32 {
	return func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nLabel
		*_cgo_addr--
		return *_cgo_addr
	}()
}
func resizeResolveLabel(p *struct_Parse, v *struct_Vdbe, j int32) {
	var nNewSize int32 = 10 - p.nLabel
	p.aLabel = (*int32)(sqlite3DbReallocOrFree(p.db, unsafe.Pointer(p.aLabel), uint64(uint(nNewSize)*4)))
	if uintptr(unsafe.Pointer(p.aLabel)) == uintptr(unsafe.Pointer(nil)) {
		p.nLabelAlloc = int32(0)
	} else {
		p.nLabelAlloc = nNewSize
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aLabel)) + uintptr(j)*4)) = v.nOp
	}
}
func sqlite3VdbeResolveLabel(v *struct_Vdbe, x int32) {
	var p *struct_Parse = v.pParse
	var j int32 = ^x
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.nLabelAlloc+p.nLabel < 0 {
		resizeResolveLabel(p, v, j)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aLabel)) + uintptr(j)*4)) = v.nOp
	}
}
func sqlite3VdbeRunOnlyOnce(p *struct_Vdbe) {
	{
		_autoGo_3 := &p.Xbf_0
		*_autoGo_3 = *_autoGo_3&^32 | uint32(1)&1<<5
	}
}
func sqlite3VdbeReusable(p *struct_Vdbe) {
	{
		_autoGo_4 := &p.Xbf_0
		*_autoGo_4 = *_autoGo_4&^32 | uint32(0)&1<<5
	}
}
func resolveP2Values(p *struct_Vdbe, pMaxFuncArgs *int32) {
	var nMaxArgs int32 = *pMaxFuncArgs
	var pOp *struct_VdbeOp
	var pParse *struct_Parse = p.pParse
	var aLabel *int32 = pParse.aLabel
	{
		_autoGo_5 := &p.Xbf_0
		*_autoGo_5 = *_autoGo_5&^128 | uint32(1)&1<<7
	}
	{
		_autoGo_6 := &p.Xbf_0
		*_autoGo_6 = *_autoGo_6&^256 | uint32(0)&1<<8
	}
	pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(p.nOp-1)*24))
	for 1 != 0 {
		if int32(pOp.opcode) <= 64 {
			switch int32(pOp.opcode) {
			case 2:
				{
					if pOp.p2 != 0 {
						{
							_autoGo_7 := &p.Xbf_0
							*_autoGo_7 = *_autoGo_7&^128 | uint32(0)&1<<7
						}
					}
				}
			case 1:
				fallthrough
			case 0:
				{
					{
						_autoGo_8 := &p.Xbf_0
						*_autoGo_8 = *_autoGo_8&^256 | uint32(1)&1<<8
					}
					break
				}
			case 6:
				fallthrough
			case 8:
				fallthrough
			case 7:
				{
					{
						_autoGo_9 := &p.Xbf_0
						*_autoGo_9 = *_autoGo_9&^128 | uint32(0)&1<<7
					}
					{
						_autoGo_10 := &p.Xbf_0
						*_autoGo_10 = *_autoGo_10&^256 | uint32(1)&1<<8
					}
					break
				}
			case 5:
				fallthrough
			case 3:
				{
					*(*func(*struct_BtCursor, int32) int32)(unsafe.Pointer(&pOp.p4)) = sqlite3BtreeNext
					pOp.p4type = int8(-5)
					func() int {
						_ = 0
						return 0
					}()
					break
				}
			case 4:
				{
					*(*func(*struct_BtCursor, int32) int32)(unsafe.Pointer(&pOp.p4)) = sqlite3BtreePrevious
					pOp.p4type = int8(-5)
					func() int {
						_ = 0
						return 0
					}()
					break
				}
			case 10:
				{
					if pOp.p2 > nMaxArgs {
						nMaxArgs = pOp.p2
					}
					break
				}
			case 9:
				{
					var n int32
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					n = (*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) - uintptr(- -1)*24))).p1
					if n > nMaxArgs {
						nMaxArgs = n
					}
				}
			default:
				{
					if pOp.p2 < 0 {
						func() int {
							_ = 0
							return 0
						}()
						func() int {
							_ = 0
							return 0
						}()
						pOp.p2 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLabel)) + uintptr(^pOp.p2)*4))
					}
					break
				}
			}
			func() int {
				_ = 0
				return 0
			}()
		}
		if uintptr(unsafe.Pointer(pOp)) == uintptr(unsafe.Pointer(p.aOp)) {
			break
		}
		*(*uintptr)(unsafe.Pointer(&pOp)) -= 24
	}
	sqlite3DbFree(p.db, unsafe.Pointer(pParse.aLabel))
	pParse.aLabel = (*int32)(nil)
	pParse.nLabel = int32(0)
	*pMaxFuncArgs = nMaxArgs
	func() int {
		_ = 0
		return 0
	}()
}
func sqlite3VdbeCurrentAddr(p *struct_Vdbe) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return p.nOp
}
func sqlite3VdbeTakeOpArray(p *struct_Vdbe, pnOp *int32, pnMaxArg *int32) *struct_VdbeOp {
	var aOp *struct_VdbeOp = p.aOp
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	resolveP2Values(p, pnMaxArg)
	*pnOp = p.nOp
	p.aOp = (*struct_VdbeOp)(nil)
	return aOp
}
func sqlite3VdbeAddOpList(p *struct_Vdbe, nOp int32, aOp *struct_VdbeOpList, iLineno int32) *struct_VdbeOp {
	var i int32
	var pOut *struct_VdbeOp
	var pFirst *struct_VdbeOp
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.nOp+nOp > p.nOpAlloc && growOpArray(p, nOp) != 0 {
		return (*struct_VdbeOp)(nil)
	}
	pFirst = func() (_cgo_ret *struct_VdbeOp) {
		_cgo_addr := &pOut
		*_cgo_addr = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(p.nOp)*24))
		return *_cgo_addr
	}()
	for i = int32(0); i < nOp; func() *struct_VdbeOp {
		func() *struct_VdbeOpList {
			i++
			return func() (_cgo_ret *struct_VdbeOpList) {
				_cgo_addr := &aOp
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 4
				return
			}()
		}()
		return func() (_cgo_ret *struct_VdbeOp) {
			_cgo_addr := &pOut
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 24
			return
		}()
	}() {
		pOut.opcode = aOp.opcode
		pOut.p1 = int32(aOp.p1)
		pOut.p2 = int32(aOp.p2)
		func() int {
			_ = 0
			return 0
		}()
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3OpcodeProperty)))) + uintptr(aOp.opcode))))&1 != 0 && int32(aOp.p2) > 0 {
			pOut.p2 += p.nOp
		}
		pOut.p3 = int32(aOp.p3)
		pOut.p4type = int8(0)
		pOut.p4.p = unsafe.Pointer(nil)
		pOut.p5 = uint16(0)
		func() int {
			_ = iLineno
			return 0
		}()
	}
	p.nOp += nOp
	return pFirst
}
func sqlite3VdbeChangeOpcode(p *struct_Vdbe, addr int32, iNewOpcode uint8) {
	sqlite3VdbeGetOp(p, addr).opcode = iNewOpcode
}
func sqlite3VdbeChangeP1(p *struct_Vdbe, addr int32, val int32) {
	sqlite3VdbeGetOp(p, addr).p1 = val
}
func sqlite3VdbeChangeP2(p *struct_Vdbe, addr int32, val int32) {
	sqlite3VdbeGetOp(p, addr).p2 = val
}
func sqlite3VdbeChangeP3(p *struct_Vdbe, addr int32, val int32) {
	sqlite3VdbeGetOp(p, addr).p3 = val
}
func sqlite3VdbeChangeP5(p *struct_Vdbe, p5 uint16) {
	func() int {
		_ = 0
		return 0
	}()
	if p.nOp > 0 {
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(p.nOp-1)*24))).p5 = p5
	}
}
func sqlite3VdbeJumpHere(p *struct_Vdbe, addr int32) {
	sqlite3VdbeChangeP2(p, addr, p.nOp)
}
func sqlite3VdbeJumpHereOrPopInst(p *struct_Vdbe, addr int32) {
	if addr == p.nOp-1 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		p.nOp--
	} else {
		sqlite3VdbeChangeP2(p, addr, p.nOp)
	}
}
func freeEphemeralFunction(db *struct_sqlite3, pDef *struct_FuncDef) {
	if pDef.funcFlags&uint32(16) != uint32(0) {
		sqlite3DbFreeNN(db, unsafe.Pointer(pDef))
	}
}
func freeP4Mem(db *struct_sqlite3, p *struct_sqlite3_value) {
	if p.szMalloc != 0 {
		sqlite3DbFree(db, unsafe.Pointer(p.zMalloc))
	}
	sqlite3DbFreeNN(db, unsafe.Pointer(p))
}
func freeP4FuncCtx(db *struct_sqlite3, p *struct_sqlite3_context) {
	freeEphemeralFunction(db, p.pFunc)
	sqlite3DbFreeNN(db, unsafe.Pointer(p))
}
func freeP4(db *struct_sqlite3, p4type int32, p4 unsafe.Pointer) {
	func() int {
		_ = 0
		return 0
	}()
	switch p4type {
	case -16:
		{
			freeP4FuncCtx(db, (*struct_sqlite3_context)(p4))
			break
		}
	case -13:
		fallthrough
	case -14:
		fallthrough
	case -7:
		fallthrough
	case -17:
		fallthrough
	case -15:
		{
			sqlite3DbFree(db, p4)
			break
		}
	case -9:
		{
			if uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3KeyInfoUnref((*struct_KeyInfo)(p4))
			}
			break
		}
	case -8:
		{
			freeEphemeralFunction(db, (*struct_FuncDef)(p4))
			break
		}
	case -11:
		{
			if uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3ValueFree((*struct_sqlite3_value)(p4))
			} else {
				freeP4Mem(db, (*struct_sqlite3_value)(p4))
			}
			break
		}
	case -12:
		{
			if uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3VtabUnlock((*struct_VTable)(p4))
			}
			break
		}
	}
}
func vdbeFreeOpArray(db *struct_sqlite3, aOp *struct_VdbeOp, nOp int32) {
	if aOp != nil {
		var pOp *struct_VdbeOp
		for pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(nOp-1)*24)); uintptr(unsafe.Pointer(pOp)) >= uintptr(unsafe.Pointer(aOp)); *(*uintptr)(unsafe.Pointer(&pOp)) -= 24 {
			if int32(pOp.p4type) <= -7 {
				freeP4(db, int32(pOp.p4type), pOp.p4.p)
			}
		}
		sqlite3DbFreeNN(db, unsafe.Pointer(aOp))
	}
}
func sqlite3VdbeLinkSubProgram(pVdbe *struct_Vdbe, p *struct_SubProgram) {
	p.pNext = pVdbe.pProgram
	pVdbe.pProgram = p
}
func sqlite3VdbeHasSubProgram(pVdbe *struct_Vdbe) int32 {
	return func() int32 {
		if uintptr(unsafe.Pointer(pVdbe.pProgram)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3VdbeChangeToNoop(p *struct_Vdbe, addr int32) int32 {
	var pOp *struct_VdbeOp
	if p.db.mallocFailed != 0 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(addr)*24))
	freeP4(p.db, int32(pOp.p4type), pOp.p4.p)
	pOp.p4type = int8(0)
	*(**int8)(unsafe.Pointer(&pOp.p4)) = (*int8)(nil)
	pOp.opcode = uint8(182)
	return int32(1)
}
func sqlite3VdbeDeletePriorOpcode(p *struct_Vdbe, op uint8) int32 {
	if p.nOp > 0 && int32((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(p.nOp-1)*24))).opcode) == int32(op) {
		return sqlite3VdbeChangeToNoop(p, p.nOp-1)
	} else {
		return int32(0)
	}
}
func vdbeChangeP4Full(p *struct_Vdbe, pOp *struct_VdbeOp, zP4 *int8, n int32) {
	if pOp.p4type != 0 {
		freeP4(p.db, int32(pOp.p4type), pOp.p4.p)
		pOp.p4type = int8(0)
		pOp.p4.p = unsafe.Pointer(nil)
	}
	if n < 0 {
		sqlite3VdbeChangeP4(p, int32((uintptr(unsafe.Pointer(pOp))-uintptr(unsafe.Pointer(p.aOp)))*24), zP4, n)
	} else {
		if n == 0 {
			n = sqlite3Strlen30(zP4)
		}
		*(**int8)(unsafe.Pointer(&pOp.p4)) = sqlite3DbStrNDup(p.db, zP4, uint64(n))
		pOp.p4type = int8(-7)
	}
}
func sqlite3VdbeChangeP4(p *struct_Vdbe, addr int32, zP4 *int8, n int32) {
	var pOp *struct_VdbeOp
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	db = p.db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		if n != -12 {
			freeP4(db, n, unsafe.Pointer(*(**int8)(unsafe.Pointer(&zP4))))
		}
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if addr < 0 {
		addr = p.nOp - 1
	}
	pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(addr)*24))
	if n >= 0 || int32(pOp.p4type) != 0 {
		vdbeChangeP4Full(p, pOp, zP4, n)
		return
	}
	if n == -3 {
		*(*int32)(unsafe.Pointer(&pOp.p4)) = int32(int(uintptr(unsafe.Pointer(zP4))))
		pOp.p4type = int8(-3)
	} else if uintptr(unsafe.Pointer(zP4)) != uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		pOp.p4.p = unsafe.Pointer(zP4)
		pOp.p4type = int8(n)
		if n == -12 {
			sqlite3VtabLock((*struct_VTable)(unsafe.Pointer(zP4)))
		}
	}
}
func sqlite3VdbeAppendP4(p *struct_Vdbe, pP4 unsafe.Pointer, n int32) {
	var pOp *struct_VdbeOp
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.db.mallocFailed != 0 {
		freeP4(p.db, n, pP4)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(p.nOp-1)*24))
		func() int {
			_ = 0
			return 0
		}()
		pOp.p4type = int8(n)
		pOp.p4.p = pP4
	}
}
func sqlite3VdbeSetP4KeyInfo(pParse *struct_Parse, pIdx *struct_Index) {
	var v *struct_Vdbe = pParse.pVdbe
	var pKeyInfo *struct_KeyInfo
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx)
	if pKeyInfo != nil {
		sqlite3VdbeAppendP4(v, unsafe.Pointer(pKeyInfo), -9)
	}
}
func sqlite3VdbeGetOp(p *struct_Vdbe, addr int32) *struct_VdbeOp {
	var dummy struct_VdbeOp
	func() int {
		_ = 0
		return 0
	}()
	if addr < 0 {
		addr = p.nOp - 1
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.db.mallocFailed != 0 {
		return (*struct_VdbeOp)(unsafe.Pointer(&dummy))
	} else {
		return &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(addr)*24))
	}
}
func sqlite3VdbeDisplayP4(db *struct_sqlite3, pOp *struct_VdbeOp) *int8 {
	var zP4 *int8 = nil
	var x struct_sqlite3_str
	sqlite3StrAccumInit(&x, nil, nil, 0, 1000000000)
	switch int32(pOp.p4type) {
	case -9:
		{
			var j int32
			var pKeyInfo *struct_KeyInfo = *(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[5]int8{'k', '(', '%', 'd', '\x00'})), int32(pKeyInfo.nKeyField))
			for j = int32(0); j < int32(pKeyInfo.nKeyField); j++ {
				var pColl *struct_CollSeq = *(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(j)*8))
				var zColl *int8 = func() *int8 {
					if pColl != nil {
						return pColl.zName
					} else {
						return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
					}
				}()
				if strcmp(zColl, (*int8)(unsafe.Pointer(&[7]int8{'B', 'I', 'N', 'A', 'R', 'Y', '\x00'}))) == 0 {
					zColl = (*int8)(unsafe.Pointer(&[2]int8{'B', '\x00'}))
				}
				sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[8]int8{',', '%', 's', '%', 's', '%', 's', '\x00'})), func() *int8 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyInfo.aSortFlags)) + uintptr(j))))&1 != 0 {
						return (*int8)(unsafe.Pointer(&[2]int8{'-', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
					}
				}(), func() *int8 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyInfo.aSortFlags)) + uintptr(j))))&2 != 0 {
						return (*int8)(unsafe.Pointer(&[3]int8{'N', '.', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
					}
				}(), zColl)
			}
			sqlite3_str_append(&x, (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'})), 1)
			break
		}
	case -2:
		{
			var encnames [4]*int8 = [4]*int8{(*int8)(unsafe.Pointer(&[2]int8{'?', '\x00'})), (*int8)(unsafe.Pointer(&[2]int8{'8', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'1', '6', 'L', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'1', '6', 'B', 'E', '\x00'}))}
			var pColl *struct_CollSeq = *(**struct_CollSeq)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[9]int8{'%', '.', '1', '8', 's', '-', '%', 's', '\x00'})), pColl.zName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&encnames)))) + uintptr(pColl.enc)*8)))
			break
		}
	case -8:
		{
			var pDef *struct_FuncDef = *(**struct_FuncDef)(unsafe.Pointer(&pOp.p4))
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[7]int8{'%', 's', '(', '%', 'd', ')', '\x00'})), pDef.zName, int32(pDef.nArg))
			break
		}
	case -16:
		{
			var pDef *struct_FuncDef = (*(**struct_sqlite3_context)(unsafe.Pointer(&pOp.p4))).pFunc
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[7]int8{'%', 's', '(', '%', 'd', ')', '\x00'})), pDef.zName, int32(pDef.nArg))
			break
		}
	case -14:
		{
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[5]int8{'%', 'l', 'l', 'd', '\x00'})), **(**int64)(unsafe.Pointer(&pOp.p4)))
			break
		}
	case -3:
		{
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[3]int8{'%', 'd', '\x00'})), *(*int32)(unsafe.Pointer(&pOp.p4)))
			break
		}
	case -13:
		{
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[6]int8{'%', '.', '1', '6', 'g', '\x00'})), **(**float64)(unsafe.Pointer(&pOp.p4)))
			break
		}
	case -11:
		{
			var pMem *struct_sqlite3_value = *(**struct_sqlite3_value)(unsafe.Pointer(&pOp.p4))
			if int32(pMem.flags)&2 != 0 {
				zP4 = pMem.z
			} else if int32(pMem.flags)&(4|32) != 0 {
				sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[5]int8{'%', 'l', 'l', 'd', '\x00'})), *(*int64)(unsafe.Pointer(&pMem.u)))
			} else if int32(pMem.flags)&8 != 0 {
				sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[6]int8{'%', '.', '1', '6', 'g', '\x00'})), pMem.u.r)
			} else if int32(pMem.flags)&1 != 0 {
				zP4 = (*int8)(unsafe.Pointer(&[5]int8{'N', 'U', 'L', 'L', '\x00'}))
			} else {
				func() int {
					_ = 0
					return 0
				}()
				zP4 = (*int8)(unsafe.Pointer(&[7]int8{'(', 'b', 'l', 'o', 'b', ')', '\x00'}))
			}
			break
		}
	case -12:
		{
			var pVtab *struct_sqlite3_vtab = (*(**struct_VTable)(unsafe.Pointer(&pOp.p4))).pVtab
			sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[8]int8{'v', 't', 'a', 'b', ':', '%', 'p', '\x00'})), pVtab)
			break
		}
	case -15:
		{
			var i uint32
			var ai *uint32 = *(**uint32)(unsafe.Pointer(&pOp.p4))
			var n uint32 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(ai)) + uintptr(0)*4))
			for i = uint32(1); i <= n; i++ {
				sqlite3_str_appendf(&x, (*int8)(unsafe.Pointer(&[5]int8{'%', 'c', '%', 'u', '\x00'})), func() int32 {
					if i == uint32(1) {
						return '['
					} else {
						return ','
					}
				}(), *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(ai)) + uintptr(i)*4)))
			}
			sqlite3_str_append(&x, (*int8)(unsafe.Pointer(&[2]int8{']', '\x00'})), 1)
			break
		}
	case -4:
		{
			zP4 = (*int8)(unsafe.Pointer(&[8]int8{'p', 'r', 'o', 'g', 'r', 'a', 'm', '\x00'}))
			break
		}
	case -17:
		fallthrough
	case -5:
		{
			break
		}
	case -6:
		{
			zP4 = (*(**struct_Table)(unsafe.Pointer(&pOp.p4))).zName
			break
		}
	default:
		{
			zP4 = *(**int8)(unsafe.Pointer(&pOp.p4))
		}
	}
	if zP4 != nil {
		sqlite3_str_appendall(&x, zP4)
	}
	if int32(x.accError)&7 != 0 {
		sqlite3OomFault(db)
	}
	return sqlite3StrAccumFinish(&x)
}
func sqlite3VdbeUsesBtree(p *struct_Vdbe, i int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	p.btreeMask |= uint32(1) << i
	if i != 1 && sqlite3BtreeSharable((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(p.db.aDb)) + uintptr(i)*32))).pBt) != 0 {
		p.lockMask |= uint32(1) << i
	}
}
func sqlite3VdbeEnter(p *struct_Vdbe) {
	var i int32
	var db *struct_sqlite3
	var aDb *struct_Db
	var nDb int32
	if p.lockMask == uint32(0) {
		return
	}
	db = p.db
	aDb = db.aDb
	nDb = db.nDb
	for i = int32(0); i < nDb; i++ {
		if i != 1 && p.lockMask&(uint32(1)<<i) != uint32(0) && uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(aDb)) + uintptr(i)*32))).pBt)) != uintptr(unsafe.Pointer(nil)) {
			sqlite3BtreeEnter((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(aDb)) + uintptr(i)*32))).pBt)
		}
	}
}
func vdbeLeave(p *struct_Vdbe) {
	var i int32
	var db *struct_sqlite3
	var aDb *struct_Db
	var nDb int32
	db = p.db
	aDb = db.aDb
	nDb = db.nDb
	for i = int32(0); i < nDb; i++ {
		if i != 1 && p.lockMask&(uint32(1)<<i) != uint32(0) && uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(aDb)) + uintptr(i)*32))).pBt)) != uintptr(unsafe.Pointer(nil)) {
			sqlite3BtreeLeave((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(aDb)) + uintptr(i)*32))).pBt)
		}
	}
}
func sqlite3VdbeLeave(p *struct_Vdbe) {
	if p.lockMask == uint32(0) {
		return
	}
	vdbeLeave(p)
}
func initMemArray(p *struct_sqlite3_value, N int32, db *struct_sqlite3, flags uint16) {
	for func() (_cgo_ret int32) {
		_cgo_addr := &N
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() > 0 {
		p.db = db
		p.flags = flags
		p.szMalloc = int32(0)
		*(*uintptr)(unsafe.Pointer(&p)) += 56
	}
}
func releaseMemArray(p *struct_sqlite3_value, N int32) {
	if p != nil && N != 0 {
		var pEnd *struct_sqlite3_value = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(N)*56))
		var db *struct_sqlite3 = p.db
		if db.pnBytesFreed != nil {
			for {
				if p.szMalloc != 0 {
					sqlite3DbFree(db, unsafe.Pointer(p.zMalloc))
				}
				if !(uintptr(unsafe.Pointer(func() (_cgo_ret *struct_sqlite3_value) {
					_cgo_addr := &p
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return *_cgo_addr
				}())) < uintptr(unsafe.Pointer(pEnd))) {
					break
				}
			}
			return
		}
		for {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(p.flags)&(8192|1024) != 0 {
				sqlite3VdbeMemRelease(p)
			} else if p.szMalloc != 0 {
				sqlite3DbFreeNN(db, unsafe.Pointer(p.zMalloc))
				p.szMalloc = int32(0)
			}
			p.flags = uint16(128)
			if !(uintptr(unsafe.Pointer(func() (_cgo_ret *struct_sqlite3_value) {
				_cgo_addr := &p
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
				return *_cgo_addr
			}())) < uintptr(unsafe.Pointer(pEnd))) {
				break
			}
		}
	}
}
func sqlite3VdbeFrameMemDel(pArg unsafe.Pointer) {
	var pFrame *struct_VdbeFrame = (*struct_VdbeFrame)(pArg)
	func() int {
		_ = 0
		return 0
	}()
	pFrame.pParent = pFrame.v.pDelFrame
	pFrame.v.pDelFrame = pFrame
}
func sqlite3VdbeNextOpcode(p *struct_Vdbe, pSub *struct_sqlite3_value, eMode int32, piPc *int32, piAddr *int32, paOp **struct_VdbeOp) int32 {
	var nRow int32
	var nSub int32 = 0
	var apSub **struct_SubProgram = nil
	var i int32
	var rc int32 = 0
	var aOp *struct_VdbeOp = nil
	var iPc int32
	nRow = p.nOp
	if uintptr(unsafe.Pointer(pSub)) != uintptr(unsafe.Pointer(nil)) {
		if int32(pSub.flags)&16 != 0 {
			nSub = int32(uint(pSub.n) / 8)
			apSub = (**struct_SubProgram)(unsafe.Pointer(pSub.z))
		}
		for i = int32(0); i < nSub; i++ {
			nRow += (*(**struct_SubProgram)(unsafe.Pointer(uintptr(unsafe.Pointer(apSub)) + uintptr(i)*8))).nOp
		}
	}
	iPc = *piPc
	for 1 != 0 {
		i = func() (_cgo_ret int32) {
			_cgo_addr := &iPc
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		if i >= nRow {
			p.rc = int32(0)
			rc = int32(101)
			break
		}
		if i < p.nOp {
			aOp = p.aOp
		} else {
			var j int32
			i -= p.nOp
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			for j = int32(0); i >= (*(**struct_SubProgram)(unsafe.Pointer(uintptr(unsafe.Pointer(apSub)) + uintptr(j)*8))).nOp; j++ {
				i -= (*(**struct_SubProgram)(unsafe.Pointer(uintptr(unsafe.Pointer(apSub)) + uintptr(j)*8))).nOp
				func() int {
					_ = 0
					return 0
				}()
			}
			aOp = (*(**struct_SubProgram)(unsafe.Pointer(uintptr(unsafe.Pointer(apSub)) + uintptr(j)*8))).aOp
		}
		if uintptr(unsafe.Pointer(pSub)) != uintptr(unsafe.Pointer(nil)) && int32((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))).p4type) == -4 {
			var nByte int32 = int32(uint(nSub+1) * 8)
			var j int32
			for j = int32(0); j < nSub; j++ {
				if uintptr(unsafe.Pointer(*(**struct_SubProgram)(unsafe.Pointer(uintptr(unsafe.Pointer(apSub)) + uintptr(j)*8)))) == uintptr(unsafe.Pointer(*(**struct_SubProgram)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))).p4)))) {
					break
				}
			}
			if j == nSub {
				p.rc = sqlite3VdbeMemGrow(pSub, nByte, func() int32 {
					if nSub != 0 {
						return 1
					} else {
						return 0
					}
				}())
				if p.rc != 0 {
					rc = int32(1)
					break
				}
				apSub = (**struct_SubProgram)(unsafe.Pointer(pSub.z))
				*(**struct_SubProgram)(unsafe.Pointer(uintptr(unsafe.Pointer(apSub)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &nSub
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())*8)) = *(**struct_SubProgram)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))).p4))
				pSub.flags = uint16(int32(pSub.flags) & ^(49599|16384) | 16)
				pSub.n = int32(uint(nSub) * 8)
				nRow += (*(**struct_SubProgram)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))).p4))).nOp
			}
		}
		if eMode == 0 {
			break
		}
		{
			func() int {
				_ = 0
				return 0
			}()
			if int32((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))).opcode) == 183 {
				break
			}
			if int32((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))).opcode) == 64 && iPc > 1 {
				break
			}
		}
	}
	*piPc = iPc
	*piAddr = i
	*paOp = aOp
	return rc
}
func sqlite3VdbeFrameDelete(p *struct_VdbeFrame) {
	var i int32
	var aMem *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(p)))) + uintptr((120+uint(7))&uint(18446744073709551608))))))
	var apCsr **struct_VdbeCursor = (**struct_VdbeCursor)(unsafe.Pointer(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(p.nChildMem)*56))))
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < p.nChildCsr; i++ {
		sqlite3VdbeFreeCursor(p.v, *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(apCsr)) + uintptr(i)*8)))
	}
	releaseMemArray(aMem, p.nChildMem)
	sqlite3VdbeDeleteAuxData(p.v.db, &p.pAuxData, -1, 0)
	sqlite3DbFree(p.v.db, unsafe.Pointer(p))
}
func sqlite3VdbeList(p *struct_Vdbe) int32 {
	var pSub *struct_sqlite3_value = nil
	var db *struct_sqlite3 = p.db
	var i int32
	var rc int32 = 0
	var pMem *struct_sqlite3_value = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMem)) + uintptr(1)*56))
	var bListSubprogs int32 = func() int32 {
		if int32(p.Xbf_0>>2&3) == 1 || db.flags&uint64(16777216) != uint64(0) {
			return 1
		} else {
			return 0
		}
	}()
	var aOp *struct_VdbeOp
	var pOp *struct_VdbeOp
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	releaseMemArray(pMem, 8)
	p.pResultSet = (*struct_sqlite3_value)(nil)
	if p.rc == 7 {
		sqlite3OomFault(db)
		return int32(1)
	}
	if bListSubprogs != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pSub = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMem)) + uintptr(9)*56))
	} else {
		pSub = (*struct_sqlite3_value)(nil)
	}
	rc = sqlite3VdbeNextOpcode(p, pSub, func() int32 {
		if int32(p.Xbf_0>>2&3) == 2 {
			return 1
		} else {
			return 0
		}
	}(), &p.pc, &i, &aOp)
	if rc == 0 {
		pOp = (*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(i)*24))
		if __atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0) != 0 {
			p.rc = int32(9)
			rc = int32(1)
			sqlite3VdbeError(p, sqlite3ErrStr(p.rc))
		} else {
			var zP4 *int8 = sqlite3VdbeDisplayP4(db, pOp)
			if int32(p.Xbf_0>>2&3) == 2 {
				sqlite3VdbeMemSetInt64(pMem, int64(pOp.p1))
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(1)*56)), int64(pOp.p2))
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(2)*56)), int64(pOp.p3))
				sqlite3VdbeMemSetStr((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(3)*56)), zP4, int64(-1), uint8(1), sqlite3_free)
				p.nResColumn = uint16(4)
			} else {
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(0)*56)), int64(i))
				sqlite3VdbeMemSetStr((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(1)*56)), (*int8)(unsafe.Pointer(sqlite3OpcodeName(int32(pOp.opcode)))), int64(-1), uint8(1), (func(unsafe.Pointer))(0))
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(2)*56)), int64(pOp.p1))
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(3)*56)), int64(pOp.p2))
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(4)*56)), int64(pOp.p3))
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(6)*56)), int64(pOp.p5))
				sqlite3VdbeMemSetNull((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem)) + uintptr(7)*56)))
				sqlite3VdbeMemSetStr((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem))+uintptr(5)*56)), zP4, int64(-1), uint8(1), sqlite3_free)
				p.nResColumn = uint16(8)
			}
			p.pResultSet = pMem
			if db.mallocFailed != 0 {
				p.rc = int32(7)
				rc = int32(1)
			} else {
				p.rc = int32(0)
				rc = int32(100)
			}
		}
	}
	return rc
}

type struct_ReusableSpace struct {
	pSpace  *uint8
	nFree   int64
	nNeeded int64
}

func allocSpace(p *struct_ReusableSpace, pBuf unsafe.Pointer, nByte int64) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pBuf)) == uintptr(unsafe.Pointer(nil)) {
		nByte = (nByte + int64(7)) & int64(^7)
		if nByte <= p.nFree {
			p.nFree -= nByte
			pBuf = unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.pSpace)) + uintptr(p.nFree))))
		} else {
			p.nNeeded += nByte
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	return pBuf
}
func sqlite3VdbeRewind(p *struct_Vdbe) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	p.iVdbeMagic = uint32(770837923)
	p.pc = int32(-1)
	p.rc = int32(0)
	p.errorAction = uint8(2)
	p.nChange = int64(0)
	p.cacheCtr = uint32(1)
	p.minWriteFileFormat = uint8(255)
	p.iStatement = int32(0)
	p.nFkConstraint = int64(0)
}
func sqlite3VdbeMakeReady(p *struct_Vdbe, pParse *struct_Parse) {
	var db *struct_sqlite3
	var nVar int32
	var nMem int32
	var nCursor int32
	var nArg int32
	var n int32
	var x struct_ReusableSpace
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	p.pVList = pParse.pVList
	pParse.pVList = (*int32)(nil)
	db = p.db
	func() int {
		_ = 0
		return 0
	}()
	nVar = int32(pParse.nVar)
	nMem = pParse.nMem
	nCursor = pParse.nTab
	nArg = pParse.nMaxArg
	nMem += nCursor
	if nCursor == 0 && nMem > 0 {
		nMem++
	}
	n = int32((24*uint(p.nOp) + uint(7)) & uint(18446744073709551608))
	x.pSpace = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(p.aOp)))) + uintptr(n)))
	func() int {
		_ = 0
		return 0
	}()
	x.nFree = int64((pParse.szOpAlloc - n) & ^7)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	resolveP2Values(p, &nArg)
	{
		_autoGo_11 := &p.Xbf_0
		*_autoGo_11 = *_autoGo_11&^64 | uint32(func() uint8 {
			if int32(pParse.isMultiWrite) != 0 && int32(pParse.mayAbort) != 0 {
				return 1
			} else {
				return 0
			}
		}())&1<<6
	}
	if pParse.explain != 0 {
		var azColName [12]*int8 = [12]*int8{(*int8)(unsafe.Pointer(&[5]int8{'a', 'd', 'd', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'o', 'p', 'c', 'o', 'd', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', '1', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', '2', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', '3', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', '4', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', '5', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'c', 'o', 'm', 'm', 'e', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'p', 'a', 'r', 'e', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'n', 'o', 't', 'u', 's', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'d', 'e', 't', 'a', 'i', 'l', '\x00'}))}
		var iFirst int32
		var mx int32
		var i int32
		if nMem < 10 {
			nMem = int32(10)
		}
		{
			_autoGo_12 := &p.Xbf_0
			*_autoGo_12 = *_autoGo_12&^12 | uint32(pParse.explain)&3<<2
		}
		if int32(pParse.explain) == 2 {
			sqlite3VdbeSetNumCols(p, 4)
			iFirst = int32(8)
			mx = int32(12)
		} else {
			sqlite3VdbeSetNumCols(p, 8)
			iFirst = int32(0)
			mx = int32(8)
		}
		for i = iFirst; i < mx; i++ {
			sqlite3VdbeSetColName(p, i-iFirst, 0, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azColName)))) + uintptr(i)*8)), (func(unsafe.Pointer))(0))
		}
	}
	{
		_autoGo_13 := &p.Xbf_0
		*_autoGo_13 = *_autoGo_13&^3 | uint32(0)&3
	}
	x.nNeeded = int64(0)
	p.aMem = (*struct_sqlite3_value)(allocSpace(&x, nil, int64(uint(nMem)*56)))
	p.aVar = (*struct_sqlite3_value)(allocSpace(&x, nil, int64(uint(nVar)*56)))
	p.apArg = (**struct_sqlite3_value)(allocSpace(&x, nil, int64(uint(nArg)*8)))
	p.apCsr = (**struct_VdbeCursor)(allocSpace(&x, nil, int64(uint(nCursor)*8)))
	if x.nNeeded != 0 {
		x.pSpace = (*uint8)(func() (_cgo_ret unsafe.Pointer) {
			_cgo_addr := &p.pFree
			*_cgo_addr = sqlite3DbMallocRawNN(db, uint64(x.nNeeded))
			return *_cgo_addr
		}())
		x.nFree = x.nNeeded
		if !(db.mallocFailed != 0) {
			p.aMem = (*struct_sqlite3_value)(allocSpace(&x, unsafe.Pointer(p.aMem), int64(uint(nMem)*56)))
			p.aVar = (*struct_sqlite3_value)(allocSpace(&x, unsafe.Pointer(p.aVar), int64(uint(nVar)*56)))
			p.apArg = (**struct_sqlite3_value)(allocSpace(&x, unsafe.Pointer(p.apArg), int64(uint(nArg)*8)))
			p.apCsr = (**struct_VdbeCursor)(allocSpace(&x, unsafe.Pointer(p.apCsr), int64(uint(nCursor)*8)))
		}
	}
	if db.mallocFailed != 0 {
		p.nVar = int16(0)
		p.nCursor = int32(0)
		p.nMem = int32(0)
	} else {
		p.nCursor = nCursor
		p.nVar = int16(nVar)
		initMemArray(p.aVar, nVar, db, uint16(1))
		p.nMem = nMem
		initMemArray(p.aMem, nMem, db, uint16(128))
		__builtin___memset_chk(unsafe.Pointer(p.apCsr), 0, uint(nCursor)*8, __builtin_object_size(unsafe.Pointer(p.apCsr), 0))
	}
	sqlite3VdbeRewind(p)
}
func sqlite3VdbeFreeCursor(p *struct_Vdbe, pCx *struct_VdbeCursor) {
	if uintptr(unsafe.Pointer(pCx)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	switch int32(pCx.eCurType) {
	case 1:
		{
			sqlite3VdbeSorterClose(p.db, pCx)
			break
		}
	case 0:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3BtreeCloseCursor(pCx.uc.pCursor)
			break
		}
	case 2:
		{
			var pVCur *struct_sqlite3_vtab_cursor = *(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCx.uc))
			var pModule *struct_sqlite3_module = pVCur.pVtab.pModule
			func() int {
				_ = 0
				return 0
			}()
			pVCur.pVtab.nRef--
			pModule.xClose(pVCur)
			break
		}
	}
}
func closeCursorsInFrame(p *struct_Vdbe) {
	if p.apCsr != nil {
		var i int32
		for i = int32(0); i < p.nCursor; i++ {
			var pC *struct_VdbeCursor = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(i)*8))
			if pC != nil {
				sqlite3VdbeFreeCursor(p, pC)
				*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(i)*8)) = (*struct_VdbeCursor)(nil)
			}
		}
	}
}
func sqlite3VdbeFrameRestore(pFrame *struct_VdbeFrame) int32 {
	var v *struct_Vdbe = pFrame.v
	closeCursorsInFrame(v)
	v.aOp = pFrame.aOp
	v.nOp = pFrame.nOp
	v.aMem = pFrame.aMem
	v.nMem = pFrame.nMem
	v.apCsr = pFrame.apCsr
	v.nCursor = pFrame.nCursor
	v.db.lastRowid = pFrame.lastRowid
	v.nChange = pFrame.nChange
	v.db.nChange = pFrame.nDbChange
	sqlite3VdbeDeleteAuxData(v.db, &v.pAuxData, -1, 0)
	v.pAuxData = pFrame.pAuxData
	pFrame.pAuxData = (*struct_AuxData)(nil)
	return pFrame.pc
}
func closeAllCursors(p *struct_Vdbe) {
	if p.pFrame != nil {
		var pFrame *struct_VdbeFrame
		for pFrame = p.pFrame; pFrame.pParent != nil; pFrame = pFrame.pParent {
		}
		sqlite3VdbeFrameRestore(pFrame)
		p.pFrame = (*struct_VdbeFrame)(nil)
		p.nFrame = int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	closeCursorsInFrame(p)
	if p.aMem != nil {
		releaseMemArray(p.aMem, p.nMem)
	}
	for p.pDelFrame != nil {
		var pDel *struct_VdbeFrame = p.pDelFrame
		p.pDelFrame = pDel.pParent
		sqlite3VdbeFrameDelete(pDel)
	}
	if p.pAuxData != nil {
		sqlite3VdbeDeleteAuxData(p.db, &p.pAuxData, -1, 0)
	}
	func() int {
		_ = 0
		return 0
	}()
}
func sqlite3VdbeSetNumCols(p *struct_Vdbe, nResColumn int32) {
	var n int32
	var db *struct_sqlite3 = p.db
	if p.nResColumn != 0 {
		releaseMemArray(p.aColName, int32(p.nResColumn)*2)
		sqlite3DbFree(db, unsafe.Pointer(p.aColName))
	}
	n = nResColumn * 2
	p.nResColumn = uint16(nResColumn)
	p.aColName = (*struct_sqlite3_value)(sqlite3DbMallocRawNN(db, uint64(56*uint(n))))
	if uintptr(unsafe.Pointer(p.aColName)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	initMemArray(p.aColName, n, db, uint16(1))
}
func sqlite3VdbeSetColName(p *struct_Vdbe, idx int32, var_ int32, zName *int8, xDel func(unsafe.Pointer)) int32 {
	var rc int32
	var pColName *struct_sqlite3_value
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.db.mallocFailed != 0 {
		func() int {
			_ = 0
			return 0
		}()
		return int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	pColName = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aColName)) + uintptr(idx+var_*int32(p.nResColumn))*56))
	rc = sqlite3VdbeMemSetStr(pColName, zName, int64(-1), uint8(1), xDel)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func vdbeCommit(db *struct_sqlite3, p *struct_Vdbe) int32 {
	var i int32
	var nTrans int32 = 0
	var rc int32 = 0
	var needXcommit int32 = 0
	rc = sqlite3VtabSync(db, p)
	for i = int32(0); rc == 0 && i < db.nDb; i++ {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if sqlite3BtreeTxnState(pBt) == 2 {
			var aMJNeeded [6]uint8 = [6]uint8{uint8(1), uint8(1), uint8(0), uint8(1), uint8(0), uint8(0)}
			var pPager *struct_Pager
			needXcommit = int32(1)
			sqlite3BtreeEnter(pBt)
			pPager = sqlite3BtreePager(pBt)
			if int32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).safety_level) != 1 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMJNeeded)))) + uintptr(sqlite3PagerGetJournalMode(pPager))))) != 0 && sqlite3PagerIsMemdb(pPager) == 0 {
				func() int {
					_ = 0
					return 0
				}()
				nTrans++
			}
			rc = sqlite3PagerExclusiveLock(pPager)
			sqlite3BtreeLeave(pBt)
		}
	}
	if rc != 0 {
		return rc
	}
	if needXcommit != 0 && db.xCommitCallback != nil {
		rc = db.xCommitCallback(db.pCommitArg)
		if rc != 0 {
			return int32(19 | 2<<8)
		}
	}
	if 0 == sqlite3Strlen30(sqlite3BtreeGetFilename((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt)) || nTrans <= 1 {
		for i = int32(0); rc == 0 && i < db.nDb; i++ {
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if pBt != nil {
				rc = sqlite3BtreeCommitPhaseOne(pBt, nil)
			}
		}
		for i = int32(0); rc == 0 && i < db.nDb; i++ {
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if pBt != nil {
				rc = sqlite3BtreeCommitPhaseTwo(pBt, 0)
			}
		}
		if rc == 0 {
			sqlite3VtabCommit(db)
		}
	} else {
		var pVfs *struct_sqlite3_vfs = db.pVfs
		var zSuper *int8 = nil
		var zMainFile *int8 = sqlite3BtreeGetFilename((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt)
		var pSuperJrnl *struct_sqlite3_file = nil
		var offset int64 = int64(0)
		var res int32
		var retryCount int32 = 0
		var nMainFile int32
		nMainFile = sqlite3Strlen30(zMainFile)
		zSuper = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[12]int8{'%', '.', '4', 'c', '%', 's', '%', '.', '1', '6', 'c', '\x00'})), 0, zMainFile, 0)
		if uintptr(unsafe.Pointer(zSuper)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		*(*uintptr)(unsafe.Pointer(&zSuper)) += uintptr(4)
		for {
			var iRandom uint32
			if retryCount != 0 {
				if retryCount > 100 {
					sqlite3_log(13, (*int8)(unsafe.Pointer(&[14]int8{'M', 'J', ' ', 'd', 'e', 'l', 'e', 't', 'e', ':', ' ', '%', 's', '\x00'})), zSuper)
					sqlite3OsDelete(pVfs, zSuper, 0)
					break
				} else if retryCount == 1 {
					sqlite3_log(13, (*int8)(unsafe.Pointer(&[15]int8{'M', 'J', ' ', 'c', 'o', 'l', 'l', 'i', 'd', 'e', ':', ' ', '%', 's', '\x00'})), zSuper)
				}
			}
			retryCount++
			sqlite3_randomness(int32(4), unsafe.Pointer(&iRandom))
			sqlite3_snprintf(13, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper)) + uintptr(nMainFile))), (*int8)(unsafe.Pointer(&[13]int8{'-', 'm', 'j', '%', '0', '6', 'X', '9', '%', '0', '2', 'X', '\x00'})), iRandom>>8&uint32(16777215), iRandom&uint32(255))
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3OsAccess(pVfs, zSuper, 0, &res)
			if !(rc == 0 && res != 0) {
				break
			}
		}
		if rc == 0 {
			rc = sqlite3OsOpenMalloc(pVfs, zSuper, &pSuperJrnl, 2|4|16|16384, nil)
		}
		if rc != 0 {
			sqlite3DbFree(db, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper))-uintptr(4)))))
			return rc
		}
		for i = int32(0); i < db.nDb; i++ {
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if sqlite3BtreeTxnState(pBt) == 2 {
				var zFile *int8 = sqlite3BtreeGetJournalname(pBt)
				if uintptr(unsafe.Pointer(zFile)) == uintptr(unsafe.Pointer(nil)) {
					continue
				}
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3OsWrite(pSuperJrnl, unsafe.Pointer(zFile), sqlite3Strlen30(zFile)+1, offset)
				offset += int64(sqlite3Strlen30(zFile) + 1)
				if rc != 0 {
					sqlite3OsCloseFree(pSuperJrnl)
					sqlite3OsDelete(pVfs, zSuper, 0)
					sqlite3DbFree(db, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper))-uintptr(4)))))
					return rc
				}
			}
		}
		if 0 == sqlite3OsDeviceCharacteristics(pSuperJrnl)&1024 && 0 != func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = sqlite3OsSync(pSuperJrnl, 2)
			return *_cgo_addr
		}() {
			sqlite3OsCloseFree(pSuperJrnl)
			sqlite3OsDelete(pVfs, zSuper, 0)
			sqlite3DbFree(db, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper))-uintptr(4)))))
			return rc
		}
		for i = int32(0); rc == 0 && i < db.nDb; i++ {
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if pBt != nil {
				rc = sqlite3BtreeCommitPhaseOne(pBt, zSuper)
			}
		}
		sqlite3OsCloseFree(pSuperJrnl)
		func() int {
			_ = 0
			return 0
		}()
		if rc != 0 {
			sqlite3DbFree(db, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper))-uintptr(4)))))
			return rc
		}
		rc = sqlite3OsDelete(pVfs, zSuper, 1)
		sqlite3DbFree(db, unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSuper))-uintptr(4)))))
		zSuper = (*int8)(nil)
		if rc != 0 {
			return rc
		}
		sqlite3BeginBenignMalloc()
		for i = int32(0); i < db.nDb; i++ {
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if pBt != nil {
				sqlite3BtreeCommitPhaseTwo(pBt, 1)
			}
		}
		sqlite3EndBenignMalloc()
		sqlite3VtabCommit(db)
	}
	return rc
}
func vdbeCloseStatement(p *struct_Vdbe, eOp int32) int32 {
	var db *struct_sqlite3 = p.db
	var rc int32 = 0
	var i int32
	var iSavepoint int32 = p.iStatement - 1
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nDb; i++ {
		var rc2 int32 = 0
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if pBt != nil {
			if eOp == 2 {
				rc2 = sqlite3BtreeSavepoint(pBt, 2, iSavepoint)
			}
			if rc2 == 0 {
				rc2 = sqlite3BtreeSavepoint(pBt, 1, iSavepoint)
			}
			if rc == 0 {
				rc = rc2
			}
		}
	}
	db.nStatement--
	p.iStatement = int32(0)
	if rc == 0 {
		if eOp == 2 {
			rc = sqlite3VtabSavepoint(db, 2, iSavepoint)
		}
		if rc == 0 {
			rc = sqlite3VtabSavepoint(db, 1, iSavepoint)
		}
	}
	if eOp == 2 {
		db.nDeferredCons = p.nStmtDefCons
		db.nDeferredImmCons = p.nStmtDefImmCons
	}
	return rc
}
func sqlite3VdbeCloseStatement(p *struct_Vdbe, eOp int32) int32 {
	if p.db.nStatement != 0 && p.iStatement != 0 {
		return vdbeCloseStatement(p, eOp)
	}
	return int32(0)
}
func sqlite3VdbeCheckFk(p *struct_Vdbe, deferred int32) int32 {
	var db *struct_sqlite3 = p.db
	if deferred != 0 && db.nDeferredCons+db.nDeferredImmCons > int64(0) || !(deferred != 0) && p.nFkConstraint > int64(0) {
		p.rc = int32(19 | 3<<8)
		p.errorAction = uint8(2)
		sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[30]int8{'F', 'O', 'R', 'E', 'I', 'G', 'N', ' ', 'K', 'E', 'Y', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', '\x00'})))
		return int32(1)
	}
	return int32(0)
}
func sqlite3VdbeHalt(p *struct_Vdbe) int32 {
	var rc int32
	var db *struct_sqlite3 = p.db
	if p.iVdbeMagic != uint32(770837923) {
		return int32(0)
	}
	if db.mallocFailed != 0 {
		p.rc = int32(7)
	}
	closeAllCursors(p)
	if p.pc >= 0 && int32(p.Xbf_0>>8&1) != 0 {
		var mrc int32
		var eStatementOp int32 = 0
		var isSpecialError int32
		sqlite3VdbeEnter(p)
		if p.rc != 0 {
			mrc = p.rc & 255
			isSpecialError = func() int32 {
				if mrc == 7 || mrc == 10 || mrc == 9 || mrc == 13 {
					return 1
				} else {
					return 0
				}
			}()
		} else {
			mrc = func() (_cgo_ret int32) {
				_cgo_addr := &isSpecialError
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
		}
		if isSpecialError != 0 {
			if !(p.Xbf_0>>7&1 != 0) || mrc != 9 {
				if (mrc == 7 || mrc == 13) && int32(p.Xbf_0>>6&1) != 0 {
					eStatementOp = int32(2)
				} else {
					sqlite3RollbackAll(db, 4|2<<8)
					sqlite3CloseSavepoints(db)
					db.autoCommit = uint8(1)
					p.nChange = int64(0)
				}
			}
		}
		if p.rc == 0 || int32(p.errorAction) == 3 && !(isSpecialError != 0) {
			sqlite3VdbeCheckFk(p, 0)
		}
		if !(db.nVTrans > 0 && uintptr(unsafe.Pointer(db.aVTrans)) == uintptr(unsafe.Pointer(nil))) && int32(db.autoCommit) != 0 && db.nVdbeWrite == func() int32 {
			if int32(p.Xbf_0>>7&1) == 0 {
				return 1
			} else {
				return 0
			}
		}() {
			if p.rc == 0 || int32(p.errorAction) == 3 && !(isSpecialError != 0) {
				rc = sqlite3VdbeCheckFk(p, 1)
				if rc != 0 {
					if p.Xbf_0>>7&1 != 0 {
						sqlite3VdbeLeave(p)
						return int32(1)
					}
					rc = int32(19 | 3<<8)
				} else if db.flags&(uint64(2)<<32) != 0 {
					rc = int32(11)
					db.flags &= ^(uint64(2) << 32)
				} else {
					rc = vdbeCommit(db, p)
				}
				if rc == 5 && int32(p.Xbf_0>>7&1) != 0 {
					sqlite3VdbeLeave(p)
					return int32(5)
				} else if rc != 0 {
					p.rc = rc
					sqlite3RollbackAll(db, 0)
					p.nChange = int64(0)
				} else {
					db.nDeferredCons = int64(0)
					db.nDeferredImmCons = int64(0)
					db.flags &= ^uint64(524288)
					sqlite3CommitInternalChanges(db)
				}
			} else {
				sqlite3RollbackAll(db, 0)
				p.nChange = int64(0)
			}
			db.nStatement = int32(0)
		} else if eStatementOp == 0 {
			if p.rc == 0 || int32(p.errorAction) == 3 {
				eStatementOp = int32(1)
			} else if int32(p.errorAction) == 2 {
				eStatementOp = int32(2)
			} else {
				sqlite3RollbackAll(db, 4|2<<8)
				sqlite3CloseSavepoints(db)
				db.autoCommit = uint8(1)
				p.nChange = int64(0)
			}
		}
		if eStatementOp != 0 {
			rc = sqlite3VdbeCloseStatement(p, eStatementOp)
			if rc != 0 {
				if p.rc == 0 || p.rc&255 == 19 {
					p.rc = rc
					sqlite3DbFree(db, unsafe.Pointer(p.zErrMsg))
					p.zErrMsg = (*int8)(nil)
				}
				sqlite3RollbackAll(db, 4|2<<8)
				sqlite3CloseSavepoints(db)
				db.autoCommit = uint8(1)
				p.nChange = int64(0)
			}
		}
		if p.Xbf_0>>4&1 != 0 {
			if eStatementOp != 2 {
				sqlite3VdbeSetChanges(db, p.nChange)
			} else {
				sqlite3VdbeSetChanges(db, int64(0))
			}
			p.nChange = int64(0)
		}
		sqlite3VdbeLeave(p)
	}
	if p.pc >= 0 {
		db.nVdbeActive--
		if !(p.Xbf_0>>7&1 != 0) {
			db.nVdbeWrite--
		}
		if p.Xbf_0>>8&1 != 0 {
			db.nVdbeRead--
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	p.iVdbeMagic = uint32(832317811)
	if db.mallocFailed != 0 {
		p.rc = int32(7)
	}
	if db.autoCommit != 0 {
	}
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if p.rc == 5 {
			return 5
		} else {
			return 0
		}
	}()
}
func sqlite3VdbeResetStepResult(p *struct_Vdbe) {
	p.rc = int32(0)
}
func sqlite3VdbeTransferError(p *struct_Vdbe) int32 {
	var db *struct_sqlite3 = p.db
	var rc int32 = p.rc
	if p.zErrMsg != nil {
		db.bBenignMalloc++
		sqlite3BeginBenignMalloc()
		if uintptr(unsafe.Pointer(db.pErr)) == uintptr(unsafe.Pointer(nil)) {
			db.pErr = sqlite3ValueNew(db)
		}
		sqlite3ValueSetStr(db.pErr, -1, unsafe.Pointer(p.zErrMsg), uint8(1), (func(unsafe.Pointer))(-1))
		sqlite3EndBenignMalloc()
		db.bBenignMalloc--
	} else if db.pErr != nil {
		sqlite3ValueSetNull(db.pErr)
	}
	db.errCode = rc
	db.errByteOffset = int32(-1)
	return rc
}
func sqlite3VdbeReset(p *struct_Vdbe) int32 {
	var db *struct_sqlite3
	db = p.db
	sqlite3VdbeHalt(p)
	if p.pc >= 0 {
		if db.pErr != nil || p.zErrMsg != nil {
			sqlite3VdbeTransferError(p)
		} else {
			db.errCode = p.rc
		}
		if p.Xbf_0>>5&1 != 0 {
			{
				_autoGo_14 := &p.Xbf_0
				*_autoGo_14 = *_autoGo_14&^3 | uint32(1)&3
			}
		}
	} else if p.rc != 0 && int32(p.Xbf_0&3) != 0 {
		sqlite3ErrorWithMsg(db, p.rc, func() *int8 {
			if p.zErrMsg != nil {
				return (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'}))
			} else {
				return nil
			}
		}(), p.zErrMsg)
	}
	if p.zErrMsg != nil {
		sqlite3DbFree(db, unsafe.Pointer(p.zErrMsg))
		p.zErrMsg = (*int8)(nil)
	}
	p.pResultSet = (*struct_sqlite3_value)(nil)
	p.iVdbeMagic = uint32(1224384374)
	return p.rc & db.errMask
}
func sqlite3VdbeFinalize(p *struct_Vdbe) int32 {
	var rc int32 = 0
	if p.iVdbeMagic == uint32(770837923) || p.iVdbeMagic == uint32(832317811) {
		rc = sqlite3VdbeReset(p)
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3VdbeDelete(p)
	return rc
}
func sqlite3VdbeDeleteAuxData(db *struct_sqlite3, pp **struct_AuxData, iOp int32, mask int32) {
	for *pp != nil {
		var pAux *struct_AuxData = *pp
		if iOp < 0 || pAux.iAuxOp == iOp && pAux.iAuxArg >= 0 && (pAux.iAuxArg > 31 || !(uint32(mask)&(uint32(1)<<pAux.iAuxArg) != 0)) {
			if pAux.xDeleteAux != nil {
				pAux.xDeleteAux(pAux.pAux)
			}
			*pp = pAux.pNextAux
			sqlite3DbFree(db, unsafe.Pointer(pAux))
		} else {
			pp = &pAux.pNextAux
		}
	}
}
func sqlite3VdbeClearObject(db *struct_sqlite3, p *struct_Vdbe) {
	var pSub *struct_SubProgram
	var pNext *struct_SubProgram
	func() int {
		_ = 0
		return 0
	}()
	releaseMemArray(p.aColName, int32(p.nResColumn)*2)
	for pSub = p.pProgram; pSub != nil; pSub = pNext {
		pNext = pSub.pNext
		vdbeFreeOpArray(db, pSub.aOp, pSub.nOp)
		sqlite3DbFree(db, unsafe.Pointer(pSub))
	}
	if p.iVdbeMagic != uint32(381479589) {
		releaseMemArray(p.aVar, int32(p.nVar))
		sqlite3DbFree(db, unsafe.Pointer(p.pVList))
		sqlite3DbFree(db, p.pFree)
	}
	vdbeFreeOpArray(db, p.aOp, p.nOp)
	sqlite3DbFree(db, unsafe.Pointer(p.aColName))
	sqlite3DbFree(db, unsafe.Pointer(p.zSql))
}
func sqlite3VdbeDelete(p *struct_Vdbe) {
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	db = p.db
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeClearObject(db, p)
	if p.pPrev != nil {
		p.pPrev.pNext = p.pNext
	} else {
		func() int {
			_ = 0
			return 0
		}()
		db.pVdbe = p.pNext
	}
	if p.pNext != nil {
		p.pNext.pPrev = p.pPrev
	}
	p.iVdbeMagic = uint32(1443283912)
	p.db = (*struct_sqlite3)(nil)
	sqlite3DbFreeNN(db, unsafe.Pointer(p))
}
func sqlite3VdbeFinishMoveto(p *struct_VdbeCursor) int32 {
	var res int32
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3BtreeTableMoveto(p.uc.pCursor, p.movetoTarget, 0, &res)
	if rc != 0 {
		return rc
	}
	if res != 0 {
		return sqlite3CorruptError(83310)
	}
	p.deferredMoveto = uint8(0)
	p.cacheStatus = uint32(0)
	return int32(0)
}
func handleMovedCursor(p *struct_VdbeCursor) int32 {
	var isDifferentRow int32
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3BtreeCursorRestore(p.uc.pCursor, &isDifferentRow)
	p.cacheStatus = uint32(0)
	if isDifferentRow != 0 {
		p.nullRow = uint8(1)
	}
	return rc
}
func sqlite3VdbeCursorRestore(p *struct_VdbeCursor) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3BtreeCursorHasMoved(p.uc.pCursor) != 0 {
		return handleMovedCursor(p)
	}
	return int32(0)
}
func sqlite3VdbeCursorMoveto(pp **struct_VdbeCursor, piCol *uint32) int32 {
	var p *struct_VdbeCursor = *pp
	func() int {
		_ = 0
		return 0
	}()
	if p.deferredMoveto != 0 {
		var iMap uint32
		func() int {
			_ = 0
			return 0
		}()
		if *(**uint32)(unsafe.Pointer(&p.ub)) != nil && func() (_cgo_ret uint32) {
			_cgo_addr := &iMap
			*_cgo_addr = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**uint32)(unsafe.Pointer(&p.ub)))) + uintptr(uint32(1)+*piCol)*4))
			return *_cgo_addr
		}() > uint32(0) && !(p.nullRow != 0) {
			*pp = p.pAltCursor
			*piCol = iMap - uint32(1)
			return int32(0)
		}
		return sqlite3VdbeFinishMoveto(p)
	}
	if sqlite3BtreeCursorHasMoved(p.uc.pCursor) != 0 {
		return handleMovedCursor(p)
	}
	return int32(0)
}

var sqlite3SmallTypeSizes [128]uint8 = [128]uint8{uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(6), uint8(8), uint8(8), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(2), uint8(2), uint8(3), uint8(3), uint8(4), uint8(4), uint8(5), uint8(5), uint8(6), uint8(6), uint8(7), uint8(7), uint8(8), uint8(8), uint8(9), uint8(9), uint8(10), uint8(10), uint8(11), uint8(11), uint8(12), uint8(12), uint8(13), uint8(13), uint8(14), uint8(14), uint8(15), uint8(15), uint8(16), uint8(16), uint8(17), uint8(17), uint8(18), uint8(18), uint8(19), uint8(19), uint8(20), uint8(20), uint8(21), uint8(21), uint8(22), uint8(22), uint8(23), uint8(23), uint8(24), uint8(24), uint8(25), uint8(25), uint8(26), uint8(26), uint8(27), uint8(27), uint8(28), uint8(28), uint8(29), uint8(29), uint8(30), uint8(30), uint8(31), uint8(31), uint8(32), uint8(32), uint8(33), uint8(33), uint8(34), uint8(34), uint8(35), uint8(35), uint8(36), uint8(36), uint8(37), uint8(37), uint8(38), uint8(38), uint8(39), uint8(39), uint8(40), uint8(40), uint8(41), uint8(41), uint8(42), uint8(42), uint8(43), uint8(43), uint8(44), uint8(44), uint8(45), uint8(45), uint8(46), uint8(46), uint8(47), uint8(47), uint8(48), uint8(48), uint8(49), uint8(49), uint8(50), uint8(50), uint8(51), uint8(51), uint8(52), uint8(52), uint8(53), uint8(53), uint8(54), uint8(54), uint8(55), uint8(55), uint8(56), uint8(56), uint8(57), uint8(57)}

func sqlite3VdbeSerialTypeLen(serial_type uint32) uint32 {
	if serial_type >= uint32(128) {
		return (serial_type - uint32(12)) / uint32(2)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		return uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3SmallTypeSizes)))) + uintptr(serial_type))))
	}
}
func sqlite3VdbeOneByteSerialTypeLen(serial_type uint8) uint8 {
	func() int {
		_ = 0
		return 0
	}()
	return *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3SmallTypeSizes)))) + uintptr(serial_type)))
}
func sqlite3VdbeSerialPut(buf *uint8, pMem *struct_sqlite3_value, serial_type uint32) uint32 {
	var len uint32
	if serial_type <= uint32(7) && serial_type > uint32(0) {
		var v uint64
		var i uint32
		if serial_type == uint32(7) {
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memcpy_chk(unsafe.Pointer(&v), unsafe.Pointer(&pMem.u.r), 8, __builtin_object_size(unsafe.Pointer(&v), 0))
		} else {
			v = uint64(*(*int64)(unsafe.Pointer(&pMem.u)))
		}
		len = func() (_cgo_ret uint32) {
			_cgo_addr := &i
			*_cgo_addr = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3SmallTypeSizes)))) + uintptr(serial_type))))
			return *_cgo_addr
		}()
		func() int {
			_ = 0
			return 0
		}()
		for {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(func() (_cgo_ret uint32) {
				_cgo_addr := &i
				*_cgo_addr--
				return *_cgo_addr
			}()))) = uint8(v & uint64(255))
			v >>= 8
			if !(i != 0) {
				break
			}
		}
		return len
	}
	if serial_type >= uint32(12) {
		func() int {
			_ = 0
			return 0
		}()
		len = uint32(pMem.n)
		if len > uint32(0) {
			__builtin___memcpy_chk(unsafe.Pointer(buf), unsafe.Pointer(pMem.z), uint(len), __builtin_object_size(unsafe.Pointer(buf), 0))
		}
		return len
	}
	return uint32(0)
}
func serialGet(buf *uint8, serial_type uint32, pMem *struct_sqlite3_value) {
	var x uint64 = uint64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(3)))))
	var y uint32 = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(4))))) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(4))))) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(4))))) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(4))))) + uintptr(3))))
	x = x<<32 + uint64(y)
	if serial_type == uint32(6) {
		*(*int64)(unsafe.Pointer(&pMem.u)) = *(*int64)(unsafe.Pointer(&x))
		pMem.flags = uint16(4)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		__builtin___memcpy_chk(unsafe.Pointer(&pMem.u.r), unsafe.Pointer(&x), 8, __builtin_object_size(unsafe.Pointer(&pMem.u.r), 0))
		pMem.flags = uint16(func() int32 {
			if x&(uint64(2047)<<52) == uint64(2047)<<52 && x&(uint64(1)<<52-uint64(1)) != uint64(0) {
				return 1
			} else {
				return 8
			}
		}())
	}
}
func sqlite3VdbeSerialGet(buf *uint8, serial_type uint32, pMem *struct_sqlite3_value) {
	switch serial_type {
	case uint32(10):
		{
			pMem.flags = uint16(1 | 16384)
			pMem.n = int32(0)
			*(*int32)(unsafe.Pointer(&pMem.u)) = int32(0)
			return
		}
	case uint32(11):
		fallthrough
	case uint32(0):
		{
			pMem.flags = uint16(1)
			return
		}
	case uint32(1):
		{
			*(*int64)(unsafe.Pointer(&pMem.u)) = int64(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(0)))))
			pMem.flags = uint16(4)
			return
		}
	case uint32(2):
		{
			*(*int64)(unsafe.Pointer(&pMem.u)) = int64(256*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(1)))))
			pMem.flags = uint16(4)
			return
		}
	case uint32(3):
		{
			*(*int64)(unsafe.Pointer(&pMem.u)) = int64(65536*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(1))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(2)))))
			pMem.flags = uint16(4)
			return
		}
	case uint32(4):
		{
			*(*int64)(unsafe.Pointer(&pMem.u)) = int64(16777216*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(1))))<<16 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(2))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(3)))))
			pMem.flags = uint16(4)
			return
		}
	case uint32(5):
		{
			*(*int64)(unsafe.Pointer(&pMem.u)) = int64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(2))))) + uintptr(0))))<<24|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(2))))) + uintptr(1))))<<16)|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(2))))) + uintptr(2))))<<8)|uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf))+uintptr(2))))) + uintptr(3))))) + int64(1)<<32*int64(256*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(0)))))|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(buf)) + uintptr(1)))))
			pMem.flags = uint16(4)
			return
		}
	case uint32(6):
		fallthrough
	case uint32(7):
		{
			serialGet(buf, serial_type, pMem)
			return
		}
	case uint32(8):
		fallthrough
	case uint32(9):
		{
			*(*int64)(unsafe.Pointer(&pMem.u)) = int64(serial_type - uint32(8))
			pMem.flags = uint16(4)
			return
		}
	default:
		{
			var aFlag [2]uint16 = [2]uint16{uint16(16 | 4096), uint16(2 | 4096)}
			pMem.z = (*int8)(unsafe.Pointer(buf))
			pMem.n = int32((serial_type - uint32(12)) / uint32(2))
			pMem.flags = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aFlag)))) + uintptr(serial_type&uint32(1))*2))
			return
		}
	}
	return
}
func sqlite3VdbeAllocUnpackedRecord(pKeyInfo *struct_KeyInfo) *struct_UnpackedRecord {
	var p *struct_UnpackedRecord
	var nByte int32
	nByte = int32((23+uint(7))&uint(18446744073709551608) + 56*uint(int32(pKeyInfo.nKeyField)+1))
	p = (*struct_UnpackedRecord)(sqlite3DbMallocRaw(pKeyInfo.db, uint64(nByte)))
	if !(p != nil) {
		return (*struct_UnpackedRecord)(nil)
	}
	p.aMem = (*struct_sqlite3_value)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p)))) + uintptr((23+uint(7))&uint(18446744073709551608))))))
	func() int {
		_ = 0
		return 0
	}()
	p.pKeyInfo = pKeyInfo
	p.nField = uint16(int32(pKeyInfo.nKeyField) + 1)
	return p
}
func sqlite3VdbeRecordUnpack(pKeyInfo *struct_KeyInfo, nKey int32, pKey unsafe.Pointer, p *struct_UnpackedRecord) {
	var aKey *uint8 = (*uint8)(pKey)
	var d uint32
	var idx uint32
	var u uint16
	var szHdr uint32
	var pMem *struct_sqlite3_value = p.aMem
	p.default_rc = int8(0)
	func() int {
		_ = 0
		return 0
	}()
	idx = uint32(uint8(func() int32 {
		if int32(*aKey) < int32(uint8(128)) {
			return int32(func() int {
				szHdr = uint32(*aKey)
				return 1
			}())
		} else {
			return int32(sqlite3GetVarint32(aKey, (*uint32)(unsafe.Pointer(&szHdr))))
		}
	}()))
	d = szHdr
	u = uint16(0)
	for idx < szHdr && d <= uint32(nKey) {
		var serial_type uint32
		idx += uint32(uint8(func() int32 {
			if int32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(idx)))) < int32(uint8(128)) {
				return int32(func() int {
					serial_type = uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(idx))))
					return 1
				}())
			} else {
				return int32(sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(idx))), (*uint32)(unsafe.Pointer(&serial_type))))
			}
		}()))
		pMem.enc = pKeyInfo.enc
		pMem.db = pKeyInfo.db
		pMem.szMalloc = int32(0)
		pMem.z = (*int8)(nil)
		sqlite3VdbeSerialGet(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(d))), serial_type, pMem)
		d += sqlite3VdbeSerialTypeLen(serial_type)
		*(*uintptr)(unsafe.Pointer(&pMem)) += 56
		if int32(func() (_cgo_ret uint16) {
			_cgo_addr := &u
			*_cgo_addr++
			return *_cgo_addr
		}()) >= int32(p.nField) {
			break
		}
	}
	if d > uint32(nKey) && int32(u) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeMemSetNull((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem)) - uintptr(1)*56)))
	}
	func() int {
		_ = 0
		return 0
	}()
	p.nField = u
}
func vdbeCompareMemString(pMem1 *struct_sqlite3_value, pMem2 *struct_sqlite3_value, pColl *struct_CollSeq, prcErr *uint8) int32 {
	if int32(pMem1.enc) == int32(pColl.enc) {
		return pColl.xCmp(pColl.pUser, pMem1.n, unsafe.Pointer(pMem1.z), pMem2.n, unsafe.Pointer(pMem2.z))
	} else {
		var rc int32
		var v1 unsafe.Pointer
		var v2 unsafe.Pointer
		var c1 struct_sqlite3_value
		var c2 struct_sqlite3_value
		sqlite3VdbeMemInit(&c1, pMem1.db, uint16(1))
		sqlite3VdbeMemInit(&c2, pMem1.db, uint16(1))
		sqlite3VdbeMemShallowCopy(&c1, pMem1, 4096)
		sqlite3VdbeMemShallowCopy(&c2, pMem2, 4096)
		v1 = sqlite3ValueText((*struct_sqlite3_value)(unsafe.Pointer(&c1)), pColl.enc)
		v2 = sqlite3ValueText((*struct_sqlite3_value)(unsafe.Pointer(&c2)), pColl.enc)
		if uintptr(unsafe.Pointer(v1)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(v2)) == uintptr(unsafe.Pointer(nil)) {
			if prcErr != nil {
				*prcErr = uint8(7)
			}
			rc = int32(0)
		} else {
			rc = pColl.xCmp(pColl.pUser, c1.n, v1, c2.n, v2)
		}
		sqlite3VdbeMemRelease(&c1)
		sqlite3VdbeMemRelease(&c2)
		return rc
	}
}
func isAllZero(z *int8, n int32) int32 {
	var i int32
	for i = int32(0); i < n; i++ {
		if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))) != 0 {
			return int32(0)
		}
	}
	return int32(1)
}
func sqlite3BlobCompare(pB1 *struct_sqlite3_value, pB2 *struct_sqlite3_value) int32 {
	var c int32
	var n1 int32 = pB1.n
	var n2 int32 = pB2.n
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if (int32(pB1.flags)|int32(pB2.flags))&16384 != 0 {
		if int32(pB1.flags)&int32(pB2.flags)&16384 != 0 {
			return *(*int32)(unsafe.Pointer(&pB1.u)) - *(*int32)(unsafe.Pointer(&pB2.u))
		} else if int32(pB1.flags)&16384 != 0 {
			if !(isAllZero(pB2.z, pB2.n) != 0) {
				return int32(-1)
			}
			return *(*int32)(unsafe.Pointer(&pB1.u)) - n2
		} else {
			if !(isAllZero(pB1.z, pB1.n) != 0) {
				return int32(1)
			}
			return n1 - *(*int32)(unsafe.Pointer(&pB2.u))
		}
	}
	c = memcmp(unsafe.Pointer(pB1.z), unsafe.Pointer(pB2.z), uint(func() int32 {
		if n1 > n2 {
			return n2
		} else {
			return n1
		}
	}()))
	if c != 0 {
		return c
	}
	return n1 - n2
}
func sqlite3IntFloatCompare(i int64, r float64) int32 {
	if false {
		var x float64 = float64(i)
		if x < float64(r) {
			return int32(-1)
		}
		if x > float64(r) {
			return int32(1)
		}
		return int32(0)
	} else {
		var y int64
		var s float64
		if r < -9.2233720368547758e+18 {
			return int32(1)
		}
		if r >= 9.2233720368547758e+18 {
			return int32(-1)
		}
		y = int64(r)
		if i < y {
			return int32(-1)
		}
		if i > y {
			return int32(1)
		}
		s = float64(i)
		if s < r {
			return int32(-1)
		}
		if s > r {
			return int32(1)
		}
		return int32(0)
	}
}
func sqlite3MemCompare(pMem1 *struct_sqlite3_value, pMem2 *struct_sqlite3_value, pColl *struct_CollSeq) int32 {
	var f1 int32
	var f2 int32
	var combined_flags int32
	f1 = int32(pMem1.flags)
	f2 = int32(pMem2.flags)
	combined_flags = f1 | f2
	func() int {
		_ = 0
		return 0
	}()
	if combined_flags&1 != 0 {
		return f2&1 - f1&1
	}
	if combined_flags&(4|8|32) != 0 {
		if f1&f2&(4|32) != 0 {
			if *(*int64)(unsafe.Pointer(&pMem1.u)) < *(*int64)(unsafe.Pointer(&pMem2.u)) {
				return int32(-1)
			}
			if *(*int64)(unsafe.Pointer(&pMem1.u)) > *(*int64)(unsafe.Pointer(&pMem2.u)) {
				return int32(1)
			}
			return int32(0)
		}
		if f1&f2&8 != 0 {
			if pMem1.u.r < pMem2.u.r {
				return int32(-1)
			}
			if pMem1.u.r > pMem2.u.r {
				return int32(1)
			}
			return int32(0)
		}
		if f1&(4|32) != 0 {
			if f2&8 != 0 {
				return sqlite3IntFloatCompare(*(*int64)(unsafe.Pointer(&pMem1.u)), pMem2.u.r)
			} else if f2&(4|32) != 0 {
				if *(*int64)(unsafe.Pointer(&pMem1.u)) < *(*int64)(unsafe.Pointer(&pMem2.u)) {
					return int32(-1)
				}
				if *(*int64)(unsafe.Pointer(&pMem1.u)) > *(*int64)(unsafe.Pointer(&pMem2.u)) {
					return int32(1)
				}
				return int32(0)
			} else {
				return int32(-1)
			}
		}
		if f1&8 != 0 {
			if f2&(4|32) != 0 {
				return -sqlite3IntFloatCompare(*(*int64)(unsafe.Pointer(&pMem2.u)), pMem1.u.r)
			} else {
				return int32(-1)
			}
		}
		return int32(1)
	}
	if combined_flags&2 != 0 {
		if f1&2 == 0 {
			return int32(1)
		}
		if f2&2 == 0 {
			return int32(-1)
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pColl != nil {
			return vdbeCompareMemString(pMem1, pMem2, pColl, nil)
		}
	}
	return sqlite3BlobCompare(pMem1, pMem2)
}
func vdbeRecordDecodeInt(serial_type uint32, aKey *uint8) int64 {
	var y uint32
	func() int {
		_ = 0
		return 0
	}()
	switch serial_type {
	case uint32(0):
		fallthrough
	case uint32(1):
		return int64(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0)))))
	case uint32(2):
		return int64(256*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1)))))
	case uint32(3):
		return int64(65536*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(2)))))
	case uint32(4):
		{
			y = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(3))))
			return int64(*(*int32)(unsafe.Pointer(&y)))
		}
	case uint32(5):
		{
			return int64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(0))))<<24|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(1))))<<16)|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(2))))<<8)|uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(3))))) + int64(1)<<32*int64(256*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0)))))|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1)))))
		}
	case uint32(6):
		{
			var x uint64 = uint64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(3)))))
			x = x<<32 | uint64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(0))))<<24|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(1))))<<16)|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(2))))<<8)|uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(3)))))
			return int64(*(*int64)(unsafe.Pointer(&x)))
		}
	}
	return int64(serial_type - uint32(8))
}
func sqlite3VdbeRecordCompareWithSkip(nKey1 int32, pKey1 unsafe.Pointer, pPKey2 *struct_UnpackedRecord, bSkip int32) int32 {
	var d1 uint32
	var i int32
	var szHdr1 uint32
	var idx1 uint32
	var rc int32 = 0
	var pRhs *struct_sqlite3_value = pPKey2.aMem
	var pKeyInfo *struct_KeyInfo
	var aKey1 *uint8 = (*uint8)(pKey1)
	var mem1 struct_sqlite3_value
	if bSkip != 0 {
		var s1 uint32
		idx1 = uint32(1 + int32(uint8(func() int32 {
			if int32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(1)))) < int32(uint8(128)) {
				return int32(func() int {
					s1 = uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(1))))
					return 1
				}())
			} else {
				return int32(sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(1))), (*uint32)(unsafe.Pointer(&s1))))
			}
		}())))
		szHdr1 = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(0))))
		d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1)
		i = int32(1)
		*(*uintptr)(unsafe.Pointer(&pRhs)) += 56
	} else {
		idx1 = uint32(uint8(func() int32 {
			if int32(*aKey1) < int32(uint8(128)) {
				return int32(func() int {
					szHdr1 = uint32(*aKey1)
					return 1
				}())
			} else {
				return int32(sqlite3GetVarint32(aKey1, (*uint32)(unsafe.Pointer(&szHdr1))))
			}
		}()))
		d1 = szHdr1
		i = int32(0)
	}
	if d1 > uint32(nKey1) {
		pPKey2.errCode = uint8(sqlite3CorruptError(84312))
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for {
		var serial_type uint32
		if int32(pRhs.flags)&(4|32) != 0 {
			serial_type = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))))
			if serial_type >= uint32(10) {
				rc = int32(1)
			} else if serial_type == uint32(0) {
				rc = int32(-1)
			} else if serial_type == uint32(7) {
				sqlite3VdbeSerialGet(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1))), serial_type, &mem1)
				rc = -sqlite3IntFloatCompare(*(*int64)(unsafe.Pointer(&pRhs.u)), mem1.u.r)
			} else {
				var lhs int64 = vdbeRecordDecodeInt(serial_type, &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1))))
				var rhs int64 = *(*int64)(unsafe.Pointer(&pRhs.u))
				if lhs < rhs {
					rc = int32(-1)
				} else if lhs > rhs {
					rc = int32(1)
				}
			}
		} else if int32(pRhs.flags)&8 != 0 {
			serial_type = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))))
			if serial_type >= uint32(10) {
				rc = int32(1)
			} else if serial_type == uint32(0) {
				rc = int32(-1)
			} else {
				sqlite3VdbeSerialGet(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1))), serial_type, &mem1)
				if serial_type == uint32(7) {
					if mem1.u.r < pRhs.u.r {
						rc = int32(-1)
					} else if mem1.u.r > pRhs.u.r {
						rc = int32(1)
					}
				} else {
					rc = sqlite3IntFloatCompare(*(*int64)(unsafe.Pointer(&mem1.u)), pRhs.u.r)
				}
			}
		} else if int32(pRhs.flags)&2 != 0 {
			serial_type = uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))))
			if serial_type >= uint32(128) {
				sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))), (*uint32)(unsafe.Pointer(&serial_type)))
			}
			if serial_type < uint32(12) {
				rc = int32(-1)
			} else if !(serial_type&uint32(1) != 0) {
				rc = int32(1)
			} else {
				mem1.n = int32((serial_type - uint32(12)) / uint32(2))
				if d1+uint32(mem1.n) > uint32(nKey1) || int32(func() (_cgo_ret *struct_KeyInfo) {
					_cgo_addr := &pKeyInfo
					*_cgo_addr = pPKey2.pKeyInfo
					return *_cgo_addr
				}().nAllField) <= i {
					pPKey2.errCode = uint8(sqlite3CorruptError(84389))
					return int32(0)
				} else if *(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(i)*8)) != nil {
					mem1.enc = pKeyInfo.enc
					mem1.db = pKeyInfo.db
					mem1.flags = uint16(2)
					mem1.z = (*int8)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1)))))
					rc = vdbeCompareMemString(&mem1, pRhs, *(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(i)*8)), &pPKey2.errCode)
				} else {
					var nCmp int32 = func() int32 {
						if mem1.n < pRhs.n {
							return mem1.n
						} else {
							return pRhs.n
						}
					}()
					rc = memcmp(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1)))), unsafe.Pointer(pRhs.z), uint(nCmp))
					if rc == 0 {
						rc = mem1.n - pRhs.n
					}
				}
			}
		} else if int32(pRhs.flags)&16 != 0 {
			func() int {
				_ = 0
				return 0
			}()
			serial_type = uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))))
			if serial_type >= uint32(128) {
				sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))), (*uint32)(unsafe.Pointer(&serial_type)))
			}
			if serial_type < uint32(12) || serial_type&uint32(1) != 0 {
				rc = int32(-1)
			} else {
				var nStr int32 = int32((serial_type - uint32(12)) / uint32(2))
				if d1+uint32(nStr) > uint32(nKey1) {
					pPKey2.errCode = uint8(sqlite3CorruptError(84419))
					return int32(0)
				} else if int32(pRhs.flags)&16384 != 0 {
					if !(isAllZero((*int8)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1))))), nStr) != 0) {
						rc = int32(1)
					} else {
						rc = nStr - *(*int32)(unsafe.Pointer(&pRhs.u))
					}
				} else {
					var nCmp int32 = func() int32 {
						if nStr < pRhs.n {
							return nStr
						} else {
							return pRhs.n
						}
					}()
					rc = memcmp(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(d1)))), unsafe.Pointer(pRhs.z), uint(nCmp))
					if rc == 0 {
						rc = nStr - pRhs.n
					}
				}
			}
		} else {
			serial_type = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(idx1))))
			rc = func() int32 {
				if serial_type != uint32(0) {
					return 1
				} else {
					return 0
				}
			}()
		}
		if rc != 0 {
			var sortFlags int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPKey2.pKeyInfo.aSortFlags)) + uintptr(i))))
			if sortFlags != 0 {
				if sortFlags&2 == 0 || sortFlags&1 != func() int32 {
					if serial_type == uint32(0) || int32(pRhs.flags)&1 != 0 {
						return 1
					} else {
						return 0
					}
				}() {
					rc = -rc
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			return rc
		}
		i++
		if i == int32(pPKey2.nField) {
			break
		}
		*(*uintptr)(unsafe.Pointer(&pRhs)) += 56
		d1 += sqlite3VdbeSerialTypeLen(serial_type)
		idx1 += uint32(sqlite3VarintLen(uint64(serial_type)))
		if !(idx1 < uint32(szHdr1) && d1 <= uint32(nKey1)) {
			break
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPKey2.eqSeen = uint8(1)
	return int32(pPKey2.default_rc)
}
func sqlite3VdbeRecordCompare(nKey1 int32, pKey1 unsafe.Pointer, pPKey2 *struct_UnpackedRecord) int32 {
	return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0)
}
func vdbeRecordCompareInt(nKey1 int32, pKey1 unsafe.Pointer, pPKey2 *struct_UnpackedRecord) int32 {
	var aKey *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pKey1))) + uintptr(int32(*(*uint8)(pKey1))&63)))
	var serial_type int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(pKey1))) + uintptr(1))))
	var res int32
	var y uint32
	var x uint64
	var v int64
	var lhs int64
	func() int {
		_ = 0
		return 0
	}()
	switch serial_type {
	case 1:
		{
			lhs = int64(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0)))))
			break
		}
	case 2:
		{
			lhs = int64(256*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1)))))
			break
		}
	case 3:
		{
			lhs = int64(65536*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))) | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1))))<<8 | int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(2)))))
			break
		}
	case 4:
		{
			y = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(3))))
			lhs = int64(*(*int32)(unsafe.Pointer(&y)))
			break
		}
	case 5:
		{
			lhs = int64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(0))))<<24|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(1))))<<16)|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(2))))<<8)|uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(2))))) + uintptr(3))))) + int64(1)<<32*int64(256*int32(int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0)))))|int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1)))))
			break
		}
	case 6:
		{
			x = uint64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(0))))<<24 | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(1))))<<16) | uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(2))))<<8) | uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey)) + uintptr(3)))))
			x = x<<32 | uint64(uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(0))))<<24|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(1))))<<16)|uint32(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(2))))<<8)|uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey))+uintptr(4))))) + uintptr(3)))))
			lhs = *(*int64)(unsafe.Pointer(&x))
			break
		}
	case 8:
		lhs = int64(0)
		break
	case 9:
		lhs = int64(1)
		break
	case 0:
		fallthrough
	case 7:
		return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2)
	default:
		return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2)
	}
	v = *(*int64)(unsafe.Pointer(&(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pPKey2.aMem)) + uintptr(0)*56))).u))
	if v > lhs {
		res = int32(pPKey2.r1)
	} else if v < lhs {
		res = int32(pPKey2.r2)
	} else if int32(pPKey2.nField) > 1 {
		res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1)
	} else {
		res = int32(pPKey2.default_rc)
		pPKey2.eqSeen = uint8(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	return res
}
func vdbeRecordCompareString(nKey1 int32, pKey1 unsafe.Pointer, pPKey2 *struct_UnpackedRecord) int32 {
	var aKey1 *uint8 = (*uint8)(pKey1)
	var serial_type int32
	var res int32
	func() int {
		_ = 0
		return 0
	}()
	serial_type = int32(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(1)))))
	if serial_type >= 128 {
		sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(1))), (*uint32)(unsafe.Pointer(&serial_type)))
	}
	if serial_type < 12 {
		res = int32(pPKey2.r1)
	} else if !(serial_type&1 != 0) {
		res = int32(pPKey2.r2)
	} else {
		var nCmp int32
		var nStr int32
		var szHdr int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(0))))
		nStr = (serial_type - 12) / 2
		if szHdr+nStr > nKey1 {
			pPKey2.errCode = uint8(sqlite3CorruptError(84614))
			return int32(0)
		}
		nCmp = func() int32 {
			if (*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pPKey2.aMem)) + uintptr(0)*56))).n < nStr {
				return (*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pPKey2.aMem)) + uintptr(0)*56))).n
			} else {
				return nStr
			}
		}()
		res = memcmp(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aKey1)) + uintptr(szHdr)))), unsafe.Pointer((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pPKey2.aMem)) + uintptr(0)*56))).z), uint(nCmp))
		if res > 0 {
			res = int32(pPKey2.r2)
		} else if res < 0 {
			res = int32(pPKey2.r1)
		} else {
			res = nStr - (*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pPKey2.aMem)) + uintptr(0)*56))).n
			if res == 0 {
				if int32(pPKey2.nField) > 1 {
					res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1)
				} else {
					res = int32(pPKey2.default_rc)
					pPKey2.eqSeen = uint8(1)
				}
			} else if res > 0 {
				res = int32(pPKey2.r2)
			} else {
				res = int32(pPKey2.r1)
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	return res
}
func sqlite3VdbeFindCompare(p *struct_UnpackedRecord) func(int32, unsafe.Pointer, *struct_UnpackedRecord) int32 {
	if int32(p.pKeyInfo.nAllField) <= 13 {
		var flags int32 = int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMem)) + uintptr(0)*56))).flags)
		if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.pKeyInfo.aSortFlags)) + uintptr(0))) != 0 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.pKeyInfo.aSortFlags)) + uintptr(0))))&2 != 0 {
				return sqlite3VdbeRecordCompare
			}
			p.r1 = int8(1)
			p.r2 = int8(-1)
		} else {
			p.r1 = int8(-1)
			p.r2 = int8(1)
		}
		if flags&4 != 0 {
			return vdbeRecordCompareInt
		}
		if flags&(8|32|1|16) == 0 && uintptr(unsafe.Pointer(*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&p.pKeyInfo.aColl)))) + uintptr(0)*8)))) == uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			return vdbeRecordCompareString
		}
	}
	return sqlite3VdbeRecordCompare
}
func sqlite3VdbeIdxRowid(db *struct_sqlite3, pCur *struct_BtCursor, rowid *int64) int32 {
	var nCellKey int64 = int64(0)
	var rc int32
	var szHdr uint32
	var typeRowid uint32
	var lenRowid uint32
	var m struct_sqlite3_value
	var v struct_sqlite3_value
	func() int {
		_ = 0
		return 0
	}()
	nCellKey = int64(sqlite3BtreePayloadSize(pCur))
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemInit(&m, db, uint16(0))
	rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, uint32(nCellKey), &m)
	if rc != 0 {
		return rc
	}
	szHdr = uint32(*(*uint8)(unsafe.Pointer(m.z)))
	if szHdr >= uint32(128) {
		sqlite3GetVarint32((*uint8)(unsafe.Pointer(m.z)), (*uint32)(unsafe.Pointer(&szHdr)))
	}
	func() int {
		_ = 0
		return 0
	}()
	if szHdr < uint32(3) || szHdr > uint32(m.n) {
		goto idx_rowid_corruption
	}
	typeRowid = uint32(*(*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.z)) + uintptr(szHdr-uint32(1)))))))
	if typeRowid >= uint32(128) {
		sqlite3GetVarint32((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.z)) + uintptr(szHdr-uint32(1)))))), (*uint32)(unsafe.Pointer(&typeRowid)))
	}
	if typeRowid < uint32(1) || typeRowid > uint32(9) || typeRowid == uint32(7) {
		goto idx_rowid_corruption
	}
	lenRowid = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3SmallTypeSizes)))) + uintptr(typeRowid))))
	if uint32(m.n) < szHdr+lenRowid {
		goto idx_rowid_corruption
	}
	sqlite3VdbeSerialGet((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(m.z)) + uintptr(uint32(m.n)-lenRowid))))), typeRowid, &v)
	*rowid = *(*int64)(unsafe.Pointer(&v.u))
	sqlite3VdbeMemRelease(&m)
	return int32(0)
idx_rowid_corruption:
	sqlite3VdbeMemRelease(&m)
	return sqlite3CorruptError(84769)
}
func sqlite3VdbeIdxKeyCompare(db *struct_sqlite3, pC *struct_VdbeCursor, pUnpacked *struct_UnpackedRecord, res *int32) int32 {
	var nCellKey int64 = int64(0)
	var rc int32
	var pCur *struct_BtCursor
	var m struct_sqlite3_value
	func() int {
		_ = 0
		return 0
	}()
	pCur = pC.uc.pCursor
	func() int {
		_ = 0
		return 0
	}()
	nCellKey = int64(sqlite3BtreePayloadSize(pCur))
	if nCellKey <= int64(0) || nCellKey > int64(2147483647) {
		*res = int32(0)
		return sqlite3CorruptError(84802)
	}
	sqlite3VdbeMemInit(&m, db, uint16(0))
	rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, uint32(nCellKey), &m)
	if rc != 0 {
		return rc
	}
	*res = sqlite3VdbeRecordCompareWithSkip(m.n, unsafe.Pointer(m.z), pUnpacked, 0)
	sqlite3VdbeMemRelease(&m)
	return int32(0)
}
func sqlite3VdbeSetChanges(db *struct_sqlite3, nChange int64) {
	func() int {
		_ = 0
		return 0
	}()
	db.nChange = nChange
	db.nTotalChange += nChange
}
func sqlite3VdbeCountChanges(v *struct_Vdbe) {
	{
		_autoGo_15 := &v.Xbf_0
		*_autoGo_15 = *_autoGo_15&^16 | uint32(1)&1<<4
	}
}
func sqlite3ExpirePreparedStatements(db *struct_sqlite3, iCode int32) {
	var p *struct_Vdbe
	for p = db.pVdbe; p != nil; p = p.pNext {
		{
			_autoGo_16 := &p.Xbf_0
			*_autoGo_16 = *_autoGo_16&^3 | uint32(iCode+1)&3
		}
	}
}
func sqlite3VdbeDb(v *struct_Vdbe) *struct_sqlite3 {
	return v.db
}
func sqlite3VdbePrepareFlags(v *struct_Vdbe) uint8 {
	return v.prepFlags
}
func sqlite3VdbeGetBoundValue(v *struct_Vdbe, iVar int32, aff uint8) *struct_sqlite3_value {
	func() int {
		_ = 0
		return 0
	}()
	if v != nil {
		var pMem *struct_sqlite3_value = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(v.aVar)) + uintptr(iVar-1)*56))
		func() int {
			_ = 0
			return 0
		}()
		if 0 == int32(pMem.flags)&1 {
			var pRet *struct_sqlite3_value = sqlite3ValueNew(v.db)
			if pRet != nil {
				sqlite3VdbeMemCopy((*struct_sqlite3_value)(unsafe.Pointer(pRet)), pMem)
				sqlite3ValueApplyAffinity(pRet, aff, uint8(1))
			}
			return pRet
		}
	}
	return (*struct_sqlite3_value)(nil)
}
func sqlite3VdbeSetVarmask(v *struct_Vdbe, iVar int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if iVar >= 32 {
		v.expmask |= uint32(2147483648)
	} else {
		v.expmask |= uint32(1) << (iVar - 1)
	}
}
func sqlite3NotPureFunc(pCtx *struct_sqlite3_context) int32 {
	var pOp *struct_VdbeOp
	pOp = (*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pCtx.pVdbe.aOp)) + uintptr(pCtx.iOp)*24))
	if int32(pOp.opcode) == 65 {
		var zContext *int8
		var zMsg *int8
		if int32(pOp.p5)&4 != 0 {
			zContext = (*int8)(unsafe.Pointer(&[19]int8{'a', ' ', 'C', 'H', 'E', 'C', 'K', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', '\x00'}))
		} else if int32(pOp.p5)&8 != 0 {
			zContext = (*int8)(unsafe.Pointer(&[19]int8{'a', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'}))
		} else {
			zContext = (*int8)(unsafe.Pointer(&[9]int8{'a', 'n', ' ', 'i', 'n', 'd', 'e', 'x', '\x00'}))
		}
		zMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[36]int8{'n', 'o', 'n', '-', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's', 't', 'i', 'c', ' ', 'u', 's', 'e', ' ', 'o', 'f', ' ', '%', 's', '(', ')', ' ', 'i', 'n', ' ', '%', 's', '\x00'})), pCtx.pFunc.zName, zContext)
		sqlite3_result_error(pCtx, zMsg, -1)
		sqlite3_free(unsafe.Pointer(zMsg))
		return int32(0)
	}
	return int32(1)
}
func sqlite3VtabImportErrmsg(p *struct_Vdbe, pVtab *struct_sqlite3_vtab) {
	if pVtab.zErrMsg != nil {
		var db *struct_sqlite3 = p.db
		sqlite3DbFree(db, unsafe.Pointer(p.zErrMsg))
		p.zErrMsg = sqlite3DbStrDup(db, pVtab.zErrMsg)
		sqlite3_free(unsafe.Pointer(pVtab.zErrMsg))
		pVtab.zErrMsg = (*int8)(nil)
	}
}
func sqlite3_expired(pStmt *struct_sqlite3_stmt) int32 {
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	return func() int32 {
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || int32(p.Xbf_0&3) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func vdbeSafety(p *struct_Vdbe) int32 {
	if uintptr(unsafe.Pointer(p.db)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_log(21, (*int8)(unsafe.Pointer(&[45]int8{'A', 'P', 'I', ' ', 'c', 'a', 'l', 'l', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 'f', 'i', 'n', 'a', 'l', 'i', 'z', 'e', 'd', ' ', 'p', 'r', 'e', 'p', 'a', 'r', 'e', 'd', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', '\x00'})))
		return int32(1)
	} else {
		return int32(0)
	}
}
func vdbeSafetyNotNull(p *struct_Vdbe) int32 {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_log(21, (*int8)(unsafe.Pointer(&[40]int8{'A', 'P', 'I', ' ', 'c', 'a', 'l', 'l', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 'N', 'U', 'L', 'L', ' ', 'p', 'r', 'e', 'p', 'a', 'r', 'e', 'd', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', '\x00'})))
		return int32(1)
	} else {
		return vdbeSafety(p)
	}
}
func invokeProfileCallback(db *struct_sqlite3, p *struct_Vdbe) {
	var iNow int64
	var iElapse int64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3OsCurrentTimeInt64(db.pVfs, &iNow)
	iElapse = (iNow - p.startTime) * int64(1000000)
	if db.xProfile != nil {
		db.xProfile(db.pProfileArg, p.zSql, uint64(iElapse))
	}
	if int32(db.mTrace)&2 != 0 {
		(*(*func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(unsafe.Pointer(&db.trace)))(uint32(2), db.pTraceArg, unsafe.Pointer(p), unsafe.Pointer(&iElapse))
	}
	p.startTime = int64(0)
}
func sqlite3_finalize(pStmt *struct_sqlite3_stmt) int32 {
	var rc int32
	if uintptr(unsafe.Pointer(pStmt)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(0)
	} else {
		var v *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
		var db *struct_sqlite3 = v.db
		if vdbeSafety(v) != 0 {
			return sqlite3MisuseError(85164)
		}
		sqlite3_mutex_enter(db.mutex)
		if v.startTime > int64(0) {
			invokeProfileCallback(db, v)
		}
		rc = sqlite3VdbeFinalize(v)
		rc = sqlite3ApiExit(db, rc)
		sqlite3LeaveMutexAndCloseZombie(db)
	}
	return rc
}
func sqlite3_reset(pStmt *struct_sqlite3_stmt) int32 {
	var rc int32
	if uintptr(unsafe.Pointer(pStmt)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(0)
	} else {
		var v *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
		var db *struct_sqlite3 = v.db
		sqlite3_mutex_enter(db.mutex)
		if v.startTime > int64(0) {
			invokeProfileCallback(db, v)
		}
		rc = sqlite3VdbeReset(v)
		sqlite3VdbeRewind(v)
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3ApiExit(db, rc)
		sqlite3_mutex_leave(db.mutex)
	}
	return rc
}
func sqlite3_clear_bindings(pStmt *struct_sqlite3_stmt) int32 {
	var i int32
	var rc int32 = 0
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	var mutex *struct_sqlite3_mutex = (*struct_Vdbe)(unsafe.Pointer(pStmt)).db.mutex
	sqlite3_mutex_enter(mutex)
	for i = int32(0); i < int32(p.nVar); i++ {
		sqlite3VdbeMemRelease(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i)*56)))
		(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i)*56))).flags = uint16(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.expmask != 0 {
		{
			_autoGo_17 := &p.Xbf_0
			*_autoGo_17 = *_autoGo_17&^3 | uint32(1)&3
		}
	}
	sqlite3_mutex_leave(mutex)
	return rc
}
func sqlite3_value_blob(pVal *struct_sqlite3_value) unsafe.Pointer {
	var p *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(pVal))
	if int32(p.flags)&(16|2) != 0 {
		if func() int32 {
			if int32(p.flags)&16384 != 0 {
				return sqlite3VdbeMemExpandBlob(p)
			} else {
				return 0
			}
		}() != 0 {
			func() int {
				_ = 0
				return 0
			}()
			return unsafe.Pointer(nil)
		}
		p.flags |= uint16(16)
		return unsafe.Pointer(func() *int8 {
			if p.n != 0 {
				return p.z
			} else {
				return nil
			}
		}())
	} else {
		return unsafe.Pointer(sqlite3_value_text(pVal))
	}
}
func sqlite3_value_bytes(pVal *struct_sqlite3_value) int32 {
	return sqlite3ValueBytes(pVal, uint8(1))
}
func sqlite3_value_bytes16(pVal *struct_sqlite3_value) int32 {
	return sqlite3ValueBytes(pVal, uint8(2))
}
func sqlite3_value_double(pVal *struct_sqlite3_value) float64 {
	return sqlite3VdbeRealValue((*struct_sqlite3_value)(unsafe.Pointer(pVal)))
}
func sqlite3_value_int(pVal *struct_sqlite3_value) int32 {
	return int32(sqlite3VdbeIntValue((*struct_sqlite3_value)(unsafe.Pointer(pVal))))
}
func sqlite3_value_int64(pVal *struct_sqlite3_value) int64 {
	return sqlite3VdbeIntValue((*struct_sqlite3_value)(unsafe.Pointer(pVal)))
}
func sqlite3_value_subtype(pVal *struct_sqlite3_value) uint32 {
	var pMem *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(pVal))
	return uint32(func() int32 {
		if int32(pMem.flags)&32768 != 0 {
			return int32(pMem.eSubtype)
		} else {
			return 0
		}
	}())
}
func sqlite3_value_pointer(pVal *struct_sqlite3_value, zPType *int8) unsafe.Pointer {
	var p *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(pVal))
	if int32(p.flags)&(49599|512|32768) == 1|512|32768 && uintptr(unsafe.Pointer(zPType)) != uintptr(unsafe.Pointer(nil)) && int32(p.eSubtype) == 'p' && strcmp(*(**int8)(unsafe.Pointer(&p.u)), zPType) == 0 {
		return unsafe.Pointer(p.z)
	} else {
		return unsafe.Pointer(nil)
	}
}
func sqlite3_value_text(pVal *struct_sqlite3_value) *uint8 {
	return (*uint8)(sqlite3ValueText(pVal, uint8(1)))
}
func sqlite3_value_text16(pVal *struct_sqlite3_value) unsafe.Pointer {
	return sqlite3ValueText(pVal, uint8(2))
}
func sqlite3_value_text16be(pVal *struct_sqlite3_value) unsafe.Pointer {
	return sqlite3ValueText(pVal, uint8(3))
}
func sqlite3_value_text16le(pVal *struct_sqlite3_value) unsafe.Pointer {
	return sqlite3ValueText(pVal, uint8(2))
}
func sqlite3_value_type(pVal *struct_sqlite3_value) int32 {
	var aType [64]uint8 = [64]uint8{uint8(4), uint8(5), uint8(3), uint8(5), uint8(1), uint8(5), uint8(1), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(1), uint8(5), uint8(1), uint8(5), uint8(4), uint8(5), uint8(3), uint8(5), uint8(1), uint8(5), uint8(1), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(1), uint8(5), uint8(1), uint8(5), uint8(2), uint8(5), uint8(3), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(4), uint8(5), uint8(3), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5), uint8(2), uint8(5)}
	return int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aType)))) + uintptr(int32(pVal.flags)&63))))
}
func sqlite3_value_nochange(pVal *struct_sqlite3_value) int32 {
	return func() int32 {
		if int32(pVal.flags)&(1|16384) == 1|16384 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3_value_frombind(pVal *struct_sqlite3_value) int32 {
	return func() int32 {
		if int32(pVal.flags)&64 != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3_value_dup(pOrig *struct_sqlite3_value) *struct_sqlite3_value {
	var pNew *struct_sqlite3_value
	if uintptr(unsafe.Pointer(pOrig)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_sqlite3_value)(nil)
	}
	pNew = (*struct_sqlite3_value)(sqlite3_malloc(int32(56)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_sqlite3_value)(nil)
	}
	__builtin___memset_chk(unsafe.Pointer(pNew), 0, 56, __builtin_object_size(unsafe.Pointer(pNew), 0))
	__builtin___memcpy_chk(unsafe.Pointer(pNew), unsafe.Pointer(pOrig), 24, __builtin_object_size(unsafe.Pointer(pNew), 0))
	pNew.flags &= uint16(^1024)
	pNew.db = (*struct_sqlite3)(nil)
	if int32(pNew.flags)&(2|16) != 0 {
		pNew.flags &= uint16(^(2048 | 1024))
		pNew.flags |= uint16(4096)
		if sqlite3VdbeMemMakeWriteable(pNew) != 0 {
			sqlite3ValueFree(pNew)
			pNew = (*struct_sqlite3_value)(nil)
		}
	}
	return pNew
}
func sqlite3_value_free(pOld *struct_sqlite3_value) {
	sqlite3ValueFree(pOld)
}
func setResultStrOrError(pCtx *struct_sqlite3_context, z *int8, n int32, enc uint8, xDel func(unsafe.Pointer)) {
	var rc int32 = sqlite3VdbeMemSetStr(pCtx.pOut, z, int64(n), enc, xDel)
	if rc != 0 {
		if rc == 18 {
			sqlite3_result_error_toobig(pCtx)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_result_error_nomem(pCtx)
		}
	}
}
func invokeValueDestructor(p unsafe.Pointer, xDel func(unsafe.Pointer), pCtx *struct_sqlite3_context) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(xDel)) == uintptr(unsafe.Pointer(nil)) {
	} else if uintptr(unsafe.Pointer(xDel)) == uintptr(unsafe.Pointer((func(unsafe.Pointer))(-1))) {
	} else {
		xDel(unsafe.Pointer(p))
	}
	sqlite3_result_error_toobig(pCtx)
	return int32(18)
}
func sqlite3_result_blob(pCtx *struct_sqlite3_context, z unsafe.Pointer, n int32, xDel func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	setResultStrOrError(pCtx, (*int8)(z), n, uint8(0), xDel)
}
func sqlite3_result_blob64(pCtx *struct_sqlite3_context, z unsafe.Pointer, n uint64, xDel func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if n > uint64(2147483647) {
		func() int {
			_ = invokeValueDestructor(z, xDel, pCtx)
			return 0
		}()
	} else {
		setResultStrOrError(pCtx, (*int8)(z), int32(n), uint8(0), xDel)
	}
}
func sqlite3_result_double(pCtx *struct_sqlite3_context, rVal float64) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemSetDouble(pCtx.pOut, rVal)
}
func sqlite3_result_error(pCtx *struct_sqlite3_context, z *int8, n int32) {
	func() int {
		_ = 0
		return 0
	}()
	pCtx.isError = int32(1)
	sqlite3VdbeMemSetStr(pCtx.pOut, z, int64(n), uint8(1), (func(unsafe.Pointer))(-1))
}
func sqlite3_result_error16(pCtx *struct_sqlite3_context, z unsafe.Pointer, n int32) {
	func() int {
		_ = 0
		return 0
	}()
	pCtx.isError = int32(1)
	sqlite3VdbeMemSetStr(pCtx.pOut, (*int8)(z), int64(n), uint8(2), (func(unsafe.Pointer))(-1))
}
func sqlite3_result_int(pCtx *struct_sqlite3_context, iVal int32) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemSetInt64(pCtx.pOut, int64(iVal))
}
func sqlite3_result_int64(pCtx *struct_sqlite3_context, iVal int64) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemSetInt64(pCtx.pOut, iVal)
}
func sqlite3_result_null(pCtx *struct_sqlite3_context) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemSetNull(pCtx.pOut)
}
func sqlite3_result_pointer(pCtx *struct_sqlite3_context, pPtr unsafe.Pointer, zPType *int8, xDestructor func(unsafe.Pointer)) {
	var pOut *struct_sqlite3_value = pCtx.pOut
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemRelease(pOut)
	pOut.flags = uint16(1)
	sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor)
}
func sqlite3_result_subtype(pCtx *struct_sqlite3_context, eSubtype uint32) {
	var pOut *struct_sqlite3_value = pCtx.pOut
	func() int {
		_ = 0
		return 0
	}()
	pOut.eSubtype = uint8(eSubtype & uint32(255))
	pOut.flags |= uint16(32768)
}
func sqlite3_result_text(pCtx *struct_sqlite3_context, z *int8, n int32, xDel func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	setResultStrOrError(pCtx, z, n, uint8(1), xDel)
}
func sqlite3_result_text64(pCtx *struct_sqlite3_context, z *int8, n uint64, xDel func(unsafe.Pointer), enc uint8) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(enc) == 4 {
		enc = uint8(2)
	}
	if n > uint64(2147483647) {
		func() int {
			_ = invokeValueDestructor(unsafe.Pointer(z), xDel, pCtx)
			return 0
		}()
	} else {
		setResultStrOrError(pCtx, z, int32(n), enc, xDel)
	}
}
func sqlite3_result_text16(pCtx *struct_sqlite3_context, z unsafe.Pointer, n int32, xDel func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	setResultStrOrError(pCtx, (*int8)(z), n, uint8(2), xDel)
}
func sqlite3_result_text16be(pCtx *struct_sqlite3_context, z unsafe.Pointer, n int32, xDel func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	setResultStrOrError(pCtx, (*int8)(z), n, uint8(3), xDel)
}
func sqlite3_result_text16le(pCtx *struct_sqlite3_context, z unsafe.Pointer, n int32, xDel func(unsafe.Pointer)) {
	func() int {
		_ = 0
		return 0
	}()
	setResultStrOrError(pCtx, (*int8)(z), n, uint8(2), xDel)
}
func sqlite3_result_value(pCtx *struct_sqlite3_context, pValue *struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemCopy(pCtx.pOut, pValue)
}
func sqlite3_result_zeroblob(pCtx *struct_sqlite3_context, n int32) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemSetZeroBlob(pCtx.pOut, n)
}
func sqlite3_result_zeroblob64(pCtx *struct_sqlite3_context, n uint64) int32 {
	var pOut *struct_sqlite3_value = pCtx.pOut
	func() int {
		_ = 0
		return 0
	}()
	if n > uint64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pOut.db.aLimit)))) + uintptr(0)*4))) {
		return int32(18)
	}
	sqlite3VdbeMemSetZeroBlob(pCtx.pOut, int32(n))
	return int32(0)
}
func sqlite3_result_error_code(pCtx *struct_sqlite3_context, errCode int32) {
	pCtx.isError = func() int32 {
		if errCode != 0 {
			return errCode
		} else {
			return -1
		}
	}()
	if int32(pCtx.pOut.flags)&1 != 0 {
		sqlite3VdbeMemSetStr(pCtx.pOut, sqlite3ErrStr(errCode), int64(-1), uint8(1), (func(unsafe.Pointer))(0))
	}
}
func sqlite3_result_error_toobig(pCtx *struct_sqlite3_context) {
	func() int {
		_ = 0
		return 0
	}()
	pCtx.isError = int32(18)
	sqlite3VdbeMemSetStr(pCtx.pOut, (*int8)(unsafe.Pointer(&[23]int8{'s', 't', 'r', 'i', 'n', 'g', ' ', 'o', 'r', ' ', 'b', 'l', 'o', 'b', ' ', 't', 'o', 'o', ' ', 'b', 'i', 'g', '\x00'})), int64(-1), uint8(1), (func(unsafe.Pointer))(0))
}
func sqlite3_result_error_nomem(pCtx *struct_sqlite3_context) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeMemSetNull(pCtx.pOut)
	pCtx.isError = int32(7)
	sqlite3OomFault(pCtx.pOut.db)
}
func sqlite3ResultIntReal(pCtx *struct_sqlite3_context) {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pCtx.pOut.flags)&4 != 0 {
		pCtx.pOut.flags &= uint16(^4)
		pCtx.pOut.flags |= uint16(32)
	}
}
func doWalCallbacks(db *struct_sqlite3) int32 {
	var rc int32 = 0
	var i int32
	for i = int32(0); i < db.nDb; i++ {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if pBt != nil {
			var nEntry int32
			sqlite3BtreeEnter(pBt)
			nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt))
			sqlite3BtreeLeave(pBt)
			if nEntry > 0 && db.xWalCallback != nil && rc == 0 {
				rc = db.xWalCallback(db.pWalArg, db, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).zDbSName, nEntry)
			}
		}
	}
	return rc
}
func sqlite3Step(p *struct_Vdbe) int32 {
	var db *struct_sqlite3
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if p.iVdbeMagic != uint32(770837923) {
		sqlite3_reset((*struct_sqlite3_stmt)(unsafe.Pointer(p)))
	}
	db = p.db
	if db.mallocFailed != 0 {
		p.rc = int32(7)
		return int32(7)
	}
	if p.pc < 0 && int32(p.Xbf_0&3) != 0 {
		p.rc = int32(17)
		rc = int32(1)
		if int32(p.prepFlags)&128 != 0 {
			rc = sqlite3VdbeTransferError(p)
		}
		goto end_of_step
	}
	if p.pc < 0 {
		if db.nVdbeActive == 0 {
			__atomic_store_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0, 0)
		}
		func() int {
			_ = 0
			return 0
		}()
		if int32(db.mTrace)&(2|128) != 0 && !(db.init.busy != 0) && p.zSql != nil {
			sqlite3OsCurrentTimeInt64(db.pVfs, &p.startTime)
		} else {
			func() int {
				_ = 0
				return 0
			}()
		}
		db.nVdbeActive++
		if int32(p.Xbf_0>>7&1) == 0 {
			db.nVdbeWrite++
		}
		if p.Xbf_0>>8&1 != 0 {
			db.nVdbeRead++
		}
		p.pc = int32(0)
	}
	if p.Xbf_0>>2&3 != 0 {
		rc = sqlite3VdbeList(p)
	} else {
		db.nVdbeExec++
		rc = sqlite3VdbeExec(p)
		db.nVdbeExec--
	}
	if rc != 100 {
		if p.startTime > int64(0) {
			invokeProfileCallback(db, p)
		}
		if rc == 101 && int32(db.autoCommit) != 0 {
			func() int {
				_ = 0
				return 0
			}()
			p.rc = doWalCallbacks(db)
			if p.rc != 0 {
				rc = int32(1)
			}
		} else if rc != 101 && int32(p.prepFlags)&128 != 0 {
			rc = sqlite3VdbeTransferError(p)
		}
	}
	db.errCode = rc
	if 7 == sqlite3ApiExit(p.db, p.rc) {
		p.rc = int32(7)
		if int32(p.prepFlags)&128 != 0 {
			rc = p.rc
		}
	}
end_of_step:
	func() int {
		_ = 0
		return 0
	}()
	return rc & db.errMask
}
func sqlite3_step(pStmt *struct_sqlite3_stmt) int32 {
	var rc int32 = 0
	var v *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	var cnt int32 = 0
	var db *struct_sqlite3
	if vdbeSafetyNotNull(v) != 0 {
		return sqlite3MisuseError(85824)
	}
	db = v.db
	sqlite3_mutex_enter(db.mutex)
	v.doingRerun = uint8(0)
	for func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3Step(v)
		return *_cgo_addr
	}() == 17 && func() (_cgo_ret int32) {
		_cgo_addr := &cnt
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}() < 50 {
		var savedPc int32 = v.pc
		rc = sqlite3Reprepare(v)
		if rc != 0 {
			var zErr *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(db.pErr)))
			sqlite3DbFree(db, unsafe.Pointer(v.zErrMsg))
			if !(db.mallocFailed != 0) {
				v.zErrMsg = sqlite3DbStrDup(db, zErr)
				v.rc = func() (_cgo_ret int32) {
					_cgo_addr := &rc
					*_cgo_addr = sqlite3ApiExit(db, rc)
					return *_cgo_addr
				}()
			} else {
				v.zErrMsg = (*int8)(nil)
				v.rc = func() (_cgo_ret int32) {
					_cgo_addr := &rc
					*_cgo_addr = int32(7)
					return *_cgo_addr
				}()
			}
			break
		}
		sqlite3_reset(pStmt)
		if savedPc >= 0 {
			v.doingRerun = uint8(1)
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_user_data(p *struct_sqlite3_context) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	return p.pFunc.pUserData
}
func sqlite3_context_db_handle(p *struct_sqlite3_context) *struct_sqlite3 {
	func() int {
		_ = 0
		return 0
	}()
	return p.pOut.db
}
func sqlite3_vtab_nochange(p *struct_sqlite3_context) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3_value_nochange(p.pOut)
}
func valueFromValueList(pVal *struct_sqlite3_value, ppOut **struct_sqlite3_value, bNext int32) int32 {
	var rc int32
	var pRhs *struct_ValueList
	*ppOut = (*struct_sqlite3_value)(nil)
	if uintptr(unsafe.Pointer(pVal)) == uintptr(unsafe.Pointer(nil)) {
		return int32(21)
	}
	pRhs = (*struct_ValueList)(sqlite3_value_pointer(pVal, (*int8)(unsafe.Pointer(&[10]int8{'V', 'a', 'l', 'u', 'e', 'L', 'i', 's', 't', '\x00'}))))
	if uintptr(unsafe.Pointer(pRhs)) == uintptr(unsafe.Pointer(nil)) {
		return int32(21)
	}
	if bNext != 0 {
		rc = sqlite3BtreeNext(pRhs.pCsr, 0)
	} else {
		var dummy int32 = 0
		rc = sqlite3BtreeFirst(pRhs.pCsr, &dummy)
		func() int {
			_ = 0
			return 0
		}()
		if sqlite3BtreeEof(pRhs.pCsr) != 0 {
			rc = int32(101)
		}
	}
	if rc == 0 {
		var sz uint32
		var sMem struct_sqlite3_value
		__builtin___memset_chk(unsafe.Pointer(&sMem), 0, 56, __builtin_object_size(unsafe.Pointer(&sMem), 0))
		sz = sqlite3BtreePayloadSize(pRhs.pCsr)
		rc = sqlite3VdbeMemFromBtreeZeroOffset(pRhs.pCsr, uint32(int32(sz)), &sMem)
		if rc == 0 {
			var zBuf *uint8 = (*uint8)(unsafe.Pointer(sMem.z))
			var iSerial uint32
			var pOut *struct_sqlite3_value = pRhs.pOut
			var iOff int32 = 1 + int32(uint8(func() int32 {
				if int32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(1)))) < int32(uint8(128)) {
					return int32(func() int {
						iSerial = uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(1))))
						return 1
					}())
				} else {
					return int32(sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(1))), (*uint32)(unsafe.Pointer(&iSerial))))
				}
			}()))
			sqlite3VdbeSerialGet(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf)) + uintptr(iOff))), iSerial, pOut)
			pOut.enc = pOut.db.enc
			if int32(pOut.flags)&4096 != 0 && sqlite3VdbeMemMakeWriteable(pOut) != 0 {
				rc = int32(7)
			} else {
				*ppOut = pOut
			}
		}
		sqlite3VdbeMemRelease(&sMem)
	}
	return rc
}
func sqlite3_vtab_in_first(pVal *struct_sqlite3_value, ppOut **struct_sqlite3_value) int32 {
	return valueFromValueList(pVal, ppOut, 0)
}
func sqlite3_vtab_in_next(pVal *struct_sqlite3_value, ppOut **struct_sqlite3_value) int32 {
	return valueFromValueList(pVal, ppOut, 1)
}
func sqlite3StmtCurrentTime(p *struct_sqlite3_context) int64 {
	var rc int32
	var piTime *int64 = &p.pVdbe.iCurrentTime
	func() int {
		_ = 0
		return 0
	}()
	if *piTime == int64(0) {
		rc = sqlite3OsCurrentTimeInt64(p.pOut.db.pVfs, piTime)
		if rc != 0 {
			*piTime = int64(0)
		}
	}
	return *piTime
}
func createAggContext(p *struct_sqlite3_context, nByte int32) unsafe.Pointer {
	var pMem *struct_sqlite3_value = p.pMem
	func() int {
		_ = 0
		return 0
	}()
	if nByte <= 0 {
		sqlite3VdbeMemSetNull(pMem)
		pMem.z = (*int8)(nil)
	} else {
		sqlite3VdbeMemClearAndResize(pMem, nByte)
		pMem.flags = uint16(8192)
		*(**struct_FuncDef)(unsafe.Pointer(&pMem.u)) = p.pFunc
		if pMem.z != nil {
			__builtin___memset_chk(unsafe.Pointer(pMem.z), 0, uint(nByte), __builtin_object_size(unsafe.Pointer(pMem.z), 0))
		}
	}
	return unsafe.Pointer(pMem.z)
}
func sqlite3_aggregate_context(p *struct_sqlite3_context, nByte int32) unsafe.Pointer {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.pMem.flags)&8192 == 0 {
		return createAggContext(p, nByte)
	} else {
		return unsafe.Pointer(p.pMem.z)
	}
}
func sqlite3_get_auxdata(pCtx *struct_sqlite3_context, iArg int32) unsafe.Pointer {
	var pAuxData *struct_AuxData
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for pAuxData = pCtx.pVdbe.pAuxData; pAuxData != nil; pAuxData = pAuxData.pNextAux {
		if pAuxData.iAuxArg == iArg && (pAuxData.iAuxOp == pCtx.iOp || iArg < 0) {
			return pAuxData.pAux
		}
	}
	return unsafe.Pointer(nil)
}
func sqlite3_set_auxdata(pCtx *struct_sqlite3_context, iArg int32, pAux unsafe.Pointer, xDelete func(unsafe.Pointer)) {
	var pAuxData *struct_AuxData
	var pVdbe *struct_Vdbe = pCtx.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for pAuxData = pVdbe.pAuxData; pAuxData != nil; pAuxData = pAuxData.pNextAux {
		if pAuxData.iAuxArg == iArg && (pAuxData.iAuxOp == pCtx.iOp || iArg < 0) {
			break
		}
	}
	if uintptr(unsafe.Pointer(pAuxData)) == uintptr(unsafe.Pointer(nil)) {
		pAuxData = (*struct_AuxData)(sqlite3DbMallocZero(pVdbe.db, uint64(32)))
		if !(pAuxData != nil) {
			goto failed
		}
		pAuxData.iAuxOp = pCtx.iOp
		pAuxData.iAuxArg = iArg
		pAuxData.pNextAux = pVdbe.pAuxData
		pVdbe.pAuxData = pAuxData
		if pCtx.isError == 0 {
			pCtx.isError = int32(-1)
		}
	} else if pAuxData.xDeleteAux != nil {
		pAuxData.xDeleteAux(pAuxData.pAux)
	}
	pAuxData.pAux = pAux
	pAuxData.xDeleteAux = xDelete
	return
failed:
	if xDelete != nil {
		xDelete(pAux)
	}
}
func sqlite3_aggregate_count(p *struct_sqlite3_context) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return p.pMem.n
}
func sqlite3_column_count(pStmt *struct_sqlite3_stmt) int32 {
	var pVm *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	return func() int32 {
		if pVm != nil {
			return int32(pVm.nResColumn)
		} else {
			return 0
		}
	}()
}
func sqlite3_data_count(pStmt *struct_sqlite3_stmt) int32 {
	var pVm *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	if uintptr(unsafe.Pointer(pVm)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pVm.pResultSet)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	return int32(pVm.nResColumn)
}
func columnNullValue() *struct_sqlite3_value {
	var nullMem struct_sqlite3_value = struct_sqlite3_value{union_MemValue{float64(0)}, uint16(1), uint8(0), uint8(0), int32(0), (*int8)(unsafe.Pointer(uintptr(0))), (*int8)(unsafe.Pointer(uintptr(0))), int32(0), uint32(0), (*struct_sqlite3)(unsafe.Pointer(uintptr(0))), (func(unsafe.Pointer))(0)}
	return &nullMem
}
func columnMem(pStmt *struct_sqlite3_stmt, i int32) *struct_sqlite3_value {
	var pVm *struct_Vdbe
	var pOut *struct_sqlite3_value
	pVm = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	if uintptr(unsafe.Pointer(pVm)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_sqlite3_value)(unsafe.Pointer(columnNullValue()))
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(pVm.db.mutex)
	if uintptr(unsafe.Pointer(pVm.pResultSet)) != uintptr(unsafe.Pointer(nil)) && i < int32(pVm.nResColumn) && i >= 0 {
		pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pVm.pResultSet)) + uintptr(i)*56))
	} else {
		sqlite3Error(pVm.db, 25)
		pOut = (*struct_sqlite3_value)(unsafe.Pointer(columnNullValue()))
	}
	return pOut
}
func columnMallocFailure(pStmt *struct_sqlite3_stmt) {
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		p.rc = sqlite3ApiExit(p.db, p.rc)
		sqlite3_mutex_leave(p.db.mutex)
	}
}
func sqlite3_column_blob(pStmt *struct_sqlite3_stmt, i int32) unsafe.Pointer {
	var val unsafe.Pointer
	val = sqlite3_value_blob(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_bytes(pStmt *struct_sqlite3_stmt, i int32) int32 {
	var val int32 = sqlite3_value_bytes(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_bytes16(pStmt *struct_sqlite3_stmt, i int32) int32 {
	var val int32 = sqlite3_value_bytes16(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_double(pStmt *struct_sqlite3_stmt, i int32) float64 {
	var val float64 = sqlite3_value_double(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_int(pStmt *struct_sqlite3_stmt, i int32) int32 {
	var val int32 = sqlite3_value_int(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_int64(pStmt *struct_sqlite3_stmt, i int32) int64 {
	var val int64 = sqlite3_value_int64(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_text(pStmt *struct_sqlite3_stmt, i int32) *uint8 {
	var val *uint8 = sqlite3_value_text(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_value(pStmt *struct_sqlite3_stmt, i int32) *struct_sqlite3_value {
	var pOut *struct_sqlite3_value = columnMem(pStmt, i)
	if int32(pOut.flags)&2048 != 0 {
		pOut.flags &= uint16(^2048)
		pOut.flags |= uint16(4096)
	}
	columnMallocFailure(pStmt)
	return (*struct_sqlite3_value)(unsafe.Pointer(pOut))
}
func sqlite3_column_text16(pStmt *struct_sqlite3_stmt, i int32) unsafe.Pointer {
	var val unsafe.Pointer = sqlite3_value_text16(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return val
}
func sqlite3_column_type(pStmt *struct_sqlite3_stmt, i int32) int32 {
	var iType int32 = sqlite3_value_type(columnMem(pStmt, i))
	columnMallocFailure(pStmt)
	return iType
}
func columnName(pStmt *struct_sqlite3_stmt, N int32, useUtf16 int32, useType int32) unsafe.Pointer {
	var ret unsafe.Pointer
	var p *struct_Vdbe
	var n int32
	var db *struct_sqlite3
	ret = unsafe.Pointer(nil)
	p = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	db = p.db
	func() int {
		_ = 0
		return 0
	}()
	n = sqlite3_column_count(pStmt)
	if N < n && N >= 0 {
		N += useType * n
		sqlite3_mutex_enter(db.mutex)
		func() int {
			_ = 0
			return 0
		}()
		if useUtf16 != 0 {
			ret = sqlite3_value_text16((*struct_sqlite3_value)(unsafe.Pointer(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aColName)) + uintptr(N)*56)))))
		} else {
			ret = unsafe.Pointer(sqlite3_value_text((*struct_sqlite3_value)(unsafe.Pointer(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aColName)) + uintptr(N)*56))))))
		}
		if db.mallocFailed != 0 {
			sqlite3OomClear(db)
			ret = unsafe.Pointer(nil)
		}
		sqlite3_mutex_leave(db.mutex)
	}
	return ret
}
func sqlite3_column_name(pStmt *struct_sqlite3_stmt, N int32) *int8 {
	return (*int8)(columnName(pStmt, N, 0, 0))
}
func sqlite3_column_name16(pStmt *struct_sqlite3_stmt, N int32) unsafe.Pointer {
	return columnName(pStmt, N, 1, 0)
}
func sqlite3_column_decltype(pStmt *struct_sqlite3_stmt, N int32) *int8 {
	return (*int8)(columnName(pStmt, N, 0, 1))
}
func sqlite3_column_decltype16(pStmt *struct_sqlite3_stmt, N int32) unsafe.Pointer {
	return columnName(pStmt, N, 1, 1)
}
func vdbeUnbind(p *struct_Vdbe, i int32) int32 {
	var pVar *struct_sqlite3_value
	if vdbeSafetyNotNull(p) != 0 {
		return sqlite3MisuseError(86465)
	}
	sqlite3_mutex_enter(p.db.mutex)
	if p.iVdbeMagic != uint32(770837923) || p.pc >= 0 {
		sqlite3Error(p.db, 21)
		sqlite3_mutex_leave(p.db.mutex)
		sqlite3_log(21, (*int8)(unsafe.Pointer(&[40]int8{'b', 'i', 'n', 'd', ' ', 'o', 'n', ' ', 'a', ' ', 'b', 'u', 's', 'y', ' ', 'p', 'r', 'e', 'p', 'a', 'r', 'e', 'd', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', ':', ' ', '[', '%', 's', ']', '\x00'})), p.zSql)
		return sqlite3MisuseError(86473)
	}
	if i < 1 || i > int32(p.nVar) {
		sqlite3Error(p.db, 25)
		sqlite3_mutex_leave(p.db.mutex)
		return int32(25)
	}
	i--
	pVar = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i)*56))
	sqlite3VdbeMemRelease(pVar)
	pVar.flags = uint16(1)
	p.db.errCode = int32(0)
	func() int {
		_ = 0
		return 0
	}()
	if p.expmask != uint32(0) && p.expmask&func() uint32 {
		if i >= 31 {
			return 2147483648
		} else {
			return uint32(1) << i
		}
	}() != uint32(0) {
		{
			_autoGo_18 := &p.Xbf_0
			*_autoGo_18 = *_autoGo_18&^3 | uint32(1)&3
		}
	}
	return int32(0)
}
func bindText(pStmt *struct_sqlite3_stmt, i int32, zData unsafe.Pointer, nData int64, xDel func(unsafe.Pointer), encoding uint8) int32 {
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	var pVar *struct_sqlite3_value
	var rc int32
	rc = vdbeUnbind(p, i)
	if rc == 0 {
		if uintptr(unsafe.Pointer(zData)) != uintptr(unsafe.Pointer(nil)) {
			pVar = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i-1)*56))
			rc = sqlite3VdbeMemSetStr(pVar, (*int8)(zData), nData, encoding, xDel)
			if rc == 0 && int32(encoding) != 0 {
				rc = sqlite3VdbeChangeEncoding(pVar, int32(p.db.enc))
			}
			if rc != 0 {
				sqlite3Error(p.db, rc)
				rc = sqlite3ApiExit(p.db, rc)
			}
		}
		sqlite3_mutex_leave(p.db.mutex)
	} else if uintptr(unsafe.Pointer(xDel)) != uintptr(unsafe.Pointer((func(unsafe.Pointer))(0))) && uintptr(unsafe.Pointer(xDel)) != uintptr(unsafe.Pointer((func(unsafe.Pointer))(-1))) {
		xDel(unsafe.Pointer(zData))
	}
	return rc
}
func sqlite3_bind_blob(pStmt *struct_sqlite3_stmt, i int32, zData unsafe.Pointer, nData int32, xDel func(unsafe.Pointer)) int32 {
	return bindText(pStmt, i, zData, int64(nData), xDel, uint8(0))
}
func sqlite3_bind_blob64(pStmt *struct_sqlite3_stmt, i int32, zData unsafe.Pointer, nData uint64, xDel func(unsafe.Pointer)) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return bindText(pStmt, i, zData, int64(nData), xDel, uint8(0))
}
func sqlite3_bind_double(pStmt *struct_sqlite3_stmt, i int32, rValue float64) int32 {
	var rc int32
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	rc = vdbeUnbind(p, i)
	if rc == 0 {
		sqlite3VdbeMemSetDouble(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i-1)*56)), rValue)
		sqlite3_mutex_leave(p.db.mutex)
	}
	return rc
}
func sqlite3_bind_int(p *struct_sqlite3_stmt, i int32, iValue int32) int32 {
	return sqlite3_bind_int64(p, i, int64(iValue))
}
func sqlite3_bind_int64(pStmt *struct_sqlite3_stmt, i int32, iValue int64) int32 {
	var rc int32
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	rc = vdbeUnbind(p, i)
	if rc == 0 {
		sqlite3VdbeMemSetInt64(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i-1)*56)), iValue)
		sqlite3_mutex_leave(p.db.mutex)
	}
	return rc
}
func sqlite3_bind_null(pStmt *struct_sqlite3_stmt, i int32) int32 {
	var rc int32
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	rc = vdbeUnbind(p, i)
	if rc == 0 {
		sqlite3_mutex_leave(p.db.mutex)
	}
	return rc
}
func sqlite3_bind_pointer(pStmt *struct_sqlite3_stmt, i int32, pPtr unsafe.Pointer, zPTtype *int8, xDestructor func(unsafe.Pointer)) int32 {
	var rc int32
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	rc = vdbeUnbind(p, i)
	if rc == 0 {
		sqlite3VdbeMemSetPointer(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i-1)*56)), pPtr, zPTtype, xDestructor)
		sqlite3_mutex_leave(p.db.mutex)
	} else if xDestructor != nil {
		xDestructor(pPtr)
	}
	return rc
}
func sqlite3_bind_text(pStmt *struct_sqlite3_stmt, i int32, zData *int8, nData int32, xDel func(unsafe.Pointer)) int32 {
	return bindText(pStmt, i, unsafe.Pointer(zData), int64(nData), xDel, uint8(1))
}
func sqlite3_bind_text64(pStmt *struct_sqlite3_stmt, i int32, zData *int8, nData uint64, xDel func(unsafe.Pointer), enc uint8) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if int32(enc) == 4 {
		enc = uint8(2)
	}
	return bindText(pStmt, i, unsafe.Pointer(zData), int64(nData), xDel, enc)
}
func sqlite3_bind_text16(pStmt *struct_sqlite3_stmt, i int32, zData unsafe.Pointer, nData int32, xDel func(unsafe.Pointer)) int32 {
	return bindText(pStmt, i, zData, int64(nData), xDel, uint8(2))
}
func sqlite3_bind_value(pStmt *struct_sqlite3_stmt, i int32, pValue *struct_sqlite3_value) int32 {
	var rc int32
	switch sqlite3_value_type((*struct_sqlite3_value)(unsafe.Pointer(pValue))) {
	case 1:
		{
			rc = sqlite3_bind_int64(pStmt, i, *(*int64)(unsafe.Pointer(&pValue.u)))
			break
		}
	case 2:
		{
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3_bind_double(pStmt, i, func() float64 {
				if int32(pValue.flags)&8 != 0 {
					return pValue.u.r
				} else {
					return float64(*(*int64)(unsafe.Pointer(&pValue.u)))
				}
			}())
			break
		}
	case 4:
		{
			if int32(pValue.flags)&16384 != 0 {
				rc = sqlite3_bind_zeroblob(pStmt, i, *(*int32)(unsafe.Pointer(&pValue.u)))
			} else {
				rc = sqlite3_bind_blob(pStmt, i, unsafe.Pointer(pValue.z), pValue.n, (func(unsafe.Pointer))(-1))
			}
			break
		}
	case 3:
		{
			rc = bindText(pStmt, i, unsafe.Pointer(pValue.z), int64(pValue.n), (func(unsafe.Pointer))(-1), pValue.enc)
			break
		}
	default:
		{
			rc = sqlite3_bind_null(pStmt, i)
			break
		}
	}
	return rc
}
func sqlite3_bind_zeroblob(pStmt *struct_sqlite3_stmt, i int32, n int32) int32 {
	var rc int32
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	rc = vdbeUnbind(p, i)
	if rc == 0 {
		sqlite3VdbeMemSetZeroBlob(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(i-1)*56)), n)
		sqlite3_mutex_leave(p.db.mutex)
	}
	return rc
}
func sqlite3_bind_zeroblob64(pStmt *struct_sqlite3_stmt, i int32, n uint64) int32 {
	var rc int32
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	sqlite3_mutex_enter(p.db.mutex)
	if n > uint64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.db.aLimit)))) + uintptr(0)*4))) {
		rc = int32(18)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3_bind_zeroblob(pStmt, i, int32(n))
	}
	rc = sqlite3ApiExit(p.db, rc)
	sqlite3_mutex_leave(p.db.mutex)
	return rc
}
func sqlite3_bind_parameter_count(pStmt *struct_sqlite3_stmt) int32 {
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	return func() int32 {
		if p != nil {
			return int32(p.nVar)
		} else {
			return 0
		}
	}()
}
func sqlite3_bind_parameter_name(pStmt *struct_sqlite3_stmt, i int32) *int8 {
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	return sqlite3VListNumToName(p.pVList, i)
}
func sqlite3VdbeParameterIndex(p *struct_Vdbe, zName *int8, nName int32) int32 {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	return sqlite3VListNameToNum(p.pVList, zName, nName)
}
func sqlite3_bind_parameter_index(pStmt *struct_sqlite3_stmt, zName *int8) int32 {
	return sqlite3VdbeParameterIndex((*struct_Vdbe)(unsafe.Pointer(pStmt)), zName, sqlite3Strlen30(zName))
}
func sqlite3TransferBindings(pFromStmt *struct_sqlite3_stmt, pToStmt *struct_sqlite3_stmt) int32 {
	var pFrom *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pFromStmt))
	var pTo *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pToStmt))
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_enter(pTo.db.mutex)
	for i = int32(0); i < int32(pFrom.nVar); i++ {
		sqlite3VdbeMemMove(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pTo.aVar)) + uintptr(i)*56)), &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrom.aVar)) + uintptr(i)*56)))
	}
	sqlite3_mutex_leave(pTo.db.mutex)
	return int32(0)
}
func sqlite3_transfer_bindings(pFromStmt *struct_sqlite3_stmt, pToStmt *struct_sqlite3_stmt) int32 {
	var pFrom *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pFromStmt))
	var pTo *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pToStmt))
	if int32(pFrom.nVar) != int32(pTo.nVar) {
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pTo.expmask != 0 {
		{
			_autoGo_19 := &pTo.Xbf_0
			*_autoGo_19 = *_autoGo_19&^3 | uint32(1)&3
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if pFrom.expmask != 0 {
		{
			_autoGo_20 := &pFrom.Xbf_0
			*_autoGo_20 = *_autoGo_20&^3 | uint32(1)&3
		}
	}
	return sqlite3TransferBindings(pFromStmt, pToStmt)
}
func sqlite3_db_handle(pStmt *struct_sqlite3_stmt) *struct_sqlite3 {
	return func() *struct_sqlite3 {
		if pStmt != nil {
			return (*struct_Vdbe)(unsafe.Pointer(pStmt)).db
		} else {
			return nil
		}
	}()
}
func sqlite3_stmt_readonly(pStmt *struct_sqlite3_stmt) int32 {
	return func() int32 {
		if pStmt != nil {
			return int32((*struct_Vdbe)(unsafe.Pointer(pStmt)).Xbf_0 >> 7 & 1)
		} else {
			return 1
		}
	}()
}
func sqlite3_stmt_isexplain(pStmt *struct_sqlite3_stmt) int32 {
	return func() int32 {
		if pStmt != nil {
			return int32((*struct_Vdbe)(unsafe.Pointer(pStmt)).Xbf_0 >> 2 & 3)
		} else {
			return 0
		}
	}()
}
func sqlite3_stmt_busy(pStmt *struct_sqlite3_stmt) int32 {
	var v *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	return func() int32 {
		if uintptr(unsafe.Pointer(v)) != uintptr(unsafe.Pointer(nil)) && v.iVdbeMagic == uint32(770837923) && v.pc >= 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3_next_stmt(pDb *struct_sqlite3, pStmt *struct_sqlite3_stmt) *struct_sqlite3_stmt {
	var pNext *struct_sqlite3_stmt
	sqlite3_mutex_enter(pDb.mutex)
	if uintptr(unsafe.Pointer(pStmt)) == uintptr(unsafe.Pointer(nil)) {
		pNext = (*struct_sqlite3_stmt)(unsafe.Pointer(pDb.pVdbe))
	} else {
		pNext = (*struct_sqlite3_stmt)(unsafe.Pointer((*struct_Vdbe)(unsafe.Pointer(pStmt)).pNext))
	}
	sqlite3_mutex_leave(pDb.mutex)
	return pNext
}
func sqlite3_stmt_status(pStmt *struct_sqlite3_stmt, op int32, resetFlag int32) int32 {
	var pVdbe *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	var v uint32
	if op == 99 {
		var db *struct_sqlite3 = pVdbe.db
		sqlite3_mutex_enter(db.mutex)
		v = uint32(0)
		db.pnBytesFreed = (*int32)(unsafe.Pointer(&v))
		sqlite3VdbeClearObject(db, pVdbe)
		sqlite3DbFree(db, unsafe.Pointer(pVdbe))
		db.pnBytesFreed = (*int32)(nil)
		sqlite3_mutex_leave(db.mutex)
	} else {
		v = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pVdbe.aCounter)))) + uintptr(op)*4))
		if resetFlag != 0 {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pVdbe.aCounter)))) + uintptr(op)*4)) = uint32(0)
		}
	}
	return int32(v)
}
func sqlite3_sql(pStmt *struct_sqlite3_stmt) *int8 {
	var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
	return func() *int8 {
		if p != nil {
			return p.zSql
		} else {
			return nil
		}
	}()
}
func sqlite3_expanded_sql(pStmt *struct_sqlite3_stmt) *int8 {
	var z *int8 = nil
	var zSql *int8 = sqlite3_sql(pStmt)
	if zSql != nil {
		var p *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pStmt))
		sqlite3_mutex_enter(p.db.mutex)
		z = sqlite3VdbeExpandSql(p, zSql)
		sqlite3_mutex_leave(p.db.mutex)
	}
	return z
}
func findNextHostParameter(zSql *int8, pnToken *int32) int32 {
	var tokenType int32
	var nTotal int32 = 0
	var n int32
	*pnToken = int32(0)
	for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0))) != 0 {
		n = sqlite3GetToken((*uint8)(unsafe.Pointer(zSql)), &tokenType)
		func() int {
			_ = 0
			return 0
		}()
		if tokenType == 156 {
			*pnToken = n
			break
		}
		nTotal += n
		*(*uintptr)(unsafe.Pointer(&zSql)) += uintptr(n)
	}
	return nTotal
}
func sqlite3VdbeExpandSql(p *struct_Vdbe, zRawSql *int8) *int8 {
	var db *struct_sqlite3
	var idx int32 = 0
	var nextIndex int32 = 1
	var n int32
	var nToken int32
	var i int32
	var pVar *struct_sqlite3_value
	var out struct_sqlite3_str
	var utf8 struct_sqlite3_value
	db = p.db
	sqlite3StrAccumInit(&out, nil, nil, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)))
	if db.nVdbeExec > 1 {
		for *zRawSql != 0 {
			var zStart *int8 = zRawSql
			for int32(*func() (_cgo_ret *int8) {
				_cgo_addr := &zRawSql
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()) != '\n' && int32(*zRawSql) != 0 {
			}
			sqlite3_str_append(&out, (*int8)(unsafe.Pointer(&[4]int8{'-', '-', ' ', '\x00'})), 3)
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_str_append(&out, zStart, int32(uintptr(unsafe.Pointer(zRawSql))-uintptr(unsafe.Pointer(zStart))))
		}
	} else if int32(p.nVar) == 0 {
		sqlite3_str_append(&out, zRawSql, sqlite3Strlen30(zRawSql))
	} else {
		for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRawSql)) + uintptr(0))) != 0 {
			n = findNextHostParameter(zRawSql, &nToken)
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_str_append(&out, zRawSql, n)
			*(*uintptr)(unsafe.Pointer(&zRawSql)) += uintptr(n)
			func() int {
				_ = 0
				return 0
			}()
			if nToken == 0 {
				break
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRawSql)) + uintptr(0)))) == '?' {
				if nToken > 1 {
					func() int {
						_ = 0
						return 0
					}()
					sqlite3GetInt32(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRawSql)) + uintptr(1))), &idx)
				} else {
					idx = nextIndex
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken)
				func() int {
					_ = 0
					return 0
				}()
			}
			*(*uintptr)(unsafe.Pointer(&zRawSql)) += uintptr(nToken)
			nextIndex = func() int32 {
				if idx+1 > nextIndex {
					return idx + 1
				} else {
					return nextIndex
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			pVar = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(idx-1)*56))
			if int32(pVar.flags)&1 != 0 {
				sqlite3_str_append(&out, (*int8)(unsafe.Pointer(&[5]int8{'N', 'U', 'L', 'L', '\x00'})), 4)
			} else if int32(pVar.flags)&(4|32) != 0 {
				sqlite3_str_appendf(&out, (*int8)(unsafe.Pointer(&[5]int8{'%', 'l', 'l', 'd', '\x00'})), *(*int64)(unsafe.Pointer(&pVar.u)))
			} else if int32(pVar.flags)&8 != 0 {
				sqlite3_str_appendf(&out, (*int8)(unsafe.Pointer(&[7]int8{'%', '!', '.', '1', '5', 'g', '\x00'})), pVar.u.r)
			} else if int32(pVar.flags)&2 != 0 {
				var nOut int32
				var enc uint8 = db.enc
				if int32(enc) != 1 {
					__builtin___memset_chk(unsafe.Pointer(&utf8), 0, 56, __builtin_object_size(unsafe.Pointer(&utf8), 0))
					utf8.db = db
					sqlite3VdbeMemSetStr(&utf8, pVar.z, int64(pVar.n), enc, (func(unsafe.Pointer))(0))
					if 7 == sqlite3VdbeChangeEncoding(&utf8, 1) {
						out.accError = uint8(7)
						out.nAlloc = uint32(0)
					}
					pVar = &utf8
				}
				nOut = pVar.n
				sqlite3_str_appendf(&out, (*int8)(unsafe.Pointer(&[7]int8{'\'', '%', '.', '*', 'q', '\'', '\x00'})), nOut, pVar.z)
				if int32(enc) != 1 {
					sqlite3VdbeMemRelease(&utf8)
				}
			} else if int32(pVar.flags)&16384 != 0 {
				sqlite3_str_appendf(&out, (*int8)(unsafe.Pointer(&[13]int8{'z', 'e', 'r', 'o', 'b', 'l', 'o', 'b', '(', '%', 'd', ')', '\x00'})), *(*int32)(unsafe.Pointer(&pVar.u)))
			} else {
				var nOut int32
				func() int {
					_ = 0
					return 0
				}()
				sqlite3_str_append(&out, (*int8)(unsafe.Pointer(&[3]int8{'x', '\'', '\x00'})), 2)
				nOut = pVar.n
				for i = int32(0); i < nOut; i++ {
					sqlite3_str_appendf(&out, (*int8)(unsafe.Pointer(&[5]int8{'%', '0', '2', 'x', '\x00'})), int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pVar.z)) + uintptr(i))))&255)
				}
				sqlite3_str_append(&out, (*int8)(unsafe.Pointer(&[2]int8{'\'', '\x00'})), 1)
			}
		}
	}
	if out.accError != 0 {
		sqlite3_str_reset(&out)
	}
	return sqlite3StrAccumFinish(&out)
}
func allocateCursor(p *struct_Vdbe, iCur int32, nField int32, eCurType uint8) *struct_VdbeCursor {
	var pMem *struct_sqlite3_value = func() *struct_sqlite3_value {
		if iCur > 0 {
			return &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMem)) + uintptr(p.nMem-iCur)*56))
		} else {
			return p.aMem
		}
	}()
	var nByte int32
	var pCx *struct_VdbeCursor = nil
	nByte = int32((116+uint(7))&uint(18446744073709551608) + uint(2)*4*uint(nField) + uint(func() int32 {
		if int32(eCurType) == 0 {
			return sqlite3BtreeCursorSize()
		} else {
			return 0
		}
	}()))
	func() int {
		_ = 0
		return 0
	}()
	if *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(iCur)*8)) != nil {
		sqlite3VdbeFreeCursor(p, *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(iCur)*8)))
		*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(iCur)*8)) = (*struct_VdbeCursor)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pMem.szMalloc < nByte {
		if pMem.szMalloc > 0 {
			sqlite3DbFreeNN(pMem.db, unsafe.Pointer(pMem.zMalloc))
		}
		pMem.z = func() (_cgo_ret *int8) {
			_cgo_addr := &pMem.zMalloc
			*_cgo_addr = (*int8)(sqlite3DbMallocRaw(pMem.db, uint64(nByte)))
			return *_cgo_addr
		}()
		if uintptr(unsafe.Pointer(pMem.zMalloc)) == uintptr(unsafe.Pointer(nil)) {
			pMem.szMalloc = int32(0)
			return (*struct_VdbeCursor)(nil)
		}
		pMem.szMalloc = nByte
	}
	*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(iCur)*8)) = func() (_cgo_ret *struct_VdbeCursor) {
		_cgo_addr := &pCx
		*_cgo_addr = (*struct_VdbeCursor)(unsafe.Pointer(pMem.zMalloc))
		return *_cgo_addr
	}()
	__builtin___memset_chk(unsafe.Pointer(pCx), 0, 40, __builtin_object_size(unsafe.Pointer(pCx), 0))
	pCx.eCurType = eCurType
	pCx.nField = int16(nField)
	pCx.aOffset = &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pCx.aType)))) + uintptr(nField)*4))
	if int32(eCurType) == 0 {
		pCx.uc.pCursor = (*struct_BtCursor)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem.z)) + uintptr((116+uint(7))&uint(18446744073709551608)+uint(2)*4*uint(nField))))))
		sqlite3BtreeCursorZero(pCx.uc.pCursor)
	}
	return pCx
}
func alsoAnInt(pRec *struct_sqlite3_value, rValue float64, piValue *int64) int32 {
	var iValue int64 = int64(float64(rValue))
	if sqlite3RealSameAsInt(rValue, iValue) != 0 {
		*piValue = iValue
		return int32(1)
	}
	return func() int32 {
		if 0 == sqlite3Atoi64(pRec.z, piValue, pRec.n, pRec.enc) {
			return 1
		} else {
			return 0
		}
	}()
}
func applyNumericAffinity(pRec *struct_sqlite3_value, bTryForInt int32) {
	var rValue float64
	var enc uint8 = pRec.enc
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3AtoF(pRec.z, &rValue, pRec.n, enc)
	if rc <= 0 {
		return
	}
	if rc == 1 && alsoAnInt(pRec, rValue, &*(*int64)(unsafe.Pointer(&pRec.u))) != 0 {
		pRec.flags |= uint16(4)
	} else {
		pRec.u.r = rValue
		pRec.flags |= uint16(8)
		if bTryForInt != 0 {
			sqlite3VdbeIntegerAffinity(pRec)
		}
	}
	pRec.flags &= uint16(^2)
}
func applyAffinity(pRec *struct_sqlite3_value, affinity int8, enc uint8) {
	if int32(affinity) >= 67 {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pRec.flags)&4 == 0 {
			if int32(pRec.flags)&8 == 0 {
				if int32(pRec.flags)&2 != 0 {
					applyNumericAffinity(pRec, 1)
				}
			} else {
				sqlite3VdbeIntegerAffinity(pRec)
			}
		}
	} else if int32(affinity) == 66 {
		if 0 == int32(pRec.flags)&2 {
			if int32(pRec.flags)&(8|4|32) != 0 {
				sqlite3VdbeMemStringify(pRec, enc, uint8(1))
			}
		}
		pRec.flags &= uint16(^(8 | 4 | 32))
	}
}
func sqlite3_value_numeric_type(pVal *struct_sqlite3_value) int32 {
	var eType int32 = sqlite3_value_type(pVal)
	if eType == 3 {
		var pMem *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(pVal))
		applyNumericAffinity(pMem, 0)
		eType = sqlite3_value_type(pVal)
	}
	return eType
}
func sqlite3ValueApplyAffinity(pVal *struct_sqlite3_value, affinity uint8, enc uint8) {
	applyAffinity((*struct_sqlite3_value)(unsafe.Pointer(pVal)), int8(affinity), enc)
}
func computeNumericType(pMem *struct_sqlite3_value) uint16 {
	var rc int32
	var ix int64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if func() int32 {
		if int32(pMem.flags)&16384 != 0 {
			return sqlite3VdbeMemExpandBlob(pMem)
		} else {
			return 0
		}
	}() != 0 {
		*(*int64)(unsafe.Pointer(&pMem.u)) = int64(0)
		return uint16(4)
	}
	rc = sqlite3AtoF(pMem.z, &pMem.u.r, pMem.n, pMem.enc)
	if rc <= 0 {
		if rc == 0 && sqlite3Atoi64(pMem.z, &ix, pMem.n, pMem.enc) <= 1 {
			*(*int64)(unsafe.Pointer(&pMem.u)) = ix
			return uint16(4)
		} else {
			return uint16(8)
		}
	} else if rc == 1 && sqlite3Atoi64(pMem.z, &ix, pMem.n, pMem.enc) == 0 {
		*(*int64)(unsafe.Pointer(&pMem.u)) = ix
		return uint16(4)
	}
	return uint16(8)
}
func numericType(pMem *struct_sqlite3_value) uint16 {
	if int32(pMem.flags)&(4|8|32) != 0 {
		return uint16(int32(pMem.flags) & (4 | 8 | 32))
	}
	if int32(pMem.flags)&(2|16) != 0 {
		return computeNumericType(pMem)
	}
	return uint16(0)
}
func out2PrereleaseWithClear(pOut *struct_sqlite3_value) *struct_sqlite3_value {
	sqlite3VdbeMemSetNull(pOut)
	pOut.flags = uint16(4)
	return pOut
}
func out2Prerelease(p *struct_Vdbe, pOp *struct_VdbeOp) *struct_sqlite3_value {
	var pOut *struct_sqlite3_value
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMem)) + uintptr(pOp.p2)*56))
	if int32(pOut.flags)&(8192|1024) != 0 {
		return out2PrereleaseWithClear(pOut)
	} else {
		pOut.flags = uint16(4)
		return pOut
	}
}
func filterHash(aMem *struct_sqlite3_value, pOp *struct_VdbeOp) uint64 {
	var i int32
	var mx int32
	var h uint64 = uint64(0)
	func() int {
		_ = 0
		return 0
	}()
	for func() int32 {
		i = pOp.p3
		return func() (_cgo_ret int32) {
			_cgo_addr := &mx
			*_cgo_addr = i + *(*int32)(unsafe.Pointer(&pOp.p4))
			return *_cgo_addr
		}()
	}(); i < mx; i++ {
		var p *struct_sqlite3_value = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(i)*56))
		if int32(p.flags)&(4|32) != 0 {
			h += uint64(*(*int64)(unsafe.Pointer(&p.u)))
		} else if int32(p.flags)&8 != 0 {
			h += uint64(sqlite3VdbeIntValue(p))
		} else if int32(p.flags)&(2|16) != 0 {
			h += uint64(p.n)
			if int32(p.flags)&16384 != 0 {
				h += uint64(*(*int32)(unsafe.Pointer(&p.u)))
			}
		}
	}
	return h
}
func vdbeMemTypeName(pMem *struct_sqlite3_value) *int8 {
	var azTypes [5]*int8 = [5]*int8{(*int8)(unsafe.Pointer(&[4]int8{'I', 'N', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'R', 'E', 'A', 'L', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'T', 'E', 'X', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'B', 'L', 'O', 'B', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'N', 'U', 'L', 'L', '\x00'}))}
	return *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azTypes)))) + uintptr(sqlite3_value_type(pMem)-1)*8))
}
func sqlite3VdbeExec(p *struct_Vdbe) int32 {
	var (
		res_cgo65            int32
		res2_cgo66           int32
		affinity_cgo67       int8
		flags1_cgo68         uint16
		flags3_cgo69         uint16
		iAddr_cgo95          uint32
		c_cgo101             int32
		c_cgo104             int32
		doTheJump_cgo109     int32
		nEntry_cgo128        int64
		pCrsr_cgo129         *struct_BtCursor
		pC_cgo143            *struct_VdbeCursor
		res_cgo151           int32
		oc_cgo152            int32
		pC_cgo153            *struct_VdbeCursor
		r_cgo154             struct_UnpackedRecord
		nField_cgo155        int32
		iKey_cgo156          int64
		eqOnly_cgo157        int32
		flags3_cgo160        uint16
		newType_cgo161       uint16
		c_cgo163             int32
		pC_cgo170            *struct_VdbeCursor
		res_cgo171           int32
		nStep_cgo172         int32
		r_cgo173             struct_UnpackedRecord
		alreadyExists_cgo188 int32
		takeJump_cgo189      int32
		ii_cgo190            int32
		pC_cgo191            *struct_VdbeCursor
		res_cgo192           int32
		pFree_cgo193         *struct_UnpackedRecord
		pIdxKey_cgo194       *struct_UnpackedRecord
		r_cgo195             struct_UnpackedRecord
		pC_cgo201            *struct_VdbeCursor
		pCrsr_cgo202         *struct_BtCursor
		res_cgo203           int32
		iKey_cgo204          uint64
		x_cgo206             struct_sqlite3_value
		pC_cgo219            *struct_VdbeCursor
		res_cgo220           int32
		nKeyCol_cgo221       int32
		pC_cgo229            *struct_VdbeCursor
		pCrsr_cgo230         *struct_BtCursor
		res_cgo231           int32
		pC_cgo235            *struct_VdbeCursor
		pCrsr_cgo236         *struct_BtCursor
		res_cgo237           int32
		sz_cgo238            int64
		pC_cgo243            *struct_VdbeCursor
		pCrsr_cgo244         *struct_BtCursor
		res_cgo245           int32
		pC_cgo248            *struct_VdbeCursor
		pC_cgo262            *struct_VdbeCursor
		res_cgo263           int32
		r_cgo264             struct_UnpackedRecord
		nRoot_cgo277         int32
		aRoot_cgo278         *uint32
		nErr_cgo279          int32
		z_cgo280             *int8
		pnErr_cgo281         *struct_sqlite3_value
		val_cgo284           int64
		iSet_cgo288          int32
		exists_cgo289        int32
		nMem_cgo293          int32
		nByte_cgo294         int32
		pRt_cgo295           *struct_sqlite3_value
		pMem_cgo296          *struct_sqlite3_value
		pEnd_cgo297          *struct_sqlite3_value
		pFrame_cgo298        *struct_VdbeFrame
		pProgram_cgo299      *struct_SubProgram
		t_cgo300             unsafe.Pointer
		pBt_cgo325           *struct_Btree
		nArg_cgo337          int32
		iQuery_cgo338        int32
		pModule_cgo339       *struct_sqlite3_module
		pQuery_cgo340        *struct_sqlite3_value
		pArgc_cgo341         *struct_sqlite3_value
		pVCur_cgo342         *struct_sqlite3_vtab_cursor
		pVtab_cgo343         *struct_sqlite3_vtab
		pCur_cgo344          *struct_VdbeCursor
		res_cgo345           int32
		i_cgo346             int32
		apArg_cgo347         **struct_sqlite3_value
		pVtab_cgo351         *struct_sqlite3_vtab
		pModule_cgo352       *struct_sqlite3_module
		res_cgo353           int32
		pCur_cgo354          *struct_VdbeCursor
		h_cgo364             uint64
		i_cgo369             int32
		zTrace_cgo370        *int8
	)
	var aOp *struct_VdbeOp = p.aOp
	var pOp *struct_VdbeOp = aOp
	var rc int32 = 0
	var db *struct_sqlite3 = p.db
	var resetSchemaOnFault uint8 = uint8(0)
	var encoding uint8 = db.enc
	var iCompare int32 = 0
	var nVmStep uint64 = uint64(0)
	var nProgressLimit uint64
	var aMem *struct_sqlite3_value = p.aMem
	var pIn1 *struct_sqlite3_value = nil
	var pIn2 *struct_sqlite3_value = nil
	var pIn3 *struct_sqlite3_value = nil
	var pOut *struct_sqlite3_value = nil
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeEnter(p)
	if db.xProgress != nil {
		var iPrior uint32 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(4)*4))
		func() int {
			_ = 0
			return 0
		}()
		nProgressLimit = uint64(db.nProgressOps - iPrior%db.nProgressOps)
	} else {
		nProgressLimit = uint64(4294967295) | uint64(4294967295)<<32
	}
	if p.rc == 7 {
		goto no_mem
	}
	func() int {
		_ = 0
		return 0
	}()
	p.rc = int32(0)
	func() int {
		_ = 0
		return 0
	}()
	p.iCurrentTime = int64(0)
	func() int {
		_ = 0
		return 0
	}()
	p.pResultSet = (*struct_sqlite3_value)(nil)
	db.busyHandler.nBusy = int32(0)
	if __atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0) != 0 {
		goto abort_due_to_interrupt
	}
	for pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(p.pc)*24)); 1 != 0; *(*uintptr)(unsafe.Pointer(&pOp)) += 24 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		nVmStep++
		_cgo_nm, _cgo_tag := true, int32(pOp.opcode)
		if _cgo_nm && _cgo_tag != 11 {
			goto _cgol_1
		}
		_cgo_nm = false
	jump_to_p2_and_check_for_interrupt:
		pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pOp.p2-1)*24))
	check_for_interrupt:
		if __atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0) != 0 {
			goto abort_due_to_interrupt
		}
		for nVmStep >= nProgressLimit && uintptr(unsafe.Pointer(db.xProgress)) != uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			nProgressLimit += uint64(db.nProgressOps)
			if db.xProgress(db.pProgressArg) != 0 {
				nProgressLimit = uint64(4294967295) | uint64(4294967295)<<32
				rc = int32(9)
				goto abort_due_to_error
			}
		}
		goto _cgol_2
	_cgol_1:
		if _cgo_nm && _cgo_tag != 12 {
			goto _cgol_3
		}
		_cgo_nm = false
		func() int {
			_ = 0
			return 0
		}()
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		pIn1.flags = uint16(4)
		*(*int64)(unsafe.Pointer(&pIn1.u)) = int64(int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24))
	jump_to_p2:
		pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pOp.p2-1)*24))
		goto _cgol_2
	_cgol_3:
		if _cgo_nm && _cgo_tag != 67 {
			goto _cgol_4
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(*(*int64)(unsafe.Pointer(&pIn1.u)))*24))
			pIn1.flags = uint16(128)
			goto _cgol_2
		}
	_cgol_4:
		if _cgo_nm && _cgo_tag != 13 {
			goto _cgol_5
		}
		_cgo_nm = false
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		*(*int64)(unsafe.Pointer(&pOut.u)) = int64(pOp.p3 - 1)
		pOut.flags = uint16(4)
		if !(pOp.p2 != 0) {
			goto _cgol_6
		}
		goto jump_to_p2
	_cgol_6:
		goto _cgol_2
	_cgol_5:
		if _cgo_nm && _cgo_tag != 68 {
			goto _cgol_7
		}
		_cgo_nm = false
		{
			var pCaller *struct_VdbeOp
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCaller = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(*(*int64)(unsafe.Pointer(&pIn1.u)))*24))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pCaller.p2-1)*24))
			pIn1.flags = uint16(128)
			goto _cgol_2
		}
	_cgol_7:
		if _cgo_nm && _cgo_tag != 14 {
			goto _cgol_8
		}
		_cgo_nm = false
		{
			var pcDest int32
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			pIn1.flags = uint16(4)
			pcDest = int32(*(*int64)(unsafe.Pointer(&pIn1.u)))
			*(*int64)(unsafe.Pointer(&pIn1.u)) = int64(int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24))
			pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pcDest)*24))
			goto _cgol_2
		}
	_cgol_8:
		if _cgo_nm && _cgo_tag != 69 {
			goto _cgol_9
		}
		_cgo_nm = false
		{
			pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			if int32(pIn3.flags)&1 == 0 {
				goto _cgol_2
			}
		}
	_cgol_9:
		if _cgo_nm && _cgo_tag != 70 {
			goto _cgol_10
		}
		_cgo_nm = false
		{
			var pFrame *struct_VdbeFrame
			var pcx int32
			pcx = int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24)
			if pOp.p1 == 0 && p.pFrame != nil {
				pFrame = p.pFrame
				p.pFrame = pFrame.pParent
				p.nFrame--
				sqlite3VdbeSetChanges(db, p.nChange)
				pcx = sqlite3VdbeFrameRestore(pFrame)
				if pOp.p2 == 4 {
					pcx = (*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(pcx)*24))).p2 - 1
				}
				aOp = p.aOp
				aMem = p.aMem
				pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pcx)*24))
				goto _cgol_2
			}
			p.rc = pOp.p1
			p.errorAction = uint8(pOp.p2)
			p.pc = pcx
			func() int {
				_ = 0
				return 0
			}()
			if p.rc != 0 {
				if pOp.p5 != 0 {
					var azType [4]*int8 = [4]*int8{(*int8)(unsafe.Pointer(&[9]int8{'N', 'O', 'T', ' ', 'N', 'U', 'L', 'L', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'U', 'N', 'I', 'Q', 'U', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'C', 'H', 'E', 'C', 'K', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'F', 'O', 'R', 'E', 'I', 'G', 'N', ' ', 'K', 'E', 'Y', '\x00'}))}
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[21]int8{'%', 's', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azType)))) + uintptr(int32(pOp.p5)-1)*8)))
					if *(**int8)(unsafe.Pointer(&pOp.p4)) != nil {
						p.zErrMsg = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[7]int8{'%', 'z', ':', ' ', '%', 's', '\x00'})), p.zErrMsg, *(**int8)(unsafe.Pointer(&pOp.p4)))
					}
				} else {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), *(**int8)(unsafe.Pointer(&pOp.p4)))
				}
				sqlite3_log(pOp.p1, (*int8)(unsafe.Pointer(&[24]int8{'a', 'b', 'o', 'r', 't', ' ', 'a', 't', ' ', '%', 'd', ' ', 'i', 'n', ' ', '[', '%', 's', ']', ':', ' ', '%', 's', '\x00'})), pcx, p.zSql, p.zErrMsg)
			}
			rc = sqlite3VdbeHalt(p)
			func() int {
				_ = 0
				return 0
			}()
			if rc == 5 {
				p.rc = int32(5)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				rc = func() int32 {
					if p.rc != 0 {
						return 1
					} else {
						return 101
					}
				}()
			}
			goto vdbe_return
		}
	_cgol_10:
		if _cgo_nm && _cgo_tag != 71 {
			goto _cgol_11
		}
		_cgo_nm = false
		{
			pOut = out2Prerelease(p, pOp)
			*(*int64)(unsafe.Pointer(&pOut.u)) = int64(pOp.p1)
			goto _cgol_2
		}
	_cgol_11:
		if _cgo_nm && _cgo_tag != 72 {
			goto _cgol_12
		}
		_cgo_nm = false
		{
			pOut = out2Prerelease(p, pOp)
			func() int {
				_ = 0
				return 0
			}()
			*(*int64)(unsafe.Pointer(&pOut.u)) = **(**int64)(unsafe.Pointer(&pOp.p4))
			goto _cgol_2
		}
	_cgol_12:
		if _cgo_nm && _cgo_tag != 153 {
			goto _cgol_13
		}
		_cgo_nm = false
		{
			pOut = out2Prerelease(p, pOp)
			pOut.flags = uint16(8)
			func() int {
				_ = 0
				return 0
			}()
			pOut.u.r = **(**float64)(unsafe.Pointer(&pOp.p4))
			goto _cgol_2
		}
	_cgol_13:
		if _cgo_nm && _cgo_tag != 117 {
			goto _cgol_14
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			pOut = out2Prerelease(p, pOp)
			pOp.p1 = sqlite3Strlen30(*(**int8)(unsafe.Pointer(&pOp.p4)))
			if int32(encoding) != 1 {
				rc = sqlite3VdbeMemSetStr(pOut, *(**int8)(unsafe.Pointer(&pOp.p4)), int64(-1), uint8(1), (func(unsafe.Pointer))(0))
				func() int {
					_ = 0
					return 0
				}()
				if rc != 0 {
					goto too_big
				}
				if 0 != sqlite3VdbeChangeEncoding(pOut, int32(encoding)) {
					goto no_mem
				}
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pOut.szMalloc = int32(0)
				pOut.flags |= uint16(2048)
				if int32(pOp.p4type) == -7 {
					sqlite3DbFree(db, unsafe.Pointer(*(**int8)(unsafe.Pointer(&pOp.p4))))
				}
				pOp.p4type = int8(-7)
				*(**int8)(unsafe.Pointer(&pOp.p4)) = pOut.z
				pOp.p1 = pOut.n
			}
			if pOp.p1 > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)) {
				goto too_big
			}
			pOp.opcode = uint8(73)
			func() int {
				_ = 0
				return 0
			}()
		}
	_cgol_14:
		if _cgo_nm && _cgo_tag != 73 {
			goto _cgol_15
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			pOut = out2Prerelease(p, pOp)
			pOut.flags = uint16(2 | 2048 | 512)
			pOut.z = *(**int8)(unsafe.Pointer(&pOp.p4))
			pOut.n = pOp.p1
			pOut.enc = encoding
			if pOp.p3 > 0 {
				func() int {
					_ = 0
					return 0
				}()
				pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
				func() int {
					_ = 0
					return 0
				}()
				if *(*int64)(unsafe.Pointer(&pIn3.u)) == int64(pOp.p5) {
					pOut.flags = uint16(16 | 2048 | 512)
				}
			}
			goto _cgol_2
		}
	_cgol_15:
		if _cgo_nm && _cgo_tag != 74 {
			goto _cgol_16
		}
		_cgo_nm = false
		{
			var cnt int32
			var nullFlag uint16
			pOut = out2Prerelease(p, pOp)
			cnt = pOp.p3 - pOp.p2
			func() int {
				_ = 0
				return 0
			}()
			pOut.flags = func() (_cgo_ret uint16) {
				_cgo_addr := &nullFlag
				*_cgo_addr = uint16(func() int32 {
					if pOp.p1 != 0 {
						return 1 | 256
					} else {
						return 1
					}
				}())
				return *_cgo_addr
			}()
			pOut.n = int32(0)
			for cnt > 0 {
				*(*uintptr)(unsafe.Pointer(&pOut)) += 56
				sqlite3VdbeMemSetNull(pOut)
				pOut.flags = nullFlag
				pOut.n = int32(0)
				cnt--
			}
			goto _cgol_2
		}
	_cgol_16:
		if _cgo_nm && _cgo_tag != 75 {
			goto _cgol_17
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pOut.flags = uint16(int32(pOut.flags) & ^(128|63) | 1)
			goto _cgol_2
		}
	_cgol_17:
		if _cgo_nm && _cgo_tag != 76 {
			goto _cgol_18
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			pOut = out2Prerelease(p, pOp)
			if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(&pOp.p4)))) == uintptr(unsafe.Pointer(nil)) {
				sqlite3VdbeMemSetZeroBlob(pOut, pOp.p1)
				if sqlite3VdbeMemExpandBlob(pOut) != 0 {
					goto no_mem
				}
			} else {
				sqlite3VdbeMemSetStr(pOut, *(**int8)(unsafe.Pointer(&pOp.p4)), int64(pOp.p1), uint8(0), nil)
			}
			pOut.enc = encoding
			goto _cgol_2
		}
	_cgol_18:
		if _cgo_nm && _cgo_tag != 77 {
			goto _cgol_19
		}
		_cgo_nm = false
		{
			var pVar *struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pVar = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aVar)) + uintptr(pOp.p1-1)*56))
			if sqlite3VdbeMemTooBig(pVar) != 0 {
				goto too_big
			}
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			if int32(pOut.flags)&(8192|1024) != 0 {
				sqlite3VdbeMemSetNull(pOut)
			}
			__builtin___memcpy_chk(unsafe.Pointer(pOut), unsafe.Pointer(pVar), 24, __builtin_object_size(unsafe.Pointer(pOut), 0))
			pOut.flags &= uint16(^(1024 | 4096))
			pOut.flags |= uint16(2048 | 64)
			goto _cgol_2
		}
	_cgol_19:
		if _cgo_nm && _cgo_tag != 78 {
			goto _cgol_20
		}
		_cgo_nm = false
		{
			var n int32
			var p1 int32
			var p2 int32
			n = pOp.p3
			p1 = pOp.p1
			p2 = pOp.p2
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(p1)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(p2)*56))
			for {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeMemMove(pOut, pIn1)
				if int32(pOut.flags)&4096 != 0 && sqlite3VdbeMemMakeWriteable(pOut) != 0 {
					goto no_mem
				}
				*(*uintptr)(unsafe.Pointer(&pIn1)) += 56
				*(*uintptr)(unsafe.Pointer(&pOut)) += 56
				if !(func() (_cgo_ret int32) {
					_cgo_addr := &n
					*_cgo_addr--
					return *_cgo_addr
				}() != 0) {
					break
				}
			}
			goto _cgol_2
		}
	_cgol_20:
		if _cgo_nm && _cgo_tag != 79 {
			goto _cgol_21
		}
		_cgo_nm = false
		{
			var n int32
			n = pOp.p3
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			func() int {
				_ = 0
				return 0
			}()
			for 1 != 0 {
				sqlite3VdbeMemShallowCopy(pOut, pIn1, 4096)
				if int32(pOut.flags)&4096 != 0 && sqlite3VdbeMemMakeWriteable(pOut) != 0 {
					goto no_mem
				}
				if func() (_cgo_ret int32) {
					_cgo_addr := &n
					_cgo_ret = *_cgo_addr
					*_cgo_addr--
					return
				}() == 0 {
					break
				}
				*(*uintptr)(unsafe.Pointer(&pOut)) += 56
				*(*uintptr)(unsafe.Pointer(&pIn1)) += 56
			}
			goto _cgol_2
		}
	_cgol_21:
		if _cgo_nm && _cgo_tag != 80 {
			goto _cgol_22
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeMemShallowCopy(pOut, pIn1, 4096)
			goto _cgol_2
		}
	_cgol_22:
		if _cgo_nm && _cgo_tag != 81 {
			goto _cgol_23
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			sqlite3VdbeMemSetInt64(pOut, *(*int64)(unsafe.Pointer(&pIn1.u)))
			goto _cgol_2
		}
	_cgol_23:
		if _cgo_nm && _cgo_tag != 82 {
			goto _cgol_24
		}
		_cgo_nm = false
		{
			if func() (_cgo_ret int32) {
				_cgo_addr := &rc
				*_cgo_addr = sqlite3VdbeCheckFk(p, 0)
				return *_cgo_addr
			}() != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_24:
		if _cgo_nm && _cgo_tag != 83 {
			goto _cgol_25
		}
		_cgo_nm = false
		{
			var pMem *struct_sqlite3_value
			var i int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			p.cacheCtr = p.cacheCtr + uint32(2) | uint32(1)
			pMem = func() (_cgo_ret *struct_sqlite3_value) {
				_cgo_addr := &p.pResultSet
				*_cgo_addr = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
				return *_cgo_addr
			}()
			for i = int32(0); i < pOp.p2; i++ {
				func() int {
					_ = 0
					return 0
				}()
				if int32((&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem)) + uintptr(i)*56))).flags)&4096 != 0 && sqlite3VdbeMemMakeWriteable(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem)) + uintptr(i)*56))) != 0 {
					goto no_mem
				}
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeMemNulTerminate(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pMem)) + uintptr(i)*56)))
			}
			if db.mallocFailed != 0 {
				goto no_mem
			}
			if int32(db.mTrace)&4 != 0 {
				(*(*func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(unsafe.Pointer(&db.trace)))(uint32(4), db.pTraceArg, unsafe.Pointer(p), nil)
			}
			p.pc = int32((uintptr(unsafe.Pointer(pOp))-uintptr(unsafe.Pointer(aOp)))*24) + 1
			rc = int32(100)
			goto vdbe_return
		}
	_cgol_25:
		if _cgo_nm && _cgo_tag != 111 {
			goto _cgol_26
		}
		_cgo_nm = false
		{
			var nByte int64
			var flags1 uint16
			var flags2 uint16
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			func() int {
				_ = 0
				return 0
			}()
			flags1 = pIn1.flags
			if (int32(flags1)|int32(pIn2.flags))&1 != 0 {
				sqlite3VdbeMemSetNull(pOut)
				goto _cgol_2
			}
			if int32(flags1)&(2|16) == 0 {
				if sqlite3VdbeMemStringify(pIn1, encoding, uint8(0)) != 0 {
					goto no_mem
				}
				flags1 = uint16(int32(pIn1.flags) & ^2)
			} else if int32(flags1)&16384 != 0 {
				if sqlite3VdbeMemExpandBlob(pIn1) != 0 {
					goto no_mem
				}
				flags1 = uint16(int32(pIn1.flags) & ^2)
			}
			flags2 = pIn2.flags
			if int32(flags2)&(2|16) == 0 {
				if sqlite3VdbeMemStringify(pIn2, encoding, uint8(0)) != 0 {
					goto no_mem
				}
				flags2 = uint16(int32(pIn2.flags) & ^2)
			} else if int32(flags2)&16384 != 0 {
				if sqlite3VdbeMemExpandBlob(pIn2) != 0 {
					goto no_mem
				}
				flags2 = uint16(int32(pIn2.flags) & ^2)
			}
			nByte = int64(pIn1.n + pIn2.n)
			if nByte > int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))) {
				goto too_big
			}
			if sqlite3VdbeMemGrow(pOut, int32(nByte)+3, func() int32 {
				if uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(pIn2)) {
					return 1
				} else {
					return 0
				}
			}()) != 0 {
				goto no_mem
			}
			pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 2)
			if uintptr(unsafe.Pointer(pOut)) != uintptr(unsafe.Pointer(pIn2)) {
				__builtin___memcpy_chk(unsafe.Pointer(pOut.z), unsafe.Pointer(pIn2.z), uint(pIn2.n), __builtin_object_size(unsafe.Pointer(pOut.z), 0))
				func() int {
					_ = 0
					return 0
				}()
				pIn2.flags = flags2
			}
			__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut.z)) + uintptr(pIn2.n)))), unsafe.Pointer(pIn1.z), uint(pIn1.n), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut.z)) + uintptr(pIn2.n)))), 0))
			func() int {
				_ = 0
				return 0
			}()
			pIn1.flags = flags1
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut.z)) + uintptr(nByte))) = int8(0)
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut.z)) + uintptr(nByte+int64(1)))) = int8(0)
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOut.z)) + uintptr(nByte+int64(2)))) = int8(0)
			pOut.flags |= uint16(512)
			pOut.n = int32(nByte)
			pOut.enc = encoding
			goto _cgol_2
		}
	_cgol_26:
		if _cgo_nm && _cgo_tag != 106 {
			goto _cgol_27
		}
		_cgo_nm = false
	_cgol_27:
		if _cgo_nm && _cgo_tag != 107 {
			goto _cgol_28
		}
		_cgo_nm = false
	_cgol_28:
		if _cgo_nm && _cgo_tag != 108 {
			goto _cgol_29
		}
		_cgo_nm = false
	_cgol_29:
		if _cgo_nm && _cgo_tag != 109 {
			goto _cgol_30
		}
		_cgo_nm = false
	_cgol_30:
		if _cgo_nm && _cgo_tag != 110 {
			goto _cgol_31
		}
		_cgo_nm = false
		{
			var flags uint16
			var type1 uint16
			var type2 uint16
			var iA int64
			var iB int64
			var rA float64
			var rB float64
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			type1 = numericType(pIn1)
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			type2 = numericType(pIn2)
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			flags = uint16(int32(pIn1.flags) | int32(pIn2.flags))
			if !(int32(type1)&int32(type2)&4 != 0) {
				goto _cgol_33
			}
			iA = *(*int64)(unsafe.Pointer(&pIn1.u))
			iB = *(*int64)(unsafe.Pointer(&pIn2.u))
			_cgo_nm, _cgo_tag := true, int32(pOp.opcode)
			if _cgo_nm && _cgo_tag != 106 {
				goto _cgol_34
			}
			_cgo_nm = false
			if !(sqlite3AddInt64(&iB, iA) != 0) {
				goto _cgol_35
			}
			goto fp_math
		_cgol_35:
			goto _cgol_36
		_cgol_34:
			if _cgo_nm && _cgo_tag != 107 {
				goto _cgol_37
			}
			_cgo_nm = false
			if !(sqlite3SubInt64(&iB, iA) != 0) {
				goto _cgol_38
			}
			goto fp_math
		_cgol_38:
			goto _cgol_36
		_cgol_37:
			if _cgo_nm && _cgo_tag != 108 {
				goto _cgol_39
			}
			_cgo_nm = false
			if !(sqlite3MulInt64(&iB, iA) != 0) {
				goto _cgol_40
			}
			goto fp_math
		_cgol_40:
			goto _cgol_36
		_cgol_39:
			if _cgo_nm && _cgo_tag != 109 {
				goto _cgol_41
			}
			_cgo_nm = false
			if iA == int64(0) {
				goto arithmetic_result_is_null
			}
			if !(iA == int64(-1) && iB == int64(-1)-(int64(4294967295)|int64(2147483647)<<32)) {
				goto _cgol_42
			}
			goto fp_math
		_cgol_42:
			iB /= iA
			goto _cgol_36
		_cgol_43:
			_cgo_nm = false
			{
				if iA == int64(0) {
					goto arithmetic_result_is_null
				}
				if iA == int64(-1) {
					iA = int64(1)
				}
				iB %= iA
				goto _cgol_36
			}
			goto _cgol_36
		_cgol_41:
			goto _cgol_43
		_cgol_36:
			*(*int64)(unsafe.Pointer(&pOut.u)) = iB
			pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 4)
			goto _cgol_32
		_cgol_33:
			if !(int32(flags)&1 != 0) {
				goto _cgol_45
			}
			goto arithmetic_result_is_null
			goto _cgol_44
		_cgol_45:
			;
		fp_math:
			rA = sqlite3VdbeRealValue(pIn1)
			rB = sqlite3VdbeRealValue(pIn2)
			switch int32(pOp.opcode) {
			case 106:
				rB += rA
				break
			case 107:
				rB -= rA
				break
			case 108:
				rB *= rA
				break
			case 109:
				{
					if rA == float64(0) {
						goto arithmetic_result_is_null
					}
					rB /= rA
					break
				}
			default:
				{
					iA = sqlite3VdbeIntValue(pIn1)
					iB = sqlite3VdbeIntValue(pIn2)
					if iA == int64(0) {
						goto arithmetic_result_is_null
					}
					if iA == int64(-1) {
						iA = int64(1)
					}
					rB = float64(iB % iA)
					break
				}
			}
			if sqlite3IsNaN(rB) != 0 {
				goto arithmetic_result_is_null
			}
			pOut.u.r = rB
			pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 8)
		_cgol_44:
			;
		_cgol_32:
			goto _cgol_2
		arithmetic_result_is_null:
			sqlite3VdbeMemSetNull(pOut)
			goto _cgol_2
		}
	_cgol_31:
		if _cgo_nm && _cgo_tag != 84 {
			goto _cgol_46
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			if pOp.p1 != 0 {
				sqlite3VdbeMemSetInt64(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56)), int64(0))
			}
			goto _cgol_2
		}
	_cgol_46:
		if _cgo_nm && _cgo_tag != 102 {
			goto _cgol_47
		}
		_cgo_nm = false
	_cgol_47:
		if _cgo_nm && _cgo_tag != 103 {
			goto _cgol_48
		}
		_cgo_nm = false
	_cgol_48:
		if _cgo_nm && _cgo_tag != 104 {
			goto _cgol_49
		}
		_cgo_nm = false
	_cgol_49:
		if _cgo_nm && _cgo_tag != 105 {
			goto _cgol_50
		}
		_cgo_nm = false
		{
			var iA int64
			var uA uint64
			var iB int64
			var op uint8
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			if (int32(pIn1.flags)|int32(pIn2.flags))&1 != 0 {
				sqlite3VdbeMemSetNull(pOut)
				goto _cgol_2
			}
			iA = sqlite3VdbeIntValue(pIn2)
			iB = sqlite3VdbeIntValue(pIn1)
			op = pOp.opcode
			if int32(op) == 102 {
				iA &= iB
			} else if int32(op) == 103 {
				iA |= iB
			} else if iB != int64(0) {
				func() int {
					_ = 0
					return 0
				}()
				if iB < int64(0) {
					func() int {
						_ = 0
						return 0
					}()
					op = uint8(2*104 + 1 - int32(op))
					iB = func() int64 {
						if iB > int64(-64) {
							return -iB
						} else {
							return int64(64)
						}
					}()
				}
				if iB >= int64(64) {
					iA = int64(func() int32 {
						if iA >= int64(0) || int32(op) == 104 {
							return 0
						} else {
							return -1
						}
					}())
				} else {
					__builtin___memcpy_chk(unsafe.Pointer(&uA), unsafe.Pointer(&iA), 8, __builtin_object_size(unsafe.Pointer(&uA), 0))
					if int32(op) == 104 {
						uA <<= iB
					} else {
						uA >>= iB
						if iA < int64(0) {
							uA |= (uint64(4294967295)<<32 | uint64(4294967295)) << (int64(64) - iB)
						}
					}
					__builtin___memcpy_chk(unsafe.Pointer(&iA), unsafe.Pointer(&uA), 8, __builtin_object_size(unsafe.Pointer(&iA), 0))
				}
			}
			*(*int64)(unsafe.Pointer(&pOut.u)) = iA
			pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 4)
			goto _cgol_2
		}
	_cgol_50:
		if _cgo_nm && _cgo_tag != 85 {
			goto _cgol_51
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			sqlite3VdbeMemIntegerify(pIn1)
			*(*int64)(unsafe.Pointer(&pIn1.u)) += int64(pOp.p2)
			goto _cgol_2
		}
	_cgol_51:
		if _cgo_nm && _cgo_tag != 15 {
			goto _cgol_52
		}
		_cgo_nm = false
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		if !(int32(pIn1.flags)&4 == 0) {
			goto _cgol_53
		}
		applyAffinity(pIn1, int8(67), encoding)
		if !(int32(pIn1.flags)&4 == 0) {
			goto _cgol_54
		}
		if !(pOp.p2 == 0) {
			goto _cgol_56
		}
		rc = int32(20)
		goto abort_due_to_error
		goto _cgol_55
	_cgol_56:
		goto jump_to_p2
	_cgol_55:
		;
	_cgol_54:
		;
	_cgol_53:
		pIn1.flags = uint16(int32(pIn1.flags) & ^(49599|16384) | 4)
		goto _cgol_2
	_cgol_52:
		if _cgo_nm && _cgo_tag != 86 {
			goto _cgol_57
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			if int32(pIn1.flags)&(4|32) != 0 {
				sqlite3VdbeMemRealify(pIn1)
			}
			goto _cgol_2
		}
	_cgol_57:
		if _cgo_nm && _cgo_tag != 87 {
			goto _cgol_58
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			rc = func() int32 {
				if int32(pIn1.flags)&16384 != 0 {
					return sqlite3VdbeMemExpandBlob(pIn1)
				} else {
					return 0
				}
			}()
			if rc != 0 {
				goto abort_due_to_error
			}
			rc = sqlite3VdbeMemCast(pIn1, uint8(pOp.p2), encoding)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_58:
		if _cgo_nm && _cgo_tag != 53 {
			goto _cgol_59
		}
		_cgo_nm = false
	_cgol_59:
		if _cgo_nm && _cgo_tag != 52 {
			goto _cgol_60
		}
		_cgo_nm = false
	_cgol_60:
		if _cgo_nm && _cgo_tag != 56 {
			goto _cgol_61
		}
		_cgo_nm = false
	_cgol_61:
		if _cgo_nm && _cgo_tag != 55 {
			goto _cgol_62
		}
		_cgo_nm = false
	_cgol_62:
		if _cgo_nm && _cgo_tag != 54 {
			goto _cgol_63
		}
		_cgo_nm = false
	_cgol_63:
		if _cgo_nm && _cgo_tag != 57 {
			goto _cgol_64
		}
		_cgo_nm = false
		res_cgo65 = 0
		res2_cgo66 = 0
		affinity_cgo67 = 0
		flags1_cgo68 = 0
		flags3_cgo69 = 0
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		flags1_cgo68 = pIn1.flags
		flags3_cgo69 = pIn3.flags
		if !(int32(flags1_cgo68)&int32(flags3_cgo69)&4 != 0) {
			goto _cgol_70
		}
		func() int {
			_ = 0
			return 0
		}()
		if !(*(*int64)(unsafe.Pointer(&pIn3.u)) > *(*int64)(unsafe.Pointer(&pIn1.u))) {
			goto _cgol_72
		}
		iCompare = int32(1)
		if !(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3aGTb)) + uintptr(pOp.opcode))) != 0) {
			goto _cgol_73
		}
		goto jump_to_p2
	_cgol_73:
		goto _cgol_71
	_cgol_72:
		if !(*(*int64)(unsafe.Pointer(&pIn3.u)) < *(*int64)(unsafe.Pointer(&pIn1.u))) {
			goto _cgol_75
		}
		iCompare = int32(-1)
		if !(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3aLTb)) + uintptr(pOp.opcode))) != 0) {
			goto _cgol_76
		}
		goto jump_to_p2
	_cgol_76:
		goto _cgol_74
	_cgol_75:
		iCompare = int32(0)
		if !(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3aEQb)) + uintptr(pOp.opcode))) != 0) {
			goto _cgol_77
		}
		goto jump_to_p2
	_cgol_77:
		;
	_cgol_74:
		;
	_cgol_71:
		goto _cgol_70
	_cgol_70:
		if !((int32(flags1_cgo68)|int32(flags3_cgo69))&1 != 0) {
			goto _cgol_79
		}
		if !(int32(pOp.p5)&128 != 0) {
			goto _cgol_81
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if int32(flags1_cgo68)&int32(flags3_cgo69)&1 != 0 && int32(flags3_cgo69)&256 == 0 {
			res_cgo65 = int32(0)
		} else {
			res_cgo65 = func() int32 {
				if int32(flags3_cgo69)&1 != 0 {
					return -1
				} else {
					return 1
				}
			}()
		}
		goto _cgol_80
	_cgol_81:
		iCompare = int32(1)
		if !(int32(pOp.p5)&16 != 0) {
			goto _cgol_82
		}
		goto jump_to_p2
	_cgol_82:
		goto _cgol_80
	_cgol_80:
		goto _cgol_78
	_cgol_79:
		affinity_cgo67 = int8(int32(pOp.p5) & 71)
		if int32(affinity_cgo67) >= 67 {
			if (int32(flags1_cgo68)|int32(flags3_cgo69))&2 != 0 {
				if int32(flags1_cgo68)&(4|32|8|2) == 2 {
					applyNumericAffinity(pIn1, 0)
					flags3_cgo69 = pIn3.flags
				}
				if int32(flags3_cgo69)&(4|32|8|2) == 2 {
					applyNumericAffinity(pIn3, 0)
				}
			}
		} else if int32(affinity_cgo67) == 66 {
			if int32(flags1_cgo68)&2 == 0 && int32(flags1_cgo68)&(4|8|32) != 0 {
				sqlite3VdbeMemStringify(pIn1, encoding, uint8(1))
				flags1_cgo68 = uint16(int32(pIn1.flags) & ^49599 | int32(flags1_cgo68)&49599)
				if uintptr(unsafe.Pointer(pIn1)) == uintptr(unsafe.Pointer(pIn3)) {
					flags3_cgo69 = uint16(int32(flags1_cgo68) | 2)
				}
			}
			if int32(flags3_cgo69)&2 == 0 && int32(flags3_cgo69)&(4|8|32) != 0 {
				sqlite3VdbeMemStringify(pIn3, encoding, uint8(1))
				flags3_cgo69 = uint16(int32(pIn3.flags) & ^49599 | int32(flags3_cgo69)&49599)
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		res_cgo65 = sqlite3MemCompare(pIn3, pIn1, *(**struct_CollSeq)(unsafe.Pointer(&pOp.p4)))
	_cgol_78:
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if res_cgo65 < 0 {
			res2_cgo66 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3aLTb)) + uintptr(pOp.opcode))))
		} else if res_cgo65 == 0 {
			res2_cgo66 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3aEQb)) + uintptr(pOp.opcode))))
		} else {
			res2_cgo66 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3aGTb)) + uintptr(pOp.opcode))))
		}
		iCompare = res_cgo65
		func() int {
			_ = 0
			return 0
		}()
		pIn3.flags = flags3_cgo69
		func() int {
			_ = 0
			return 0
		}()
		pIn1.flags = flags1_cgo68
		if !(res2_cgo66 != 0) {
			goto _cgol_83
		}
		goto jump_to_p2
	_cgol_83:
		goto _cgol_2
	_cgol_64:
		if _cgo_nm && _cgo_tag != 58 {
			goto _cgol_84
		}
		_cgo_nm = false
		if !(iCompare == 0) {
			goto _cgol_85
		}
		goto jump_to_p2
	_cgol_85:
		goto _cgol_2
	_cgol_84:
		if _cgo_nm && _cgo_tag != 88 {
			goto _cgol_86
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		}
	_cgol_86:
		if _cgo_nm && _cgo_tag != 89 {
			goto _cgol_87
		}
		_cgo_nm = false
		{
			var n int32
			var i int32
			var p1 int32
			var p2 int32
			var pKeyInfo *struct_KeyInfo
			var idx uint32
			var pColl *struct_CollSeq
			var bRev int32
			var aPermute *uint32
			if int32(pOp.p5)&1 == 0 {
				aPermute = (*uint32)(nil)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				aPermute = (*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**uint32)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) - uintptr(- -1)*24))).p4)))) + uintptr(1)*4))
				func() int {
					_ = 0
					return 0
				}()
			}
			n = pOp.p3
			pKeyInfo = *(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			p1 = pOp.p1
			p2 = pOp.p2
			for i = int32(0); i < n; i++ {
				idx = func() uint32 {
					if aPermute != nil {
						return *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aPermute)) + uintptr(i)*4))
					} else {
						return uint32(i)
					}
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pColl = *(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(i)*8))
				bRev = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyInfo.aSortFlags)) + uintptr(i)))) & 1
				iCompare = sqlite3MemCompare(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(uint32(p1)+idx)*56)), &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(uint32(p2)+idx)*56)), pColl)
				if iCompare != 0 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyInfo.aSortFlags)) + uintptr(i))))&2 != 0 && (int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(uint32(p1)+idx)*56))).flags)&1 != 0 || int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(uint32(p2)+idx)*56))).flags)&1 != 0) {
						iCompare = -iCompare
					}
					if bRev != 0 {
						iCompare = -iCompare
					}
					break
				}
			}
			goto _cgol_2
		}
	_cgol_87:
		if _cgo_nm && _cgo_tag != 16 {
			goto _cgol_88
		}
		_cgo_nm = false
		{
			if iCompare < 0 {
				pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pOp.p1-1)*24))
			} else if iCompare == 0 {
				pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pOp.p2-1)*24))
			} else {
				pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(pOp.p3-1)*24))
			}
			goto _cgol_2
		}
	_cgol_88:
		if _cgo_nm && _cgo_tag != 44 {
			goto _cgol_89
		}
		_cgo_nm = false
	_cgol_89:
		if _cgo_nm && _cgo_tag != 43 {
			goto _cgol_90
		}
		_cgo_nm = false
		{
			var v1 int32
			var v2 int32
			v1 = sqlite3VdbeBooleanValue(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56)), 2)
			v2 = sqlite3VdbeBooleanValue(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56)), 2)
			if int32(pOp.opcode) == 44 {
				var and_logic [9]uint8 = [9]uint8{uint8(0), uint8(0), uint8(0), uint8(0), uint8(1), uint8(2), uint8(0), uint8(2), uint8(2)}
				v1 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&and_logic)))) + uintptr(v1*3+v2))))
			} else {
				var or_logic [9]uint8 = [9]uint8{uint8(0), uint8(1), uint8(2), uint8(1), uint8(1), uint8(1), uint8(2), uint8(1), uint8(2)}
				v1 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&or_logic)))) + uintptr(v1*3+v2))))
			}
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			if v1 == 2 {
				pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 1)
			} else {
				*(*int64)(unsafe.Pointer(&pOut.u)) = int64(v1)
				pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 4)
			}
			goto _cgol_2
		}
	_cgol_90:
		if _cgo_nm && _cgo_tag != 90 {
			goto _cgol_91
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeMemSetInt64(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56)), int64(sqlite3VdbeBooleanValue(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56)), pOp.p3)^*(*int32)(unsafe.Pointer(&pOp.p4))))
			goto _cgol_2
		}
	_cgol_91:
		if _cgo_nm && _cgo_tag != 19 {
			goto _cgol_92
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			if int32(pIn1.flags)&1 == 0 {
				sqlite3VdbeMemSetInt64(pOut, func() int64 {
					if !(sqlite3VdbeBooleanValue(pIn1, 0) != 0) {
						return 1
					} else {
						return 0
					}
				}())
			} else {
				sqlite3VdbeMemSetNull(pOut)
			}
			goto _cgol_2
		}
	_cgol_92:
		if _cgo_nm && _cgo_tag != 114 {
			goto _cgol_93
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			sqlite3VdbeMemSetNull(pOut)
			if int32(pIn1.flags)&1 == 0 {
				pOut.flags = uint16(4)
				*(*int64)(unsafe.Pointer(&pOut.u)) = ^sqlite3VdbeIntValue(pIn1)
			}
			goto _cgol_2
		}
	_cgol_93:
		if _cgo_nm && _cgo_tag != 17 {
			goto _cgol_94
		}
		_cgo_nm = false
		iAddr_cgo95 = 0
		func() int {
			_ = 0
			return 0
		}()
		if !(p.pFrame != nil) {
			goto _cgol_97
		}
		iAddr_cgo95 = uint32(int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(p.aOp))) * 24))
		if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.pFrame.aOnce)) + uintptr(iAddr_cgo95/uint32(8)))))&int32(1<<(iAddr_cgo95&uint32(7))) != 0) {
			goto _cgol_98
		}
		goto jump_to_p2
	_cgol_98:
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.pFrame.aOnce)) + uintptr(iAddr_cgo95/uint32(8)))) |= uint8(1 << (iAddr_cgo95 & uint32(7)))
		goto _cgol_96
	_cgol_97:
		if !((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(0)*24))).p1 == pOp.p1) {
			goto _cgol_99
		}
		goto jump_to_p2
	_cgol_99:
		;
	_cgol_96:
		pOp.p1 = (*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(0)*24))).p1
		goto _cgol_2
	_cgol_94:
		if _cgo_nm && _cgo_tag != 18 {
			goto _cgol_100
		}
		_cgo_nm = false
		c_cgo101 = 0
		c_cgo101 = sqlite3VdbeBooleanValue(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56)), pOp.p3)
		if !(c_cgo101 != 0) {
			goto _cgol_102
		}
		goto jump_to_p2
	_cgol_102:
		goto _cgol_2
	_cgol_100:
		if _cgo_nm && _cgo_tag != 20 {
			goto _cgol_103
		}
		_cgo_nm = false
		c_cgo104 = 0
		c_cgo104 = func() int32 {
			if !(sqlite3VdbeBooleanValue(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56)), func() int32 {
				if !(pOp.p3 != 0) {
					return 1
				} else {
					return 0
				}
			}()) != 0) {
				return 1
			} else {
				return 0
			}
		}()
		if !(c_cgo104 != 0) {
			goto _cgol_105
		}
		goto jump_to_p2
	_cgol_105:
		goto _cgol_2
	_cgol_103:
		if _cgo_nm && _cgo_tag != 50 {
			goto _cgol_106
		}
		_cgo_nm = false
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		if !(int32(pIn1.flags)&1 != 0) {
			goto _cgol_107
		}
		goto jump_to_p2
	_cgol_107:
		goto _cgol_2
	_cgol_106:
		if _cgo_nm && _cgo_tag != 21 {
			goto _cgol_108
		}
		_cgo_nm = false
		doTheJump_cgo109 = 0
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		doTheJump_cgo109 = func() int32 {
			if int32(pIn1.flags)&1 != 0 || sqlite3_value_type(pIn1) == pOp.p3 {
				return 1
			} else {
				return 0
			}
		}()
		if !(doTheJump_cgo109 != 0) {
			goto _cgol_110
		}
		goto jump_to_p2
	_cgol_110:
		goto _cgol_2
	_cgol_108:
		if _cgo_nm && _cgo_tag != 91 {
			goto _cgol_111
		}
		_cgo_nm = false
		{
			if int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))).flags)&1 != 0 || int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))).flags)&1 != 0 {
				sqlite3VdbeMemSetNull((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56)))
			} else {
				sqlite3VdbeMemSetInt64((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem))+uintptr(pOp.p2)*56)), int64(0))
			}
			goto _cgol_2
		}
	_cgol_111:
		if _cgo_nm && _cgo_tag != 51 {
			goto _cgol_112
		}
		_cgo_nm = false
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		if !(int32(pIn1.flags)&1 == 0) {
			goto _cgol_113
		}
		goto jump_to_p2
	_cgol_113:
		goto _cgol_2
	_cgol_112:
		if _cgo_nm && _cgo_tag != 22 {
			goto _cgol_114
		}
		_cgo_nm = false
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if !((*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))).nullRow != 0) {
			goto _cgol_115
		}
		sqlite3VdbeMemSetNull((*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56)))
		goto jump_to_p2
	_cgol_115:
		goto _cgol_2
	_cgol_114:
		if _cgo_nm && _cgo_tag != 93 {
			goto _cgol_116
		}
		_cgo_nm = false
		{
			var p2 uint32
			var pC *struct_VdbeCursor
			var pCrsr *struct_BtCursor
			var aOffset *uint32
			var len int32
			var i int32
			var pDest *struct_sqlite3_value
			var sMem struct_sqlite3_value
			var zData *uint8
			var zHdr *uint8
			var zEndHdr *uint8
			var offset64 uint64
			var t uint32
			var pReg *struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			p2 = uint32(pOp.p2)
			rc = sqlite3VdbeCursorMoveto(&pC, &p2)
			if rc != 0 {
				goto abort_due_to_error
			}
			func() int {
				_ = 0
				return 0
			}()
			pDest = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			aOffset = pC.aOffset
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if !(pC.cacheStatus != p.cacheCtr) {
				goto _cgol_117
			}
			if pC.nullRow != 0 {
				if int32(pC.eCurType) == 3 {
					func() int {
						_ = 0
						return 0
					}()
					pReg = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pC.seekResult)*56))
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					pC.payloadSize = func() (_cgo_ret uint32) {
						_cgo_addr := &pC.szRow
						*_cgo_addr = uint32(pReg.n)
						return *_cgo_addr
					}()
					pC.aRow = (*uint8)(unsafe.Pointer(pReg.z))
				} else {
					sqlite3VdbeMemSetNull(pDest)
					goto op_column_out
				}
			} else {
				pCrsr = pC.uc.pCursor
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pC.payloadSize = sqlite3BtreePayloadSize(pCrsr)
				pC.aRow = (*uint8)(sqlite3BtreePayloadFetch(pCrsr, &pC.szRow))
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if pC.payloadSize > uint32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))) {
					goto too_big
				}
			}
			pC.cacheStatus = p.cacheCtr
			pC.iHdrOffset = uint32(uint8(func() int32 {
				if int32(*pC.aRow) < int32(uint8(128)) {
					return int32(func() int {
						*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4)) = uint32(*pC.aRow)
						return 1
					}())
				} else {
					return int32(sqlite3GetVarint32(pC.aRow, (*uint32)(unsafe.Pointer(&*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4))))))
				}
			}()))
			pC.nHdrParsed = uint16(0)
			if !(pC.szRow < *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4))) {
				goto _cgol_119
			}
			pC.aRow = (*uint8)(nil)
			pC.szRow = uint32(0)
			if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4)) > uint32(98307) || *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4)) > pC.payloadSize {
				goto op_column_corrupt
			}
			goto _cgol_118
		_cgol_119:
			zData = pC.aRow
			func() int {
				_ = 0
				return 0
			}()
			goto op_column_read_header
		_cgol_118:
			;
		_cgol_117:
			if !(uint32(pC.nHdrParsed) <= p2) {
				goto _cgol_121
			}
			if !(pC.iHdrOffset < *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4))) {
				goto _cgol_123
			}
			if uintptr(unsafe.Pointer(pC.aRow)) == uintptr(unsafe.Pointer(nil)) {
				__builtin___memset_chk(unsafe.Pointer(&sMem), 0, 56, __builtin_object_size(unsafe.Pointer(&sMem), 0))
				rc = sqlite3VdbeMemFromBtreeZeroOffset(pC.uc.pCursor, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4)), &sMem)
				if rc != 0 {
					goto abort_due_to_error
				}
				zData = (*uint8)(unsafe.Pointer(sMem.z))
			} else {
				zData = pC.aRow
			}
		op_column_read_header:
			i = int32(pC.nHdrParsed)
			offset64 = uint64(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(i)*4)))
			zHdr = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zData)) + uintptr(pC.iHdrOffset)))
			zEndHdr = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zData)) + uintptr(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4)))))
			for {
				if func() (_cgo_ret uint32) {
					_cgo_addr := &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pC.aType)))) + uintptr(i)*4))
					*_cgo_addr = func() (_cgo_ret uint32) {
						_cgo_addr := &t
						*_cgo_addr = uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHdr)) + uintptr(0))))
						return *_cgo_addr
					}()
					return *_cgo_addr
				}() < uint32(128) {
					*(*uintptr)(unsafe.Pointer(&zHdr))++
					offset64 += uint64(sqlite3VdbeOneByteSerialTypeLen(uint8(t)))
				} else {
					*(*uintptr)(unsafe.Pointer(&zHdr)) += uintptr(int32(sqlite3GetVarint32(zHdr, &t)))
					*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pC.aType)))) + uintptr(i)*4)) = t
					offset64 += uint64(sqlite3VdbeSerialTypeLen(t))
				}
				*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &i
					*_cgo_addr++
					return *_cgo_addr
				}())*4)) = uint32(offset64 & uint64(4294967295))
				if !(uint32(i) <= p2 && uintptr(unsafe.Pointer(zHdr)) < uintptr(unsafe.Pointer(zEndHdr))) {
					break
				}
			}
			if uintptr(unsafe.Pointer(zHdr)) >= uintptr(unsafe.Pointer(zEndHdr)) && (uintptr(unsafe.Pointer(zHdr)) > uintptr(unsafe.Pointer(zEndHdr)) || offset64 != uint64(pC.payloadSize)) || offset64 > uint64(pC.payloadSize) {
				if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(0)*4)) == uint32(0) {
					i = int32(0)
					zHdr = zEndHdr
				} else {
					if uintptr(unsafe.Pointer(pC.aRow)) == uintptr(unsafe.Pointer(nil)) {
						sqlite3VdbeMemRelease(&sMem)
					}
					goto op_column_corrupt
				}
			}
			pC.nHdrParsed = uint16(i)
			pC.iHdrOffset = uint32(uintptr(unsafe.Pointer(zHdr)) - uintptr(unsafe.Pointer(zData)))
			if uintptr(unsafe.Pointer(pC.aRow)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3VdbeMemRelease(&sMem)
			}
			goto _cgol_122
		_cgol_123:
			t = uint32(0)
		_cgol_122:
			if uint32(pC.nHdrParsed) <= p2 {
				if int32(pOp.p4type) == -11 {
					sqlite3VdbeMemShallowCopy(pDest, *(**struct_sqlite3_value)(unsafe.Pointer(&pOp.p4)), 2048)
				} else {
					sqlite3VdbeMemSetNull(pDest)
				}
				goto op_column_out
			}
			goto _cgol_120
		_cgol_121:
			t = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pC.aType)))) + uintptr(p2)*4))
		_cgol_120:
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(pDest.flags)&(8192|1024) != 0 {
				sqlite3VdbeMemSetNull(pDest)
			}
			func() int {
				_ = 0
				return 0
			}()
			if pC.szRow >= *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(p2+uint32(1))*4)) {
				zData = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pC.aRow)) + uintptr(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(p2)*4)))))
				if t < uint32(12) {
					sqlite3VdbeSerialGet(zData, t, pDest)
				} else {
					var aFlag [2]uint16 = [2]uint16{uint16(16), uint16(2 | 512)}
					pDest.n = func() (_cgo_ret int32) {
						_cgo_addr := &len
						*_cgo_addr = int32((t - uint32(12)) / uint32(2))
						return *_cgo_addr
					}()
					pDest.enc = encoding
					if pDest.szMalloc < len+2 {
						pDest.flags = uint16(1)
						if sqlite3VdbeMemGrow(pDest, len+2, 0) != 0 {
							goto no_mem
						}
					} else {
						pDest.z = pDest.zMalloc
					}
					__builtin___memcpy_chk(unsafe.Pointer(pDest.z), unsafe.Pointer(zData), uint(len), __builtin_object_size(unsafe.Pointer(pDest.z), 0))
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest.z)) + uintptr(len))) = int8(0)
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest.z)) + uintptr(len+1))) = int8(0)
					pDest.flags = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aFlag)))) + uintptr(t&uint32(1))*2))
				}
			} else {
				pDest.enc = encoding
				if int32(pOp.p5)&(64|128) != 0 && (t >= uint32(12) && t&uint32(1) == uint32(0) || int32(pOp.p5)&128 != 0) || func() (_cgo_ret int32) {
					_cgo_addr := &len
					*_cgo_addr = int32(sqlite3VdbeSerialTypeLen(t))
					return *_cgo_addr
				}() == 0 {
					sqlite3VdbeSerialGet((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))), t, pDest)
				} else {
					rc = sqlite3VdbeMemFromBtree(pC.uc.pCursor, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aOffset)) + uintptr(p2)*4)), uint32(len), pDest)
					if rc != 0 {
						goto abort_due_to_error
					}
					sqlite3VdbeSerialGet((*uint8)(unsafe.Pointer(pDest.z)), t, pDest)
					pDest.flags &= uint16(^4096)
				}
			}
		op_column_out:
			goto _cgol_2
		op_column_corrupt:
			if (*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p3 > 0 {
				pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p3-1)*24))
				goto _cgol_2
			} else {
				rc = sqlite3CorruptError(90323)
				goto abort_due_to_error
			}
		}
	_cgol_116:
		if _cgo_nm && _cgo_tag != 94 {
			goto _cgol_124
		}
		_cgo_nm = false
		{
			var pTab *struct_Table
			var aCol *struct_Column
			var i int32
			func() int {
				_ = 0
				return 0
			}()
			pTab = *(**struct_Table)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			aCol = pTab.aCol
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			for i = int32(0); i < int32(pTab.nCol); i++ {
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(i)*20))).colFlags)&96 != 0 {
					if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(i)*20))).colFlags)&32 != 0 {
						continue
					}
					if pOp.p3 != 0 {
						*(*uintptr)(unsafe.Pointer(&pIn1)) += 56
						continue
					}
				}
				func() int {
					_ = 0
					return 0
				}()
				applyAffinity(pIn1, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(i)*20))).affinity, encoding)
				if int32(pIn1.flags)&1 == 0 {
					switch int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(i)*20))).Xbf_0 >> 4 & 15) {
					case 2:
						{
							if int32(pIn1.flags)&16 == 0 {
								goto vdbe_type_error
							}
							break
						}
					case 4:
						fallthrough
					case 3:
						{
							if int32(pIn1.flags)&4 == 0 {
								goto vdbe_type_error
							}
							break
						}
					case 6:
						{
							if int32(pIn1.flags)&2 == 0 {
								goto vdbe_type_error
							}
							break
						}
					case 5:
						{
							if int32(pIn1.flags)&4 != 0 {
								if *(*int64)(unsafe.Pointer(&pIn1.u)) <= 140737488355327 && *(*int64)(unsafe.Pointer(&pIn1.u)) >= -140737488355328 {
									pIn1.flags |= uint16(32)
									pIn1.flags &= uint16(^4)
								} else {
									pIn1.u.r = float64(*(*int64)(unsafe.Pointer(&pIn1.u)))
									pIn1.flags |= uint16(8)
									pIn1.flags &= uint16(^4)
								}
							} else if int32(pIn1.flags)&(8|32) == 0 {
								goto vdbe_type_error
							}
							break
						}
					default:
						{
							break
						}
					}
				}
				*(*uintptr)(unsafe.Pointer(&pIn1)) += 56
			}
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		vdbe_type_error:
			sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[41]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 's', 't', 'o', 'r', 'e', ' ', '%', 's', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'i', 'n', ' ', '%', 's', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '%', 's', '.', '%', 's', '\x00'})), vdbeMemTypeName(pIn1), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&sqlite3StdType)))) + uintptr(int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(i)*20))).Xbf_0>>4&15)-1)*8)), pTab.zName, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(i)*20))).zCnName)
			rc = int32(19 | 12<<8)
			goto abort_due_to_error
		}
	_cgol_124:
		if _cgo_nm && _cgo_tag != 95 {
			goto _cgol_125
		}
		_cgo_nm = false
		{
			var zAffinity *int8
			zAffinity = *(**int8)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			for 1 != 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				applyAffinity(pIn1, *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAffinity)) + uintptr(0))), encoding)
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAffinity)) + uintptr(0)))) == 69 && int32(pIn1.flags)&4 != 0 {
					if *(*int64)(unsafe.Pointer(&pIn1.u)) <= 140737488355327 && *(*int64)(unsafe.Pointer(&pIn1.u)) >= -140737488355328 {
						pIn1.flags |= uint16(32)
						pIn1.flags &= uint16(^4)
					} else {
						pIn1.u.r = float64(*(*int64)(unsafe.Pointer(&pIn1.u)))
						pIn1.flags |= uint16(8)
						pIn1.flags &= uint16(^4)
					}
				}
				*(*uintptr)(unsafe.Pointer(&zAffinity))++
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAffinity)) + uintptr(0)))) == 0 {
					break
				}
				*(*uintptr)(unsafe.Pointer(&pIn1)) += 56
			}
			goto _cgol_2
		}
	_cgol_125:
		if _cgo_nm && _cgo_tag != 96 {
			goto _cgol_126
		}
		_cgo_nm = false
		{
			var pRec *struct_sqlite3_value
			var nData uint64
			var nHdr int32
			var nByte int64
			var nZero int64
			var nVarint int32
			var serial_type uint32
			var pData0 *struct_sqlite3_value
			var pLast *struct_sqlite3_value
			var nField int32
			var zAffinity *int8
			var file_format int32
			var len uint32
			var zHdr *uint8
			var zPayload *uint8
			nData = uint64(0)
			nHdr = int32(0)
			nZero = int64(0)
			nField = pOp.p1
			zAffinity = *(**int8)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			pData0 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(nField)*56))
			nField = pOp.p2
			pLast = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pData0)) + uintptr(nField-1)*56))
			file_format = int32(p.minWriteFileFormat)
			func() int {
				_ = 0
				return 0
			}()
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			func() int {
				_ = 0
				return 0
			}()
			if zAffinity != nil {
				pRec = pData0
				for {
					applyAffinity(pRec, *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAffinity)) + uintptr(0))), encoding)
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAffinity)) + uintptr(0)))) == 69 && int32(pRec.flags)&4 != 0 {
						pRec.flags |= uint16(32)
						pRec.flags &= uint16(^4)
					}
					*(*uintptr)(unsafe.Pointer(&zAffinity))++
					*(*uintptr)(unsafe.Pointer(&pRec)) += 56
					func() int {
						_ = 0
						return 0
					}()
					if !(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAffinity)) + uintptr(0))) != 0) {
						break
					}
				}
			}
			pRec = pLast
			for {
				func() int {
					_ = 0
					return 0
				}()
				if int32(pRec.flags)&1 != 0 {
					if int32(pRec.flags)&16384 != 0 {
						func() int {
							_ = 0
							return 0
						}()
						pRec.uTemp = uint32(10)
					} else {
						pRec.uTemp = uint32(0)
					}
					nHdr++
				} else if int32(pRec.flags)&(4|32) != 0 {
					var i int64 = *(*int64)(unsafe.Pointer(&pRec.u))
					var uu uint64
					if i < int64(0) {
						uu = uint64(^i)
					} else {
						uu = uint64(i)
					}
					nHdr++
					if uu <= uint64(127) {
						if i&int64(1) == i && file_format >= 4 {
							pRec.uTemp = uint32(8) + uint32(uu)
						} else {
							nData++
							pRec.uTemp = uint32(1)
						}
					} else if uu <= uint64(32767) {
						nData += uint64(2)
						pRec.uTemp = uint32(2)
					} else if uu <= uint64(8388607) {
						nData += uint64(3)
						pRec.uTemp = uint32(3)
					} else if uu <= uint64(2147483647) {
						nData += uint64(4)
						pRec.uTemp = uint32(4)
					} else if uu <= uint64(140737488355327) {
						nData += uint64(6)
						pRec.uTemp = uint32(5)
					} else {
						nData += uint64(8)
						if int32(pRec.flags)&32 != 0 {
							pRec.u.r = float64(*(*int64)(unsafe.Pointer(&pRec.u)))
							pRec.flags &= uint16(^32)
							pRec.flags |= uint16(8)
							pRec.uTemp = uint32(7)
						} else {
							pRec.uTemp = uint32(6)
						}
					}
				} else if int32(pRec.flags)&8 != 0 {
					nHdr++
					nData += uint64(8)
					pRec.uTemp = uint32(7)
				} else {
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					len = uint32(pRec.n)
					serial_type = len*uint32(2) + uint32(12) + func() uint32 {
						if int32(pRec.flags)&2 != 0 {
							return 1
						} else {
							return 0
						}
					}()
					if int32(pRec.flags)&16384 != 0 {
						serial_type += uint32(*(*int32)(unsafe.Pointer(&pRec.u)) * 2)
						if nData != 0 {
							if sqlite3VdbeMemExpandBlob(pRec) != 0 {
								goto no_mem
							}
							len += uint32(*(*int32)(unsafe.Pointer(&pRec.u)))
						} else {
							nZero += int64(*(*int32)(unsafe.Pointer(&pRec.u)))
						}
					}
					nData += uint64(len)
					nHdr += sqlite3VarintLen(uint64(serial_type))
					pRec.uTemp = serial_type
				}
				if uintptr(unsafe.Pointer(pRec)) == uintptr(unsafe.Pointer(pData0)) {
					break
				}
				*(*uintptr)(unsafe.Pointer(&pRec)) -= 56
				if false {
					break
				}
			}
			if nHdr <= 126 {
				nHdr += int32(1)
			} else {
				nVarint = sqlite3VarintLen(uint64(nHdr))
				nHdr += nVarint
				if nVarint < sqlite3VarintLen(uint64(nHdr)) {
					nHdr++
				}
			}
			nByte = int64(uint64(nHdr) + nData)
			if nByte+nZero <= int64(pOut.szMalloc) {
				pOut.z = pOut.zMalloc
			} else {
				if nByte+nZero > int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))) {
					goto too_big
				}
				if sqlite3VdbeMemClearAndResize(pOut, int32(nByte)) != 0 {
					goto no_mem
				}
			}
			pOut.n = int32(nByte)
			pOut.flags = uint16(16)
			if nZero != 0 {
				*(*int32)(unsafe.Pointer(&pOut.u)) = int32(nZero)
				pOut.flags |= uint16(16384)
			}
			zHdr = (*uint8)(unsafe.Pointer(pOut.z))
			zPayload = (*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHdr)) + uintptr(nHdr)))
			*(*uintptr)(unsafe.Pointer(&zHdr)) += uintptr(int32(uint8(func() int32 {
				if uint32(nHdr) < uint32(128) {
					return int32(func() int {
						*zHdr = uint8(nHdr)
						return 1
					}())
				} else {
					return sqlite3PutVarint(zHdr, uint64(nHdr))
				}
			}())))
			func() int {
				_ = 0
				return 0
			}()
			pRec = pData0
			for {
				serial_type = pRec.uTemp
				*(*uintptr)(unsafe.Pointer(&zHdr)) += uintptr(int32(uint8(func() int32 {
					if uint32(serial_type) < uint32(128) {
						return int32(func() int {
							*zHdr = uint8(serial_type)
							return 1
						}())
					} else {
						return sqlite3PutVarint(zHdr, uint64(serial_type))
					}
				}())))
				*(*uintptr)(unsafe.Pointer(&zPayload)) += uintptr(sqlite3VdbeSerialPut(zPayload, pRec, serial_type))
				if !(uintptr(unsafe.Pointer(func() (_cgo_ret *struct_sqlite3_value) {
					_cgo_addr := &pRec
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return *_cgo_addr
				}())) <= uintptr(unsafe.Pointer(pLast))) {
					break
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		}
	_cgol_126:
		if _cgo_nm && _cgo_tag != 97 {
			goto _cgol_127
		}
		_cgo_nm = false
		nEntry_cgo128 = 0
		pCrsr_cgo129 = nil
		func() int {
			_ = 0
			return 0
		}()
		pCrsr_cgo129 = (*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))).uc.pCursor
		func() int {
			_ = 0
			return 0
		}()
		if pOp.p3 != 0 {
			nEntry_cgo128 = sqlite3BtreeRowCountEst(pCrsr_cgo129)
		} else {
			nEntry_cgo128 = int64(0)
			rc = sqlite3BtreeCount(db, pCrsr_cgo129, &nEntry_cgo128)
			if rc != 0 {
				goto abort_due_to_error
			}
		}
		pOut = out2Prerelease(p, pOp)
		*(*int64)(unsafe.Pointer(&pOut.u)) = nEntry_cgo128
		goto check_for_interrupt
	_cgol_127:
		if _cgo_nm && _cgo_tag != 0 {
			goto _cgol_130
		}
		_cgo_nm = false
		{
			var p1 int32
			var zName *int8
			var nName int32
			var pNew *struct_Savepoint
			var pSavepoint *struct_Savepoint
			var pTmp *struct_Savepoint
			var iSavepoint int32
			var ii int32
			p1 = pOp.p1
			zName = *(**int8)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if p1 == 0 {
				if db.nVdbeWrite > 0 {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[51]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 's', 'a', 'v', 'e', 'p', 'o', 'i', 'n', 't', ' ', '-', ' ', 'S', 'Q', 'L', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', '\x00'})))
					rc = int32(5)
				} else {
					nName = sqlite3Strlen30(zName)
					func() int {
						_ = 0
						return 0
					}()
					rc = sqlite3VtabSavepoint(db, 0, db.nStatement+db.nSavepoint)
					if rc != 0 {
						goto abort_due_to_error
					}
					pNew = (*struct_Savepoint)(sqlite3DbMallocRawNN(db, uint64(32+uint(nName)+uint(1))))
					if pNew != nil {
						pNew.zName = (*int8)(unsafe.Pointer(&*(*struct_Savepoint)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew)) + uintptr(1)*32))))
						__builtin___memcpy_chk(unsafe.Pointer(pNew.zName), unsafe.Pointer(zName), uint(nName+1), __builtin_object_size(unsafe.Pointer(pNew.zName), 0))
						if db.autoCommit != 0 {
							db.autoCommit = uint8(0)
							db.isTransactionSavepoint = uint8(1)
						} else {
							db.nSavepoint++
						}
						pNew.pNext = db.pSavepoint
						db.pSavepoint = pNew
						pNew.nDeferredCons = db.nDeferredCons
						pNew.nDeferredImmCons = db.nDeferredImmCons
					}
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				iSavepoint = int32(0)
				for pSavepoint = db.pSavepoint; pSavepoint != nil && sqlite3StrICmp(pSavepoint.zName, zName) != 0; pSavepoint = pSavepoint.pNext {
					iSavepoint++
				}
				if !(pSavepoint != nil) {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[22]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 's', 'a', 'v', 'e', 'p', 'o', 'i', 'n', 't', ':', ' ', '%', 's', '\x00'})), zName)
					rc = int32(1)
				} else if db.nVdbeWrite > 0 && p1 == 1 {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[54]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'r', 'e', 'l', 'e', 'a', 's', 'e', ' ', 's', 'a', 'v', 'e', 'p', 'o', 'i', 'n', 't', ' ', '-', ' ', 'S', 'Q', 'L', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', '\x00'})))
					rc = int32(5)
				} else {
					var isTransaction int32 = func() int32 {
						if uintptr(unsafe.Pointer(pSavepoint.pNext)) == uintptr(unsafe.Pointer(nil)) && int32(db.isTransactionSavepoint) != 0 {
							return 1
						} else {
							return 0
						}
					}()
					if isTransaction != 0 && p1 == 1 {
						if func() (_cgo_ret int32) {
							_cgo_addr := &rc
							*_cgo_addr = sqlite3VdbeCheckFk(p, 1)
							return *_cgo_addr
						}() != 0 {
							goto vdbe_return
						}
						db.autoCommit = uint8(1)
						if sqlite3VdbeHalt(p) == 5 {
							p.pc = int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24)
							db.autoCommit = uint8(0)
							p.rc = func() (_cgo_ret int32) {
								_cgo_addr := &rc
								*_cgo_addr = int32(5)
								return *_cgo_addr
							}()
							goto vdbe_return
						}
						rc = p.rc
						if rc != 0 {
							db.autoCommit = uint8(0)
						} else {
							db.isTransactionSavepoint = uint8(0)
						}
					} else {
						var isSchemaChange int32
						iSavepoint = db.nSavepoint - iSavepoint - 1
						if p1 == 2 {
							isSchemaChange = func() int32 {
								if db.mDbFlags&uint32(1) != uint32(0) {
									return 1
								} else {
									return 0
								}
							}()
							for ii = int32(0); ii < db.nDb; ii++ {
								rc = sqlite3BtreeTripAllCursors((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt, 4|2<<8, func() int32 {
									if isSchemaChange == 0 {
										return 1
									} else {
										return 0
									}
								}())
								if rc != 0 {
									goto abort_due_to_error
								}
							}
						} else {
							func() int {
								_ = 0
								return 0
							}()
							isSchemaChange = int32(0)
						}
						for ii = int32(0); ii < db.nDb; ii++ {
							rc = sqlite3BtreeSavepoint((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt, p1, iSavepoint)
							if rc != 0 {
								goto abort_due_to_error
							}
						}
						if isSchemaChange != 0 {
							sqlite3ExpirePreparedStatements(db, 0)
							sqlite3ResetAllSchemasOfConnection(db)
							db.mDbFlags |= uint32(1)
						}
					}
					if rc != 0 {
						goto abort_due_to_error
					}
					for uintptr(unsafe.Pointer(db.pSavepoint)) != uintptr(unsafe.Pointer(pSavepoint)) {
						pTmp = db.pSavepoint
						db.pSavepoint = pTmp.pNext
						sqlite3DbFree(db, unsafe.Pointer(pTmp))
						db.nSavepoint--
					}
					if p1 == 1 {
						func() int {
							_ = 0
							return 0
						}()
						db.pSavepoint = pSavepoint.pNext
						sqlite3DbFree(db, unsafe.Pointer(pSavepoint))
						if !(isTransaction != 0) {
							db.nSavepoint--
						}
					} else {
						func() int {
							_ = 0
							return 0
						}()
						db.nDeferredCons = pSavepoint.nDeferredCons
						db.nDeferredImmCons = pSavepoint.nDeferredImmCons
					}
					if !(isTransaction != 0) || p1 == 2 {
						rc = sqlite3VtabSavepoint(db, p1, iSavepoint)
						if rc != 0 {
							goto abort_due_to_error
						}
					}
				}
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_130:
		if _cgo_nm && _cgo_tag != 1 {
			goto _cgol_131
		}
		_cgo_nm = false
		{
			var desiredAutoCommit int32
			var iRollback int32
			desiredAutoCommit = pOp.p1
			iRollback = pOp.p2
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if desiredAutoCommit != int32(db.autoCommit) {
				if iRollback != 0 {
					func() int {
						_ = 0
						return 0
					}()
					sqlite3RollbackAll(db, 4|2<<8)
					db.autoCommit = uint8(1)
				} else if desiredAutoCommit != 0 && db.nVdbeWrite > 0 {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[55]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'i', 't', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', ' ', '-', ' ', 'S', 'Q', 'L', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', '\x00'})))
					rc = int32(5)
					goto abort_due_to_error
				} else if func() (_cgo_ret int32) {
					_cgo_addr := &rc
					*_cgo_addr = sqlite3VdbeCheckFk(p, 1)
					return *_cgo_addr
				}() != 0 {
					goto vdbe_return
				} else {
					db.autoCommit = uint8(desiredAutoCommit)
				}
				if sqlite3VdbeHalt(p) == 5 {
					p.pc = int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24)
					db.autoCommit = uint8(1 - desiredAutoCommit)
					p.rc = func() (_cgo_ret int32) {
						_cgo_addr := &rc
						*_cgo_addr = int32(5)
						return *_cgo_addr
					}()
					goto vdbe_return
				}
				sqlite3CloseSavepoints(db)
				if p.rc == 0 {
					rc = int32(101)
				} else {
					rc = int32(1)
				}
				goto vdbe_return
			} else {
				sqlite3VdbeError(p, func() *int8 {
					if !(desiredAutoCommit != 0) {
						return (*int8)(unsafe.Pointer(&[48]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 's', 't', 'a', 'r', 't', ' ', 'a', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'a', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '\x00'}))
					} else {
						return func() *int8 {
							if iRollback != 0 {
								return (*int8)(unsafe.Pointer(&[43]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'r', 'o', 'l', 'l', 'b', 'a', 'c', 'k', ' ', '-', ' ', 'n', 'o', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'i', 's', ' ', 'a', 'c', 't', 'i', 'v', 'e', '\x00'}))
							} else {
								return (*int8)(unsafe.Pointer(&[41]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'o', 'm', 'm', 'i', 't', ' ', '-', ' ', 'n', 'o', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', ' ', 'i', 's', ' ', 'a', 'c', 't', 'i', 'v', 'e', '\x00'}))
							}
						}()
					}
				}())
				rc = int32(1)
				goto abort_due_to_error
			}
			func() int {
				_ = 0
				return 0
			}()
		}
	_cgol_131:
		if _cgo_nm && _cgo_tag != 2 {
			goto _cgol_132
		}
		_cgo_nm = false
		{
			var pBt *struct_Btree
			var iMeta int32 = 0
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if pOp.p2 != 0 && db.flags&(uint64(1048576)|uint64(2)<<32) != uint64(0) {
				if db.flags&uint64(1048576) != 0 {
					rc = int32(8)
				} else {
					rc = int32(11)
				}
				goto abort_due_to_error
			}
			pBt = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pBt
			if pBt != nil {
				rc = sqlite3BtreeBeginTrans(pBt, pOp.p2, &iMeta)
				if rc != 0 {
					if rc&255 == 5 {
						p.pc = int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24)
						p.rc = rc
						goto vdbe_return
					}
					goto abort_due_to_error
				}
				if int32(p.Xbf_0>>6&1) != 0 && pOp.p2 != 0 && (int32(db.autoCommit) == 0 || db.nVdbeRead > 1) {
					func() int {
						_ = 0
						return 0
					}()
					if p.iStatement == 0 {
						func() int {
							_ = 0
							return 0
						}()
						db.nStatement++
						p.iStatement = db.nSavepoint + db.nStatement
					}
					rc = sqlite3VtabSavepoint(db, 0, p.iStatement-1)
					if rc == 0 {
						rc = sqlite3BtreeBeginStmt(pBt, p.iStatement)
					}
					p.nStmtDefCons = db.nDeferredCons
					p.nStmtDefImmCons = db.nDeferredImmCons
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			if rc == 0 && int32(pOp.p5) != 0 && (iMeta != pOp.p3 || (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pSchema.iGeneration != *(*int32)(unsafe.Pointer(&pOp.p4))) {
				sqlite3DbFree(db, unsafe.Pointer(p.zErrMsg))
				p.zErrMsg = sqlite3DbStrDup(db, (*int8)(unsafe.Pointer(&[28]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'h', 'a', 's', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', '\x00'})))
				if (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pSchema.schema_cookie != iMeta {
					sqlite3ResetOneSchema(db, pOp.p1)
				}
				{
					_autoGo_21 := &p.Xbf_0
					*_autoGo_21 = *_autoGo_21&^3 | uint32(1)&3
				}
				rc = int32(17)
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_132:
		if _cgo_nm && _cgo_tag != 98 {
			goto _cgol_133
		}
		_cgo_nm = false
		{
			var iMeta int32
			var iDb int32
			var iCookie int32
			func() int {
				_ = 0
				return 0
			}()
			iDb = pOp.p1
			iCookie = pOp.p3
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3BtreeGetMeta((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt, iCookie, (*uint32)(unsafe.Pointer(&iMeta)))
			pOut = out2Prerelease(p, pOp)
			*(*int64)(unsafe.Pointer(&pOut.u)) = int64(iMeta)
			goto _cgol_2
		}
	_cgol_133:
		if _cgo_nm && _cgo_tag != 99 {
			goto _cgol_134
		}
		_cgo_nm = false
		{
			var pDb *struct_Db
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3BtreeUpdateMeta(pDb.pBt, pOp.p2, uint32(pOp.p3))
			if pOp.p2 == 1 {
				pDb.pSchema.schema_cookie = pOp.p3 - int32(pOp.p5)
				db.mDbFlags |= uint32(1)
				sqlite3FkClearTriggerCache(db, pOp.p1)
			} else if pOp.p2 == 2 {
				pDb.pSchema.file_format = uint8(pOp.p3)
			}
			if pOp.p1 == 1 {
				sqlite3ExpirePreparedStatements(db, 0)
				{
					_autoGo_22 := &p.Xbf_0
					*_autoGo_22 = *_autoGo_22&^3 | uint32(0)&3
				}
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_134:
		if _cgo_nm && _cgo_tag != 100 {
			goto _cgol_135
		}
		_cgo_nm = false
		{
			var nField int32
			var pKeyInfo *struct_KeyInfo
			var p2 uint32
			var iDb int32
			var wrFlag int32
			var pX *struct_Btree
			var pCur *struct_VdbeCursor
			var pDb *struct_Db
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCur = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			if pCur != nil && pCur.pgnoRoot == uint32(pOp.p2) {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				sqlite3BtreeClearCursor(pCur.uc.pCursor)
				goto open_cursor_set_hints
			}
		_cgol_135:
			if _cgo_nm && _cgo_tag != 101 {
				goto _cgol_136
			}
			_cgo_nm = false
		_cgol_136:
			if _cgo_nm && _cgo_tag != 112 {
				goto _cgol_137
			}
			_cgo_nm = false
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(p.Xbf_0&3) == 1 {
				rc = int32(4 | 2<<8)
				goto abort_due_to_error
			}
			nField = int32(0)
			pKeyInfo = (*struct_KeyInfo)(nil)
			p2 = uint32(pOp.p2)
			iDb = pOp.p3
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
			pX = pDb.pBt
			func() int {
				_ = 0
				return 0
			}()
			if int32(pOp.opcode) == 112 {
				func() int {
					_ = 0
					return 0
				}()
				wrFlag = 4 | int32(pOp.p5)&8
				func() int {
					_ = 0
					return 0
				}()
				if int32(pDb.pSchema.file_format) < int32(p.minWriteFileFormat) {
					p.minWriteFileFormat = pDb.pSchema.file_format
				}
			} else {
				wrFlag = int32(0)
			}
			if int32(pOp.p5)&16 != 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(p2)*56))
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeMemIntegerify(pIn2)
				p2 = uint32(int32(*(*int64)(unsafe.Pointer(&pIn2.u))))
				func() int {
					_ = 0
					return 0
				}()
			}
			if int32(pOp.p4type) == -9 {
				pKeyInfo = *(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4))
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				nField = int32(pKeyInfo.nAllField)
			} else if int32(pOp.p4type) == -3 {
				nField = *(*int32)(unsafe.Pointer(&pOp.p4))
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCur = allocateCursor(p, pOp.p1, nField, uint8(0))
			if uintptr(unsafe.Pointer(pCur)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			pCur.iDb = int8(iDb)
			pCur.nullRow = uint8(1)
			{
				_autoGo_23 := &pCur.Xbf_0
				*_autoGo_23 = *_autoGo_23&^4 | uint32(1)&1<<2
			}
			pCur.pgnoRoot = p2
			rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur.uc.pCursor)
			pCur.pKeyInfo = pKeyInfo
			pCur.isTable = func() uint8 {
				if int32(pOp.p4type) != -9 {
					return 1
				} else {
					return 0
				}
			}()
		open_cursor_set_hints:
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3BtreeCursorHintFlags(pCur.uc.pCursor, uint32(int32(pOp.p5)&(1|2)))
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_137:
		if _cgo_nm && _cgo_tag != 113 {
			goto _cgol_138
		}
		_cgo_nm = false
		{
			var pOrig *struct_VdbeCursor
			var pCx *struct_VdbeCursor
			pOrig = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p2)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCx = allocateCursor(p, pOp.p1, int32(pOrig.nField), uint8(0))
			if uintptr(unsafe.Pointer(pCx)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			pCx.nullRow = uint8(1)
			{
				_autoGo_24 := &pCx.Xbf_0
				*_autoGo_24 = *_autoGo_24&^1 | uint32(1)&1
			}
			pCx.pKeyInfo = pOrig.pKeyInfo
			pCx.isTable = pOrig.isTable
			pCx.pgnoRoot = pOrig.pgnoRoot
			{
				_autoGo_25 := &pCx.Xbf_0
				*_autoGo_25 = *_autoGo_25&^4 | pOrig.Xbf_0>>2&1&1<<2
			}
			pCx.ub.pBtx = pOrig.ub.pBtx
			{
				_autoGo_26 := &pCx.Xbf_0
				*_autoGo_26 = *_autoGo_26&^8 | uint32(1)&1<<3
			}
			{
				_autoGo_27 := &pOrig.Xbf_0
				*_autoGo_27 = *_autoGo_27&^8 | uint32(1)&1<<3
			}
			rc = sqlite3BtreeCursor(pCx.ub.pBtx, pCx.pgnoRoot, 4, pCx.pKeyInfo, pCx.uc.pCursor)
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		}
	_cgol_138:
		if _cgo_nm && _cgo_tag != 115 {
			goto _cgol_139
		}
		_cgo_nm = false
	_cgol_139:
		if _cgo_nm && _cgo_tag != 116 {
			goto _cgol_140
		}
		_cgo_nm = false
		{
			var pCx *struct_VdbeCursor
			var pKeyInfo *struct_KeyInfo
			var vfsFlags int32 = 2 | 4 | 16 | 8 | 1024
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if pOp.p3 > 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))).n = int32(0)
				(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))).z = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
			}
			pCx = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			if pCx != nil && !(pCx.Xbf_0>>3&1 != 0) && pOp.p2 <= int32(pCx.nField) {
				func() int {
					_ = 0
					return 0
				}()
				pCx.seqCount = int64(0)
				pCx.cacheStatus = uint32(0)
				rc = sqlite3BtreeClearTable(pCx.ub.pBtx, int32(pCx.pgnoRoot), nil)
			} else {
				pCx = allocateCursor(p, pOp.p1, pOp.p2, uint8(0))
				if uintptr(unsafe.Pointer(pCx)) == uintptr(unsafe.Pointer(nil)) {
					goto no_mem
				}
				{
					_autoGo_28 := &pCx.Xbf_0
					*_autoGo_28 = *_autoGo_28&^1 | uint32(1)&1
				}
				rc = sqlite3BtreeOpen(db.pVfs, nil, db, &pCx.ub.pBtx, 1|4|int32(pOp.p5), vfsFlags)
				if rc == 0 {
					rc = sqlite3BtreeBeginTrans(pCx.ub.pBtx, 1, nil)
					if rc == 0 {
						if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_KeyInfo) {
							_cgo_addr := &pCx.pKeyInfo
							*_cgo_addr = func() (_cgo_ret *struct_KeyInfo) {
								_cgo_addr := &pKeyInfo
								*_cgo_addr = *(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4))
								return *_cgo_addr
							}()
							return *_cgo_addr
						}())) != uintptr(unsafe.Pointer(nil)) {
							func() int {
								_ = 0
								return 0
							}()
							rc = sqlite3BtreeCreateTable(pCx.ub.pBtx, &pCx.pgnoRoot, 2|int32(pOp.p5))
							if rc == 0 {
								func() int {
									_ = 0
									return 0
								}()
								func() int {
									_ = 0
									return 0
								}()
								func() int {
									_ = 0
									return 0
								}()
								rc = sqlite3BtreeCursor(pCx.ub.pBtx, pCx.pgnoRoot, 4, pKeyInfo, pCx.uc.pCursor)
							}
							pCx.isTable = uint8(0)
						} else {
							pCx.pgnoRoot = uint32(1)
							rc = sqlite3BtreeCursor(pCx.ub.pBtx, uint32(1), 4, nil, pCx.uc.pCursor)
							pCx.isTable = uint8(1)
						}
					}
					{
						_autoGo_29 := &pCx.Xbf_0
						*_autoGo_29 = *_autoGo_29&^4 | func() uint32 {
							if int32(pOp.p5) != 8 {
								return 1
							} else {
								return 0
							}
						}()&1<<2
					}
					if rc != 0 {
						sqlite3BtreeClose(pCx.ub.pBtx)
					}
				}
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			pCx.nullRow = uint8(1)
			goto _cgol_2
		}
	_cgol_140:
		if _cgo_nm && _cgo_tag != 118 {
			goto _cgol_141
		}
		_cgo_nm = false
		{
			var pCx *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCx = allocateCursor(p, pOp.p1, pOp.p2, uint8(1))
			if uintptr(unsafe.Pointer(pCx)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			pCx.pKeyInfo = *(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3VdbeSorterInit(db, pOp.p3, pCx)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_141:
		if _cgo_nm && _cgo_tag != 119 {
			goto _cgol_142
		}
		_cgo_nm = false
		pC_cgo143 = nil
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo143 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		if !(func() (_cgo_ret int64) {
			_cgo_addr := &pC_cgo143.seqCount
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}() == int64(0)) {
			goto _cgol_144
		}
		goto jump_to_p2
	_cgol_144:
		goto _cgol_2
	_cgol_142:
		if _cgo_nm && _cgo_tag != 120 {
			goto _cgol_145
		}
		_cgo_nm = false
		{
			var pCx *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCx = allocateCursor(p, pOp.p1, pOp.p3, uint8(3))
			if uintptr(unsafe.Pointer(pCx)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			pCx.nullRow = uint8(1)
			pCx.seekResult = pOp.p2
			pCx.isTable = uint8(1)
			pCx.uc.pCursor = sqlite3BtreeFakeValidCursor()
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		}
	_cgol_145:
		if _cgo_nm && _cgo_tag != 121 {
			goto _cgol_146
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeFreeCursor(p, *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8)))
			*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8)) = (*struct_VdbeCursor)(nil)
			goto _cgol_2
		}
	_cgol_146:
		if _cgo_nm && _cgo_tag != 23 {
			goto _cgol_147
		}
		_cgo_nm = false
	_cgol_147:
		if _cgo_nm && _cgo_tag != 24 {
			goto _cgol_148
		}
		_cgo_nm = false
	_cgol_148:
		if _cgo_nm && _cgo_tag != 25 {
			goto _cgol_149
		}
		_cgo_nm = false
	_cgol_149:
		if _cgo_nm && _cgo_tag != 26 {
			goto _cgol_150
		}
		_cgo_nm = false
		res_cgo151 = 0
		oc_cgo152 = 0
		pC_cgo153 = nil
		r_cgo154 = struct {
			pKeyInfo   *struct_KeyInfo
			aMem       *struct_sqlite3_value
			nField     uint16
			default_rc int8
			errCode    uint8
			r1         int8
			r2         int8
			eqSeen     uint8
		}{}
		nField_cgo155 = 0
		iKey_cgo156 = 0
		eqOnly_cgo157 = 0
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo153 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		oc_cgo152 = int32(pOp.opcode)
		eqOnly_cgo157 = int32(0)
		pC_cgo153.nullRow = uint8(0)
		pC_cgo153.deferredMoveto = uint8(0)
		pC_cgo153.cacheStatus = uint32(0)
		if !(pC_cgo153.isTable != 0) {
			goto _cgol_159
		}
		flags3_cgo160 = 0
		newType_cgo161 = 0
		func() int {
			_ = 0
			return 0
		}()
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		flags3_cgo160 = pIn3.flags
		if int32(flags3_cgo160)&(4|8|32|2) == 2 {
			applyNumericAffinity(pIn3, 0)
		}
		iKey_cgo156 = sqlite3VdbeIntValue(pIn3)
		newType_cgo161 = pIn3.flags
		pIn3.flags = flags3_cgo160
		if !(int32(newType_cgo161)&(4|32) == 0) {
			goto _cgol_162
		}
		c_cgo163 = 0
		if !(int32(newType_cgo161)&8 == 0) {
			goto _cgol_164
		}
		if !(int32(newType_cgo161)&1 != 0 || oc_cgo152 >= 25) {
			goto _cgol_166
		}
		goto jump_to_p2
		goto _cgol_165
	_cgol_166:
		rc = sqlite3BtreeLast(pC_cgo153.uc.pCursor, &res_cgo151)
		if rc != 0 {
			goto abort_due_to_error
		}
		goto seek_not_found
	_cgol_165:
		;
	_cgol_164:
		c_cgo163 = sqlite3IntFloatCompare(iKey_cgo156, pIn3.u.r)
		if c_cgo163 > 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if oc_cgo152&1 == 26&1 {
				oc_cgo152--
			}
		} else if c_cgo163 < 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if oc_cgo152&1 == 23&1 {
				oc_cgo152++
			}
		}
	_cgol_162:
		rc = sqlite3BtreeTableMoveto(pC_cgo153.uc.pCursor, int64(uint64(iKey_cgo156)), 0, &res_cgo151)
		pC_cgo153.movetoTarget = iKey_cgo156
		if rc != 0 {
			goto abort_due_to_error
		}
		goto _cgol_158
	_cgol_159:
		if sqlite3BtreeCursorHasHint(pC_cgo153.uc.pCursor, uint32(2)) != 0 {
			eqOnly_cgo157 = int32(1)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
		}
		nField_cgo155 = *(*int32)(unsafe.Pointer(&pOp.p4))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		r_cgo154.pKeyInfo = pC_cgo153.pKeyInfo
		r_cgo154.nField = uint16(nField_cgo155)
		r_cgo154.default_rc = int8(func() int32 {
			if 1&(oc_cgo152-23) != 0 {
				return -1
			} else {
				return 1
			}
		}())
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		r_cgo154.aMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		r_cgo154.eqSeen = uint8(0)
		rc = sqlite3BtreeIndexMoveto(pC_cgo153.uc.pCursor, &r_cgo154, &res_cgo151)
		if rc != 0 {
			goto abort_due_to_error
		}
		if eqOnly_cgo157 != 0 && int32(r_cgo154.eqSeen) == 0 {
			func() int {
				_ = 0
				return 0
			}()
			goto seek_not_found
		}
	_cgol_158:
		if oc_cgo152 >= 25 {
			func() int {
				_ = 0
				return 0
			}()
			if res_cgo151 < 0 || res_cgo151 == 0 && oc_cgo152 == 26 {
				res_cgo151 = int32(0)
				rc = sqlite3BtreeNext(pC_cgo153.uc.pCursor, 0)
				if rc != 0 {
					if rc == 101 {
						rc = int32(0)
						res_cgo151 = int32(1)
					} else {
						goto abort_due_to_error
					}
				}
			} else {
				res_cgo151 = int32(0)
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			if res_cgo151 > 0 || res_cgo151 == 0 && oc_cgo152 == 23 {
				res_cgo151 = int32(0)
				rc = sqlite3BtreePrevious(pC_cgo153.uc.pCursor, 0)
				if rc != 0 {
					if rc == 101 {
						rc = int32(0)
						res_cgo151 = int32(1)
					} else {
						goto abort_due_to_error
					}
				}
			} else {
				res_cgo151 = sqlite3BtreeEof(pC_cgo153.uc.pCursor)
			}
		}
	seek_not_found:
		func() int {
			_ = 0
			return 0
		}()
		if !(res_cgo151 != 0) {
			goto _cgol_168
		}
		goto jump_to_p2
		goto _cgol_167
	_cgol_168:
		if eqOnly_cgo157 != 0 {
			func() int {
				_ = 0
				return 0
			}()
			*(*uintptr)(unsafe.Pointer(&pOp)) += 24
		}
	_cgol_167:
		goto _cgol_2
	_cgol_150:
		if _cgo_nm && _cgo_tag != 123 {
			goto _cgol_169
		}
		_cgo_nm = false
		pC_cgo170 = nil
		res_cgo171 = 0
		nStep_cgo172 = 0
		r_cgo173 = struct {
			pKeyInfo   *struct_KeyInfo
			aMem       *struct_sqlite3_value
			nField     uint16
			default_rc int8
			errCode    uint8
			r1         int8
			r2         int8
			eqSeen     uint8
		}{}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo170 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) + uintptr(1)*24))).p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if !(sqlite3BtreeCursorIsValidNN(pC_cgo170.uc.pCursor) != 0) {
			goto _cgol_2
		}
		nStep_cgo172 = pOp.p1
		func() int {
			_ = 0
			return 0
		}()
		r_cgo173.pKeyInfo = pC_cgo170.pKeyInfo
		r_cgo173.nField = uint16(*(*int32)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) + uintptr(1)*24))).p4)))
		r_cgo173.default_rc = int8(0)
		r_cgo173.aMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) + uintptr(1)*24))).p3)*56))
		res_cgo171 = int32(0)
	_cgol_174:
		if false {
			goto _cgol_175
		}
		rc = sqlite3VdbeIdxKeyCompare(db, pC_cgo170, &r_cgo173, &res_cgo171)
		if rc != 0 {
			goto abort_due_to_error
		}
		if !(res_cgo171 > 0) {
			goto _cgol_176
		}
	seekscan_search_fail:
		*(*uintptr)(unsafe.Pointer(&pOp)) += 24
		goto jump_to_p2
	_cgol_176:
		if !(res_cgo171 == 0) {
			goto _cgol_177
		}
		goto jump_to_p2
		goto _cgol_177
	_cgol_177:
		if nStep_cgo172 <= 0 {
			goto _cgol_175
		}
		nStep_cgo172--
		rc = sqlite3BtreeNext(pC_cgo170.uc.pCursor, 0)
		if !(rc != 0) {
			goto _cgol_178
		}
		if !(rc == 101) {
			goto _cgol_180
		}
		rc = int32(0)
		goto seekscan_search_fail
		goto _cgol_179
	_cgol_180:
		goto abort_due_to_error
	_cgol_179:
		;
	_cgol_178:
		goto _cgol_174
	_cgol_175:
		goto _cgol_2
	_cgol_169:
		if _cgo_nm && _cgo_tag != 124 {
			goto _cgol_181
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(pC.seekHit) < pOp.p2 {
				pC.seekHit = uint16(pOp.p2)
			} else if int32(pC.seekHit) > pOp.p3 {
				pC.seekHit = uint16(pOp.p3)
			}
			goto _cgol_2
		}
	_cgol_181:
		if _cgo_nm && _cgo_tag != 27 {
			goto _cgol_182
		}
		_cgo_nm = false
		func() int {
			_ = 0
			return 0
		}()
		if !!(*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8)) != nil) {
			goto _cgol_183
		}
		goto jump_to_p2_and_check_for_interrupt
	_cgol_183:
		goto _cgol_2
	_cgol_182:
		if _cgo_nm && _cgo_tag != 28 {
			goto _cgol_184
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			if int32(pC.seekHit) >= *(*int32)(unsafe.Pointer(&pOp.p4)) {
				goto _cgol_2
			}
		}
	_cgol_184:
		if _cgo_nm && _cgo_tag != 29 {
			goto _cgol_185
		}
		_cgo_nm = false
	_cgol_185:
		if _cgo_nm && _cgo_tag != 30 {
			goto _cgol_186
		}
		_cgo_nm = false
	_cgol_186:
		if _cgo_nm && _cgo_tag != 31 {
			goto _cgol_187
		}
		_cgo_nm = false
		alreadyExists_cgo188 = 0
		takeJump_cgo189 = 0
		ii_cgo190 = 0
		pC_cgo191 = nil
		res_cgo192 = 0
		pFree_cgo193 = nil
		pIdxKey_cgo194 = nil
		r_cgo195 = struct {
			pKeyInfo   *struct_KeyInfo
			aMem       *struct_sqlite3_value
			nField     uint16
			default_rc int8
			errCode    uint8
			r1         int8
			r2         int8
			eqSeen     uint8
		}{}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo191 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if *(*int32)(unsafe.Pointer(&pOp.p4)) > 0 {
			r_cgo195.pKeyInfo = pC_cgo191.pKeyInfo
			r_cgo195.nField = uint16(*(*int32)(unsafe.Pointer(&pOp.p4)))
			r_cgo195.aMem = pIn3
			pIdxKey_cgo194 = &r_cgo195
			pFree_cgo193 = (*struct_UnpackedRecord)(nil)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			rc = func() int32 {
				if int32(pIn3.flags)&16384 != 0 {
					return sqlite3VdbeMemExpandBlob(pIn3)
				} else {
					return 0
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			if rc != 0 {
				goto no_mem
			}
			pFree_cgo193 = func() (_cgo_ret *struct_UnpackedRecord) {
				_cgo_addr := &pIdxKey_cgo194
				*_cgo_addr = sqlite3VdbeAllocUnpackedRecord(pC_cgo191.pKeyInfo)
				return *_cgo_addr
			}()
			if uintptr(unsafe.Pointer(pIdxKey_cgo194)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			sqlite3VdbeRecordUnpack(pC_cgo191.pKeyInfo, pIn3.n, unsafe.Pointer(pIn3.z), pIdxKey_cgo194)
		}
		pIdxKey_cgo194.default_rc = int8(0)
		takeJump_cgo189 = int32(0)
		if int32(pOp.opcode) == 29 {
			for ii_cgo190 = int32(0); ii_cgo190 < int32(pIdxKey_cgo194.nField); ii_cgo190++ {
				if int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxKey_cgo194.aMem)) + uintptr(ii_cgo190)*56))).flags)&1 != 0 {
					takeJump_cgo189 = int32(1)
					break
				}
			}
		}
		rc = sqlite3BtreeIndexMoveto(pC_cgo191.uc.pCursor, pIdxKey_cgo194, &res_cgo192)
		if pFree_cgo193 != nil {
			sqlite3DbFreeNN(db, unsafe.Pointer(pFree_cgo193))
		}
		if rc != 0 {
			goto abort_due_to_error
		}
		pC_cgo191.seekResult = res_cgo192
		alreadyExists_cgo188 = func() int32 {
			if res_cgo192 == 0 {
				return 1
			} else {
				return 0
			}
		}()
		pC_cgo191.nullRow = uint8(1 - alreadyExists_cgo188)
		pC_cgo191.deferredMoveto = uint8(0)
		pC_cgo191.cacheStatus = uint32(0)
		if !(int32(pOp.opcode) == 31) {
			goto _cgol_197
		}
		if !(alreadyExists_cgo188 != 0) {
			goto _cgol_198
		}
		goto jump_to_p2
	_cgol_198:
		goto _cgol_196
	_cgol_197:
		if !(takeJump_cgo189 != 0 || !(alreadyExists_cgo188 != 0)) {
			goto _cgol_199
		}
		goto jump_to_p2
	_cgol_199:
		if int32(pOp.opcode) == 28 {
			pC_cgo191.seekHit = uint16(*(*int32)(unsafe.Pointer(&pOp.p4)))
		}
	_cgol_196:
		goto _cgol_2
	_cgol_187:
		if _cgo_nm && _cgo_tag != 32 {
			goto _cgol_200
		}
		_cgo_nm = false
		pC_cgo201 = nil
		pCrsr_cgo202 = nil
		res_cgo203 = 0
		iKey_cgo204 = 0
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		if !(int32(pIn3.flags)&(4|32) == 0) {
			goto _cgol_205
		}
		x_cgo206 = *(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn3)) + uintptr(0)*56))
		applyAffinity(&x_cgo206, int8(67), encoding)
		if !(int32(x_cgo206.flags)&4 == 0) {
			goto _cgol_207
		}
		goto jump_to_p2
	_cgol_207:
		iKey_cgo204 = uint64(*(*int64)(unsafe.Pointer(&x_cgo206.u)))
		goto notExistsWithKey
	_cgol_205:
		;
	_cgol_200:
		if _cgo_nm && _cgo_tag != 33 {
			goto _cgol_208
		}
		_cgo_nm = false
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		iKey_cgo204 = uint64(*(*int64)(unsafe.Pointer(&pIn3.u)))
	notExistsWithKey:
		pC_cgo201 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pCrsr_cgo202 = pC_cgo201.uc.pCursor
		func() int {
			_ = 0
			return 0
		}()
		res_cgo203 = int32(0)
		rc = sqlite3BtreeTableMoveto(pCrsr_cgo202, int64(iKey_cgo204), 0, &res_cgo203)
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo201.movetoTarget = int64(iKey_cgo204)
		pC_cgo201.nullRow = uint8(0)
		pC_cgo201.cacheStatus = uint32(0)
		pC_cgo201.deferredMoveto = uint8(0)
		pC_cgo201.seekResult = res_cgo203
		if !(res_cgo203 != 0) {
			goto _cgol_209
		}
		func() int {
			_ = 0
			return 0
		}()
		if !(pOp.p2 == 0) {
			goto _cgol_211
		}
		rc = sqlite3CorruptError(92470)
		goto _cgol_210
	_cgol_211:
		goto jump_to_p2
	_cgol_210:
		;
	_cgol_209:
		if rc != 0 {
			goto abort_due_to_error
		}
		goto _cgol_2
	_cgol_208:
		if _cgo_nm && _cgo_tag != 125 {
			goto _cgol_212
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pOut = out2Prerelease(p, pOp)
			*(*int64)(unsafe.Pointer(&pOut.u)) = func() (_cgo_ret int64) {
				_cgo_addr := &(*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))).seqCount
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			goto _cgol_2
		}
	_cgol_212:
		if _cgo_nm && _cgo_tag != 126 {
			goto _cgol_213
		}
		_cgo_nm = false
		{
			var v int64
			var pC *struct_VdbeCursor
			var res int32
			var cnt int32
			var pMem *struct_sqlite3_value
			var pFrame *struct_VdbeFrame
			v = int64(0)
			res = int32(0)
			pOut = out2Prerelease(p, pOp)
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			{
				func() int {
					_ = 0
					return 0
				}()
				if !(pC.Xbf_0>>1&1 != 0) {
					rc = sqlite3BtreeLast(pC.uc.pCursor, &res)
					if rc != 0 {
						goto abort_due_to_error
					}
					if res != 0 {
						v = int64(1)
					} else {
						func() int {
							_ = 0
							return 0
						}()
						v = sqlite3BtreeIntegerKey(pC.uc.pCursor)
						if v >= int64(uint64(2147483647)<<32|uint64(4294967295)) {
							{
								_autoGo_30 := &pC.Xbf_0
								*_autoGo_30 = *_autoGo_30&^2 | uint32(1)&1<<1
							}
						} else {
							v++
						}
					}
				}
				if pOp.p3 != 0 {
					func() int {
						_ = 0
						return 0
					}()
					if p.pFrame != nil {
						for pFrame = p.pFrame; pFrame.pParent != nil; pFrame = pFrame.pParent {
						}
						func() int {
							_ = 0
							return 0
						}()
						pMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrame.aMem)) + uintptr(pOp.p3)*56))
					} else {
						func() int {
							_ = 0
							return 0
						}()
						pMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
					}
					func() int {
						_ = 0
						return 0
					}()
					sqlite3VdbeMemIntegerify(pMem)
					func() int {
						_ = 0
						return 0
					}()
					if *(*int64)(unsafe.Pointer(&pMem.u)) == int64(uint64(2147483647)<<32|uint64(4294967295)) || int32(pC.Xbf_0>>1&1) != 0 {
						rc = int32(13)
						goto abort_due_to_error
					}
					if v < *(*int64)(unsafe.Pointer(&pMem.u))+int64(1) {
						v = *(*int64)(unsafe.Pointer(&pMem.u)) + int64(1)
					}
					*(*int64)(unsafe.Pointer(&pMem.u)) = v
				}
				if pC.Xbf_0>>1&1 != 0 {
					func() int {
						_ = 0
						return 0
					}()
					cnt = int32(0)
					for {
						sqlite3_randomness(int32(8), unsafe.Pointer(&v))
						v &= int64(uint64(2147483647)<<32|uint64(4294967295)) >> 1
						v++
						if !(func() (_cgo_ret int32) {
							_cgo_addr := &rc
							*_cgo_addr = sqlite3BtreeTableMoveto(pC.uc.pCursor, int64(uint64(v)), 0, &res)
							return *_cgo_addr
						}() == 0 && res == 0 && func() (_cgo_ret int32) {
							_cgo_addr := &cnt
							*_cgo_addr++
							return *_cgo_addr
						}() < 100) {
							break
						}
					}
					if rc != 0 {
						goto abort_due_to_error
					}
					if res == 0 {
						rc = int32(13)
						goto abort_due_to_error
					}
					func() int {
						_ = 0
						return 0
					}()
				}
				pC.deferredMoveto = uint8(0)
				pC.cacheStatus = uint32(0)
			}
			*(*int64)(unsafe.Pointer(&pOut.u)) = v
			goto _cgol_2
		}
	_cgol_213:
		if _cgo_nm && _cgo_tag != 127 {
			goto _cgol_214
		}
		_cgo_nm = false
		{
			var pData *struct_sqlite3_value
			var pKey *struct_sqlite3_value
			var pC *struct_VdbeCursor
			var seekResult int32
			var zDb *int8
			var pTab *struct_Table
			var x struct_BtreePayload
			pData = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pKey = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			x.nKey = *(*int64)(unsafe.Pointer(&pKey.u))
			if int32(pOp.p4type) == -6 && db.xUpdateCallback != nil {
				func() int {
					_ = 0
					return 0
				}()
				zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pC.iDb)*32))).zDbSName
				pTab = *(**struct_Table)(unsafe.Pointer(&pOp.p4))
				func() int {
					_ = 0
					return 0
				}()
			} else {
				pTab = (*struct_Table)(nil)
				zDb = (*int8)(nil)
			}
			if int32(pOp.p5)&1 != 0 {
				p.nChange++
			}
			if int32(pOp.p5)&32 != 0 {
				db.lastRowid = x.nKey
			}
			func() int {
				_ = 0
				return 0
			}()
			x.pData = unsafe.Pointer(pData.z)
			x.nData = pData.n
			seekResult = func() int32 {
				if int32(pOp.p5)&16 != 0 {
					return pC.seekResult
				} else {
					return 0
				}
			}()
			if int32(pData.flags)&16384 != 0 {
				x.nZero = *(*int32)(unsafe.Pointer(&pData.u))
			} else {
				x.nZero = int32(0)
			}
			x.pKey = unsafe.Pointer(nil)
			rc = sqlite3BtreeInsert(pC.uc.pCursor, &x, int32(pOp.p5)&(8|2|128), seekResult)
			pC.deferredMoveto = uint8(0)
			pC.cacheStatus = uint32(0)
			if rc != 0 {
				goto abort_due_to_error
			}
			if pTab != nil {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				db.xUpdateCallback(db.pUpdateArg, func() int32 {
					if int32(pOp.p5)&4 != 0 {
						return 23
					} else {
						return 18
					}
				}(), zDb, pTab.zName, x.nKey)
			}
			goto _cgol_2
		}
	_cgol_214:
		if _cgo_nm && _cgo_tag != 128 {
			goto _cgol_215
		}
		_cgo_nm = false
		{
			var pDest *struct_VdbeCursor
			var pSrc *struct_VdbeCursor
			var iKey int64
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pDest = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			pSrc = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p2)*8))
			iKey = func() int64 {
				if pOp.p3 != 0 {
					return *(*int64)(unsafe.Pointer(&(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))).u))
				} else {
					return int64(0)
				}
			}()
			rc = sqlite3BtreeTransferRow(pDest.uc.pCursor, pSrc.uc.pCursor, iKey)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_215:
		if _cgo_nm && _cgo_tag != 129 {
			goto _cgol_216
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var zDb *int8
			var pTab *struct_Table
			var opflags int32
			opflags = pOp.p2
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(pOp.p4type) == -6 && db.xUpdateCallback != nil {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pC.iDb)*32))).zDbSName
				pTab = *(**struct_Table)(unsafe.Pointer(&pOp.p4))
				if int32(pOp.p5)&2 != 0 && int32(pC.isTable) != 0 {
					pC.movetoTarget = sqlite3BtreeIntegerKey(pC.uc.pCursor)
				}
			} else {
				zDb = (*int8)(nil)
				pTab = (*struct_Table)(nil)
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3BtreeDelete(pC.uc.pCursor, uint8(pOp.p5))
			pC.cacheStatus = uint32(0)
			pC.seekResult = int32(0)
			if rc != 0 {
				goto abort_due_to_error
			}
			if opflags&1 != 0 {
				p.nChange++
				if db.xUpdateCallback != nil && uintptr(unsafe.Pointer(pTab)) != uintptr(unsafe.Pointer(nil)) && pTab.tabFlags&uint32(128) == uint32(0) {
					db.xUpdateCallback(db.pUpdateArg, 9, zDb, pTab.zName, pC.movetoTarget)
					func() int {
						_ = 0
						return 0
					}()
				}
			}
			goto _cgol_2
		}
	_cgol_216:
		if _cgo_nm && _cgo_tag != 130 {
			goto _cgol_217
		}
		_cgo_nm = false
		{
			sqlite3VdbeSetChanges(db, p.nChange)
			p.nChange = int64(0)
			goto _cgol_2
		}
	_cgol_217:
		if _cgo_nm && _cgo_tag != 131 {
			goto _cgol_218
		}
		_cgo_nm = false
		pC_cgo219 = nil
		res_cgo220 = 0
		nKeyCol_cgo221 = 0
		pC_cgo219 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		nKeyCol_cgo221 = *(*int32)(unsafe.Pointer(&pOp.p4))
		res_cgo220 = int32(0)
		rc = sqlite3VdbeSorterCompare(pC_cgo219, pIn3, nKeyCol_cgo221, &res_cgo220)
		if rc != 0 {
			goto abort_due_to_error
		}
		if !(res_cgo220 != 0) {
			goto _cgol_222
		}
		goto jump_to_p2
	_cgol_222:
		goto _cgol_2
	_cgol_218:
		if _cgo_nm && _cgo_tag != 132 {
			goto _cgol_223
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3VdbeSorterRowkey(pC, pOut)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if rc != 0 {
				goto abort_due_to_error
			}
			(*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p3)*8))).cacheStatus = uint32(0)
			goto _cgol_2
		}
	_cgol_223:
		if _cgo_nm && _cgo_tag != 133 {
			goto _cgol_224
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var pCrsr *struct_BtCursor
			var n uint32
			pOut = out2Prerelease(p, pOp)
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCrsr = pC.uc.pCursor
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			n = sqlite3BtreePayloadSize(pCrsr)
			if n > uint32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))) {
				goto too_big
			}
			rc = sqlite3VdbeMemFromBtreeZeroOffset(pCrsr, n, pOut)
			if rc != 0 {
				goto abort_due_to_error
			}
			if !(pOp.p3 != 0) {
				if int32(pOut.flags)&4096 != 0 && sqlite3VdbeMemMakeWriteable(pOut) != 0 {
					goto no_mem
				}
			}
			goto _cgol_2
		}
	_cgol_224:
		if _cgo_nm && _cgo_tag != 134 {
			goto _cgol_225
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var v int64
			var pVtab *struct_sqlite3_vtab
			var pModule *struct_sqlite3_module
			pOut = out2Prerelease(p, pOp)
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if pC.nullRow != 0 {
				pOut.flags = uint16(1)
				goto _cgol_2
			} else if pC.deferredMoveto != 0 {
				v = pC.movetoTarget
			} else if int32(pC.eCurType) == 2 {
				func() int {
					_ = 0
					return 0
				}()
				pVtab = (*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pC.uc))).pVtab
				pModule = pVtab.pModule
				func() int {
					_ = 0
					return 0
				}()
				rc = pModule.xRowid(*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pC.uc)), &v)
				sqlite3VtabImportErrmsg(p, pVtab)
				if rc != 0 {
					goto abort_due_to_error
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3VdbeCursorRestore(pC)
				if rc != 0 {
					goto abort_due_to_error
				}
				if pC.nullRow != 0 {
					pOut.flags = uint16(1)
					goto _cgol_2
				}
				v = sqlite3BtreeIntegerKey(pC.uc.pCursor)
			}
			*(*int64)(unsafe.Pointer(&pOut.u)) = v
			goto _cgol_2
		}
	_cgol_225:
		if _cgo_nm && _cgo_tag != 135 {
			goto _cgol_226
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			pC.nullRow = uint8(1)
			pC.cacheStatus = uint32(0)
			if int32(pC.eCurType) == 0 {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3BtreeClearCursor(pC.uc.pCursor)
			}
			goto _cgol_2
		}
	_cgol_226:
		if _cgo_nm && _cgo_tag != 136 {
			goto _cgol_227
		}
		_cgo_nm = false
	_cgol_227:
		if _cgo_nm && _cgo_tag != 34 {
			goto _cgol_228
		}
		_cgo_nm = false
		pC_cgo229 = nil
		pCrsr_cgo230 = nil
		res_cgo231 = 0
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo229 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pCrsr_cgo230 = pC_cgo229.uc.pCursor
		res_cgo231 = int32(0)
		func() int {
			_ = 0
			return 0
		}()
		if int32(pOp.opcode) == 136 {
			func() int {
				_ = 0
				return 0
			}()
			pC_cgo229.seekResult = int32(-1)
			if sqlite3BtreeCursorIsValidNN(pCrsr_cgo230) != 0 {
				goto _cgol_2
			}
		}
		rc = sqlite3BtreeLast(pCrsr_cgo230, &res_cgo231)
		pC_cgo229.nullRow = uint8(res_cgo231)
		pC_cgo229.deferredMoveto = uint8(0)
		pC_cgo229.cacheStatus = uint32(0)
		if rc != 0 {
			goto abort_due_to_error
		}
		if !(pOp.p2 > 0) {
			goto _cgol_232
		}
		if !(res_cgo231 != 0) {
			goto _cgol_233
		}
		goto jump_to_p2
	_cgol_233:
		;
	_cgol_232:
		goto _cgol_2
	_cgol_228:
		if _cgo_nm && _cgo_tag != 35 {
			goto _cgol_234
		}
		_cgo_nm = false
		pC_cgo235 = nil
		pCrsr_cgo236 = nil
		res_cgo237 = 0
		sz_cgo238 = 0
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo235 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		pCrsr_cgo236 = pC_cgo235.uc.pCursor
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3BtreeFirst(pCrsr_cgo236, &res_cgo237)
		if rc != 0 {
			goto abort_due_to_error
		}
		if res_cgo237 == 0 {
			sz_cgo238 = sqlite3BtreeRowCountEst(pCrsr_cgo236)
			if sz_cgo238 >= int64(0) && int32(sqlite3LogEst(uint64(sz_cgo238))) < pOp.p3 {
				res_cgo237 = int32(1)
			}
		}
		if !(res_cgo237 != 0) {
			goto _cgol_239
		}
		goto jump_to_p2
	_cgol_239:
		goto _cgol_2
	_cgol_234:
		if _cgo_nm && _cgo_tag != 36 {
			goto _cgol_240
		}
		_cgo_nm = false
	_cgol_240:
		if _cgo_nm && _cgo_tag != 37 {
			goto _cgol_241
		}
		_cgo_nm = false
		{
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(2)*4))++
		}
	_cgol_241:
		if _cgo_nm && _cgo_tag != 38 {
			goto _cgol_242
		}
		_cgo_nm = false
		pC_cgo243 = nil
		pCrsr_cgo244 = nil
		res_cgo245 = 0
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo243 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		res_cgo245 = int32(1)
		if int32(pC_cgo243.eCurType) == 1 {
			rc = sqlite3VdbeSorterRewind(pC_cgo243, &res_cgo245)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			pCrsr_cgo244 = pC_cgo243.uc.pCursor
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3BtreeFirst(pCrsr_cgo244, &res_cgo245)
			pC_cgo243.deferredMoveto = uint8(0)
			pC_cgo243.cacheStatus = uint32(0)
		}
		if rc != 0 {
			goto abort_due_to_error
		}
		pC_cgo243.nullRow = uint8(res_cgo245)
		func() int {
			_ = 0
			return 0
		}()
		if !(res_cgo245 != 0) {
			goto _cgol_246
		}
		goto jump_to_p2
	_cgol_246:
		goto _cgol_2
	_cgol_242:
		if _cgo_nm && _cgo_tag != 3 {
			goto _cgol_247
		}
		_cgo_nm = false
		pC_cgo248 = nil
		pC_cgo248 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3VdbeSorterNext(db, pC_cgo248)
		goto next_tail
	_cgol_247:
		if _cgo_nm && _cgo_tag != 4 {
			goto _cgol_249
		}
		_cgo_nm = false
	_cgol_249:
		if _cgo_nm && _cgo_tag != 5 {
			goto _cgol_250
		}
		_cgo_nm = false
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo248 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		rc = (*(*func(*struct_BtCursor, int32) int32)(unsafe.Pointer(&pOp.p4)))(pC_cgo248.uc.pCursor, pOp.p3)
	next_tail:
		pC_cgo248.cacheStatus = uint32(0)
		if !(rc == 0) {
			goto _cgol_251
		}
		pC_cgo248.nullRow = uint8(0)
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(pOp.p5)*4))++
		goto jump_to_p2_and_check_for_interrupt
	_cgol_251:
		if rc != 101 {
			goto abort_due_to_error
		}
		rc = int32(0)
		pC_cgo248.nullRow = uint8(1)
		goto check_for_interrupt
	_cgol_250:
		if _cgo_nm && _cgo_tag != 137 {
			goto _cgol_252
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var x struct_BtreePayload
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			func() int {
				_ = 0
				return 0
			}()
			if int32(pOp.p5)&1 != 0 {
				p.nChange++
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = func() int32 {
				if int32(pIn2.flags)&16384 != 0 {
					return sqlite3VdbeMemExpandBlob(pIn2)
				} else {
					return 0
				}
			}()
			if rc != 0 {
				goto abort_due_to_error
			}
			x.nKey = int64(pIn2.n)
			x.pKey = unsafe.Pointer(pIn2.z)
			x.aMem = (*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			x.nMem = uint16(*(*int32)(unsafe.Pointer(&pOp.p4)))
			rc = sqlite3BtreeInsert(pC.uc.pCursor, &x, int32(pOp.p5)&(8|2|128), func() int32 {
				if int32(pOp.p5)&16 != 0 {
					return pC.seekResult
				} else {
					return 0
				}
			}())
			func() int {
				_ = 0
				return 0
			}()
			pC.cacheStatus = uint32(0)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_252:
		if _cgo_nm && _cgo_tag != 138 {
			goto _cgol_253
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = func() int32 {
				if int32(pIn2.flags)&16384 != 0 {
					return sqlite3VdbeMemExpandBlob(pIn2)
				} else {
					return 0
				}
			}()
			if rc != 0 {
				goto abort_due_to_error
			}
			rc = sqlite3VdbeSorterWrite(pC, pIn2)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_253:
		if _cgo_nm && _cgo_tag != 139 {
			goto _cgol_254
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var pCrsr *struct_BtCursor
			var res int32
			var r struct_UnpackedRecord
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCrsr = pC.uc.pCursor
			func() int {
				_ = 0
				return 0
			}()
			r.pKeyInfo = pC.pKeyInfo
			r.nField = uint16(pOp.p3)
			r.default_rc = int8(0)
			r.aMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			rc = sqlite3BtreeIndexMoveto(pCrsr, &r, &res)
			if rc != 0 {
				goto abort_due_to_error
			}
			if res == 0 {
				rc = sqlite3BtreeDelete(pCrsr, uint8(4))
				if rc != 0 {
					goto abort_due_to_error
				}
			} else if int32(pOp.p5) != 0 && !(sqlite3WritableSchema(db) != 0) {
				rc = sqlite3ReportError(11|3<<8, 93526, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 'd', 'e', 'x', ' ', 'c', 'o', 'r', 'r', 'u', 'p', 't', 'i', 'o', 'n', '\x00'})))
				goto abort_due_to_error
			}
			func() int {
				_ = 0
				return 0
			}()
			pC.cacheStatus = uint32(0)
			pC.seekResult = int32(0)
			goto _cgol_2
		}
	_cgol_254:
		if _cgo_nm && _cgo_tag != 140 {
			goto _cgol_255
		}
		_cgo_nm = false
	_cgol_255:
		if _cgo_nm && _cgo_tag != 141 {
			goto _cgol_256
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var pTabCur *struct_VdbeCursor
			var rowid int64
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3VdbeCursorRestore(pC)
			if rc != 0 {
				goto abort_due_to_error
			}
			if !(pC.nullRow != 0) {
				rowid = int64(0)
				rc = sqlite3VdbeIdxRowid(db, pC.uc.pCursor, &rowid)
				if rc != 0 {
					goto abort_due_to_error
				}
				if int32(pOp.opcode) == 140 {
					func() int {
						_ = 0
						return 0
					}()
					pTabCur = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p3)*8))
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					pTabCur.nullRow = uint8(0)
					pTabCur.movetoTarget = rowid
					pTabCur.deferredMoveto = uint8(1)
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					*(**uint32)(unsafe.Pointer(&pTabCur.ub)) = *(**uint32)(unsafe.Pointer(&pOp.p4))
					func() int {
						_ = 0
						return 0
					}()
					pTabCur.pAltCursor = pC
				} else {
					pOut = out2Prerelease(p, pOp)
					*(*int64)(unsafe.Pointer(&pOut.u)) = rowid
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeMemSetNull(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56)))
			}
			goto _cgol_2
		}
	_cgol_256:
		if _cgo_nm && _cgo_tag != 142 {
			goto _cgol_257
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			if pC.deferredMoveto != 0 {
				rc = sqlite3VdbeFinishMoveto(pC)
				if rc != 0 {
					goto abort_due_to_error
				}
			}
			goto _cgol_2
		}
	_cgol_257:
		if _cgo_nm && _cgo_tag != 39 {
			goto _cgol_258
		}
		_cgo_nm = false
	_cgol_258:
		if _cgo_nm && _cgo_tag != 40 {
			goto _cgol_259
		}
		_cgo_nm = false
	_cgol_259:
		if _cgo_nm && _cgo_tag != 41 {
			goto _cgol_260
		}
		_cgo_nm = false
	_cgol_260:
		if _cgo_nm && _cgo_tag != 42 {
			goto _cgol_261
		}
		_cgo_nm = false
		pC_cgo262 = nil
		res_cgo263 = 0
		r_cgo264 = struct {
			pKeyInfo   *struct_KeyInfo
			aMem       *struct_sqlite3_value
			nField     uint16
			default_rc int8
			errCode    uint8
			r1         int8
			r2         int8
			eqSeen     uint8
		}{}
		func() int {
			_ = 0
			return 0
		}()
		pC_cgo262 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		r_cgo264.pKeyInfo = pC_cgo262.pKeyInfo
		r_cgo264.nField = uint16(*(*int32)(unsafe.Pointer(&pOp.p4)))
		if int32(pOp.opcode) < 41 {
			func() int {
				_ = 0
				return 0
			}()
			r_cgo264.default_rc = int8(-1)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			r_cgo264.default_rc = int8(0)
		}
		r_cgo264.aMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		{
			var nCellKey int64 = int64(0)
			var pCur *struct_BtCursor
			var m struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			pCur = pC_cgo262.uc.pCursor
			func() int {
				_ = 0
				return 0
			}()
			nCellKey = int64(sqlite3BtreePayloadSize(pCur))
			if nCellKey <= int64(0) || nCellKey > int64(2147483647) {
				rc = sqlite3CorruptError(93730)
				goto abort_due_to_error
			}
			sqlite3VdbeMemInit(&m, db, uint16(0))
			rc = sqlite3VdbeMemFromBtreeZeroOffset(pCur, uint32(nCellKey), &m)
			if rc != 0 {
				goto abort_due_to_error
			}
			res_cgo263 = sqlite3VdbeRecordCompareWithSkip(m.n, unsafe.Pointer(m.z), &r_cgo264, 0)
			sqlite3VdbeMemRelease(&m)
		}
		func() int {
			_ = 0
			return 0
		}()
		if int32(pOp.opcode)&1 == 41&1 {
			func() int {
				_ = 0
				return 0
			}()
			res_cgo263 = -res_cgo263
		} else {
			func() int {
				_ = 0
				return 0
			}()
			res_cgo263++
		}
		func() int {
			_ = 0
			return 0
		}()
		if !(res_cgo263 > 0) {
			goto _cgol_265
		}
		goto jump_to_p2
	_cgol_265:
		goto _cgol_2
	_cgol_261:
		if _cgo_nm && _cgo_tag != 143 {
			goto _cgol_266
		}
		_cgo_nm = false
		{
			var iMoved int32
			var iDb int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pOut = out2Prerelease(p, pOp)
			pOut.flags = uint16(1)
			if db.nVdbeRead > db.nVDestroy+1 {
				rc = int32(6)
				p.errorAction = uint8(2)
				goto abort_due_to_error
			} else {
				iDb = pOp.p3
				func() int {
					_ = 0
					return 0
				}()
				iMoved = int32(0)
				rc = sqlite3BtreeDropTable((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt, pOp.p1, &iMoved)
				pOut.flags = uint16(4)
				*(*int64)(unsafe.Pointer(&pOut.u)) = int64(iMoved)
				if rc != 0 {
					goto abort_due_to_error
				}
				if iMoved != 0 {
					sqlite3RootPageMoved(db, iDb, uint32(iMoved), uint32(pOp.p1))
					func() int {
						_ = 0
						return 0
					}()
					resetSchemaOnFault = uint8(iDb + 1)
				}
			}
			goto _cgol_2
		}
	_cgol_266:
		if _cgo_nm && _cgo_tag != 144 {
			goto _cgol_267
		}
		_cgo_nm = false
		{
			var nChange int64
			nChange = int64(0)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3BtreeClearTable((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p2)*32))).pBt, int32(uint32(pOp.p1)), &nChange)
			if pOp.p3 != 0 {
				p.nChange += nChange
				if pOp.p3 > 0 {
					func() int {
						_ = 0
						return 0
					}()
					*(*int64)(unsafe.Pointer(&(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))).u)) += nChange
				}
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_267:
		if _cgo_nm && _cgo_tag != 145 {
			goto _cgol_268
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			if int32(pC.eCurType) == 1 {
				sqlite3VdbeSorterReset(db, *(**struct_VdbeSorter)(unsafe.Pointer(&pC.uc)))
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3BtreeClearTableOfCursor(pC.uc.pCursor)
				if rc != 0 {
					goto abort_due_to_error
				}
			}
			goto _cgol_2
		}
	_cgol_268:
		if _cgo_nm && _cgo_tag != 146 {
			goto _cgol_269
		}
		_cgo_nm = false
		{
			var pgno uint32
			var pDb *struct_Db
			pOut = out2Prerelease(p, pOp)
			pgno = uint32(0)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3BtreeCreateTable(pDb.pBt, &pgno, pOp.p3)
			if rc != 0 {
				goto abort_due_to_error
			}
			*(*int64)(unsafe.Pointer(&pOut.u)) = int64(pgno)
			goto _cgol_2
		}
	_cgol_269:
		if _cgo_nm && _cgo_tag != 147 {
			goto _cgol_270
		}
		_cgo_nm = false
		{
			db.nSqlExec++
			rc = sqlite3_exec(db, *(**int8)(unsafe.Pointer(&pOp.p4)), nil, nil, nil)
			db.nSqlExec--
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_270:
		if _cgo_nm && _cgo_tag != 148 {
			goto _cgol_271
		}
		_cgo_nm = false
		{
			var iDb int32
			var zSchema *int8
			var zSql *int8
			var initData _cgoa_26
			iDb = pOp.p1
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(&pOp.p4)))) == uintptr(unsafe.Pointer(nil)) {
				sqlite3SchemaClear(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema))
				db.mDbFlags &= uint32(4294967279)
				rc = sqlite3InitOne(db, iDb, &p.zErrMsg, uint32(pOp.p5))
				db.mDbFlags |= uint32(1)
				{
					_autoGo_31 := &p.Xbf_0
					*_autoGo_31 = *_autoGo_31&^3 | uint32(0)&3
				}
			} else {
				zSchema = (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
				initData.db = db
				initData.iDb = iDb
				initData.pzErrMsg = &p.zErrMsg
				initData.mInitFlags = uint32(0)
				initData.mxPage = sqlite3BtreeLastPage((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt)
				zSql = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[43]int8{'S', 'E', 'L', 'E', 'C', 'T', '*', 'F', 'R', 'O', 'M', '"', '%', 'w', '"', '.', '%', 's', ' ', 'W', 'H', 'E', 'R', 'E', ' ', '%', 's', ' ', 'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', ' ', 'r', 'o', 'w', 'i', 'd', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, zSchema, *(**int8)(unsafe.Pointer(&pOp.p4)))
				if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
				} else {
					func() int {
						_ = 0
						return 0
					}()
					db.init.busy = uint8(1)
					initData.rc = int32(0)
					initData.nInitRow = uint32(0)
					func() int {
						_ = 0
						return 0
					}()
					rc = sqlite3_exec(db, zSql, sqlite3InitCallback, unsafe.Pointer(&initData), nil)
					if rc == 0 {
						rc = initData.rc
					}
					if rc == 0 && initData.nInitRow == uint32(0) {
						rc = sqlite3CorruptError(93982)
					}
					sqlite3DbFreeNN(db, unsafe.Pointer(zSql))
					db.init.busy = uint8(0)
				}
			}
			if rc != 0 {
				sqlite3ResetAllSchemasOfConnection(db)
				if rc == 7 {
					goto no_mem
				}
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_271:
		if _cgo_nm && _cgo_tag != 149 {
			goto _cgol_272
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3AnalysisLoad(db, pOp.p1)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_272:
		if _cgo_nm && _cgo_tag != 150 {
			goto _cgol_273
		}
		_cgo_nm = false
		{
			sqlite3UnlinkAndDeleteTable(db, pOp.p1, *(**int8)(unsafe.Pointer(&pOp.p4)))
			goto _cgol_2
		}
	_cgol_273:
		if _cgo_nm && _cgo_tag != 151 {
			goto _cgol_274
		}
		_cgo_nm = false
		{
			sqlite3UnlinkAndDeleteIndex(db, pOp.p1, *(**int8)(unsafe.Pointer(&pOp.p4)))
			goto _cgol_2
		}
	_cgol_274:
		if _cgo_nm && _cgo_tag != 152 {
			goto _cgol_275
		}
		_cgo_nm = false
		{
			sqlite3UnlinkAndDeleteTrigger(db, pOp.p1, *(**int8)(unsafe.Pointer(&pOp.p4)))
			goto _cgol_2
		}
	_cgol_275:
		if _cgo_nm && _cgo_tag != 154 {
			goto _cgol_276
		}
		_cgo_nm = false
		nRoot_cgo277 = 0
		aRoot_cgo278 = nil
		nErr_cgo279 = 0
		z_cgo280 = nil
		pnErr_cgo281 = nil
		func() int {
			_ = 0
			return 0
		}()
		nRoot_cgo277 = pOp.p2
		aRoot_cgo278 = *(**uint32)(unsafe.Pointer(&pOp.p4))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pnErr_cgo281 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		z_cgo280 = sqlite3BtreeIntegrityCheck(db, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p5)*32))).pBt, &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot_cgo278)) + uintptr(1)*4)), nRoot_cgo277, int32(*(*int64)(unsafe.Pointer(&pnErr_cgo281.u)))+1, &nErr_cgo279)
		sqlite3VdbeMemSetNull(pIn1)
		if nErr_cgo279 == 0 {
			func() int {
				_ = 0
				return 0
			}()
		} else if uintptr(unsafe.Pointer(z_cgo280)) == uintptr(unsafe.Pointer(nil)) {
			goto no_mem
		} else {
			*(*int64)(unsafe.Pointer(&pnErr_cgo281.u)) -= int64(nErr_cgo279 - 1)
			sqlite3VdbeMemSetStr(pIn1, z_cgo280, int64(-1), uint8(1), sqlite3_free)
		}
		sqlite3VdbeChangeEncoding(pIn1, int32(encoding))
		goto check_for_interrupt
	_cgol_276:
		if _cgo_nm && _cgo_tag != 155 {
			goto _cgol_282
		}
		_cgo_nm = false
		{
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			func() int {
				_ = 0
				return 0
			}()
			if int32(pIn1.flags)&16 == 0 {
				if sqlite3VdbeMemSetRowSet(pIn1) != 0 {
					goto no_mem
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			sqlite3RowSetInsert((*struct_RowSet)(unsafe.Pointer(pIn1.z)), *(*int64)(unsafe.Pointer(&pIn2.u)))
			goto _cgol_2
		}
	_cgol_282:
		if _cgo_nm && _cgo_tag != 45 {
			goto _cgol_283
		}
		_cgo_nm = false
		val_cgo284 = 0
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		if !(int32(pIn1.flags)&16 == 0 || sqlite3RowSetNext((*struct_RowSet)(unsafe.Pointer(pIn1.z)), &val_cgo284) == 0) {
			goto _cgol_286
		}
		sqlite3VdbeMemSetNull(pIn1)
		goto jump_to_p2_and_check_for_interrupt
		goto _cgol_285
	_cgol_286:
		sqlite3VdbeMemSetInt64(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56)), val_cgo284)
	_cgol_285:
		goto check_for_interrupt
	_cgol_283:
		if _cgo_nm && _cgo_tag != 46 {
			goto _cgol_287
		}
		_cgo_nm = false
		iSet_cgo288 = 0
		exists_cgo289 = 0
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		iSet_cgo288 = *(*int32)(unsafe.Pointer(&pOp.p4))
		func() int {
			_ = 0
			return 0
		}()
		if int32(pIn1.flags)&16 == 0 {
			if sqlite3VdbeMemSetRowSet(pIn1) != 0 {
				goto no_mem
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if !(iSet_cgo288 != 0) {
			goto _cgol_290
		}
		exists_cgo289 = sqlite3RowSetTest((*struct_RowSet)(unsafe.Pointer(pIn1.z)), iSet_cgo288, *(*int64)(unsafe.Pointer(&pIn3.u)))
		if !(exists_cgo289 != 0) {
			goto _cgol_291
		}
		goto jump_to_p2
	_cgol_291:
		;
	_cgol_290:
		if iSet_cgo288 >= 0 {
			sqlite3RowSetInsert((*struct_RowSet)(unsafe.Pointer(pIn1.z)), *(*int64)(unsafe.Pointer(&pIn3.u)))
		}
		goto _cgol_2
	_cgol_287:
		if _cgo_nm && _cgo_tag != 47 {
			goto _cgol_292
		}
		_cgo_nm = false
		nMem_cgo293 = 0
		nByte_cgo294 = 0
		pRt_cgo295 = nil
		pMem_cgo296 = nil
		pEnd_cgo297 = nil
		pFrame_cgo298 = nil
		pProgram_cgo299 = nil
		t_cgo300 = nil
		pProgram_cgo299 = *(**struct_SubProgram)(unsafe.Pointer(&pOp.p4))
		pRt_cgo295 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		func() int {
			_ = 0
			return 0
		}()
		if pOp.p5 != 0 {
			t_cgo300 = pProgram_cgo299.token
			for pFrame_cgo298 = p.pFrame; pFrame_cgo298 != nil && uintptr(unsafe.Pointer(pFrame_cgo298.token)) != uintptr(unsafe.Pointer(t_cgo300)); pFrame_cgo298 = pFrame_cgo298.pParent {
			}
			if pFrame_cgo298 != nil {
				goto _cgol_2
			}
		}
		if p.nFrame >= *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(10)*4)) {
			rc = int32(1)
			sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[37]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'l', 'e', 'v', 'e', 'l', 's', ' ', 'o', 'f', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', ' ', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'o', 'n', '\x00'})))
			goto abort_due_to_error
		}
		if int32(pRt_cgo295.flags)&16 == 0 {
			nMem_cgo293 = pProgram_cgo299.nMem + pProgram_cgo299.nCsr
			func() int {
				_ = 0
				return 0
			}()
			if pProgram_cgo299.nCsr == 0 {
				nMem_cgo293++
			}
			nByte_cgo294 = int32((120+uint(7))&uint(18446744073709551608) + uint(nMem_cgo293)*56 + uint(pProgram_cgo299.nCsr)*8 + uint((pProgram_cgo299.nOp+7)/8))
			pFrame_cgo298 = (*struct_VdbeFrame)(sqlite3DbMallocZero(db, uint64(nByte_cgo294)))
			if !(pFrame_cgo298 != nil) {
				goto no_mem
			}
			sqlite3VdbeMemRelease(pRt_cgo295)
			pRt_cgo295.flags = uint16(16 | 1024)
			pRt_cgo295.z = (*int8)(unsafe.Pointer(pFrame_cgo298))
			pRt_cgo295.n = nByte_cgo294
			pRt_cgo295.xDel = sqlite3VdbeFrameMemDel
			pFrame_cgo298.v = p
			pFrame_cgo298.nChildMem = nMem_cgo293
			pFrame_cgo298.nChildCsr = pProgram_cgo299.nCsr
			pFrame_cgo298.pc = int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24)
			pFrame_cgo298.aMem = p.aMem
			pFrame_cgo298.nMem = p.nMem
			pFrame_cgo298.apCsr = p.apCsr
			pFrame_cgo298.nCursor = p.nCursor
			pFrame_cgo298.aOp = p.aOp
			pFrame_cgo298.nOp = p.nOp
			pFrame_cgo298.token = pProgram_cgo299.token
			pEnd_cgo297 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sqlite3_value)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pFrame_cgo298)))) + uintptr((120+uint(7))&uint(18446744073709551608)))))))) + uintptr(pFrame_cgo298.nChildMem)*56))
			for pMem_cgo296 = (*struct_sqlite3_value)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pFrame_cgo298)))) + uintptr((120+uint(7))&uint(18446744073709551608)))))); uintptr(unsafe.Pointer(pMem_cgo296)) != uintptr(unsafe.Pointer(pEnd_cgo297)); *(*uintptr)(unsafe.Pointer(&pMem_cgo296)) += 56 {
				pMem_cgo296.flags = uint16(128)
				pMem_cgo296.db = db
			}
		} else {
			pFrame_cgo298 = (*struct_VdbeFrame)(unsafe.Pointer(pRt_cgo295.z))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
		}
		p.nFrame++
		pFrame_cgo298.pParent = p.pFrame
		pFrame_cgo298.lastRowid = db.lastRowid
		pFrame_cgo298.nChange = p.nChange
		pFrame_cgo298.nDbChange = p.db.nChange
		func() int {
			_ = 0
			return 0
		}()
		pFrame_cgo298.pAuxData = p.pAuxData
		p.pAuxData = (*struct_AuxData)(nil)
		p.nChange = int64(0)
		p.pFrame = pFrame_cgo298
		p.aMem = func() (_cgo_ret *struct_sqlite3_value) {
			_cgo_addr := &aMem
			*_cgo_addr = (*struct_sqlite3_value)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pFrame_cgo298)))) + uintptr((120+uint(7))&uint(18446744073709551608))))))
			return *_cgo_addr
		}()
		p.nMem = pFrame_cgo298.nChildMem
		p.nCursor = int32(uint16(pFrame_cgo298.nChildCsr))
		p.apCsr = (**struct_VdbeCursor)(unsafe.Pointer(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(p.nMem)*56))))
		pFrame_cgo298.aOnce = (*uint8)(unsafe.Pointer(&*(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pProgram_cgo299.nCsr)*8))))
		__builtin___memset_chk(unsafe.Pointer(pFrame_cgo298.aOnce), 0, uint((pProgram_cgo299.nOp+7)/8), __builtin_object_size(unsafe.Pointer(pFrame_cgo298.aOnce), 0))
		p.aOp = func() (_cgo_ret *struct_VdbeOp) {
			_cgo_addr := &aOp
			*_cgo_addr = pProgram_cgo299.aOp
			return *_cgo_addr
		}()
		p.nOp = pProgram_cgo299.nOp
		pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) - uintptr(- -1)*24))
		goto check_for_interrupt
	_cgol_292:
		if _cgo_nm && _cgo_tag != 156 {
			goto _cgol_301
		}
		_cgo_nm = false
		{
			var pFrame *struct_VdbeFrame
			var pIn *struct_sqlite3_value
			pOut = out2Prerelease(p, pOp)
			pFrame = p.pFrame
			pIn = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrame.aMem)) + uintptr(pOp.p1+(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrame.aOp)) + uintptr(pFrame.pc)*24))).p1)*56))
			sqlite3VdbeMemShallowCopy(pOut, pIn, 4096)
			goto _cgol_2
		}
	_cgol_301:
		if _cgo_nm && _cgo_tag != 157 {
			goto _cgol_302
		}
		_cgo_nm = false
		{
			if db.flags&uint64(524288) != 0 {
				db.nDeferredImmCons += int64(pOp.p2)
			} else if pOp.p1 != 0 {
				db.nDeferredCons += int64(pOp.p2)
			} else {
				p.nFkConstraint += int64(pOp.p2)
			}
			goto _cgol_2
		}
	_cgol_302:
		if _cgo_nm && _cgo_tag != 48 {
			goto _cgol_303
		}
		_cgo_nm = false
		if !(pOp.p1 != 0) {
			goto _cgol_305
		}
		if !(db.nDeferredCons == int64(0) && db.nDeferredImmCons == int64(0)) {
			goto _cgol_306
		}
		goto jump_to_p2
	_cgol_306:
		goto _cgol_304
	_cgol_305:
		if !(p.nFkConstraint == int64(0) && db.nDeferredImmCons == int64(0)) {
			goto _cgol_307
		}
		goto jump_to_p2
	_cgol_307:
		;
	_cgol_304:
		goto _cgol_2
	_cgol_303:
		if _cgo_nm && _cgo_tag != 158 {
			goto _cgol_308
		}
		_cgo_nm = false
		{
			var pFrame *struct_VdbeFrame
			if p.pFrame != nil {
				for pFrame = p.pFrame; pFrame.pParent != nil; pFrame = pFrame.pParent {
				}
				pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrame.aMem)) + uintptr(pOp.p1)*56))
			} else {
				pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			}
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeMemIntegerify(pIn1)
			pIn2 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
			sqlite3VdbeMemIntegerify(pIn2)
			if *(*int64)(unsafe.Pointer(&pIn1.u)) < *(*int64)(unsafe.Pointer(&pIn2.u)) {
				*(*int64)(unsafe.Pointer(&pIn1.u)) = *(*int64)(unsafe.Pointer(&pIn2.u))
			}
			goto _cgol_2
		}
	_cgol_308:
		if _cgo_nm && _cgo_tag != 49 {
			goto _cgol_309
		}
		_cgo_nm = false
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		if !(*(*int64)(unsafe.Pointer(&pIn1.u)) > int64(0)) {
			goto _cgol_310
		}
		*(*int64)(unsafe.Pointer(&pIn1.u)) -= int64(pOp.p3)
		goto jump_to_p2
	_cgol_310:
		goto _cgol_2
	_cgol_309:
		if _cgo_nm && _cgo_tag != 159 {
			goto _cgol_311
		}
		_cgo_nm = false
		{
			var x int64
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			pIn3 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			pOut = out2Prerelease(p, pOp)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			x = *(*int64)(unsafe.Pointer(&pIn1.u))
			if x <= int64(0) || sqlite3AddInt64(&x, func() int64 {
				if *(*int64)(unsafe.Pointer(&pIn3.u)) > int64(0) {
					return *(*int64)(unsafe.Pointer(&pIn3.u))
				} else {
					return int64(0)
				}
			}()) != 0 {
				*(*int64)(unsafe.Pointer(&pOut.u)) = int64(-1)
			} else {
				*(*int64)(unsafe.Pointer(&pOut.u)) = x
			}
			goto _cgol_2
		}
	_cgol_311:
		if _cgo_nm && _cgo_tag != 59 {
			goto _cgol_312
		}
		_cgo_nm = false
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		if !(*(*int64)(unsafe.Pointer(&pIn1.u)) != 0) {
			goto _cgol_313
		}
		if *(*int64)(unsafe.Pointer(&pIn1.u)) > int64(0) {
			*(*int64)(unsafe.Pointer(&pIn1.u))--
		}
		goto jump_to_p2
	_cgol_313:
		goto _cgol_2
	_cgol_312:
		if _cgo_nm && _cgo_tag != 60 {
			goto _cgol_314
		}
		_cgo_nm = false
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		if *(*int64)(unsafe.Pointer(&pIn1.u)) > int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
			*(*int64)(unsafe.Pointer(&pIn1.u))--
		}
		if !(*(*int64)(unsafe.Pointer(&pIn1.u)) == int64(0)) {
			goto _cgol_315
		}
		goto jump_to_p2
	_cgol_315:
		goto _cgol_2
	_cgol_314:
		if _cgo_nm && _cgo_tag != 160 {
			goto _cgol_316
		}
		_cgo_nm = false
	_cgol_316:
		if _cgo_nm && _cgo_tag != 161 {
			goto _cgol_317
		}
		_cgo_nm = false
		{
			var n int32
			var pCtx *struct_sqlite3_context
			func() int {
				_ = 0
				return 0
			}()
			n = int32(pOp.p5)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCtx = (*struct_sqlite3_context)(sqlite3DbMallocRawNN(db, uint64(uint(n)*8+(56+56-8))))
			if uintptr(unsafe.Pointer(pCtx)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			pCtx.pMem = (*struct_sqlite3_value)(nil)
			pCtx.pOut = (*struct_sqlite3_value)(unsafe.Pointer(&*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pCtx.argv)))) + uintptr(n)*8))))
			sqlite3VdbeMemInit(pCtx.pOut, db, uint16(1))
			pCtx.pFunc = *(**struct_FuncDef)(unsafe.Pointer(&pOp.p4))
			pCtx.iOp = int32((uintptr(unsafe.Pointer(pOp)) - uintptr(unsafe.Pointer(aOp))) * 24)
			pCtx.pVdbe = p
			pCtx.skipFlag = uint8(0)
			pCtx.isError = int32(0)
			pCtx.argc = uint8(n)
			pOp.p4type = int8(-16)
			*(**struct_sqlite3_context)(unsafe.Pointer(&pOp.p4)) = pCtx
			func() int {
				_ = 0
				return 0
			}()
			pOp.opcode = uint8(162)
		}
	_cgol_317:
		if _cgo_nm && _cgo_tag != 162 {
			goto _cgol_318
		}
		_cgo_nm = false
		{
			var i int32
			var pCtx *struct_sqlite3_context
			var pMem *struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			pCtx = *(**struct_sqlite3_context)(unsafe.Pointer(&pOp.p4))
			pMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			if uintptr(unsafe.Pointer(pCtx.pMem)) != uintptr(unsafe.Pointer(pMem)) {
				pCtx.pMem = pMem
				for i = int32(pCtx.argc) - 1; i >= 0; i-- {
					*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pCtx.argv)))) + uintptr(i)*8)) = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2+i)*56))
				}
			}
			pMem.n++
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if pOp.p1 != 0 {
				pCtx.pFunc.xInverse(pCtx, int32(pCtx.argc), (**struct_sqlite3_value)(unsafe.Pointer(&pCtx.argv)))
			} else {
				pCtx.pFunc.xSFunc(pCtx, int32(pCtx.argc), (**struct_sqlite3_value)(unsafe.Pointer(&pCtx.argv)))
			}
			if pCtx.isError != 0 {
				if pCtx.isError > 0 {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_value_text(pCtx.pOut))
					rc = pCtx.isError
				}
				if pCtx.skipFlag != 0 {
					func() int {
						_ = 0
						return 0
					}()
					i = (*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) - uintptr(- -1)*24))).p1
					if i != 0 {
						sqlite3VdbeMemSetInt64(&*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(i)*56)), int64(1))
					}
					pCtx.skipFlag = uint8(0)
				}
				sqlite3VdbeMemRelease(pCtx.pOut)
				pCtx.pOut.flags = uint16(1)
				pCtx.isError = int32(0)
				if rc != 0 {
					goto abort_due_to_error
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		}
	_cgol_318:
		if _cgo_nm && _cgo_tag != 163 {
			goto _cgol_319
		}
		_cgo_nm = false
	_cgol_319:
		if _cgo_nm && _cgo_tag != 164 {
			goto _cgol_320
		}
		_cgo_nm = false
		{
			var pMem *struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			if pOp.p3 != 0 {
				rc = sqlite3VdbeMemAggValue(pMem, &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56)), *(**struct_FuncDef)(unsafe.Pointer(&pOp.p4)))
				pMem = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			} else {
				rc = sqlite3VdbeMemFinalize(pMem, *(**struct_FuncDef)(unsafe.Pointer(&pOp.p4)))
			}
			if rc != 0 {
				sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_value_text(pMem))
				goto abort_due_to_error
			}
			sqlite3VdbeChangeEncoding(pMem, int32(encoding))
			if sqlite3VdbeMemTooBig(pMem) != 0 {
				goto too_big
			}
			goto _cgol_2
		}
	_cgol_320:
		if _cgo_nm && _cgo_tag != 6 {
			goto _cgol_321
		}
		_cgo_nm = false
		{
			var i int32
			var aRes [3]int32
			var pMem *struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(0)*4)) = int32(0)
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(1)*4)) = func() (_cgo_ret int32) {
				_cgo_addr := &*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(2)*4))
				*_cgo_addr = int32(-1)
				return *_cgo_addr
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3Checkpoint(db, pOp.p1, pOp.p2, &*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(1)*4)), &*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(2)*4)))
			if rc != 0 {
				if rc != 5 {
					goto abort_due_to_error
				}
				rc = int32(0)
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(0)*4)) = int32(1)
			}
			for func() *struct_sqlite3_value {
				i = int32(0)
				return func() (_cgo_ret *struct_sqlite3_value) {
					_cgo_addr := &pMem
					*_cgo_addr = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
					return *_cgo_addr
				}()
			}(); i < 3; func() *struct_sqlite3_value {
				i++
				return func() (_cgo_ret *struct_sqlite3_value) {
					_cgo_addr := &pMem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return
				}()
			}() {
				sqlite3VdbeMemSetInt64(pMem, int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aRes)))) + uintptr(i)*4))))
			}
			goto _cgol_2
		}
	_cgol_321:
		if _cgo_nm && _cgo_tag != 7 {
			goto _cgol_322
		}
		_cgo_nm = false
		{
			var pBt *struct_Btree
			var pPager *struct_Pager
			var eNew int32
			var eOld int32
			var zFilename *int8
			pOut = out2Prerelease(p, pOp)
			eNew = pOp.p3
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pBt = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pBt
			pPager = sqlite3BtreePager(pBt)
			eOld = sqlite3PagerGetJournalMode(pPager)
			if eNew == -1 {
				eNew = eOld
			}
			func() int {
				_ = 0
				return 0
			}()
			if !(sqlite3PagerOkToChangeJournalMode(pPager) != 0) {
				eNew = eOld
			}
			zFilename = sqlite3PagerFilename(pPager, 1)
			if eNew == 5 && (sqlite3Strlen30(zFilename) == 0 || !(sqlite3PagerWalSupported(pPager) != 0)) {
				eNew = eOld
			}
			if eNew != eOld && (eOld == 5 || eNew == 5) {
				if !(db.autoCommit != 0) || db.nVdbeRead > 1 {
					rc = int32(1)
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[52]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'h', 'a', 'n', 'g', 'e', ' ', '%', 's', ' ', 'w', 'a', 'l', ' ', 'm', 'o', 'd', 'e', ' ', 'f', 'r', 'o', 'm', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'a', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '\x00'})), func() *int8 {
						if eNew == 5 {
							return (*int8)(unsafe.Pointer(&[5]int8{'i', 'n', 't', 'o', '\x00'}))
						} else {
							return (*int8)(unsafe.Pointer(&[7]int8{'o', 'u', 't', ' ', 'o', 'f', '\x00'}))
						}
					}())
					goto abort_due_to_error
				} else {
					if eOld == 5 {
						rc = sqlite3PagerCloseWal(pPager, db)
						if rc == 0 {
							sqlite3PagerSetJournalMode(pPager, eNew)
						}
					} else if eOld == 4 {
						sqlite3PagerSetJournalMode(pPager, 2)
					}
					func() int {
						_ = 0
						return 0
					}()
					if rc == 0 {
						rc = sqlite3BtreeSetVersion(pBt, func() int32 {
							if eNew == 5 {
								return 2
							} else {
								return 1
							}
						}())
					}
				}
			}
			if rc != 0 {
				eNew = eOld
			}
			eNew = sqlite3PagerSetJournalMode(pPager, eNew)
			pOut.flags = uint16(2 | 2048 | 512)
			pOut.z = (*int8)(unsafe.Pointer(sqlite3JournalModename(eNew)))
			pOut.n = sqlite3Strlen30(pOut.z)
			pOut.enc = uint8(1)
			sqlite3VdbeChangeEncoding(pOut, int32(encoding))
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_322:
		if _cgo_nm && _cgo_tag != 8 {
			goto _cgol_323
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3RunVacuum(&p.zErrMsg, db, pOp.p1, func() *struct_sqlite3_value {
				if pOp.p2 != 0 {
					return &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56))
				} else {
					return nil
				}
			}())
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_323:
		if _cgo_nm && _cgo_tag != 61 {
			goto _cgol_324
		}
		_cgo_nm = false
		pBt_cgo325 = nil
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pBt_cgo325 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pBt
		rc = sqlite3BtreeIncrVacuum(pBt_cgo325)
		if !(rc != 0) {
			goto _cgol_326
		}
		if rc != 101 {
			goto abort_due_to_error
		}
		rc = int32(0)
		goto jump_to_p2
	_cgol_326:
		goto _cgol_2
	_cgol_324:
		if _cgo_nm && _cgo_tag != 165 {
			goto _cgol_327
		}
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			if !(pOp.p1 != 0) {
				sqlite3ExpirePreparedStatements(db, pOp.p2)
			} else {
				{
					_autoGo_32 := &p.Xbf_0
					*_autoGo_32 = *_autoGo_32&^3 | uint32(pOp.p2+1)&3
				}
			}
			goto _cgol_2
		}
	_cgol_327:
		if _cgo_nm && _cgo_tag != 166 {
			goto _cgol_328
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3BtreeCursorPin(pC.uc.pCursor)
			goto _cgol_2
		}
	_cgol_328:
		if _cgo_nm && _cgo_tag != 167 {
			goto _cgol_329
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			func() int {
				_ = 0
				return 0
			}()
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3BtreeCursorUnpin(pC.uc.pCursor)
			goto _cgol_2
		}
	_cgol_329:
		if _cgo_nm && _cgo_tag != 168 {
			goto _cgol_330
		}
		_cgo_nm = false
		{
			var isWriteLock uint8 = uint8(pOp.p3)
			if int32(isWriteLock) != 0 || uint64(0) == db.flags&uint64(1024) {
				var p1 int32 = pOp.p1
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3BtreeLockTable((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(p1)*32))).pBt, pOp.p2, isWriteLock)
				if rc != 0 {
					if rc&255 == 6 {
						var z *int8 = *(**int8)(unsafe.Pointer(&pOp.p4))
						sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[29]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'i', 's', ' ', 'l', 'o', 'c', 'k', 'e', 'd', ':', ' ', '%', 's', '\x00'})), z)
					}
					goto abort_due_to_error
				}
			}
			goto _cgol_2
		}
	_cgol_330:
		if _cgo_nm && _cgo_tag != 169 {
			goto _cgol_331
		}
		_cgo_nm = false
		{
			var pVTab *struct_VTable
			pVTab = *(**struct_VTable)(unsafe.Pointer(&pOp.p4))
			rc = sqlite3VtabBegin(db, pVTab)
			if pVTab != nil {
				sqlite3VtabImportErrmsg(p, pVTab.pVtab)
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_331:
		if _cgo_nm && _cgo_tag != 170 {
			goto _cgol_332
		}
		_cgo_nm = false
		{
			var sMem struct_sqlite3_value
			var zTab *int8
			__builtin___memset_chk(unsafe.Pointer(&sMem), 0, 56, __builtin_object_size(unsafe.Pointer(&sMem), 0))
			sMem.db = db
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3VdbeMemCopy(&sMem, &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2)*56)))
			func() int {
				_ = 0
				return 0
			}()
			zTab = (*int8)(unsafe.Pointer(sqlite3_value_text(&sMem)))
			func() int {
				_ = 0
				return 0
			}()
			if zTab != nil {
				rc = sqlite3VtabCallCreate(db, pOp.p1, zTab, &p.zErrMsg)
			}
			sqlite3VdbeMemRelease(&sMem)
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_332:
		if _cgo_nm && _cgo_tag != 171 {
			goto _cgol_333
		}
		_cgo_nm = false
		{
			db.nVDestroy++
			rc = sqlite3VtabCallDestroy(db, pOp.p1, *(**int8)(unsafe.Pointer(&pOp.p4)))
			db.nVDestroy--
			func() int {
				_ = 0
				return 0
			}()
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_333:
		if _cgo_nm && _cgo_tag != 172 {
			goto _cgol_334
		}
		_cgo_nm = false
		{
			var pCur *struct_VdbeCursor
			var pVCur *struct_sqlite3_vtab_cursor
			var pVtab *struct_sqlite3_vtab
			var pModule *struct_sqlite3_module
			func() int {
				_ = 0
				return 0
			}()
			pCur = (*struct_VdbeCursor)(nil)
			pVCur = (*struct_sqlite3_vtab_cursor)(nil)
			pVtab = (*(**struct_VTable)(unsafe.Pointer(&pOp.p4))).pVtab
			if uintptr(unsafe.Pointer(pVtab)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pVtab.pModule)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(6)
				goto abort_due_to_error
			}
			pModule = pVtab.pModule
			rc = pModule.xOpen(pVtab, &pVCur)
			sqlite3VtabImportErrmsg(p, pVtab)
			if rc != 0 {
				goto abort_due_to_error
			}
			pVCur.pVtab = pVtab
			pCur = allocateCursor(p, pOp.p1, 0, uint8(2))
			if pCur != nil {
				*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur.uc)) = pVCur
				pVtab.nRef++
			} else {
				func() int {
					_ = 0
					return 0
				}()
				pModule.xClose(pVCur)
				goto no_mem
			}
			goto _cgol_2
		}
	_cgol_334:
		if _cgo_nm && _cgo_tag != 173 {
			goto _cgol_335
		}
		_cgo_nm = false
		{
			var pC *struct_VdbeCursor
			var pRhs *struct_ValueList
			pC = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			pRhs = (*struct_ValueList)(sqlite3_malloc64(uint64(16)))
			if uintptr(unsafe.Pointer(pRhs)) == uintptr(unsafe.Pointer(nil)) {
				goto no_mem
			}
			pRhs.pCsr = pC.uc.pCursor
			pRhs.pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			pOut = out2Prerelease(p, pOp)
			pOut.flags = uint16(1)
			sqlite3VdbeMemSetPointer(pOut, unsafe.Pointer(pRhs), (*int8)(unsafe.Pointer(&[10]int8{'V', 'a', 'l', 'u', 'e', 'L', 'i', 's', 't', '\x00'})), sqlite3_free)
			goto _cgol_2
		}
	_cgol_335:
		if _cgo_nm && _cgo_tag != 9 {
			goto _cgol_336
		}
		_cgo_nm = false
		nArg_cgo337 = 0
		iQuery_cgo338 = 0
		pModule_cgo339 = nil
		pQuery_cgo340 = nil
		pArgc_cgo341 = nil
		pVCur_cgo342 = nil
		pVtab_cgo343 = nil
		pCur_cgo344 = nil
		res_cgo345 = 0
		i_cgo346 = 0
		apArg_cgo347 = nil
		pQuery_cgo340 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
		pArgc_cgo341 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pQuery_cgo340)) + uintptr(1)*56))
		pCur_cgo344 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pVCur_cgo342 = *(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur_cgo344.uc))
		pVtab_cgo343 = pVCur_cgo342.pVtab
		pModule_cgo339 = pVtab_cgo343.pModule
		func() int {
			_ = 0
			return 0
		}()
		nArg_cgo337 = int32(*(*int64)(unsafe.Pointer(&pArgc_cgo341.u)))
		iQuery_cgo338 = int32(*(*int64)(unsafe.Pointer(&pQuery_cgo340.u)))
		apArg_cgo347 = p.apArg
		for i_cgo346 = int32(0); i_cgo346 < nArg_cgo337; i_cgo346++ {
			*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg_cgo347)) + uintptr(i_cgo346)*8)) = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(pArgc_cgo341)) + uintptr(i_cgo346+1)*56))
		}
		rc = pModule_cgo339.xFilter(pVCur_cgo342, iQuery_cgo338, *(**int8)(unsafe.Pointer(&pOp.p4)), nArg_cgo337, apArg_cgo347)
		sqlite3VtabImportErrmsg(p, pVtab_cgo343)
		if rc != 0 {
			goto abort_due_to_error
		}
		res_cgo345 = pModule_cgo339.xEof(pVCur_cgo342)
		pCur_cgo344.nullRow = uint8(0)
		if !(res_cgo345 != 0) {
			goto _cgol_348
		}
		goto jump_to_p2
	_cgol_348:
		goto _cgol_2
	_cgol_336:
		if _cgo_nm && _cgo_tag != 174 {
			goto _cgol_349
		}
		_cgo_nm = false
		{
			var pVtab *struct_sqlite3_vtab
			var pModule *struct_sqlite3_module
			var pDest *struct_sqlite3_value
			var sContext struct_sqlite3_context
			var pCur *struct_VdbeCursor = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pDest = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			if pCur.nullRow != 0 {
				sqlite3VdbeMemSetNull(pDest)
				goto _cgol_2
			}
			pVtab = (*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur.uc))).pVtab
			pModule = pVtab.pModule
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memset_chk(unsafe.Pointer(&sContext), 0, 56, __builtin_object_size(unsafe.Pointer(&sContext), 0))
			sContext.pOut = pDest
			func() int {
				_ = 0
				return 0
			}()
			if int32(pOp.p5)&1 != 0 {
				sqlite3VdbeMemSetNull(pDest)
				pDest.flags = uint16(1 | 16384)
				*(*int32)(unsafe.Pointer(&pDest.u)) = int32(0)
			} else {
				pDest.flags = uint16(int32(pDest.flags) & ^(49599|16384) | 1)
			}
			rc = pModule.xColumn(*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur.uc)), &sContext, pOp.p2)
			sqlite3VtabImportErrmsg(p, pVtab)
			if sContext.isError > 0 {
				sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_value_text(pDest))
				rc = sContext.isError
			}
			sqlite3VdbeChangeEncoding(pDest, int32(encoding))
			if sqlite3VdbeMemTooBig(pDest) != 0 {
				goto too_big
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_349:
		if _cgo_nm && _cgo_tag != 62 {
			goto _cgol_350
		}
		_cgo_nm = false
		pVtab_cgo351 = nil
		pModule_cgo352 = nil
		res_cgo353 = 0
		pCur_cgo354 = nil
		pCur_cgo354 = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(p.apCsr)) + uintptr(pOp.p1)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pCur_cgo354.nullRow != 0 {
			goto _cgol_2
		}
		pVtab_cgo351 = (*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur_cgo354.uc))).pVtab
		pModule_cgo352 = pVtab_cgo351.pModule
		func() int {
			_ = 0
			return 0
		}()
		rc = pModule_cgo352.xNext(*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur_cgo354.uc)))
		sqlite3VtabImportErrmsg(p, pVtab_cgo351)
		if rc != 0 {
			goto abort_due_to_error
		}
		res_cgo353 = pModule_cgo352.xEof(*(**struct_sqlite3_vtab_cursor)(unsafe.Pointer(&pCur_cgo354.uc)))
		if !!(res_cgo353 != 0) {
			goto _cgol_355
		}
		goto jump_to_p2_and_check_for_interrupt
	_cgol_355:
		goto check_for_interrupt
	_cgol_350:
		if _cgo_nm && _cgo_tag != 175 {
			goto _cgol_356
		}
		_cgo_nm = false
		{
			var pVtab *struct_sqlite3_vtab
			var pName *struct_sqlite3_value
			var isLegacy int32
			isLegacy = int32(db.flags & uint64(67108864))
			db.flags |= uint64(67108864)
			pVtab = (*(**struct_VTable)(unsafe.Pointer(&pOp.p4))).pVtab
			pName = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = sqlite3VdbeChangeEncoding(pName, 1)
			if rc != 0 {
				goto abort_due_to_error
			}
			rc = pVtab.pModule.xRename(pVtab, pName.z)
			if isLegacy == 0 {
				db.flags &= ^uint64(67108864)
			}
			sqlite3VtabImportErrmsg(p, pVtab)
			{
				_autoGo_33 := &p.Xbf_0
				*_autoGo_33 = *_autoGo_33&^3 | uint32(0)&3
			}
			if rc != 0 {
				goto abort_due_to_error
			}
			goto _cgol_2
		}
	_cgol_356:
		if _cgo_nm && _cgo_tag != 10 {
			goto _cgol_357
		}
		_cgo_nm = false
		{
			var pVtab *struct_sqlite3_vtab
			var pModule *struct_sqlite3_module
			var nArg int32
			var i int32
			var rowid int64 = int64(0)
			var apArg **struct_sqlite3_value
			var pX *struct_sqlite3_value
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if db.mallocFailed != 0 {
				goto no_mem
			}
			pVtab = (*(**struct_VTable)(unsafe.Pointer(&pOp.p4))).pVtab
			if uintptr(unsafe.Pointer(pVtab)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pVtab.pModule)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(6)
				goto abort_due_to_error
			}
			pModule = pVtab.pModule
			nArg = pOp.p2
			func() int {
				_ = 0
				return 0
			}()
			if pModule.xUpdate != nil {
				var vtabOnConflict uint8 = db.vtabOnConflict
				apArg = p.apArg
				pX = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
				for i = int32(0); i < nArg; i++ {
					func() int {
						_ = 0
						return 0
					}()
					*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(i)*8)) = pX
					*(*uintptr)(unsafe.Pointer(&pX)) += 56
				}
				db.vtabOnConflict = uint8(pOp.p5)
				rc = pModule.xUpdate(pVtab, nArg, apArg, &rowid)
				db.vtabOnConflict = vtabOnConflict
				sqlite3VtabImportErrmsg(p, pVtab)
				if rc == 0 && pOp.p1 != 0 {
					func() int {
						_ = 0
						return 0
					}()
					db.lastRowid = rowid
				}
				if rc&255 == 19 && int32((*(**struct_VTable)(unsafe.Pointer(&pOp.p4))).bConstraint) != 0 {
					if int32(pOp.p5) == 4 {
						rc = int32(0)
					} else {
						p.errorAction = uint8(func() int32 {
							if int32(pOp.p5) == 5 {
								return 2
							} else {
								return int32(pOp.p5)
							}
						}())
					}
				} else {
					p.nChange++
				}
				if rc != 0 {
					goto abort_due_to_error
				}
			}
			goto _cgol_2
		}
	_cgol_357:
		if _cgo_nm && _cgo_tag != 176 {
			goto _cgol_358
		}
		_cgo_nm = false
		{
			pOut = out2Prerelease(p, pOp)
			*(*int64)(unsafe.Pointer(&pOut.u)) = int64(sqlite3BtreeLastPage((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pBt))
			goto _cgol_2
		}
	_cgol_358:
		if _cgo_nm && _cgo_tag != 177 {
			goto _cgol_359
		}
		_cgo_nm = false
		{
			var newMax uint32
			var pBt *struct_Btree
			pOut = out2Prerelease(p, pOp)
			pBt = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(pOp.p1)*32))).pBt
			newMax = uint32(0)
			if pOp.p3 != 0 {
				newMax = sqlite3BtreeLastPage(pBt)
				if newMax < uint32(pOp.p3) {
					newMax = uint32(pOp.p3)
				}
			}
			*(*int64)(unsafe.Pointer(&pOut.u)) = int64(sqlite3BtreeMaxPageCount(pBt, newMax))
			goto _cgol_2
		}
	_cgol_359:
		if _cgo_nm && _cgo_tag != 65 {
			goto _cgol_360
		}
		_cgo_nm = false
	_cgol_360:
		if _cgo_nm && _cgo_tag != 66 {
			goto _cgol_361
		}
		_cgo_nm = false
		{
			var i int32
			var pCtx *struct_sqlite3_context
			func() int {
				_ = 0
				return 0
			}()
			pCtx = *(**struct_sqlite3_context)(unsafe.Pointer(&pOp.p4))
			pOut = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p3)*56))
			if uintptr(unsafe.Pointer(pCtx.pOut)) != uintptr(unsafe.Pointer(pOut)) {
				pCtx.pVdbe = p
				pCtx.pOut = pOut
				for i = int32(pCtx.argc) - 1; i >= 0; i-- {
					*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pCtx.argv)))) + uintptr(i)*8)) = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p2+i)*56))
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 1)
			func() int {
				_ = 0
				return 0
			}()
			pCtx.pFunc.xSFunc(pCtx, int32(pCtx.argc), (**struct_sqlite3_value)(unsafe.Pointer(&pCtx.argv)))
			if pCtx.isError != 0 {
				if pCtx.isError > 0 {
					sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_value_text(pOut))
					rc = pCtx.isError
				}
				sqlite3VdbeDeleteAuxData(db, &p.pAuxData, pCtx.iOp, pOp.p1)
				pCtx.isError = int32(0)
				if rc != 0 {
					goto abort_due_to_error
				}
			}
			if int32(pOut.flags)&(2|16) != 0 {
				sqlite3VdbeChangeEncoding(pOut, int32(encoding))
				if sqlite3VdbeMemTooBig(pOut) != 0 {
					goto too_big
				}
			}
			goto _cgol_2
		}
	_cgol_361:
		if _cgo_nm && _cgo_tag != 178 {
			goto _cgol_362
		}
		_cgo_nm = false
		{
			var h uint64
			func() int {
				_ = 0
				return 0
			}()
			pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			h = filterHash(aMem, pOp)
			h %= uint64(pIn1.n)
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn1.z)) + uintptr(h/uint64(8)))) |= int8(1 << (h & uint64(7)))
			goto _cgol_2
		}
	_cgol_362:
		if _cgo_nm && _cgo_tag != 63 {
			goto _cgol_363
		}
		_cgo_nm = false
		h_cgo364 = 0
		func() int {
			_ = 0
			return 0
		}()
		pIn1 = &*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aMem)) + uintptr(pOp.p1)*56))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		h_cgo364 = filterHash(aMem, pOp)
		h_cgo364 %= uint64(pIn1.n)
		if !(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIn1.z)) + uintptr(h_cgo364/uint64(8)))))&int32(1<<(h_cgo364&uint64(7))) == 0) {
			goto _cgol_366
		}
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(8)*4))++
		goto jump_to_p2
		goto _cgol_365
	_cgol_366:
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(7)*4))++
	_cgol_365:
		goto _cgol_2
	_cgol_363:
		if _cgo_nm && _cgo_tag != 179 {
			goto _cgol_367
		}
		_cgo_nm = false
	_cgol_367:
		if _cgo_nm && _cgo_tag != 64 {
			goto _cgol_368
		}
		_cgo_nm = false
		i_cgo369 = 0
		zTrace_cgo370 = nil
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if int32(db.mTrace)&(1|64) != 0 && !(p.doingRerun != 0) && uintptr(unsafe.Pointer(func() (_cgo_ret *int8) {
			_cgo_addr := &zTrace_cgo370
			*_cgo_addr = func() *int8 {
				if *(**int8)(unsafe.Pointer(&pOp.p4)) != nil {
					return *(**int8)(unsafe.Pointer(&pOp.p4))
				} else {
					return p.zSql
				}
			}()
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			if int32(db.mTrace)&64 != 0 {
				var z *int8 = sqlite3VdbeExpandSql(p, zTrace_cgo370)
				db.trace.xLegacy(db.pTraceArg, z)
				sqlite3_free(unsafe.Pointer(z))
			} else if db.nVdbeExec > 1 {
				var z *int8 = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[6]int8{'-', '-', ' ', '%', 's', '\x00'})), zTrace_cgo370)
				func() int {
					_ = (*(*func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(unsafe.Pointer(&db.trace)))(uint32(1), db.pTraceArg, unsafe.Pointer(p), unsafe.Pointer(z))
					return 0
				}()
				sqlite3DbFree(db, unsafe.Pointer(z))
			} else {
				func() int {
					_ = (*(*func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(unsafe.Pointer(&db.trace)))(uint32(1), db.pTraceArg, unsafe.Pointer(p), unsafe.Pointer(zTrace_cgo370))
					return 0
				}()
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		if pOp.p1 >= sqlite3Config.iOnceResetThreshold {
			if int32(pOp.opcode) == 179 {
				goto _cgol_2
			}
			for i_cgo369 = int32(1); i_cgo369 < p.nOp; i_cgo369++ {
				if int32((*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(i_cgo369)*24))).opcode) == 17 {
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aOp)) + uintptr(i_cgo369)*24))).p1 = int32(0)
				}
			}
			pOp.p1 = int32(0)
		}
		pOp.p1++
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(6)*4))++
		goto jump_to_p2
	_cgol_371:
		_cgo_nm = false
		{
			func() int {
				_ = 0
				return 0
			}()
			goto _cgol_2
		}
		goto _cgol_2
	_cgol_368:
		goto _cgol_371
	_cgol_2:
	}
abort_due_to_error:
	if db.mallocFailed != 0 {
		rc = int32(7)
	} else if rc == 10|33<<8 {
		rc = sqlite3CorruptError(95919)
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p.zErrMsg)) == uintptr(unsafe.Pointer(nil)) && rc != 10|12<<8 {
		sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3ErrStr(rc))
	}
	p.rc = rc
	sqlite3SystemError(db, rc)
	sqlite3_log(rc, (*int8)(unsafe.Pointer(&[32]int8{'s', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', ' ', 'a', 'b', 'o', 'r', 't', 's', ' ', 'a', 't', ' ', '%', 'd', ':', ' ', '[', '%', 's', ']', ' ', '%', 's', '\x00'})), int32((uintptr(unsafe.Pointer(pOp))-uintptr(unsafe.Pointer(aOp)))*24), p.zSql, p.zErrMsg)
	sqlite3VdbeHalt(p)
	if rc == 10|12<<8 {
		sqlite3OomFault(db)
	}
	if rc == 11 && int32(db.autoCommit) == 0 {
		db.flags |= uint64(2) << 32
	}
	rc = int32(1)
	if int32(resetSchemaOnFault) > 0 {
		sqlite3ResetOneSchema(db, int32(resetSchemaOnFault)-1)
	}
vdbe_return:
	for nVmStep >= nProgressLimit && uintptr(unsafe.Pointer(db.xProgress)) != uintptr(unsafe.Pointer(nil)) {
		nProgressLimit += uint64(db.nProgressOps)
		if db.xProgress(db.pProgressArg) != 0 {
			nProgressLimit = uint64(4294967295) | uint64(4294967295)<<32
			rc = int32(9)
			goto abort_due_to_error
		}
	}
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&p.aCounter)))) + uintptr(4)*4)) += uint32(int32(nVmStep))
	sqlite3VdbeLeave(p)
	func() int {
		_ = 0
		return 0
	}()
	return rc
too_big:
	sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[23]int8{'s', 't', 'r', 'i', 'n', 'g', ' ', 'o', 'r', ' ', 'b', 'l', 'o', 'b', ' ', 't', 'o', 'o', ' ', 'b', 'i', 'g', '\x00'})))
	rc = int32(18)
	goto abort_due_to_error
no_mem:
	sqlite3OomFault(db)
	sqlite3VdbeError(p, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
	rc = int32(7)
	goto abort_due_to_error
abort_due_to_interrupt:
	func() int {
		_ = 0
		return 0
	}()
	rc = int32(9)
	goto abort_due_to_error
}

type Incrblob = struct_Incrblob
type struct_Incrblob struct {
	nByte   int32
	iOffset int32
	iCol    uint16
	pCsr    *struct_BtCursor
	pStmt   *struct_sqlite3_stmt
	db      *struct_sqlite3
	zDb     *int8
	pTab    *struct_Table
}

func blobSeekToRow(p *struct_Incrblob, iRow int64, pzErr **int8) int32 {
	var rc int32
	var zErr *int8 = nil
	var v *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(p.pStmt))
	(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(v.aMem)) + uintptr(1)*56))).flags = uint16(4)
	*(*int64)(unsafe.Pointer(&(*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(v.aMem)) + uintptr(1)*56))).u)) = iRow
	if v.pc > 4 {
		v.pc = int32(4)
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3VdbeExec(v)
	} else {
		rc = sqlite3_step(p.pStmt)
	}
	if rc == 100 {
		var pC *struct_VdbeCursor = *(**struct_VdbeCursor)(unsafe.Pointer(uintptr(unsafe.Pointer(v.apCsr)) + uintptr(0)*8))
		var type_ uint32
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		type_ = func() uint32 {
			if int32(pC.nHdrParsed) > int32(p.iCol) {
				return *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pC.aType)))) + uintptr(p.iCol)*4))
			} else {
				return uint32(0)
			}
		}()
		if type_ < uint32(12) {
			zErr = sqlite3MPrintf(p.db, (*int8)(unsafe.Pointer(&[29]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f', ' ', 't', 'y', 'p', 'e', ' ', '%', 's', '\x00'})), func() *int8 {
				if type_ == uint32(0) {
					return (*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'}))
				} else {
					return func() *int8 {
						if type_ == uint32(7) {
							return (*int8)(unsafe.Pointer(&[5]int8{'r', 'e', 'a', 'l', '\x00'}))
						} else {
							return (*int8)(unsafe.Pointer(&[8]int8{'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'}))
						}
					}()
				}
			}())
			rc = int32(1)
			sqlite3_finalize(p.pStmt)
			p.pStmt = (*struct_sqlite3_stmt)(nil)
		} else {
			p.iOffset = int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pC.aType)))) + uintptr(int32(p.iCol)+int32(pC.nField))*4)))
			p.nByte = int32(sqlite3VdbeSerialTypeLen(type_))
			p.pCsr = pC.uc.pCursor
			sqlite3BtreeIncrblobCursor(p.pCsr)
		}
	}
	if rc == 100 {
		rc = int32(0)
	} else if p.pStmt != nil {
		rc = sqlite3_finalize(p.pStmt)
		p.pStmt = (*struct_sqlite3_stmt)(nil)
		if rc == 0 {
			zErr = sqlite3MPrintf(p.db, (*int8)(unsafe.Pointer(&[20]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'r', 'o', 'w', 'i', 'd', ':', ' ', '%', 'l', 'l', 'd', '\x00'})), iRow)
			rc = int32(1)
		} else {
			zErr = sqlite3MPrintf(p.db, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_errmsg(p.db))
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*pzErr = zErr
	return rc
}
func sqlite3_blob_open(db *struct_sqlite3, zDb *int8, zTable *int8, zColumn *int8, iRow int64, wrFlag int32, ppBlob **struct_sqlite3_blob) int32 {
	var nAttempt int32 = 0
	var iCol int32
	var rc int32 = 0
	var zErr *int8 = nil
	var pTab *struct_Table
	var pBlob *struct_Incrblob = nil
	var sParse struct_Parse
	*ppBlob = (*struct_sqlite3_blob)(nil)
	wrFlag = func() int32 {
		if !!(wrFlag != 0) {
			return 1
		} else {
			return 0
		}
	}()
	sqlite3_mutex_enter(db.mutex)
	pBlob = (*struct_Incrblob)(sqlite3DbMallocZero(db, uint64(56)))
	for 1 != 0 {
		sqlite3ParseObjectInit(&sParse, db)
		if !(pBlob != nil) {
			goto blob_open_out
		}
		sqlite3DbFree(db, unsafe.Pointer(zErr))
		zErr = (*int8)(nil)
		sqlite3BtreeEnterAll(db)
		pTab = sqlite3LocateTable(&sParse, uint32(0), zTable, zDb)
		if pTab != nil && int32(pTab.eTabType) == 1 {
			pTab = (*struct_Table)(nil)
			sqlite3ErrorMsg(&sParse, (*int8)(unsafe.Pointer(&[30]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', ':', ' ', '%', 's', '\x00'})), zTable)
		}
		if pTab != nil && !(pTab.tabFlags&uint32(128) == uint32(0)) {
			pTab = (*struct_Table)(nil)
			sqlite3ErrorMsg(&sParse, (*int8)(unsafe.Pointer(&[36]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'w', 'i', 't', 'h', 'o', 'u', 't', ' ', 'r', 'o', 'w', 'i', 'd', ':', ' ', '%', 's', '\x00'})), zTable)
		}
		if pTab != nil && int32(pTab.eTabType) == 2 {
			pTab = (*struct_Table)(nil)
			sqlite3ErrorMsg(&sParse, (*int8)(unsafe.Pointer(&[21]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 'v', 'i', 'e', 'w', ':', ' ', '%', 's', '\x00'})), zTable)
		}
		if !(pTab != nil) {
			if sParse.zErrMsg != nil {
				sqlite3DbFree(db, unsafe.Pointer(zErr))
				zErr = sParse.zErrMsg
				sParse.zErrMsg = (*int8)(nil)
			}
			rc = int32(1)
			sqlite3BtreeLeaveAll(db)
			goto blob_open_out
		}
		pBlob.pTab = pTab
		pBlob.zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(sqlite3SchemaToIndex(db, pTab.pSchema))*32))).zDbSName
		for iCol = int32(0); iCol < int32(pTab.nCol); iCol++ {
			if sqlite3StrICmp((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName, zColumn) == 0 {
				break
			}
		}
		if iCol == int32(pTab.nCol) {
			sqlite3DbFree(db, unsafe.Pointer(zErr))
			zErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[21]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ':', ' ', '"', '%', 's', '"', '\x00'})), zColumn)
			rc = int32(1)
			sqlite3BtreeLeaveAll(db)
			goto blob_open_out
		}
		if wrFlag != 0 {
			var zFault *int8 = nil
			var pIdx *struct_Index
			if db.flags&uint64(16384) != 0 {
				var pFKey *struct_FKey
				func() int {
					_ = 0
					return 0
				}()
				for pFKey = pTab.u.tab.pFKey; pFKey != nil; pFKey = pFKey.pNextFrom {
					var j int32
					for j = int32(0); j < pFKey.nCol; j++ {
						if (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(j)*16))).iFrom == iCol {
							zFault = (*int8)(unsafe.Pointer(&[12]int8{'f', 'o', 'r', 'e', 'i', 'g', 'n', ' ', 'k', 'e', 'y', '\x00'}))
						}
					}
				}
			}
			for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
				var j int32
				for j = int32(0); j < int32(pIdx.nKeyCol); j++ {
					if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2))) == iCol || int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2))) == -2 {
						zFault = (*int8)(unsafe.Pointer(&[8]int8{'i', 'n', 'd', 'e', 'x', 'e', 'd', '\x00'}))
					}
				}
			}
			if zFault != nil {
				sqlite3DbFree(db, unsafe.Pointer(zErr))
				zErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[34]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', '%', 's', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'f', 'o', 'r', ' ', 'w', 'r', 'i', 't', 'i', 'n', 'g', '\x00'})), zFault)
				rc = int32(1)
				sqlite3BtreeLeaveAll(db)
				goto blob_open_out
			}
		}
		pBlob.pStmt = (*struct_sqlite3_stmt)(unsafe.Pointer(sqlite3VdbeCreate(&sParse)))
		func() int {
			_ = 0
			return 0
		}()
		if pBlob.pStmt != nil {
			const iLn int32 = 0
			var openBlob [6]struct_VdbeOpList = [6]struct_VdbeOpList{struct_VdbeOpList{uint8(168), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(101), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(33), int8(0), int8(5), int8(1)}, struct_VdbeOpList{uint8(93), int8(0), int8(0), int8(1)}, struct_VdbeOpList{uint8(83), int8(1), int8(0), int8(0)}, struct_VdbeOpList{uint8(70), int8(0), int8(0), int8(0)}}
			var v *struct_Vdbe = (*struct_Vdbe)(unsafe.Pointer(pBlob.pStmt))
			var iDb int32 = sqlite3SchemaToIndex(db, pTab.pSchema)
			var aOp *struct_VdbeOp
			sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag, pTab.pSchema.schema_cookie, pTab.pSchema.iGeneration)
			sqlite3VdbeChangeP5(v, uint16(1))
			func() int {
				_ = 0
				return 0
			}()
			aOp = sqlite3VdbeAddOpList(v, int32(24/4), (*struct_VdbeOpList)(unsafe.Pointer(&openBlob)), iLn)
			sqlite3VdbeUsesBtree(v, iDb)
			if int32(db.mallocFailed) == 0 {
				func() int {
					_ = 0
					return 0
				}()
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p2 = int32(pTab.tnum)
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p3 = wrFlag
				sqlite3VdbeChangeP4(v, 2, pTab.zName, 0)
			}
			if int32(db.mallocFailed) == 0 {
				if wrFlag != 0 {
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).opcode = uint8(112)
				}
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p2 = int32(pTab.tnum)
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p3 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p4type = int8(-3)
				*(*int32)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p4)) = int32(pTab.nCol) + 1
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p2 = int32(pTab.nCol)
				sParse.nVar = int16(0)
				sParse.nMem = int32(1)
				sParse.nTab = int32(1)
				sqlite3VdbeMakeReady(v, &sParse)
			}
		}
		pBlob.iCol = uint16(iCol)
		pBlob.db = db
		sqlite3BtreeLeaveAll(db)
		if db.mallocFailed != 0 {
			goto blob_open_out
		}
		rc = blobSeekToRow(pBlob, iRow, &zErr)
		if func() (_cgo_ret int32) {
			_cgo_addr := &nAttempt
			*_cgo_addr++
			return *_cgo_addr
		}() >= 50 || rc != 17 {
			break
		}
		sqlite3ParseObjectReset(&sParse)
	}
blob_open_out:
	if rc == 0 && int32(db.mallocFailed) == 0 {
		*ppBlob = (*struct_sqlite3_blob)(unsafe.Pointer(pBlob))
	} else {
		if pBlob != nil && pBlob.pStmt != nil {
			sqlite3VdbeFinalize((*struct_Vdbe)(unsafe.Pointer(pBlob.pStmt)))
		}
		sqlite3DbFree(db, unsafe.Pointer(pBlob))
	}
	sqlite3ErrorWithMsg(db, rc, func() *int8 {
		if zErr != nil {
			return (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'}))
		} else {
			return nil
		}
	}(), zErr)
	sqlite3DbFree(db, unsafe.Pointer(zErr))
	sqlite3ParseObjectReset(&sParse)
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_blob_close(pBlob *struct_sqlite3_blob) int32 {
	var p *struct_Incrblob = (*struct_Incrblob)(unsafe.Pointer(pBlob))
	var rc int32
	var db *struct_sqlite3
	if p != nil {
		var pStmt *struct_sqlite3_stmt = p.pStmt
		db = p.db
		sqlite3_mutex_enter(db.mutex)
		sqlite3DbFree(db, unsafe.Pointer(p))
		sqlite3_mutex_leave(db.mutex)
		rc = sqlite3_finalize(pStmt)
	} else {
		rc = int32(0)
	}
	return rc
}
func blobReadWrite(pBlob *struct_sqlite3_blob, z unsafe.Pointer, n int32, iOffset int32, xCall func(*struct_BtCursor, uint32, uint32, unsafe.Pointer) int32) int32 {
	var rc int32
	var p *struct_Incrblob = (*struct_Incrblob)(unsafe.Pointer(pBlob))
	var v *struct_Vdbe
	var db *struct_sqlite3
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3MisuseError(96390)
	}
	db = p.db
	sqlite3_mutex_enter(db.mutex)
	v = (*struct_Vdbe)(unsafe.Pointer(p.pStmt))
	if n < 0 || iOffset < 0 || int64(iOffset)+int64(n) > int64(p.nByte) {
		rc = int32(1)
	} else if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(4)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3BtreeEnterCursor(p.pCsr)
		rc = xCall(p.pCsr, uint32(iOffset+p.iOffset), uint32(n), z)
		sqlite3BtreeLeaveCursor(p.pCsr)
		if rc == 4 {
			sqlite3VdbeFinalize(v)
			p.pStmt = (*struct_sqlite3_stmt)(nil)
		} else {
			v.rc = rc
		}
	}
	sqlite3Error(db, rc)
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_blob_read(pBlob *struct_sqlite3_blob, z unsafe.Pointer, n int32, iOffset int32) int32 {
	return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked)
}
func sqlite3_blob_write(pBlob *struct_sqlite3_blob, z unsafe.Pointer, n int32, iOffset int32) int32 {
	return blobReadWrite(pBlob, unsafe.Pointer(z), n, iOffset, sqlite3BtreePutData)
}
func sqlite3_blob_bytes(pBlob *struct_sqlite3_blob) int32 {
	var p *struct_Incrblob = (*struct_Incrblob)(unsafe.Pointer(pBlob))
	return func() int32 {
		if p != nil && p.pStmt != nil {
			return p.nByte
		} else {
			return 0
		}
	}()
}
func sqlite3_blob_reopen(pBlob *struct_sqlite3_blob, iRow int64) int32 {
	var rc int32
	var p *struct_Incrblob = (*struct_Incrblob)(unsafe.Pointer(pBlob))
	var db *struct_sqlite3
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3MisuseError(96490)
	}
	db = p.db
	sqlite3_mutex_enter(db.mutex)
	if uintptr(unsafe.Pointer(p.pStmt)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(4)
	} else {
		var zErr *int8
		(*struct_Vdbe)(unsafe.Pointer(p.pStmt)).rc = int32(0)
		rc = blobSeekToRow(p, iRow, &zErr)
		if rc != 0 {
			sqlite3ErrorWithMsg(db, rc, func() *int8 {
				if zErr != nil {
					return (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'}))
				} else {
					return nil
				}
			}(), zErr)
			sqlite3DbFree(db, unsafe.Pointer(zErr))
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	rc = sqlite3ApiExit(db, rc)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_leave(db.mutex)
	return rc
}

type MergeEngine = struct_MergeEngine
type PmaReader = struct_PmaReader
type PmaWriter = struct_PmaWriter
type SorterRecord = struct_SorterRecord
type SortSubtask = struct_SortSubtask
type SorterFile = struct_SorterFile
type SorterList = struct_SorterList
type IncrMerger = struct_IncrMerger
type struct_SorterFile struct {
	pFd  *struct_sqlite3_file
	iEof int64
}
type struct_SorterList struct {
	pList   *struct_SorterRecord
	aMemory *uint8
	szPMA   int32
}
type struct_MergeEngine struct {
	nTree  int32
	pTask  *struct_SortSubtask
	aTree  *int32
	aReadr *struct_PmaReader
}
type SorterCompare = func(*struct_SortSubtask, *int32, unsafe.Pointer, int32, unsafe.Pointer, int32) int32
type struct_SortSubtask struct {
	pThread   *struct_SQLiteThread
	bDone     int32
	pSorter   *struct_VdbeSorter
	pUnpacked *struct_UnpackedRecord
	list      struct_SorterList
	nPMA      int32
	xCompare  func(*struct_SortSubtask, *int32, unsafe.Pointer, int32, unsafe.Pointer, int32) int32
	file      struct_SorterFile
	file2     struct_SorterFile
}
type struct_VdbeSorter struct {
	mnPmaSize   int32
	mxPmaSize   int32
	mxKeysize   int32
	pgsz        int32
	pReader     *struct_PmaReader
	pMerger     *struct_MergeEngine
	db          *struct_sqlite3
	pKeyInfo    *struct_KeyInfo
	pUnpacked   *struct_UnpackedRecord
	list        struct_SorterList
	iMemory     int32
	nMemory     int32
	bUsePMA     uint8
	bUseThreads uint8
	iPrev       uint8
	nTask       uint8
	typeMask    uint8
	aTask       [1]struct_SortSubtask
}
type struct_PmaReader struct {
	iReadOff int64
	iEof     int64
	nAlloc   int32
	nKey     int32
	pFd      *struct_sqlite3_file
	aAlloc   *uint8
	aKey     *uint8
	aBuffer  *uint8
	nBuffer  int32
	aMap     *uint8
	pIncr    *struct_IncrMerger
}
type struct_IncrMerger struct {
	pTask      *struct_SortSubtask
	pMerger    *struct_MergeEngine
	iStartOff  int64
	mxSz       int32
	bEof       int32
	bUseThread int32
	aFile      [2]struct_SorterFile
}
type struct_PmaWriter struct {
	eFWErr    int32
	aBuffer   *uint8
	nBuffer   int32
	iBufStart int32
	iBufEnd   int32
	iWriteOff int64
	pFd       *struct_sqlite3_file
}
type _cgoa_74 struct {
	pNext *struct_SorterRecord
}
type struct_SorterRecord struct {
	nVal int32
	u    _cgoa_74
}

func vdbePmaReaderClear(pReadr *struct_PmaReader) {
	sqlite3_free(unsafe.Pointer(pReadr.aAlloc))
	sqlite3_free(unsafe.Pointer(pReadr.aBuffer))
	if pReadr.aMap != nil {
		sqlite3OsUnfetch(pReadr.pFd, int64(0), unsafe.Pointer(pReadr.aMap))
	}
	vdbeIncrFree(pReadr.pIncr)
	__builtin___memset_chk(unsafe.Pointer(pReadr), 0, 80, __builtin_object_size(unsafe.Pointer(pReadr), 0))
}
func vdbePmaReadBlob(p *struct_PmaReader, nByte int32, ppOut **uint8) int32 {
	var iBuf int32
	var nAvail int32
	if p.aMap != nil {
		*ppOut = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMap)) + uintptr(p.iReadOff)))
		p.iReadOff += int64(nByte)
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	iBuf = int32(p.iReadOff % int64(p.nBuffer))
	if iBuf == 0 {
		var nRead int32
		var rc int32
		if p.iEof-p.iReadOff > int64(p.nBuffer) {
			nRead = p.nBuffer
		} else {
			nRead = int32(p.iEof - p.iReadOff)
		}
		func() int {
			_ = 0
			return 0
		}()
		rc = sqlite3OsRead(p.pFd, unsafe.Pointer(p.aBuffer), nRead, p.iReadOff)
		func() int {
			_ = 0
			return 0
		}()
		if rc != 0 {
			return rc
		}
	}
	nAvail = p.nBuffer - iBuf
	if nByte <= nAvail {
		*ppOut = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(iBuf)))
		p.iReadOff += int64(nByte)
	} else {
		var nRem int32
		if p.nAlloc < nByte {
			var aNew *uint8
			var nNew int64 = func() int64 {
				if int64(128) > int64(2)*int64(p.nAlloc) {
					return int64(128)
				} else {
					return int64(2) * int64(p.nAlloc)
				}
			}()
			for int64(nByte) > nNew {
				nNew = nNew * int64(2)
			}
			aNew = (*uint8)(sqlite3Realloc(unsafe.Pointer(p.aAlloc), uint64(nNew)))
			if !(aNew != nil) {
				return int32(7)
			}
			p.nAlloc = int32(nNew)
			p.aAlloc = aNew
		}
		__builtin___memcpy_chk(unsafe.Pointer(p.aAlloc), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(iBuf)))), uint(nAvail), __builtin_object_size(unsafe.Pointer(p.aAlloc), 0))
		p.iReadOff += int64(nAvail)
		nRem = nByte - nAvail
		for nRem > 0 {
			var rc int32
			var nCopy int32
			var aNext *uint8
			nCopy = nRem
			if nRem > p.nBuffer {
				nCopy = p.nBuffer
			}
			rc = vdbePmaReadBlob(p, nCopy, &aNext)
			if rc != 0 {
				return rc
			}
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aAlloc)) + uintptr(nByte-nRem)))), unsafe.Pointer(aNext), uint(nCopy), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aAlloc)) + uintptr(nByte-nRem)))), 0))
			nRem -= nCopy
		}
		*ppOut = p.aAlloc
	}
	return int32(0)
}
func vdbePmaReadVarint(p *struct_PmaReader, pnOut *uint64) int32 {
	var iBuf int32
	if p.aMap != nil {
		p.iReadOff += int64(sqlite3GetVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aMap)) + uintptr(p.iReadOff))), pnOut))
	} else {
		iBuf = int32(p.iReadOff % int64(p.nBuffer))
		if iBuf != 0 && p.nBuffer-iBuf >= 9 {
			p.iReadOff += int64(sqlite3GetVarint(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(iBuf))), pnOut))
		} else {
			var aVarint [16]uint8
			var a *uint8
			var i int32 = 0
			var rc int32
			for {
				rc = vdbePmaReadBlob(p, 1, &a)
				if rc != 0 {
					return rc
				}
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aVarint)))) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &i
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()&15))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(0)))
				if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(0))))&128 != 0) {
					break
				}
			}
			sqlite3GetVarint((*uint8)(unsafe.Pointer(&aVarint)), pnOut)
		}
	}
	return int32(0)
}
func vdbeSorterMapFile(pTask *struct_SortSubtask, pFile *struct_SorterFile, pp **uint8) int32 {
	var rc int32 = 0
	if pFile.iEof <= int64(pTask.pSorter.db.nMaxSorterMmap) {
		var pFd *struct_sqlite3_file = pFile.pFd
		if pFd.pMethods.iVersion >= 3 {
			rc = sqlite3OsFetch(pFd, int64(0), int32(pFile.iEof), (*unsafe.Pointer)(unsafe.Pointer(pp)))
		}
	}
	return rc
}
func vdbePmaReaderSeek(pTask *struct_SortSubtask, pReadr *struct_PmaReader, pFile *struct_SorterFile, iOff int64) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3FaultSim(201) != 0 {
		return int32(10 | 1<<8)
	}
	if pReadr.aMap != nil {
		sqlite3OsUnfetch(pReadr.pFd, int64(0), unsafe.Pointer(pReadr.aMap))
		pReadr.aMap = (*uint8)(nil)
	}
	pReadr.iReadOff = iOff
	pReadr.iEof = pFile.iEof
	pReadr.pFd = pFile.pFd
	rc = vdbeSorterMapFile(pTask, pFile, &pReadr.aMap)
	if rc == 0 && uintptr(unsafe.Pointer(pReadr.aMap)) == uintptr(unsafe.Pointer(nil)) {
		var pgsz int32 = pTask.pSorter.pgsz
		var iBuf int32 = int32(pReadr.iReadOff % int64(pgsz))
		if uintptr(unsafe.Pointer(pReadr.aBuffer)) == uintptr(unsafe.Pointer(nil)) {
			pReadr.aBuffer = (*uint8)(sqlite3Malloc(uint64(pgsz)))
			if uintptr(unsafe.Pointer(pReadr.aBuffer)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(7)
			}
			pReadr.nBuffer = pgsz
		}
		if rc == 0 && iBuf != 0 {
			var nRead int32 = pgsz - iBuf
			if pReadr.iReadOff+int64(nRead) > pReadr.iEof {
				nRead = int32(pReadr.iEof - pReadr.iReadOff)
			}
			rc = sqlite3OsRead(pReadr.pFd, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pReadr.aBuffer)) + uintptr(iBuf)))), nRead, pReadr.iReadOff)
		}
	}
	return rc
}
func vdbePmaReaderNext(pReadr *struct_PmaReader) int32 {
	var rc int32 = 0
	var nRec uint64 = uint64(0)
	if pReadr.iReadOff >= pReadr.iEof {
		var pIncr *struct_IncrMerger = pReadr.pIncr
		var bEof int32 = 1
		if pIncr != nil {
			rc = vdbeIncrSwap(pIncr)
			if rc == 0 && pIncr.bEof == 0 {
				rc = vdbePmaReaderSeek(pIncr.pTask, pReadr, &*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16)), pIncr.iStartOff)
				bEof = int32(0)
			}
		}
		if bEof != 0 {
			vdbePmaReaderClear(pReadr)
			return rc
		}
	}
	if rc == 0 {
		rc = vdbePmaReadVarint(pReadr, &nRec)
	}
	if rc == 0 {
		pReadr.nKey = int32(nRec)
		rc = vdbePmaReadBlob(pReadr, int32(nRec), &pReadr.aKey)
	}
	return rc
}
func vdbePmaReaderInit(pTask *struct_SortSubtask, pFile *struct_SorterFile, iStart int64, pReadr *struct_PmaReader, pnByte *int64) int32 {
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart)
	if rc == 0 {
		var nByte uint64 = uint64(0)
		rc = vdbePmaReadVarint(pReadr, &nByte)
		pReadr.iEof = int64(uint64(pReadr.iReadOff) + nByte)
		*pnByte += int64(nByte)
	}
	if rc == 0 {
		rc = vdbePmaReaderNext(pReadr)
	}
	return rc
}
func vdbeSorterCompareTail(pTask *struct_SortSubtask, pbKey2Cached *int32, pKey1 unsafe.Pointer, nKey1 int32, pKey2 unsafe.Pointer, nKey2 int32) int32 {
	var r2 *struct_UnpackedRecord = pTask.pUnpacked
	if *pbKey2Cached == 0 {
		sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, nKey2, pKey2, r2)
		*pbKey2Cached = int32(1)
	}
	return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1)
}
func vdbeSorterCompare(pTask *struct_SortSubtask, pbKey2Cached *int32, pKey1 unsafe.Pointer, nKey1 int32, pKey2 unsafe.Pointer, nKey2 int32) int32 {
	var r2 *struct_UnpackedRecord = pTask.pUnpacked
	if !(*pbKey2Cached != 0) {
		sqlite3VdbeRecordUnpack(pTask.pSorter.pKeyInfo, nKey2, pKey2, r2)
		*pbKey2Cached = int32(1)
	}
	return sqlite3VdbeRecordCompare(nKey1, pKey1, r2)
}
func vdbeSorterCompareText(pTask *struct_SortSubtask, pbKey2Cached *int32, pKey1 unsafe.Pointer, nKey1 int32, pKey2 unsafe.Pointer, nKey2 int32) int32 {
	var p1 *uint8 = (*uint8)(pKey1)
	var p2 *uint8 = (*uint8)(pKey2)
	var v1 *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(0))))))
	var v2 *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(0))))))
	var n1 int32
	var n2 int32
	var res int32
	n1 = int32(uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(1)))))
	if n1 >= 128 {
		sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(1))), (*uint32)(unsafe.Pointer(&n1)))
	}
	n2 = int32(uint32(*&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(1)))))
	if n2 >= 128 {
		sqlite3GetVarint32(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(1))), (*uint32)(unsafe.Pointer(&n2)))
	}
	res = memcmp(unsafe.Pointer(v1), unsafe.Pointer(v2), uint((func() int32 {
		if n1 < n2 {
			return n1
		} else {
			return n2
		}
	}()-13)/2))
	if res == 0 {
		res = n1 - n2
	}
	if res == 0 {
		if int32(pTask.pSorter.pKeyInfo.nKeyField) > 1 {
			res = vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2)
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTask.pSorter.pKeyInfo.aSortFlags)) + uintptr(0))) != 0 {
			res = res * -1
		}
	}
	return res
}
func vdbeSorterCompareInt(pTask *struct_SortSubtask, pbKey2Cached *int32, pKey1 unsafe.Pointer, nKey1 int32, pKey2 unsafe.Pointer, nKey2 int32) int32 {
	var p1 *uint8 = (*uint8)(pKey1)
	var p2 *uint8 = (*uint8)(pKey2)
	var s1 int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(1))))
	var s2 int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(1))))
	var v1 *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p1)) + uintptr(0))))))
	var v2 *uint8 = &*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p2)) + uintptr(0))))))
	var res int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if s1 == s2 {
		var aLen [10]uint8 = [10]uint8{uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(6), uint8(8), uint8(0), uint8(0), uint8(0)}
		var n uint8 = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aLen)))) + uintptr(s1)))
		var i int32
		res = int32(0)
		for i = int32(0); i < int32(n); i++ {
			if func() (_cgo_ret int32) {
				_cgo_addr := &res
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v1)) + uintptr(i)))) - int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v2)) + uintptr(i))))
				return *_cgo_addr
			}() != 0 {
				if (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v1)) + uintptr(0))))^int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v2)) + uintptr(0)))))&128 != 0 {
					res = func() int32 {
						if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(v1)) + uintptr(0))))&128 != 0 {
							return -1
						} else {
							return 1
						}
					}()
				}
				break
			}
		}
	} else if s1 > 7 && s2 > 7 {
		res = s1 - s2
	} else {
		if s2 > 7 {
			res = int32(1)
		} else if s1 > 7 {
			res = int32(-1)
		} else {
			res = s1 - s2
		}
		func() int {
			_ = 0
			return 0
		}()
		if res > 0 {
			if int32(*v1)&128 != 0 {
				res = int32(-1)
			}
		} else if int32(*v2)&128 != 0 {
			res = int32(1)
		}
	}
	if res == 0 {
		if int32(pTask.pSorter.pKeyInfo.nKeyField) > 1 {
			res = vdbeSorterCompareTail(pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2)
		}
	} else if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTask.pSorter.pKeyInfo.aSortFlags)) + uintptr(0))) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		res = res * -1
	}
	return res
}
func sqlite3VdbeSorterInit(db *struct_sqlite3, nField int32, pCsr *struct_VdbeCursor) int32 {
	var pgsz int32
	var i int32
	var pSorter *struct_VdbeSorter
	var pKeyInfo *struct_KeyInfo
	var szKeyInfo int32
	var sz int32
	var rc int32 = 0
	var nWorker int32
	if sqlite3TempInMemory(db) != 0 || int32(sqlite3Config.bCoreMutex) == 0 {
		nWorker = int32(0)
	} else {
		nWorker = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(11)*4))
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	szKeyInfo = int32(40 + uint(int32(pCsr.pKeyInfo.nKeyField)-1)*8)
	sz = int32(192 + uint(nWorker)*96)
	pSorter = (*struct_VdbeSorter)(sqlite3DbMallocZero(db, uint64(sz+szKeyInfo)))
	*(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc)) = pSorter
	if uintptr(unsafe.Pointer(pSorter)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(7)
	} else {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt
		pSorter.pKeyInfo = func() (_cgo_ret *struct_KeyInfo) {
			_cgo_addr := &pKeyInfo
			*_cgo_addr = (*struct_KeyInfo)(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pSorter)))) + uintptr(sz)))))
			return *_cgo_addr
		}()
		__builtin___memcpy_chk(unsafe.Pointer(pKeyInfo), unsafe.Pointer(pCsr.pKeyInfo), uint(szKeyInfo), __builtin_object_size(unsafe.Pointer(pKeyInfo), 0))
		pKeyInfo.db = (*struct_sqlite3)(nil)
		if nField != 0 && nWorker == 0 {
			pKeyInfo.nKeyField = uint16(nField)
		}
		sqlite3BtreeEnter(pBt)
		pSorter.pgsz = func() (_cgo_ret int32) {
			_cgo_addr := &pgsz
			*_cgo_addr = sqlite3BtreeGetPageSize(pBt)
			return *_cgo_addr
		}()
		sqlite3BtreeLeave(pBt)
		pSorter.nTask = uint8(nWorker + 1)
		pSorter.iPrev = uint8(nWorker - 1)
		pSorter.bUseThreads = func() uint8 {
			if int32(pSorter.nTask) > 1 {
				return 1
			} else {
				return 0
			}
		}()
		pSorter.db = db
		for i = int32(0); i < int32(pSorter.nTask); i++ {
			var pTask *struct_SortSubtask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(i)*96))
			pTask.pSorter = pSorter
		}
		if !(sqlite3TempInMemory(db) != 0) {
			var mxCache int64
			var szPma uint32 = sqlite3Config.szPma
			pSorter.mnPmaSize = int32(szPma * uint32(pgsz))
			mxCache = int64((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.cache_size)
			if mxCache < int64(0) {
				mxCache = mxCache * int64(-1024)
			} else {
				mxCache = mxCache * int64(pgsz)
			}
			mxCache = func() int64 {
				if mxCache < int64(1<<29) {
					return mxCache
				} else {
					return int64(1 << 29)
				}
			}()
			pSorter.mxPmaSize = func() int32 {
				if pSorter.mnPmaSize > int32(mxCache) {
					return pSorter.mnPmaSize
				} else {
					return int32(mxCache)
				}
			}()
			if int32(sqlite3Config.bSmallMalloc) == 0 {
				func() int {
					_ = 0
					return 0
				}()
				pSorter.nMemory = pgsz
				pSorter.list.aMemory = (*uint8)(sqlite3Malloc(uint64(pgsz)))
				if !(pSorter.list.aMemory != nil) {
					rc = int32(7)
				}
			}
		}
		if int32(pKeyInfo.nAllField) < 13 && (uintptr(unsafe.Pointer(*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(0)*8)))) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(0)*8)))) == uintptr(unsafe.Pointer(db.pDfltColl))) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyInfo.aSortFlags)) + uintptr(0))))&2 == 0 {
			pSorter.typeMask = uint8(1 | 2)
		}
	}
	return rc
}
func vdbeSorterRecordFree(db *struct_sqlite3, pRecord *struct_SorterRecord) {
	var p *struct_SorterRecord
	var pNext *struct_SorterRecord
	for p = pRecord; p != nil; p = pNext {
		pNext = p.u.pNext
		sqlite3DbFree(db, unsafe.Pointer(p))
	}
}
func vdbeSortSubtaskCleanup(db *struct_sqlite3, pTask *struct_SortSubtask) {
	sqlite3DbFree(db, unsafe.Pointer(pTask.pUnpacked))
	if pTask.list.aMemory != nil {
		sqlite3_free(unsafe.Pointer(pTask.list.aMemory))
	} else {
		func() int {
			_ = 0
			return 0
		}()
		vdbeSorterRecordFree(nil, pTask.list.pList)
	}
	if pTask.file.pFd != nil {
		sqlite3OsCloseFree(pTask.file.pFd)
	}
	if pTask.file2.pFd != nil {
		sqlite3OsCloseFree(pTask.file2.pFd)
	}
	__builtin___memset_chk(unsafe.Pointer(pTask), 0, 96, __builtin_object_size(unsafe.Pointer(pTask), 0))
}
func vdbeSorterJoinThread(pTask *struct_SortSubtask) int32 {
	var rc int32 = 0
	if pTask.pThread != nil {
		var pRet unsafe.Pointer = unsafe.Pointer(int(1))
		func() int {
			_ = sqlite3ThreadJoin(pTask.pThread, &pRet)
			return 0
		}()
		rc = int32(int(pRet))
		func() int {
			_ = 0
			return 0
		}()
		pTask.bDone = int32(0)
		pTask.pThread = (*struct_SQLiteThread)(nil)
	}
	return rc
}
func vdbeSorterCreateThread(pTask *struct_SortSubtask, xTask func(unsafe.Pointer) unsafe.Pointer, pIn unsafe.Pointer) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3ThreadCreate(&pTask.pThread, xTask, pIn)
}
func vdbeSorterJoinAll(pSorter *struct_VdbeSorter, rcin int32) int32 {
	var rc int32 = rcin
	var i int32
	for i = int32(pSorter.nTask) - 1; i >= 0; i-- {
		var pTask *struct_SortSubtask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(i)*96))
		var rc2 int32 = vdbeSorterJoinThread(pTask)
		if rc == 0 {
			rc = rc2
		}
	}
	return rc
}
func vdbeMergeEngineNew(nReader int32) *struct_MergeEngine {
	var N int32 = 2
	var nByte int32
	var pNew *struct_MergeEngine
	func() int {
		_ = 0
		return 0
	}()
	for N < nReader {
		N += N
	}
	nByte = int32(32 + uint(N)*(4+80))
	pNew = func() *struct_MergeEngine {
		if sqlite3FaultSim(100) != 0 {
			return nil
		} else {
			return (*struct_MergeEngine)(sqlite3MallocZero(uint64(nByte)))
		}
	}()
	if pNew != nil {
		pNew.nTree = N
		pNew.pTask = (*struct_SortSubtask)(nil)
		pNew.aReadr = (*struct_PmaReader)(unsafe.Pointer(&*(*struct_MergeEngine)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew)) + uintptr(1)*32))))
		pNew.aTree = (*int32)(unsafe.Pointer(&*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aReadr)) + uintptr(N)*80))))
	}
	return pNew
}
func vdbeMergeEngineFree(pMerger *struct_MergeEngine) {
	var i int32
	if pMerger != nil {
		for i = int32(0); i < pMerger.nTree; i++ {
			vdbePmaReaderClear(&*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(i)*80)))
		}
	}
	sqlite3_free(unsafe.Pointer(pMerger))
}
func vdbeIncrFree(pIncr *struct_IncrMerger) {
	if pIncr != nil {
		if pIncr.bUseThread != 0 {
			vdbeSorterJoinThread(pIncr.pTask)
			if (*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16))).pFd != nil {
				sqlite3OsCloseFree((*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16))).pFd)
			}
			if (*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))).pFd != nil {
				sqlite3OsCloseFree((*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))).pFd)
			}
		}
		vdbeMergeEngineFree(pIncr.pMerger)
		sqlite3_free(unsafe.Pointer(pIncr))
	}
}
func sqlite3VdbeSorterReset(db *struct_sqlite3, pSorter *struct_VdbeSorter) {
	var i int32
	func() int {
		_ = vdbeSorterJoinAll(pSorter, 0)
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pSorter.pReader != nil {
		vdbePmaReaderClear(pSorter.pReader)
		sqlite3DbFree(db, unsafe.Pointer(pSorter.pReader))
		pSorter.pReader = (*struct_PmaReader)(nil)
	}
	vdbeMergeEngineFree(pSorter.pMerger)
	pSorter.pMerger = (*struct_MergeEngine)(nil)
	for i = int32(0); i < int32(pSorter.nTask); i++ {
		var pTask *struct_SortSubtask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(i)*96))
		vdbeSortSubtaskCleanup(db, pTask)
		pTask.pSorter = pSorter
	}
	if uintptr(unsafe.Pointer(pSorter.list.aMemory)) == uintptr(unsafe.Pointer(nil)) {
		vdbeSorterRecordFree(nil, pSorter.list.pList)
	}
	pSorter.list.pList = (*struct_SorterRecord)(nil)
	pSorter.list.szPMA = int32(0)
	pSorter.bUsePMA = uint8(0)
	pSorter.iMemory = int32(0)
	pSorter.mxKeysize = int32(0)
	sqlite3DbFree(db, unsafe.Pointer(pSorter.pUnpacked))
	pSorter.pUnpacked = (*struct_UnpackedRecord)(nil)
}
func sqlite3VdbeSorterClose(db *struct_sqlite3, pCsr *struct_VdbeCursor) {
	var pSorter *struct_VdbeSorter
	func() int {
		_ = 0
		return 0
	}()
	pSorter = *(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc))
	if pSorter != nil {
		sqlite3VdbeSorterReset(db, pSorter)
		sqlite3_free(unsafe.Pointer(pSorter.list.aMemory))
		sqlite3DbFree(db, unsafe.Pointer(pSorter))
		*(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc)) = (*struct_VdbeSorter)(nil)
	}
}
func vdbeSorterExtendFile(db *struct_sqlite3, pFd *struct_sqlite3_file, nByte int64) {
	if nByte <= int64(db.nMaxSorterMmap) && pFd.pMethods.iVersion >= 3 {
		var p unsafe.Pointer = nil
		var chunksize int32 = 4 * 1024
		sqlite3OsFileControlHint(pFd, 6, unsafe.Pointer(&chunksize))
		sqlite3OsFileControlHint(pFd, 5, unsafe.Pointer(&nByte))
		sqlite3OsFetch(pFd, int64(0), int32(nByte), &p)
		if p != nil {
			sqlite3OsUnfetch(pFd, int64(0), p)
		}
	}
}
func vdbeSorterOpenTempFile(db *struct_sqlite3, nExtend int64, ppFd **struct_sqlite3_file) int32 {
	var rc int32
	if sqlite3FaultSim(202) != 0 {
		return int32(10 | 13<<8)
	}
	rc = sqlite3OsOpenMalloc(db.pVfs, nil, ppFd, 4096|2|4|16|8, &rc)
	if rc == 0 {
		var max int64 = int64(2147418112)
		sqlite3OsFileControlHint(*ppFd, 18, unsafe.Pointer(&max))
		if nExtend > int64(0) {
			vdbeSorterExtendFile(db, *ppFd, nExtend)
		}
	}
	return rc
}
func vdbeSortAllocUnpacked(pTask *struct_SortSubtask) int32 {
	if uintptr(unsafe.Pointer(pTask.pUnpacked)) == uintptr(unsafe.Pointer(nil)) {
		pTask.pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask.pSorter.pKeyInfo)
		if uintptr(unsafe.Pointer(pTask.pUnpacked)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		pTask.pUnpacked.nField = pTask.pSorter.pKeyInfo.nKeyField
		pTask.pUnpacked.errCode = uint8(0)
	}
	return int32(0)
}
func vdbeSorterMerge(pTask *struct_SortSubtask, p1 *struct_SorterRecord, p2 *struct_SorterRecord) *struct_SorterRecord {
	var pFinal *struct_SorterRecord = nil
	var pp **struct_SorterRecord = &pFinal
	var bCached int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	for {
		var res int32
		res = pTask.xCompare(pTask, &bCached, unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(p1))))+uintptr(1)*16))), p1.nVal, unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(p2))))+uintptr(1)*16))), p2.nVal)
		if res <= 0 {
			*pp = p1
			pp = &p1.u.pNext
			p1 = p1.u.pNext
			if uintptr(unsafe.Pointer(p1)) == uintptr(unsafe.Pointer(nil)) {
				*pp = p2
				break
			}
		} else {
			*pp = p2
			pp = &p2.u.pNext
			p2 = p2.u.pNext
			bCached = int32(0)
			if uintptr(unsafe.Pointer(p2)) == uintptr(unsafe.Pointer(nil)) {
				*pp = p1
				break
			}
		}
	}
	return pFinal
}
func vdbeSorterGetCompare(p *struct_VdbeSorter) func(*struct_SortSubtask, *int32, unsafe.Pointer, int32, unsafe.Pointer, int32) int32 {
	if int32(p.typeMask) == 1 {
		return vdbeSorterCompareInt
	} else if int32(p.typeMask) == 2 {
		return vdbeSorterCompareText
	}
	return vdbeSorterCompare
}
func vdbeSorterSort(pTask *struct_SortSubtask, pList *struct_SorterList) int32 {
	var i int32
	var p *struct_SorterRecord
	var rc int32
	var aSlot [64]*struct_SorterRecord
	rc = vdbeSortAllocUnpacked(pTask)
	if rc != 0 {
		return rc
	}
	p = pList.pList
	pTask.xCompare = vdbeSorterGetCompare(pTask.pSorter)
	__builtin___memset_chk(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot))), 0, 512, __builtin_object_size(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot))), 0))
	for p != nil {
		var pNext *struct_SorterRecord
		if pList.aMemory != nil {
			if uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(p)))) == uintptr(unsafe.Pointer(pList.aMemory)) {
				pNext = (*struct_SorterRecord)(nil)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				pNext = (*struct_SorterRecord)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.aMemory)) + uintptr(*(*int32)(unsafe.Pointer(&p.u)))))))
			}
		} else {
			pNext = p.u.pNext
		}
		p.u.pNext = (*struct_SorterRecord)(nil)
		for i = int32(0); *(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8)) != nil; i++ {
			p = vdbeSorterMerge(pTask, p, *(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8)))
			*(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8)) = (*struct_SorterRecord)(nil)
		}
		*(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8)) = p
		p = pNext
	}
	p = (*struct_SorterRecord)(nil)
	for i = int32(0); i < int32(512/8); i++ {
		if uintptr(unsafe.Pointer(*(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		p = func() *struct_SorterRecord {
			if p != nil {
				return vdbeSorterMerge(pTask, p, *(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8)))
			} else {
				return *(**struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_SorterRecord)(unsafe.Pointer(&aSlot)))) + uintptr(i)*8))
			}
		}()
	}
	pList.pList = p
	func() int {
		_ = 0
		return 0
	}()
	return int32(pTask.pUnpacked.errCode)
}
func vdbePmaWriterInit(pFd *struct_sqlite3_file, p *struct_PmaWriter, nBuf int32, iStart int64) {
	__builtin___memset_chk(unsafe.Pointer(p), 0, 48, __builtin_object_size(unsafe.Pointer(p), 0))
	p.aBuffer = (*uint8)(sqlite3Malloc(uint64(nBuf)))
	if !(p.aBuffer != nil) {
		p.eFWErr = int32(7)
	} else {
		p.iBufEnd = func() (_cgo_ret int32) {
			_cgo_addr := &p.iBufStart
			*_cgo_addr = int32(iStart % int64(nBuf))
			return *_cgo_addr
		}()
		p.iWriteOff = iStart - int64(p.iBufStart)
		p.nBuffer = nBuf
		p.pFd = pFd
	}
}
func vdbePmaWriteBlob(p *struct_PmaWriter, pData *uint8, nData int32) {
	var nRem int32 = nData
	for nRem > 0 && p.eFWErr == 0 {
		var nCopy int32 = nRem
		if nCopy > p.nBuffer-p.iBufEnd {
			nCopy = p.nBuffer - p.iBufEnd
		}
		__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(p.iBufEnd)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pData)) + uintptr(nData-nRem)))), uint(nCopy), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(p.iBufEnd)))), 0))
		p.iBufEnd += nCopy
		if p.iBufEnd == p.nBuffer {
			p.eFWErr = sqlite3OsWrite(p.pFd, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(p.iBufStart)))), p.iBufEnd-p.iBufStart, p.iWriteOff+int64(p.iBufStart))
			p.iBufStart = func() (_cgo_ret int32) {
				_cgo_addr := &p.iBufEnd
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
			p.iWriteOff += int64(p.nBuffer)
		}
		func() int {
			_ = 0
			return 0
		}()
		nRem -= nCopy
	}
}
func vdbePmaWriterFinish(p *struct_PmaWriter, piEof *int64) int32 {
	var rc int32
	if p.eFWErr == 0 && p.aBuffer != nil && p.iBufEnd > p.iBufStart {
		p.eFWErr = sqlite3OsWrite(p.pFd, unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aBuffer)) + uintptr(p.iBufStart)))), p.iBufEnd-p.iBufStart, p.iWriteOff+int64(p.iBufStart))
	}
	*piEof = p.iWriteOff + int64(p.iBufEnd)
	sqlite3_free(unsafe.Pointer(p.aBuffer))
	rc = p.eFWErr
	__builtin___memset_chk(unsafe.Pointer(p), 0, 48, __builtin_object_size(unsafe.Pointer(p), 0))
	return rc
}
func vdbePmaWriteVarint(p *struct_PmaWriter, iVal uint64) {
	var nByte int32
	var aByte [10]uint8
	nByte = sqlite3PutVarint((*uint8)(unsafe.Pointer(&aByte)), iVal)
	vdbePmaWriteBlob(p, (*uint8)(unsafe.Pointer(&aByte)), nByte)
}
func vdbeSorterListToPMA(pTask *struct_SortSubtask, pList *struct_SorterList) int32 {
	var db *struct_sqlite3 = pTask.pSorter.db
	var rc int32 = 0
	var writer struct_PmaWriter
	__builtin___memset_chk(unsafe.Pointer(&writer), 0, 48, __builtin_object_size(unsafe.Pointer(&writer), 0))
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pTask.file.pFd)) == uintptr(unsafe.Pointer(nil)) {
		rc = vdbeSorterOpenTempFile(db, int64(0), &pTask.file.pFd)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	if rc == 0 {
		vdbeSorterExtendFile(db, pTask.file.pFd, pTask.file.iEof+int64(pList.szPMA)+int64(9))
	}
	if rc == 0 {
		rc = vdbeSorterSort(pTask, pList)
	}
	if rc == 0 {
		var p *struct_SorterRecord
		var pNext *struct_SorterRecord = nil
		vdbePmaWriterInit(pTask.file.pFd, &writer, pTask.pSorter.pgsz, pTask.file.iEof)
		pTask.nPMA++
		vdbePmaWriteVarint(&writer, uint64(pList.szPMA))
		for p = pList.pList; p != nil; p = pNext {
			pNext = p.u.pNext
			vdbePmaWriteVarint(&writer, uint64(p.nVal))
			vdbePmaWriteBlob(&writer, (*uint8)(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(p))))+uintptr(1)*16)))), p.nVal)
			if uintptr(unsafe.Pointer(pList.aMemory)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3_free(unsafe.Pointer(p))
			}
		}
		pList.pList = p
		rc = vdbePmaWriterFinish(&writer, &pTask.file.iEof)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func vdbeMergeEngineStep(pMerger *struct_MergeEngine, pbEof *int32) int32 {
	var rc int32
	var iPrev int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(1)*4))
	var pTask *struct_SortSubtask = pMerger.pTask
	rc = vdbePmaReaderNext(&*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(iPrev)*80)))
	if rc == 0 {
		var i int32
		var pReadr1 *struct_PmaReader
		var pReadr2 *struct_PmaReader
		var bCached int32 = 0
		pReadr1 = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(iPrev&65534)*80))
		pReadr2 = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(iPrev|1)*80))
		for i = (pMerger.nTree + iPrev) / 2; i > 0; i = i / 2 {
			var iRes int32
			if uintptr(unsafe.Pointer(pReadr1.pFd)) == uintptr(unsafe.Pointer(nil)) {
				iRes = int32(1)
			} else if uintptr(unsafe.Pointer(pReadr2.pFd)) == uintptr(unsafe.Pointer(nil)) {
				iRes = int32(-1)
			} else {
				iRes = pTask.xCompare(pTask, &bCached, unsafe.Pointer(pReadr1.aKey), pReadr1.nKey, unsafe.Pointer(pReadr2.aKey), pReadr2.nKey)
			}
			if iRes < 0 || iRes == 0 && uintptr(unsafe.Pointer(pReadr1)) < uintptr(unsafe.Pointer(pReadr2)) {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(i)*4)) = int32((uintptr(unsafe.Pointer(pReadr1)) - uintptr(unsafe.Pointer(pMerger.aReadr))) * 80)
				pReadr2 = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(i^1)*4)))*80))
				bCached = int32(0)
			} else {
				if pReadr1.pFd != nil {
					bCached = int32(0)
				}
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(i)*4)) = int32((uintptr(unsafe.Pointer(pReadr2)) - uintptr(unsafe.Pointer(pMerger.aReadr))) * 80)
				pReadr1 = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(i^1)*4)))*80))
			}
		}
		*pbEof = func() int32 {
			if uintptr(unsafe.Pointer((*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(1)*4)))*80))).pFd)) == uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}()
	}
	return func() int32 {
		if rc == 0 {
			return int32(pTask.pUnpacked.errCode)
		} else {
			return rc
		}
	}()
}
func vdbeSorterFlushThread(pCtx unsafe.Pointer) unsafe.Pointer {
	var pTask *struct_SortSubtask = (*struct_SortSubtask)(pCtx)
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	rc = vdbeSorterListToPMA(pTask, &pTask.list)
	pTask.bDone = int32(1)
	return unsafe.Pointer(int(rc))
}
func vdbeSorterFlushPMA(pSorter *struct_VdbeSorter) int32 {
	var rc int32 = 0
	var i int32
	var pTask *struct_SortSubtask = nil
	var nWorker int32 = int32(pSorter.nTask) - 1
	pSorter.bUsePMA = uint8(1)
	for i = int32(0); i < nWorker; i++ {
		var iTest int32 = (int32(pSorter.iPrev) + i + 1) % nWorker
		pTask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(iTest)*96))
		if pTask.bDone != 0 {
			rc = vdbeSorterJoinThread(pTask)
		}
		if rc != 0 || uintptr(unsafe.Pointer(pTask.pThread)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
	}
	if rc == 0 {
		if i == nWorker {
			rc = vdbeSorterListToPMA(&*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(nWorker)*96)), &pSorter.list)
		} else {
			var aMem *uint8
			var pCtx unsafe.Pointer
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			aMem = pTask.list.aMemory
			pCtx = unsafe.Pointer(pTask)
			pSorter.iPrev = uint8((uintptr(unsafe.Pointer(pTask)) - uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask))))) * 96)
			pTask.list = pSorter.list
			pSorter.list.pList = (*struct_SorterRecord)(nil)
			pSorter.list.szPMA = int32(0)
			if aMem != nil {
				pSorter.list.aMemory = aMem
				pSorter.nMemory = sqlite3MallocSize(unsafe.Pointer(aMem))
			} else if pSorter.list.aMemory != nil {
				pSorter.list.aMemory = (*uint8)(sqlite3Malloc(uint64(pSorter.nMemory)))
				if !(pSorter.list.aMemory != nil) {
					return int32(7)
				}
			}
			rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx)
		}
	}
	return rc
}
func sqlite3VdbeSorterWrite(pCsr *struct_VdbeCursor, pVal *struct_sqlite3_value) int32 {
	var pSorter *struct_VdbeSorter
	var rc int32 = 0
	var pNew *struct_SorterRecord
	var bFlush int32
	var nReq int32
	var nPMA int32
	var t int32
	func() int {
		_ = 0
		return 0
	}()
	pSorter = *(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc))
	t = int32(uint32(*(*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pVal.z)) + uintptr(1)))))))
	if t >= 128 {
		sqlite3GetVarint32((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pVal.z)) + uintptr(1))))), (*uint32)(unsafe.Pointer(&t)))
	}
	if t > 0 && t < 10 && t != 7 {
		pSorter.typeMask &= uint8(1)
	} else if t > 10 && t&1 != 0 {
		pSorter.typeMask &= uint8(2)
	} else {
		pSorter.typeMask = uint8(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	nReq = int32(uint(pVal.n) + 16)
	nPMA = pVal.n + sqlite3VarintLen(uint64(pVal.n))
	if pSorter.mxPmaSize != 0 {
		if pSorter.list.aMemory != nil {
			bFlush = func() int32 {
				if pSorter.iMemory != 0 && pSorter.iMemory+nReq > pSorter.mxPmaSize {
					return 1
				} else {
					return 0
				}
			}()
		} else {
			bFlush = func() int32 {
				if pSorter.list.szPMA > pSorter.mxPmaSize || pSorter.list.szPMA > pSorter.mnPmaSize && sqlite3HeapNearlyFull() != 0 {
					return 1
				} else {
					return 0
				}
			}()
		}
		if bFlush != 0 {
			rc = vdbeSorterFlushPMA(pSorter)
			pSorter.list.szPMA = int32(0)
			pSorter.iMemory = int32(0)
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	pSorter.list.szPMA += nPMA
	if nPMA > pSorter.mxKeysize {
		pSorter.mxKeysize = nPMA
	}
	if pSorter.list.aMemory != nil {
		var nMin int32 = pSorter.iMemory + nReq
		if nMin > pSorter.nMemory {
			var aNew *uint8
			var nNew int64 = int64(2) * int64(pSorter.nMemory)
			var iListOff int32 = -1
			if pSorter.list.pList != nil {
				iListOff = int32(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pSorter.list.pList)))) - uintptr(unsafe.Pointer(pSorter.list.aMemory)))
			}
			for nNew < int64(nMin) {
				nNew = nNew * int64(2)
			}
			if nNew > int64(pSorter.mxPmaSize) {
				nNew = int64(pSorter.mxPmaSize)
			}
			if nNew < int64(nMin) {
				nNew = int64(nMin)
			}
			aNew = (*uint8)(sqlite3Realloc(unsafe.Pointer(pSorter.list.aMemory), uint64(nNew)))
			if !(aNew != nil) {
				return int32(7)
			}
			if iListOff >= 0 {
				pSorter.list.pList = (*struct_SorterRecord)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aNew)) + uintptr(iListOff)))))
			}
			pSorter.list.aMemory = aNew
			pSorter.nMemory = int32(nNew)
		}
		pNew = (*struct_SorterRecord)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pSorter.list.aMemory)) + uintptr(pSorter.iMemory)))))
		pSorter.iMemory += (nReq + 7) & ^7
		if pSorter.list.pList != nil {
			*(*int32)(unsafe.Pointer(&pNew.u)) = int32(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(pSorter.list.pList)))) - uintptr(unsafe.Pointer(pSorter.list.aMemory)))
		}
	} else {
		pNew = (*struct_SorterRecord)(sqlite3Malloc(uint64(nReq)))
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		pNew.u.pNext = pSorter.list.pList
	}
	__builtin___memcpy_chk(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(pNew))))+uintptr(1)*16))), unsafe.Pointer(pVal.z), uint(pVal.n), __builtin_object_size(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(pNew))))+uintptr(1)*16))), 0))
	pNew.nVal = pVal.n
	pSorter.list.pList = pNew
	return rc
}
func vdbeIncrPopulate(pIncr *struct_IncrMerger) int32 {
	var rc int32 = 0
	var rc2 int32
	var iStart int64 = pIncr.iStartOff
	var pOut *struct_SorterFile = &*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))
	var pTask *struct_SortSubtask = pIncr.pTask
	var pMerger *struct_MergeEngine = pIncr.pMerger
	var writer struct_PmaWriter
	func() int {
		_ = 0
		return 0
	}()
	vdbePmaWriterInit(pOut.pFd, &writer, pTask.pSorter.pgsz, iStart)
	for rc == 0 {
		var dummy int32
		var pReader *struct_PmaReader = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(1)*4)))*80))
		var nKey int32 = pReader.nKey
		var iEof int64 = writer.iWriteOff + int64(writer.iBufEnd)
		if uintptr(unsafe.Pointer(pReader.pFd)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		if iEof+int64(nKey)+int64(sqlite3VarintLen(uint64(nKey))) > iStart+int64(pIncr.mxSz) {
			break
		}
		vdbePmaWriteVarint(&writer, uint64(nKey))
		vdbePmaWriteBlob(&writer, pReader.aKey, nKey)
		func() int {
			_ = 0
			return 0
		}()
		rc = vdbeMergeEngineStep(pIncr.pMerger, &dummy)
	}
	rc2 = vdbePmaWriterFinish(&writer, &pOut.iEof)
	if rc == 0 {
		rc = rc2
	}
	return rc
}
func vdbeIncrPopulateThread(pCtx unsafe.Pointer) unsafe.Pointer {
	var pIncr *struct_IncrMerger = (*struct_IncrMerger)(pCtx)
	var pRet unsafe.Pointer = unsafe.Pointer(int(vdbeIncrPopulate(pIncr)))
	pIncr.pTask.bDone = int32(1)
	return pRet
}
func vdbeIncrBgPopulate(pIncr *struct_IncrMerger) int32 {
	var p unsafe.Pointer = unsafe.Pointer(pIncr)
	func() int {
		_ = 0
		return 0
	}()
	return vdbeSorterCreateThread(pIncr.pTask, vdbeIncrPopulateThread, p)
}
func vdbeIncrSwap(pIncr *struct_IncrMerger) int32 {
	var rc int32 = 0
	if pIncr.bUseThread != 0 {
		rc = vdbeSorterJoinThread(pIncr.pTask)
		if rc == 0 {
			var f0 struct_SorterFile = *(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16))
			*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16)) = *(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))
			*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16)) = f0
		}
		if rc == 0 {
			if (*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16))).iEof == pIncr.iStartOff {
				pIncr.bEof = int32(1)
			} else {
				rc = vdbeIncrBgPopulate(pIncr)
			}
		}
	} else {
		rc = vdbeIncrPopulate(pIncr)
		*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16)) = *(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))
		if (*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16))).iEof == pIncr.iStartOff {
			pIncr.bEof = int32(1)
		}
	}
	return rc
}
func vdbeIncrMergerNew(pTask *struct_SortSubtask, pMerger *struct_MergeEngine, ppOut **struct_IncrMerger) int32 {
	var rc int32 = 0
	var pIncr *struct_IncrMerger = func() (_cgo_ret *struct_IncrMerger) {
		_cgo_addr := &*ppOut
		*_cgo_addr = (*struct_IncrMerger)(func() unsafe.Pointer {
			if sqlite3FaultSim(100) != 0 {
				return nil
			} else {
				return sqlite3MallocZero(uint64(72))
			}
		}())
		return *_cgo_addr
	}()
	if pIncr != nil {
		pIncr.pMerger = pMerger
		pIncr.pTask = pTask
		pIncr.mxSz = func() int32 {
			if pTask.pSorter.mxKeysize+9 > pTask.pSorter.mxPmaSize/2 {
				return pTask.pSorter.mxKeysize + 9
			} else {
				return pTask.pSorter.mxPmaSize / 2
			}
		}()
		pTask.file2.iEof += int64(pIncr.mxSz)
	} else {
		vdbeMergeEngineFree(pMerger)
		rc = int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func vdbeIncrMergerSetThreads(pIncr *struct_IncrMerger) {
	pIncr.bUseThread = int32(1)
	pIncr.pTask.file2.iEof -= int64(pIncr.mxSz)
}
func vdbeMergeEngineCompare(pMerger *struct_MergeEngine, iOut int32) {
	var i1 int32
	var i2 int32
	var iRes int32
	var p1 *struct_PmaReader
	var p2 *struct_PmaReader
	func() int {
		_ = 0
		return 0
	}()
	if iOut >= pMerger.nTree/2 {
		i1 = (iOut - pMerger.nTree/2) * 2
		i2 = i1 + 1
	} else {
		i1 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(iOut*2)*4))
		i2 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(iOut*2+1)*4))
	}
	p1 = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(i1)*80))
	p2 = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(i2)*80))
	if uintptr(unsafe.Pointer(p1.pFd)) == uintptr(unsafe.Pointer(nil)) {
		iRes = i2
	} else if uintptr(unsafe.Pointer(p2.pFd)) == uintptr(unsafe.Pointer(nil)) {
		iRes = i1
	} else {
		var pTask *struct_SortSubtask = pMerger.pTask
		var bCached int32 = 0
		var res int32
		func() int {
			_ = 0
			return 0
		}()
		res = pTask.xCompare(pTask, &bCached, unsafe.Pointer(p1.aKey), p1.nKey, unsafe.Pointer(p2.aKey), p2.nKey)
		if res <= 0 {
			iRes = i1
		} else {
			iRes = i2
		}
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aTree)) + uintptr(iOut)*4)) = iRes
}
func vdbeMergeEngineInit(pTask *struct_SortSubtask, pMerger *struct_MergeEngine, eMode int32) int32 {
	var rc int32 = 0
	var i int32
	var nTree int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pMerger.pTask = pTask
	nTree = pMerger.nTree
	for i = int32(0); i < nTree; i++ {
		if true && eMode == 2 {
			rc = vdbePmaReaderNext(&*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(nTree-i-1)*80)))
		} else {
			rc = vdbePmaReaderIncrInit(&*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMerger.aReadr)) + uintptr(i)*80)), 0)
		}
		if rc != 0 {
			return rc
		}
	}
	for i = pMerger.nTree - 1; i > 0; i-- {
		vdbeMergeEngineCompare(pMerger, i)
	}
	return int32(pTask.pUnpacked.errCode)
}
func vdbePmaReaderIncrMergeInit(pReadr *struct_PmaReader, eMode int32) int32 {
	var rc int32 = 0
	var pIncr *struct_IncrMerger = pReadr.pIncr
	var pTask *struct_SortSubtask = pIncr.pTask
	var db *struct_sqlite3 = pTask.pSorter.db
	func() int {
		_ = 0
		return 0
	}()
	rc = vdbeMergeEngineInit(pTask, pIncr.pMerger, eMode)
	if rc == 0 {
		var mxSz int32 = pIncr.mxSz
		if pIncr.bUseThread != 0 {
			rc = vdbeSorterOpenTempFile(db, int64(mxSz), &(*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(0)*16))).pFd)
			if rc == 0 {
				rc = vdbeSorterOpenTempFile(db, int64(mxSz), &(*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))).pFd)
			}
		} else {
			if uintptr(unsafe.Pointer(pTask.file2.pFd)) == uintptr(unsafe.Pointer(nil)) {
				func() int {
					_ = 0
					return 0
				}()
				rc = vdbeSorterOpenTempFile(db, pTask.file2.iEof, &pTask.file2.pFd)
				pTask.file2.iEof = int64(0)
			}
			if rc == 0 {
				(*(*struct_SorterFile)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterFile)(unsafe.Pointer(&pIncr.aFile)))) + uintptr(1)*16))).pFd = pTask.file2.pFd
				pIncr.iStartOff = pTask.file2.iEof
				pTask.file2.iEof += int64(mxSz)
			}
		}
	}
	if rc == 0 && pIncr.bUseThread != 0 {
		func() int {
			_ = 0
			return 0
		}()
		rc = vdbeIncrPopulate(pIncr)
	}
	if rc == 0 && (8 == 0 || eMode != 1) {
		rc = vdbePmaReaderNext(pReadr)
	}
	return rc
}
func vdbePmaReaderBgIncrInit(pCtx unsafe.Pointer) unsafe.Pointer {
	var pReader *struct_PmaReader = (*struct_PmaReader)(pCtx)
	var pRet unsafe.Pointer = unsafe.Pointer(int(vdbePmaReaderIncrMergeInit(pReader, 1)))
	pReader.pIncr.pTask.bDone = int32(1)
	return pRet
}
func vdbePmaReaderIncrInit(pReadr *struct_PmaReader, eMode int32) int32 {
	var pIncr *struct_IncrMerger = pReadr.pIncr
	var rc int32 = 0
	if pIncr != nil {
		func() int {
			_ = 0
			return 0
		}()
		if pIncr.bUseThread != 0 {
			var pCtx unsafe.Pointer = unsafe.Pointer(pReadr)
			rc = vdbeSorterCreateThread(pIncr.pTask, vdbePmaReaderBgIncrInit, pCtx)
		} else {
			rc = vdbePmaReaderIncrMergeInit(pReadr, eMode)
		}
	}
	return rc
}
func vdbeMergeEngineLevel0(pTask *struct_SortSubtask, nPMA int32, piOffset *int64, ppOut **struct_MergeEngine) int32 {
	var pNew *struct_MergeEngine
	var iOff int64 = *piOffset
	var i int32
	var rc int32 = 0
	*ppOut = func() (_cgo_ret *struct_MergeEngine) {
		_cgo_addr := &pNew
		*_cgo_addr = vdbeMergeEngineNew(nPMA)
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(7)
	}
	for i = int32(0); i < nPMA && rc == 0; i++ {
		var nDummy int64 = int64(0)
		var pReadr *struct_PmaReader = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aReadr)) + uintptr(i)*80))
		rc = vdbePmaReaderInit(pTask, &pTask.file, iOff, pReadr, &nDummy)
		iOff = pReadr.iEof
	}
	if rc != 0 {
		vdbeMergeEngineFree(pNew)
		*ppOut = (*struct_MergeEngine)(nil)
	}
	*piOffset = iOff
	return rc
}
func vdbeSorterTreeDepth(nPMA int32) int32 {
	var nDepth int32 = 0
	var nDiv int64 = int64(16)
	for nDiv < int64(nPMA) {
		nDiv = nDiv * int64(16)
		nDepth++
	}
	return nDepth
}
func vdbeSorterAddToTree(pTask *struct_SortSubtask, nDepth int32, iSeq int32, pRoot *struct_MergeEngine, pLeaf *struct_MergeEngine) int32 {
	var rc int32 = 0
	var nDiv int32 = 1
	var i int32
	var p *struct_MergeEngine = pRoot
	var pIncr *struct_IncrMerger
	rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr)
	for i = int32(1); i < nDepth; i++ {
		nDiv = nDiv * 16
	}
	for i = int32(1); i < nDepth && rc == 0; i++ {
		var iIter int32 = iSeq / nDiv % 16
		var pReadr *struct_PmaReader = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aReadr)) + uintptr(iIter)*80))
		if uintptr(unsafe.Pointer(pReadr.pIncr)) == uintptr(unsafe.Pointer(nil)) {
			var pNew *struct_MergeEngine = vdbeMergeEngineNew(16)
			if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(7)
			} else {
				rc = vdbeIncrMergerNew(pTask, pNew, &pReadr.pIncr)
			}
		}
		if rc == 0 {
			p = pReadr.pIncr.pMerger
			nDiv = nDiv / 16
		}
	}
	if rc == 0 {
		(*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aReadr)) + uintptr(iSeq%16)*80))).pIncr = pIncr
	} else {
		vdbeIncrFree(pIncr)
	}
	return rc
}
func vdbeSorterMergeTreeBuild(pSorter *struct_VdbeSorter, ppOut **struct_MergeEngine) int32 {
	var pMain *struct_MergeEngine = nil
	var rc int32 = 0
	var iTask int32
	func() int {
		_ = 0
		return 0
	}()
	if int32(pSorter.nTask) > 1 {
		pMain = vdbeMergeEngineNew(int32(pSorter.nTask))
		if uintptr(unsafe.Pointer(pMain)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
		}
	}
	for iTask = int32(0); rc == 0 && iTask < int32(pSorter.nTask); iTask++ {
		var pTask *struct_SortSubtask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(iTask)*96))
		func() int {
			_ = 0
			return 0
		}()
		if 8 == 0 || pTask.nPMA != 0 {
			var pRoot *struct_MergeEngine = nil
			var nDepth int32 = vdbeSorterTreeDepth(pTask.nPMA)
			var iReadOff int64 = int64(0)
			if pTask.nPMA <= 16 {
				rc = vdbeMergeEngineLevel0(pTask, pTask.nPMA, &iReadOff, &pRoot)
			} else {
				var i int32
				var iSeq int32 = 0
				pRoot = vdbeMergeEngineNew(16)
				if uintptr(unsafe.Pointer(pRoot)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
				}
				for i = int32(0); i < pTask.nPMA && rc == 0; i += int32(16) {
					var pMerger *struct_MergeEngine = nil
					var nReader int32
					nReader = func() int32 {
						if pTask.nPMA-i < 16 {
							return pTask.nPMA - i
						} else {
							return 16
						}
					}()
					rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger)
					if rc == 0 {
						rc = vdbeSorterAddToTree(pTask, nDepth, func() (_cgo_ret int32) {
							_cgo_addr := &iSeq
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}(), pRoot, pMerger)
					}
				}
			}
			if rc == 0 {
				if uintptr(unsafe.Pointer(pMain)) != uintptr(unsafe.Pointer(nil)) {
					rc = vdbeIncrMergerNew(pTask, pRoot, &(*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMain.aReadr)) + uintptr(iTask)*80))).pIncr)
				} else {
					func() int {
						_ = 0
						return 0
					}()
					pMain = pRoot
				}
			} else {
				vdbeMergeEngineFree(pRoot)
			}
		}
	}
	if rc != 0 {
		vdbeMergeEngineFree(pMain)
		pMain = (*struct_MergeEngine)(nil)
	}
	*ppOut = pMain
	return rc
}
func vdbeSorterSetupMerge(pSorter *struct_VdbeSorter) int32 {
	var rc int32
	var pTask0 *struct_SortSubtask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(0)*96))
	var pMain *struct_MergeEngine = nil
	var db *struct_sqlite3 = pTask0.pSorter.db
	var i int32
	var xCompare func(*struct_SortSubtask, *int32, unsafe.Pointer, int32, unsafe.Pointer, int32) int32 = vdbeSorterGetCompare(pSorter)
	for i = int32(0); i < int32(pSorter.nTask); i++ {
		(*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(i)*96))).xCompare = xCompare
	}
	rc = vdbeSorterMergeTreeBuild(pSorter, &pMain)
	if rc == 0 {
		func() int {
			_ = 0
			return 0
		}()
		if pSorter.bUseThreads != 0 {
			var iTask int32
			var pReadr *struct_PmaReader = nil
			var pLast *struct_SortSubtask = &*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(int32(pSorter.nTask)-1)*96))
			rc = vdbeSortAllocUnpacked(pLast)
			if rc == 0 {
				pReadr = (*struct_PmaReader)(sqlite3DbMallocZero(db, uint64(80)))
				pSorter.pReader = pReadr
				if uintptr(unsafe.Pointer(pReadr)) == uintptr(unsafe.Pointer(nil)) {
					rc = int32(7)
				}
			}
			if rc == 0 {
				rc = vdbeIncrMergerNew(pLast, pMain, &pReadr.pIncr)
				if rc == 0 {
					vdbeIncrMergerSetThreads(pReadr.pIncr)
					for iTask = int32(0); iTask < int32(pSorter.nTask)-1; iTask++ {
						var pIncr *struct_IncrMerger
						if func() (_cgo_ret *struct_IncrMerger) {
							_cgo_addr := &pIncr
							*_cgo_addr = (*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMain.aReadr)) + uintptr(iTask)*80))).pIncr
							return *_cgo_addr
						}() != nil {
							vdbeIncrMergerSetThreads(pIncr)
							func() int {
								_ = 0
								return 0
							}()
						}
					}
					for iTask = int32(0); rc == 0 && iTask < int32(pSorter.nTask); iTask++ {
						var p *struct_PmaReader = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pMain.aReadr)) + uintptr(iTask)*80))
						func() int {
							_ = 0
							return 0
						}()
						rc = vdbePmaReaderIncrInit(p, 1)
					}
				}
				pMain = (*struct_MergeEngine)(nil)
			}
			if rc == 0 {
				rc = vdbePmaReaderIncrMergeInit(pReadr, 2)
			}
		} else {
			rc = vdbeMergeEngineInit(pTask0, pMain, 0)
			pSorter.pMerger = pMain
			pMain = (*struct_MergeEngine)(nil)
		}
	}
	if rc != 0 {
		vdbeMergeEngineFree(pMain)
	}
	return rc
}
func sqlite3VdbeSorterRewind(pCsr *struct_VdbeCursor, pbEof *int32) int32 {
	var pSorter *struct_VdbeSorter
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	pSorter = *(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc))
	func() int {
		_ = 0
		return 0
	}()
	if int32(pSorter.bUsePMA) == 0 {
		if pSorter.list.pList != nil {
			*pbEof = int32(0)
			rc = vdbeSorterSort(&*(*struct_SortSubtask)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SortSubtask)(unsafe.Pointer(&pSorter.aTask)))) + uintptr(0)*96)), &pSorter.list)
		} else {
			*pbEof = int32(1)
		}
		return rc
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = vdbeSorterFlushPMA(pSorter)
	rc = vdbeSorterJoinAll(pSorter, rc)
	func() int {
		_ = 0
		return 0
	}()
	if rc == 0 {
		rc = vdbeSorterSetupMerge(pSorter)
		*pbEof = int32(0)
	}
	return rc
}
func sqlite3VdbeSorterNext(db *struct_sqlite3, pCsr *struct_VdbeCursor) int32 {
	var pSorter *struct_VdbeSorter
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	pSorter = *(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc))
	func() int {
		_ = 0
		return 0
	}()
	if pSorter.bUsePMA != 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pSorter.bUseThreads != 0 {
			rc = vdbePmaReaderNext(pSorter.pReader)
			if rc == 0 && uintptr(unsafe.Pointer(pSorter.pReader.pFd)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(101)
			}
		} else {
			var res int32 = 0
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			rc = vdbeMergeEngineStep(pSorter.pMerger, &res)
			if rc == 0 && res != 0 {
				rc = int32(101)
			}
		}
	} else {
		var pFree *struct_SorterRecord = pSorter.list.pList
		pSorter.list.pList = pFree.u.pNext
		pFree.u.pNext = (*struct_SorterRecord)(nil)
		if uintptr(unsafe.Pointer(pSorter.list.aMemory)) == uintptr(unsafe.Pointer(nil)) {
			vdbeSorterRecordFree(db, pFree)
		}
		rc = func() int32 {
			if pSorter.list.pList != nil {
				return 0
			} else {
				return 101
			}
		}()
	}
	return rc
}
func vdbeSorterRowkey(pSorter *struct_VdbeSorter, pnKey *int32) unsafe.Pointer {
	var pKey unsafe.Pointer
	if pSorter.bUsePMA != 0 {
		var pReader *struct_PmaReader
		if pSorter.bUseThreads != 0 {
			pReader = pSorter.pReader
		} else {
			pReader = &*(*struct_PmaReader)(unsafe.Pointer(uintptr(unsafe.Pointer(pSorter.pMerger.aReadr)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pSorter.pMerger.aTree)) + uintptr(1)*4)))*80))
		}
		*pnKey = pReader.nKey
		pKey = unsafe.Pointer(pReader.aKey)
	} else {
		*pnKey = pSorter.list.pList.nVal
		pKey = unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SorterRecord)(unsafe.Pointer(pSorter.list.pList)))) + uintptr(1)*16)))
	}
	return pKey
}
func sqlite3VdbeSorterRowkey(pCsr *struct_VdbeCursor, pOut *struct_sqlite3_value) int32 {
	var pSorter *struct_VdbeSorter
	var pKey unsafe.Pointer
	var nKey int32
	func() int {
		_ = 0
		return 0
	}()
	pSorter = *(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc))
	pKey = vdbeSorterRowkey(pSorter, &nKey)
	if sqlite3VdbeMemClearAndResize(pOut, nKey) != 0 {
		return int32(7)
	}
	pOut.n = nKey
	pOut.flags = uint16(int32(pOut.flags) & ^(49599|16384) | 16)
	__builtin___memcpy_chk(unsafe.Pointer(pOut.z), pKey, uint(nKey), __builtin_object_size(unsafe.Pointer(pOut.z), 0))
	return int32(0)
}
func sqlite3VdbeSorterCompare(pCsr *struct_VdbeCursor, pVal *struct_sqlite3_value, nKeyCol int32, pRes *int32) int32 {
	var pSorter *struct_VdbeSorter
	var r2 *struct_UnpackedRecord
	var pKeyInfo *struct_KeyInfo
	var i int32
	var pKey unsafe.Pointer
	var nKey int32
	func() int {
		_ = 0
		return 0
	}()
	pSorter = *(**struct_VdbeSorter)(unsafe.Pointer(&pCsr.uc))
	r2 = pSorter.pUnpacked
	pKeyInfo = pCsr.pKeyInfo
	if uintptr(unsafe.Pointer(r2)) == uintptr(unsafe.Pointer(nil)) {
		r2 = func() (_cgo_ret *struct_UnpackedRecord) {
			_cgo_addr := &pSorter.pUnpacked
			*_cgo_addr = sqlite3VdbeAllocUnpackedRecord(pKeyInfo)
			return *_cgo_addr
		}()
		if uintptr(unsafe.Pointer(r2)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		r2.nField = uint16(nKeyCol)
	}
	func() int {
		_ = 0
		return 0
	}()
	pKey = vdbeSorterRowkey(pSorter, &nKey)
	sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, r2)
	for i = int32(0); i < nKeyCol; i++ {
		if int32((*(*struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(r2.aMem)) + uintptr(i)*56))).flags)&1 != 0 {
			*pRes = int32(-1)
			return int32(0)
		}
	}
	*pRes = sqlite3VdbeRecordCompare(pVal.n, unsafe.Pointer(pVal.z), r2)
	return int32(0)
}

type MemJournal = struct_MemJournal
type FilePoint = struct_FilePoint
type FileChunk = struct_FileChunk
type struct_FileChunk struct {
	pNext  *struct_FileChunk
	zChunk [8]uint8
}
type struct_FilePoint struct {
	iOffset int64
	pChunk  *struct_FileChunk
}
type struct_MemJournal struct {
	pMethod    *struct_sqlite3_io_methods
	nChunkSize int32
	nSpill     int32
	pFirst     *struct_FileChunk
	endpoint   struct_FilePoint
	readpoint  struct_FilePoint
	flags      int32
	pVfs       *struct_sqlite3_vfs
	zJournal   *int8
}

func memjrnlRead(pJfd *struct_sqlite3_file, zBuf unsafe.Pointer, iAmt int32, iOfst int64) int32 {
	var p *struct_MemJournal = (*struct_MemJournal)(unsafe.Pointer(pJfd))
	var zOut *uint8 = (*uint8)(zBuf)
	var nRead int32 = iAmt
	var iChunkOffset int32
	var pChunk *struct_FileChunk
	if int64(iAmt)+iOfst > p.endpoint.iOffset {
		return int32(10 | 2<<8)
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.readpoint.iOffset != iOfst || iOfst == int64(0) {
		var iOff int64 = int64(0)
		for pChunk = p.pFirst; pChunk != nil && iOff+int64(p.nChunkSize) <= iOfst; pChunk = pChunk.pNext {
			iOff += int64(p.nChunkSize)
		}
	} else {
		pChunk = p.readpoint.pChunk
		func() int {
			_ = 0
			return 0
		}()
	}
	iChunkOffset = int32(iOfst % int64(p.nChunkSize))
	for {
		var iSpace int32 = p.nChunkSize - iChunkOffset
		var nCopy int32 = func() int32 {
			if nRead < p.nChunkSize-iChunkOffset {
				return nRead
			} else {
				return p.nChunkSize - iChunkOffset
			}
		}()
		__builtin___memcpy_chk(unsafe.Pointer(zOut), unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&pChunk.zChunk))))))+uintptr(iChunkOffset)))), uint(nCopy), __builtin_object_size(unsafe.Pointer(zOut), 0))
		*(*uintptr)(unsafe.Pointer(&zOut)) += uintptr(nCopy)
		nRead -= iSpace
		iChunkOffset = int32(0)
		if !(nRead >= 0 && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_FileChunk) {
			_cgo_addr := &pChunk
			*_cgo_addr = pChunk.pNext
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) && nRead > 0) {
			break
		}
	}
	p.readpoint.iOffset = func() int64 {
		if pChunk != nil {
			return iOfst + int64(iAmt)
		} else {
			return int64(0)
		}
	}()
	p.readpoint.pChunk = pChunk
	return int32(0)
}
func memjrnlFreeChunks(pFirst *struct_FileChunk) {
	var pIter *struct_FileChunk
	var pNext *struct_FileChunk
	for pIter = pFirst; pIter != nil; pIter = pNext {
		pNext = pIter.pNext
		sqlite3_free(unsafe.Pointer(pIter))
	}
}
func memjrnlCreateFile(p *struct_MemJournal) int32 {
	var rc int32
	var pReal *struct_sqlite3_file = (*struct_sqlite3_file)(unsafe.Pointer(p))
	var copy struct_MemJournal = *p
	__builtin___memset_chk(unsafe.Pointer(p), 0, 80, __builtin_object_size(unsafe.Pointer(p), 0))
	rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, nil)
	if rc == 0 {
		var nChunk int32 = copy.nChunkSize
		var iOff int64 = int64(0)
		var pIter *struct_FileChunk
		for pIter = copy.pFirst; pIter != nil; pIter = pIter.pNext {
			if iOff+int64(nChunk) > copy.endpoint.iOffset {
				nChunk = int32(copy.endpoint.iOffset - iOff)
			}
			rc = sqlite3OsWrite(pReal, unsafe.Pointer((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&pIter.zChunk))))), nChunk, iOff)
			if rc != 0 {
				break
			}
			iOff += int64(nChunk)
		}
		if rc == 0 {
			memjrnlFreeChunks(copy.pFirst)
		}
	}
	if rc != 0 {
		sqlite3OsClose(pReal)
		*p = copy
	}
	return rc
}
func memjrnlWrite(pJfd *struct_sqlite3_file, zBuf unsafe.Pointer, iAmt int32, iOfst int64) int32 {
	var p *struct_MemJournal = (*struct_MemJournal)(unsafe.Pointer(pJfd))
	var nWrite int32 = iAmt
	var zWrite *uint8 = (*uint8)(zBuf)
	if p.nSpill > 0 && int64(iAmt)+iOfst > int64(p.nSpill) {
		var rc int32 = memjrnlCreateFile(p)
		if rc == 0 {
			rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst)
		}
		return rc
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if iOfst > int64(0) && iOfst != p.endpoint.iOffset {
			memjrnlTruncate(pJfd, iOfst)
		}
		if iOfst == int64(0) && p.pFirst != nil {
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memcpy_chk(unsafe.Pointer((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&p.pFirst.zChunk))))), zBuf, uint(iAmt), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&p.pFirst.zChunk))))), 0))
		} else {
			for nWrite > 0 {
				var pChunk *struct_FileChunk = p.endpoint.pChunk
				var iChunkOffset int32 = int32(p.endpoint.iOffset % int64(p.nChunkSize))
				var iSpace int32 = func() int32 {
					if nWrite < p.nChunkSize-iChunkOffset {
						return nWrite
					} else {
						return p.nChunkSize - iChunkOffset
					}
				}()
				func() int {
					_ = 0
					return 0
				}()
				if iChunkOffset == 0 {
					var pNew *struct_FileChunk = (*struct_FileChunk)(sqlite3_malloc(int32(16 + uint(p.nChunkSize-8))))
					if !(pNew != nil) {
						return int32(10 | 12<<8)
					}
					pNew.pNext = (*struct_FileChunk)(nil)
					if pChunk != nil {
						func() int {
							_ = 0
							return 0
						}()
						pChunk.pNext = pNew
					} else {
						func() int {
							_ = 0
							return 0
						}()
						p.pFirst = pNew
					}
					pChunk = func() (_cgo_ret *struct_FileChunk) {
						_cgo_addr := &p.endpoint.pChunk
						*_cgo_addr = pNew
						return *_cgo_addr
					}()
				}
				func() int {
					_ = 0
					return 0
				}()
				__builtin___memcpy_chk(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&pChunk.zChunk))))))+uintptr(iChunkOffset)))), unsafe.Pointer(zWrite), uint(iSpace), __builtin_object_size(unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&pChunk.zChunk))))))+uintptr(iChunkOffset)))), 0))
				*(*uintptr)(unsafe.Pointer(&zWrite)) += uintptr(iSpace)
				nWrite -= iSpace
				p.endpoint.iOffset += int64(iSpace)
			}
		}
	}
	return int32(0)
}
func memjrnlTruncate(pJfd *struct_sqlite3_file, size int64) int32 {
	var p *struct_MemJournal = (*struct_MemJournal)(unsafe.Pointer(pJfd))
	func() int {
		_ = 0
		return 0
	}()
	if size < p.endpoint.iOffset {
		var pIter *struct_FileChunk = nil
		if size == int64(0) {
			memjrnlFreeChunks(p.pFirst)
			p.pFirst = (*struct_FileChunk)(nil)
		} else {
			var iOff int64 = int64(p.nChunkSize)
			for pIter = p.pFirst; pIter != nil && iOff < size; pIter = pIter.pNext {
				iOff += int64(p.nChunkSize)
			}
			if pIter != nil {
				memjrnlFreeChunks(pIter.pNext)
				pIter.pNext = (*struct_FileChunk)(nil)
			}
		}
		p.endpoint.pChunk = pIter
		p.endpoint.iOffset = size
		p.readpoint.pChunk = (*struct_FileChunk)(nil)
		p.readpoint.iOffset = int64(0)
	}
	return int32(0)
}
func memjrnlClose(pJfd *struct_sqlite3_file) int32 {
	var p *struct_MemJournal = (*struct_MemJournal)(unsafe.Pointer(pJfd))
	memjrnlFreeChunks(p.pFirst)
	return int32(0)
}
func memjrnlSync(pJfd *struct_sqlite3_file, flags int32) int32 {
	func() int {
		func() int {
			_ = pJfd
			return 0
		}()
		return func() int {
			_ = flags
			return 0
		}()
	}()
	return int32(0)
}
func memjrnlFileSize(pJfd *struct_sqlite3_file, pSize *int64) int32 {
	var p *struct_MemJournal = (*struct_MemJournal)(unsafe.Pointer(pJfd))
	*pSize = int64(p.endpoint.iOffset)
	return int32(0)
}

var MemJournalMethods struct_sqlite3_io_methods = struct_sqlite3_io_methods{1, memjrnlClose, memjrnlRead, memjrnlWrite, memjrnlTruncate, memjrnlSync, memjrnlFileSize, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil}

func sqlite3JournalOpen(pVfs *struct_sqlite3_vfs, zName *int8, pJfd *struct_sqlite3_file, flags int32, nSpill int32) int32 {
	var p *struct_MemJournal = (*struct_MemJournal)(unsafe.Pointer(pJfd))
	__builtin___memset_chk(unsafe.Pointer(p), 0, 80, __builtin_object_size(unsafe.Pointer(p), 0))
	if nSpill == 0 {
		return sqlite3OsOpen(pVfs, zName, pJfd, flags, nil)
	}
	if nSpill > 0 {
		p.nChunkSize = nSpill
	} else {
		p.nChunkSize = int32(uint(8+1024) - 16)
		func() int {
			_ = 0
			return 0
		}()
	}
	pJfd.pMethods = (*struct_sqlite3_io_methods)(unsafe.Pointer(&MemJournalMethods))
	p.nSpill = nSpill
	p.flags = flags
	p.zJournal = zName
	p.pVfs = pVfs
	return int32(0)
}
func sqlite3MemJournalOpen(pJfd *struct_sqlite3_file) {
	sqlite3JournalOpen(nil, nil, pJfd, 0, -1)
}
func sqlite3JournalIsInMemory(p *struct_sqlite3_file) int32 {
	return func() int32 {
		if uintptr(unsafe.Pointer(p.pMethods)) == uintptr(unsafe.Pointer(&MemJournalMethods)) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3JournalSize(pVfs *struct_sqlite3_vfs) int32 {
	return func() int32 {
		if pVfs.szOsFile > int32(80) {
			return pVfs.szOsFile
		} else {
			return int32(80)
		}
	}()
}
func walkWindowList(pWalker *struct_Walker, pList *struct_Window, bOneOnly int32) int32 {
	var pWin *struct_Window
	for pWin = pList; pWin != nil; pWin = pWin.pNextWin {
		var rc int32
		rc = sqlite3WalkExprList(pWalker, pWin.pOrderBy)
		if rc != 0 {
			return int32(2)
		}
		rc = sqlite3WalkExprList(pWalker, pWin.pPartition)
		if rc != 0 {
			return int32(2)
		}
		rc = sqlite3WalkExpr(pWalker, pWin.pFilter)
		if rc != 0 {
			return int32(2)
		}
		rc = sqlite3WalkExpr(pWalker, pWin.pStart)
		if rc != 0 {
			return int32(2)
		}
		rc = sqlite3WalkExpr(pWalker, pWin.pEnd)
		if rc != 0 {
			return int32(2)
		}
		if bOneOnly != 0 {
			break
		}
	}
	return int32(0)
}
func walkExpr(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var rc int32
	for 1 != 0 {
		rc = pWalker.xExprCallback(pWalker, pExpr)
		if rc != 0 {
			return rc & 2
		}
		if !(pExpr.flags&uint32(16384|8388608) != uint32(0)) {
			func() int {
				_ = 0
				return 0
			}()
			if pExpr.pLeft != nil && walkExpr(pWalker, pExpr.pLeft) != 0 {
				return int32(2)
			}
			if pExpr.pRight != nil {
				func() int {
					_ = 0
					return 0
				}()
				pExpr = pExpr.pRight
				continue
			} else if pExpr.flags&uint32(2048) != uint32(0) {
				func() int {
					_ = 0
					return 0
				}()
				if sqlite3WalkSelect(pWalker, *(**struct_Select)(unsafe.Pointer(&pExpr.x))) != 0 {
					return int32(2)
				}
			} else {
				if pExpr.x.pList != nil {
					if sqlite3WalkExprList(pWalker, pExpr.x.pList) != 0 {
						return int32(2)
					}
				}
				if pExpr.flags&uint32(16777216) != uint32(0) {
					if walkWindowList(pWalker, *(**struct_Window)(unsafe.Pointer(&pExpr.y)), 1) != 0 {
						return int32(2)
					}
				}
			}
		}
		break
	}
	return int32(0)
}
func sqlite3WalkExpr(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	return func() int32 {
		if pExpr != nil {
			return walkExpr(pWalker, pExpr)
		} else {
			return 0
		}
	}()
}
func sqlite3WalkExprList(pWalker *struct_Walker, p *struct_ExprList) int32 {
	var i int32
	var pItem *struct_ExprList_item
	if p != nil {
		for func() *struct_ExprList_item {
			i = p.nExpr
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&p.a))
				return *_cgo_addr
			}()
		}(); i > 0; func() *struct_ExprList_item {
			i--
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}() {
			if sqlite3WalkExpr(pWalker, pItem.pExpr) != 0 {
				return int32(2)
			}
		}
	}
	return int32(0)
}
func sqlite3WalkWinDefnDummyCallback(pWalker *struct_Walker, p *struct_Select) {
	func() int {
		_ = pWalker
		return 0
	}()
	func() int {
		_ = p
		return 0
	}()
}
func sqlite3WalkSelectExpr(pWalker *struct_Walker, p *struct_Select) int32 {
	if sqlite3WalkExprList(pWalker, p.pEList) != 0 {
		return int32(2)
	}
	if sqlite3WalkExpr(pWalker, p.pWhere) != 0 {
		return int32(2)
	}
	if sqlite3WalkExprList(pWalker, p.pGroupBy) != 0 {
		return int32(2)
	}
	if sqlite3WalkExpr(pWalker, p.pHaving) != 0 {
		return int32(2)
	}
	if sqlite3WalkExprList(pWalker, p.pOrderBy) != 0 {
		return int32(2)
	}
	if sqlite3WalkExpr(pWalker, p.pLimit) != 0 {
		return int32(2)
	}
	if p.pWinDefn != nil {
		var pParse *struct_Parse
		if uintptr(unsafe.Pointer(pWalker.xSelectCallback2)) == uintptr(unsafe.Pointer(sqlite3WalkWinDefnDummyCallback)) || uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Parse) {
			_cgo_addr := &pParse
			*_cgo_addr = pWalker.pParse
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) && int32(pParse.eParseMode) >= 2 || uintptr(unsafe.Pointer(pWalker.xSelectCallback2)) == uintptr(unsafe.Pointer(sqlite3SelectPopWith)) {
			var rc int32 = walkWindowList(pWalker, p.pWinDefn, 0)
			return rc
		}
	}
	return int32(0)
}
func sqlite3WalkSelectFrom(pWalker *struct_Walker, p *struct_Select) int32 {
	var pSrc *struct_SrcList
	var i int32
	var pItem *struct_SrcItem
	pSrc = p.pSrc
	if pSrc != nil {
		for func() *struct_SrcItem {
			i = pSrc.nSrc
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pSrc.a))
				return *_cgo_addr
			}()
		}(); i > 0; func() *struct_SrcItem {
			i--
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
				return
			}()
		}() {
			if pItem.pSelect != nil && sqlite3WalkSelect(pWalker, pItem.pSelect) != 0 {
				return int32(2)
			}
			if int32(pItem.fg.Xbf_0>>2&1) != 0 && sqlite3WalkExprList(pWalker, *(**struct_ExprList)(unsafe.Pointer(&pItem.u1))) != 0 {
				return int32(2)
			}
		}
	}
	return int32(0)
}
func sqlite3WalkSelect(pWalker *struct_Walker, p *struct_Select) int32 {
	var rc int32
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pWalker.xSelectCallback)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	for {
		rc = pWalker.xSelectCallback(pWalker, p)
		if rc != 0 {
			return rc & 2
		}
		if sqlite3WalkSelectExpr(pWalker, p) != 0 || sqlite3WalkSelectFrom(pWalker, p) != 0 {
			return int32(2)
		}
		if pWalker.xSelectCallback2 != nil {
			pWalker.xSelectCallback2(pWalker, p)
		}
		p = p.pPrior
		if !(uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil))) {
			break
		}
	}
	return int32(0)
}
func sqlite3WalkerDepthIncrease(pWalker *struct_Walker, pSelect *struct_Select) int32 {
	func() int {
		_ = pSelect
		return 0
	}()
	pWalker.walkerDepth++
	return int32(0)
}
func sqlite3WalkerDepthDecrease(pWalker *struct_Walker, pSelect *struct_Select) {
	func() int {
		_ = pSelect
		return 0
	}()
	pWalker.walkerDepth--
}
func sqlite3ExprWalkNoop(NotUsed *struct_Walker, NotUsed2 *struct_Expr) int32 {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	return int32(0)
}
func sqlite3SelectWalkNoop(NotUsed *struct_Walker, NotUsed2 *struct_Select) int32 {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	return int32(0)
}
func incrAggDepth(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 168 {
		pExpr.op2 += uint8(*(*int32)(unsafe.Pointer(&pWalker.u)))
	}
	return int32(0)
}
func incrAggFunctionDepth(pExpr *struct_Expr, N int32) {
	if N > 0 {
		var w struct_Walker
		__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
		w.xExprCallback = incrAggDepth
		*(*int32)(unsafe.Pointer(&w.u)) = N
		sqlite3WalkExpr(&w, pExpr)
	}
}
func resolveAlias(pParse *struct_Parse, pEList *struct_ExprList, iCol int32, pExpr *struct_Expr, nSubquery int32) {
	var pOrig *struct_Expr
	var pDup *struct_Expr
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	pOrig = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(iCol)*28))).pExpr
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	pDup = sqlite3ExprDup(db, pOrig, 0)
	if db.mallocFailed != 0 {
		sqlite3ExprDelete(db, pDup)
		pDup = (*struct_Expr)(nil)
	} else {
		incrAggFunctionDepth(pDup, nSubquery)
		if int32(pExpr.op) == 113 {
			func() int {
				_ = 0
				return 0
			}()
			pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr.u.zToken)
		}
		pExpr.flags |= uint32(134217728)
		sqlite3ExprDelete(db, pExpr)
		__builtin___memcpy_chk(unsafe.Pointer(pExpr), unsafe.Pointer(pDup), 72, __builtin_object_size(unsafe.Pointer(pExpr), 0))
		if !(pExpr.flags&uint32(1024) != uint32(0)) && uintptr(unsafe.Pointer(pExpr.u.zToken)) != uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			pExpr.u.zToken = sqlite3DbStrDup(db, pExpr.u.zToken)
			pExpr.flags |= uint32(65536)
		}
		if pExpr.flags&uint32(16777216) != uint32(0) {
			if uintptr(unsafe.Pointer(*(**struct_Window)(unsafe.Pointer(&pExpr.y)))) != uintptr(unsafe.Pointer(nil)) {
				(*(**struct_Window)(unsafe.Pointer(&pExpr.y))).pOwner = pExpr
			}
		}
		sqlite3DbFree(db, unsafe.Pointer(pDup))
	}
}
func nameInUsingClause(pUsing *struct_IdList, zCol *int8) int32 {
	if pUsing != nil {
		var k int32
		for k = int32(0); k < pUsing.nId; k++ {
			if sqlite3StrICmp((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pUsing.a)) + uintptr(k)*12))).zName, zCol) == 0 {
				return int32(1)
			}
		}
	}
	return int32(0)
}
func sqlite3MatchEName(pItem *struct_ExprList_item, zCol *int8, zTab *int8, zDb *int8) int32 {
	var n int32
	var zSpan *int8
	if int32(pItem.Xbf_0&3) != 2 {
		return int32(0)
	}
	zSpan = pItem.zEName
	for n = int32(0); int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSpan)) + uintptr(n)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSpan)) + uintptr(n)))) != '.'; n++ {
	}
	if zDb != nil && (sqlite3_strnicmp(zSpan, zDb, n) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDb)) + uintptr(n)))) != 0) {
		return int32(0)
	}
	*(*uintptr)(unsafe.Pointer(&zSpan)) += uintptr(n + 1)
	for n = int32(0); int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSpan)) + uintptr(n)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSpan)) + uintptr(n)))) != '.'; n++ {
	}
	if zTab != nil && (sqlite3_strnicmp(zSpan, zTab, n) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zTab)) + uintptr(n)))) != 0) {
		return int32(0)
	}
	*(*uintptr)(unsafe.Pointer(&zSpan)) += uintptr(n + 1)
	if zCol != nil && sqlite3StrICmp(zSpan, zCol) != 0 {
		return int32(0)
	}
	return int32(1)
}
func areDoubleQuotedStringsEnabled(db *struct_sqlite3, pTopNC *struct_NameContext) int32 {
	if db.init.busy != 0 {
		return int32(1)
	}
	if pTopNC.ncFlags&65536 != 0 {
		if sqlite3WritableSchema(db) != 0 && db.flags&uint64(1073741824) != uint64(0) {
			return int32(1)
		}
		return func() int32 {
			if db.flags&uint64(536870912) != uint64(0) {
				return 1
			} else {
				return 0
			}
		}()
	} else {
		return func() int32 {
			if db.flags&uint64(1073741824) != uint64(0) {
				return 1
			} else {
				return 0
			}
		}()
	}
}
func sqlite3ExprColUsed(pExpr *struct_Expr) uint64 {
	var n int32
	var pExTab *struct_Table
	n = int32(pExpr.iColumn)
	func() int {
		_ = 0
		return 0
	}()
	pExTab = pExpr.y.pTab
	func() int {
		_ = 0
		return 0
	}()
	if pExTab.tabFlags&uint32(96) != uint32(0) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pExTab.aCol)) + uintptr(n)*20))).colFlags)&96 != 0 {
		return func() uint64 {
			if int32(pExTab.nCol) >= int32(8*uint(8)) {
				return uint64(18446744073709551615)
			} else {
				return uint64(1)<<int32(pExTab.nCol) - uint64(1)
			}
		}()
	} else {
		if n >= int32(8*uint(8)) {
			n = int32(8*uint(8)) - 1
		}
		return uint64(1) << n
	}
}
func lookupName(pParse *struct_Parse, zDb *int8, zTab *int8, zCol *int8, pNC *struct_NameContext, pExpr *struct_Expr) int32 {
	var i int32
	var j int32
	var cnt int32 = 0
	var cntTab int32 = 0
	var nSubquery int32 = 0
	var db *struct_sqlite3 = pParse.db
	var pItem *struct_SrcItem
	var pMatch *struct_SrcItem = nil
	var pTopNC *struct_NameContext = pNC
	var pSchema *struct_Schema = nil
	var eNewExprOp int32 = 167
	var pTab *struct_Table = nil
	var pCol *struct_Column
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pExpr.iTable = int32(-1)
	if zDb != nil {
		if pNC.ncFlags&(2|4) != 0 {
			zDb = (*int8)(nil)
		} else {
			for i = int32(0); i < db.nDb; i++ {
				func() int {
					_ = 0
					return 0
				}()
				if sqlite3StrICmp((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).zDbSName, zDb) == 0 {
					pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema
					break
				}
			}
			if i == db.nDb && sqlite3StrICmp((*int8)(unsafe.Pointer(&[5]int8{'m', 'a', 'i', 'n', '\x00'})), zDb) == 0 {
				pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema
				zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).zDbSName
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	for {
		var pEList *struct_ExprList
		var pSrcList *struct_SrcList = pNC.pSrcList
		if pSrcList != nil {
			for func() *struct_SrcItem {
				i = int32(0)
				return func() (_cgo_ret *struct_SrcItem) {
					_cgo_addr := &pItem
					*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pSrcList.a))
					return *_cgo_addr
				}()
			}(); i < pSrcList.nSrc; func() *struct_SrcItem {
				i++
				return func() (_cgo_ret *struct_SrcItem) {
					_cgo_addr := &pItem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
					return
				}()
			}() {
				var hCol uint8
				pTab = pItem.pTab
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if pItem.pSelect != nil && pItem.pSelect.selFlags&uint32(2048) != uint32(0) {
					var hit int32 = 0
					pEList = pItem.pSelect.pEList
					for j = int32(0); j < pEList.nExpr; j++ {
						if sqlite3MatchEName(&*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(j)*28)), zCol, zTab, zDb) != 0 {
							cnt++
							cntTab = int32(2)
							pMatch = pItem
							pExpr.iColumn = int16(j)
							hit = int32(1)
						}
					}
					if hit != 0 || uintptr(unsafe.Pointer(zTab)) == uintptr(unsafe.Pointer(nil)) {
						continue
					}
				}
				if zDb != nil {
					if uintptr(unsafe.Pointer(pTab.pSchema)) != uintptr(unsafe.Pointer(pSchema)) {
						continue
					}
					if uintptr(unsafe.Pointer(pSchema)) == uintptr(unsafe.Pointer(nil)) && strcmp(zDb, (*int8)(unsafe.Pointer(&[2]int8{'*', '\x00'}))) != 0 {
						continue
					}
				}
				if zTab != nil {
					var zTabName *int8 = func() *int8 {
						if pItem.zAlias != nil {
							return pItem.zAlias
						} else {
							return pTab.zName
						}
					}()
					func() int {
						_ = 0
						return 0
					}()
					if sqlite3StrICmp(zTabName, zTab) != 0 {
						continue
					}
					func() int {
						_ = 0
						return 0
					}()
					if int32(pParse.eParseMode) >= 2 && pItem.zAlias != nil {
						sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer(&pExpr.y.pTab))
					}
				}
				hCol = sqlite3StrIHash(zCol)
				for func() *struct_Column {
					j = int32(0)
					return func() (_cgo_ret *struct_Column) {
						_cgo_addr := &pCol
						*_cgo_addr = pTab.aCol
						return *_cgo_addr
					}()
				}(); j < int32(pTab.nCol); func() *struct_Column {
					j++
					return func() (_cgo_ret *struct_Column) {
						_cgo_addr := &pCol
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
						return
					}()
				}() {
					if int32(pCol.hName) == int32(hCol) && sqlite3StrICmp(pCol.zCnName, zCol) == 0 {
						if cnt == 1 {
							if int32(pItem.fg.jointype)&4 != 0 {
								continue
							}
							if nameInUsingClause(pItem.pUsing, zCol) != 0 {
								continue
							}
						}
						cnt++
						pMatch = pItem
						pExpr.iColumn = int16(func() int32 {
							if j == int32(pTab.iPKey) {
								return -1
							} else {
								return int32(int16(j))
							}
						}())
						break
					}
				}
				if 0 == cnt && pTab.tabFlags&uint32(512) == uint32(0) {
					cntTab++
					pMatch = pItem
				}
			}
			if pMatch != nil {
				pExpr.iTable = pMatch.iCursor
				func() int {
					_ = 0
					return 0
				}()
				pExpr.y.pTab = pMatch.pTab
				func() int {
					_ = 0
					return 0
				}()
				if int32(pMatch.fg.jointype)&8 != 0 {
					pExpr.flags |= uint32(1048576)
				}
				pSchema = pExpr.y.pTab.pSchema
			}
		}
		if cnt == 0 && uintptr(unsafe.Pointer(zDb)) == uintptr(unsafe.Pointer(nil)) {
			pTab = (*struct_Table)(nil)
			if uintptr(unsafe.Pointer(pParse.pTriggerTab)) != uintptr(unsafe.Pointer(nil)) {
				var op int32 = int32(pParse.eTriggerOp)
				func() int {
					_ = 0
					return 0
				}()
				if pParse.bReturning != 0 {
					if pNC.ncFlags&1024 != 0 && (uintptr(unsafe.Pointer(zTab)) == uintptr(unsafe.Pointer(nil)) || sqlite3StrICmp(zTab, pParse.pTriggerTab.zName) == 0) {
						pExpr.iTable = func() int32 {
							if op != 128 {
								return 1
							} else {
								return 0
							}
						}()
						pTab = pParse.pTriggerTab
					}
				} else if op != 128 && zTab != nil && sqlite3StrICmp((*int8)(unsafe.Pointer(&[4]int8{'n', 'e', 'w', '\x00'})), zTab) == 0 {
					pExpr.iTable = int32(1)
					pTab = pParse.pTriggerTab
				} else if op != 127 && zTab != nil && sqlite3StrICmp((*int8)(unsafe.Pointer(&[4]int8{'o', 'l', 'd', '\x00'})), zTab) == 0 {
					pExpr.iTable = int32(0)
					pTab = pParse.pTriggerTab
				}
			}
			if pNC.ncFlags&512 != 0 && uintptr(unsafe.Pointer(zTab)) != uintptr(unsafe.Pointer(nil)) {
				var pUpsert *struct_Upsert = *(**struct_Upsert)(unsafe.Pointer(&pNC.uNC))
				if pUpsert != nil && sqlite3StrICmp((*int8)(unsafe.Pointer(&[9]int8{'e', 'x', 'c', 'l', 'u', 'd', 'e', 'd', '\x00'})), zTab) == 0 {
					pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pUpsert.pUpsertSrc.a)))) + uintptr(0)*112))).pTab
					pExpr.iTable = int32(2)
				}
			}
			if pTab != nil {
				var iCol int32
				var hCol uint8 = sqlite3StrIHash(zCol)
				pSchema = pTab.pSchema
				cntTab++
				for func() *struct_Column {
					iCol = int32(0)
					return func() (_cgo_ret *struct_Column) {
						_cgo_addr := &pCol
						*_cgo_addr = pTab.aCol
						return *_cgo_addr
					}()
				}(); iCol < int32(pTab.nCol); func() *struct_Column {
					iCol++
					return func() (_cgo_ret *struct_Column) {
						_cgo_addr := &pCol
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
						return
					}()
				}() {
					if int32(pCol.hName) == int32(hCol) && sqlite3StrICmp(pCol.zCnName, zCol) == 0 {
						if iCol == int32(pTab.iPKey) {
							iCol = int32(-1)
						}
						break
					}
				}
				if iCol >= int32(pTab.nCol) && sqlite3IsRowid(zCol) != 0 && pTab.tabFlags&uint32(512) == uint32(0) {
					iCol = int32(-1)
				}
				if iCol < int32(pTab.nCol) {
					cnt++
					pMatch = (*struct_SrcItem)(nil)
					if pExpr.iTable == 2 {
						func() int {
							_ = 0
							return 0
						}()
						if int32(pParse.eParseMode) >= 2 {
							pExpr.iColumn = int16(iCol)
							pExpr.y.pTab = pTab
							eNewExprOp = int32(167)
						} else {
							pExpr.iTable = (*(**struct_Upsert)(unsafe.Pointer(&pNC.uNC))).regData + int32(sqlite3TableColumnToStorage(pTab, int16(iCol)))
							eNewExprOp = int32(176)
						}
					} else {
						func() int {
							_ = 0
							return 0
						}()
						pExpr.y.pTab = pTab
						if pParse.bReturning != 0 {
							eNewExprOp = int32(176)
							pExpr.op2 = uint8(167)
							pExpr.iTable = *(*int32)(unsafe.Pointer(&pNC.uNC)) + (int32(pTab.nCol)+1)*pExpr.iTable + int32(sqlite3TableColumnToStorage(pTab, int16(iCol))) + 1
						} else {
							pExpr.iColumn = int16(iCol)
							eNewExprOp = int32(77)
							if iCol < 0 {
								pExpr.affExpr = int8(68)
							} else if pExpr.iTable == 0 {
								pParse.oldmask |= func() uint32 {
									if iCol >= 32 {
										return 4294967295
									} else {
										return uint32(1) << iCol
									}
								}()
							} else {
								pParse.newmask |= func() uint32 {
									if iCol >= 32 {
										return 4294967295
									} else {
										return uint32(1) << iCol
									}
								}()
							}
						}
					}
				}
			}
		}
		if cnt == 0 && cntTab == 1 && pMatch != nil && pNC.ncFlags&(32|8) == 0 && sqlite3IsRowid(zCol) != 0 && pMatch.pTab.tabFlags&uint32(512) == uint32(0) {
			cnt = int32(1)
			pExpr.iColumn = int16(-1)
			pExpr.affExpr = int8(68)
		}
		if cnt == 0 && pNC.ncFlags&128 != 0 && uintptr(unsafe.Pointer(zTab)) == uintptr(unsafe.Pointer(nil)) {
			pEList = pNC.uNC.pEList
			func() int {
				_ = 0
				return 0
			}()
			for j = int32(0); j < pEList.nExpr; j++ {
				var zAs *int8 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(j)*28))).zEName
				if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(j)*28))).Xbf_0&3) == 0 && sqlite3_stricmp(zAs, zCol) == 0 {
					var pOrig *struct_Expr
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					pOrig = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(j)*28))).pExpr
					if pNC.ncFlags&1 == 0 && pOrig.flags&uint32(16) != uint32(0) {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[31]int8{'m', 'i', 's', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'l', 'i', 'a', 's', 'e', 'd', ' ', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ' ', '%', 's', '\x00'})), zAs)
						return int32(2)
					}
					if pOrig.flags&uint32(32768) != uint32(0) && (pNC.ncFlags&16384 == 0 || uintptr(unsafe.Pointer(pNC)) != uintptr(unsafe.Pointer(pTopNC))) {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[37]int8{'m', 'i', 's', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'l', 'i', 'a', 's', 'e', 'd', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', '%', 's', '\x00'})), zAs)
						return int32(2)
					}
					if sqlite3ExprVectorSize(pOrig) != 1 {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'r', 'o', 'w', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'i', 's', 'u', 's', 'e', 'd', '\x00'})))
						return int32(2)
					}
					resolveAlias(pParse, pEList, j, pExpr, nSubquery)
					cnt = int32(1)
					pMatch = (*struct_SrcItem)(nil)
					func() int {
						_ = 0
						return 0
					}()
					if int32(pParse.eParseMode) >= 2 {
						sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer(pExpr))
					}
					goto lookupname_end
				}
			}
		}
		if cnt != 0 {
			break
		}
		pNC = pNC.pNext
		nSubquery++
		if !(pNC != nil) {
			break
		}
	}
	if cnt == 0 && uintptr(unsafe.Pointer(zTab)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		if pExpr.flags&uint32(64) != uint32(0) && areDoubleQuotedStringsEnabled(db, pTopNC) != 0 {
			sqlite3_log(28, (*int8)(unsafe.Pointer(&[35]int8{'d', 'o', 'u', 'b', 'l', 'e', '-', 'q', 'u', 'o', 't', 'e', 'd', ' ', 's', 't', 'r', 'i', 'n', 'g', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l', ':', ' ', '"', '%', 'w', '"', '\x00'})), zCol)
			pExpr.op = uint8(117)
			__builtin___memset_chk(unsafe.Pointer(&pExpr.y), 0, 8, __builtin_object_size(unsafe.Pointer(&pExpr.y), 0))
			return int32(1)
		}
		if sqlite3ExprIdToTrueFalse(pExpr) != 0 {
			return int32(1)
		}
	}
	if cnt != 1 {
		var zErr *int8
		zErr = func() *int8 {
			if cnt == 0 {
				return (*int8)(unsafe.Pointer(&[15]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[22]int8{'a', 'm', 'b', 'i', 'g', 'u', 'o', 'u', 's', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'n', 'a', 'm', 'e', '\x00'}))
			}
		}()
		if zDb != nil {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[13]int8{'%', 's', ':', ' ', '%', 's', '.', '%', 's', '.', '%', 's', '\x00'})), zErr, zDb, zTab, zCol)
		} else if zTab != nil {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[10]int8{'%', 's', ':', ' ', '%', 's', '.', '%', 's', '\x00'})), zErr, zTab, zCol)
		} else {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[7]int8{'%', 's', ':', ' ', '%', 's', '\x00'})), zErr, zCol)
		}
		sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr)
		pParse.checkSchema = uint8(1)
		pTopNC.nNcErr++
	}
	if int32(pExpr.iColumn) >= 0 && uintptr(unsafe.Pointer(pMatch)) != uintptr(unsafe.Pointer(nil)) {
		pMatch.colUsed |= sqlite3ExprColUsed(pExpr)
	}
	if !(pExpr.flags&uint32(16384|8388608) != uint32(0)) {
		sqlite3ExprDelete(db, pExpr.pLeft)
		pExpr.pLeft = (*struct_Expr)(nil)
		sqlite3ExprDelete(db, pExpr.pRight)
		pExpr.pRight = (*struct_Expr)(nil)
	}
	pExpr.op = uint8(eNewExprOp)
	pExpr.flags |= uint32(8388608)
lookupname_end:
	if cnt == 1 {
		func() int {
			_ = 0
			return 0
		}()
		if pParse.db.xAuth != nil && (int32(pExpr.op) == 167 || int32(pExpr.op) == 77) {
			sqlite3AuthRead(pParse, pExpr, pSchema, pNC.pSrcList)
		}
		for {
			func() int {
				_ = 0
				return 0
			}()
			pTopNC.nRef++
			if uintptr(unsafe.Pointer(pTopNC)) == uintptr(unsafe.Pointer(pNC)) {
				break
			}
			pTopNC = pTopNC.pNext
		}
		return int32(1)
	} else {
		return int32(2)
	}
}
func sqlite3CreateColumnExpr(db *struct_sqlite3, pSrc *struct_SrcList, iSrc int32, iCol int32) *struct_Expr {
	var p *struct_Expr = sqlite3ExprAlloc(db, 167, nil, 0)
	if p != nil {
		var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(iSrc)*112))
		var pTab *struct_Table
		func() int {
			_ = 0
			return 0
		}()
		pTab = func() (_cgo_ret *struct_Table) {
			_cgo_addr := &p.y.pTab
			*_cgo_addr = pItem.pTab
			return *_cgo_addr
		}()
		p.iTable = pItem.iCursor
		if int32(p.y.pTab.iPKey) == iCol {
			p.iColumn = int16(-1)
		} else {
			p.iColumn = int16(iCol)
			if pTab.tabFlags&uint32(96) != uint32(0) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).colFlags)&96 != 0 {
				pItem.colUsed = func() uint64 {
					if int32(pTab.nCol) >= 64 {
						return uint64(18446744073709551615)
					} else {
						return uint64(1)<<int32(pTab.nCol) - uint64(1)
					}
				}()
			} else {
				pItem.colUsed |= uint64(1) << func() int32 {
					if iCol >= int32(8*uint(8)) {
						return int32(8*uint(8)) - 1
					} else {
						return iCol
					}
				}()
			}
		}
	}
	return p
}
func notValidImpl(pParse *struct_Parse, pNC *struct_NameContext, zMsg *int8, pExpr *struct_Expr, pError *struct_Expr) {
	var zIn *int8 = (*int8)(unsafe.Pointer(&[28]int8{'p', 'a', 'r', 't', 'i', 'a', 'l', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'c', 'l', 'a', 'u', 's', 'e', 's', '\x00'}))
	if pNC.ncFlags&32 != 0 {
		zIn = (*int8)(unsafe.Pointer(&[18]int8{'i', 'n', 'd', 'e', 'x', ' ', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 's', '\x00'}))
	} else if pNC.ncFlags&4 != 0 {
		zIn = (*int8)(unsafe.Pointer(&[18]int8{'C', 'H', 'E', 'C', 'K', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', 's', '\x00'}))
	} else if pNC.ncFlags&8 != 0 {
		zIn = (*int8)(unsafe.Pointer(&[18]int8{'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', '\x00'}))
	}
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[20]int8{'%', 's', ' ', 'p', 'r', 'o', 'h', 'i', 'b', 'i', 't', 'e', 'd', ' ', 'i', 'n', ' ', '%', 's', '\x00'})), zMsg, zIn)
	if pExpr != nil {
		pExpr.op = uint8(121)
	}
	sqlite3RecordErrorOffsetOfExpr(pParse.db, pError)
}
func exprProbability(p *struct_Expr) int32 {
	var r float64 = -1
	if int32(p.op) != 153 {
		return int32(-1)
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3AtoF(p.u.zToken, &r, sqlite3Strlen30(p.u.zToken), uint8(1))
	func() int {
		_ = 0
		return 0
	}()
	if r > 1 {
		return int32(-1)
	}
	return int32(r * 134217728)
}
func resolveExprStep(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var pNC *struct_NameContext
	var pParse *struct_Parse
	pNC = pWalker.u.pNC
	func() int {
		_ = 0
		return 0
	}()
	pParse = pNC.pParse
	func() int {
		_ = 0
		return 0
	}()
	switch int32(pExpr.op) {
	case 75:
		{
			var pSrcList *struct_SrcList = pNC.pSrcList
			var pItem *struct_SrcItem
			func() int {
				_ = 0
				return 0
			}()
			pItem = (*struct_SrcItem)(unsafe.Pointer(&pSrcList.a))
			pExpr.op = uint8(167)
			func() int {
				_ = 0
				return 0
			}()
			pExpr.y.pTab = pItem.pTab
			pExpr.iTable = pItem.iCursor
			pExpr.iColumn--
			pExpr.affExpr = int8(68)
			break
		}
	case 51:
		fallthrough
	case 50:
		{
			var anRef [8]int32
			var p *struct_NameContext
			var i int32
			for func() *struct_NameContext {
				i = int32(0)
				return func() (_cgo_ret *struct_NameContext) {
					_cgo_addr := &p
					*_cgo_addr = pNC
					return *_cgo_addr
				}()
			}(); p != nil && i < int32(32/4); func() int32 {
				p = p.pNext
				return func() (_cgo_ret int32) {
					_cgo_addr := &i
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
			}() {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&anRef)))) + uintptr(i)*4)) = p.nRef
			}
			sqlite3WalkExpr(pWalker, pExpr.pLeft)
			if 0 == sqlite3ExprCanBeNull(pExpr.pLeft) && !(int32(pParse.eParseMode) >= 2) {
				func() int {
					_ = 0
					return 0
				}()
				if int32(pExpr.op) == 51 {
					pExpr.u.zToken = (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'u', 'e', '\x00'}))
					pExpr.flags |= uint32(268435456)
				} else {
					pExpr.u.zToken = (*int8)(unsafe.Pointer(&[6]int8{'f', 'a', 'l', 's', 'e', '\x00'}))
					pExpr.flags |= uint32(536870912)
				}
				pExpr.op = uint8(170)
				for func() *struct_NameContext {
					i = int32(0)
					return func() (_cgo_ret *struct_NameContext) {
						_cgo_addr := &p
						*_cgo_addr = pNC
						return *_cgo_addr
					}()
				}(); p != nil && i < int32(32/4); func() int32 {
					p = p.pNext
					return func() (_cgo_ret int32) {
						_cgo_addr := &i
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
				}() {
					p.nRef = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&anRef)))) + uintptr(i)*4))
				}
				sqlite3ExprDelete(pParse.db, pExpr.pLeft)
				pExpr.pLeft = (*struct_Expr)(nil)
			}
			return int32(1)
		}
	case 59:
		fallthrough
	case 141:
		{
			var zColumn *int8
			var zTable *int8
			var zDb *int8
			var pRight *struct_Expr
			if int32(pExpr.op) == 59 {
				zDb = (*int8)(nil)
				zTable = (*int8)(nil)
				func() int {
					_ = 0
					return 0
				}()
				zColumn = pExpr.u.zToken
			} else {
				var pLeft *struct_Expr = pExpr.pLeft
				func() int {
					_ = 0
					return 0
				}()
				if pNC.ncFlags&(32|8) != 0 {
					notValidImpl(pParse, pNC, (*int8)(unsafe.Pointer(&[17]int8{'t', 'h', 'e', ' ', '"', '.', '"', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'o', 'r', '\x00'})), nil, pExpr)
				}
				pRight = pExpr.pRight
				if int32(pRight.op) == 59 {
					zDb = (*int8)(nil)
				} else {
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					zDb = pLeft.u.zToken
					pLeft = pRight.pLeft
					pRight = pRight.pRight
				}
				func() int {
					_ = 0
					return 0
				}()
				zTable = pLeft.u.zToken
				zColumn = pRight.u.zToken
				func() int {
					_ = 0
					return 0
				}()
				if int32(pParse.eParseMode) >= 2 {
					sqlite3RenameTokenRemap(pParse, unsafe.Pointer(pExpr), unsafe.Pointer(pRight))
					sqlite3RenameTokenRemap(pParse, unsafe.Pointer(&pExpr.y.pTab), unsafe.Pointer(pLeft))
				}
			}
			return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr)
		}
	case 172:
		{
			var pList *struct_ExprList = pExpr.x.pList
			var n int32 = func() int32 {
				if pList != nil {
					return pList.nExpr
				} else {
					return 0
				}
			}()
			var no_such_func int32 = 0
			var wrong_num_args int32 = 0
			var is_agg int32 = 0
			var zId *int8
			var pDef *struct_FuncDef
			var enc uint8 = pParse.db.enc
			var savedAllowFlags int32 = pNC.ncFlags & (1 | 16384)
			var pWin *struct_Window = func() *struct_Window {
				if pExpr.flags&uint32(16777216) != uint32(0) && int32((*(**struct_Window)(unsafe.Pointer(&pExpr.y))).eFrmType) != 166 {
					return *(**struct_Window)(unsafe.Pointer(&pExpr.y))
				} else {
					return nil
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			zId = pExpr.u.zToken
			pDef = sqlite3FindFunction(pParse.db, zId, n, enc, uint8(0))
			if uintptr(unsafe.Pointer(pDef)) == uintptr(unsafe.Pointer(nil)) {
				pDef = sqlite3FindFunction(pParse.db, zId, -2, enc, uint8(0))
				if uintptr(unsafe.Pointer(pDef)) == uintptr(unsafe.Pointer(nil)) {
					no_such_func = int32(1)
				} else {
					wrong_num_args = int32(1)
				}
			} else {
				is_agg = func() int32 {
					if uintptr(unsafe.Pointer(pDef.xFinalize)) != uintptr(unsafe.Pointer(nil)) {
						return 1
					} else {
						return 0
					}
				}()
				if pDef.funcFlags&uint32(1024) != 0 {
					pExpr.flags |= uint32(262144)
					if n == 2 {
						pExpr.iTable = exprProbability((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(1)*28))).pExpr)
						if pExpr.iTable < 0 {
							sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[64]int8{'s', 'e', 'c', 'o', 'n', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 't', 'o', ' ', '%', '#', 'T', '(', ')', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', '0', '.', '0', ' ', 'a', 'n', 'd', ' ', '1', '.', '0', '\x00'})), pExpr)
							pNC.nNcErr++
						}
					} else {
						pExpr.iTable = func() int32 {
							if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDef.zName)) + uintptr(0)))) == 'u' {
								return 8388608
							} else {
								return 125829120
							}
						}()
					}
				}
				{
					var auth int32 = sqlite3AuthCheck(pParse, 31, nil, pDef.zName, nil)
					if auth != 0 {
						if auth == 1 {
							sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[36]int8{'n', 'o', 't', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'e', 'd', ' ', 't', 'o', ' ', 'u', 's', 'e', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ':', ' ', '%', '#', 'T', '\x00'})), pExpr)
							pNC.nNcErr++
						}
						pExpr.op = uint8(121)
						return int32(1)
					}
				}
				if pDef.funcFlags&uint32(2048|8192) != 0 {
					pExpr.flags |= uint32(524288)
				}
				if pDef.funcFlags&uint32(2048) == uint32(0) {
					func() int {
						_ = 0
						return 0
					}()
					if pNC.ncFlags&(32|2|8) != 0 {
						notValidImpl(pParse, pNC, (*int8)(unsafe.Pointer(&[28]int8{'n', 'o', 'n', '-', 'd', 'e', 't', 'e', 'r', 'm', 'i', 'n', 'i', 's', 't', 'i', 'c', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', 's', '\x00'})), nil, pExpr)
					}
				} else {
					func() int {
						_ = 0
						return 0
					}()
					pExpr.op2 = uint8(pNC.ncFlags & 46)
					if pNC.ncFlags&262144 != 0 {
						pExpr.flags |= uint32(1073741824)
					}
				}
				if pDef.funcFlags&uint32(262144) != uint32(0) && int32(pParse.nested) == 0 && pParse.db.mDbFlags&uint32(32) == uint32(0) {
					no_such_func = int32(1)
					pDef = (*struct_FuncDef)(nil)
				} else if pDef.funcFlags&uint32(524288|2097152) != uint32(0) && !(int32(pParse.eParseMode) >= 2) {
					sqlite3ExprFunctionUsable(pParse, pExpr, pDef)
				}
			}
			if 0 == func() int32 {
				if int32(pParse.eParseMode) >= 2 {
					return 1
				} else {
					return 0
				}
			}() {
				func() int {
					_ = 0
					return 0
				}()
				if pDef != nil && uintptr(unsafe.Pointer(pDef.xValue)) == uintptr(unsafe.Pointer(nil)) && pWin != nil {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[43]int8{'%', '#', 'T', '(', ')', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'd', ' ', 'a', 's', ' ', 'a', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', '\x00'})), pExpr)
					pNC.nNcErr++
				} else if is_agg != 0 && pNC.ncFlags&1 == 0 || is_agg != 0 && pDef.funcFlags&uint32(65536) != 0 && !(pWin != nil) || is_agg != 0 && pWin != nil && pNC.ncFlags&16384 == 0 {
					var zType *int8
					if pDef.funcFlags&uint32(65536) != 0 || pWin != nil {
						zType = (*int8)(unsafe.Pointer(&[7]int8{'w', 'i', 'n', 'd', 'o', 'w', '\x00'}))
					} else {
						zType = (*int8)(unsafe.Pointer(&[10]int8{'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', '\x00'}))
					}
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'m', 'i', 's', 'u', 's', 'e', ' ', 'o', 'f', ' ', '%', 's', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', '%', '#', 'T', '(', ')', '\x00'})), zType, pExpr)
					pNC.nNcErr++
					is_agg = int32(0)
				} else if no_such_func != 0 && int32(pParse.db.init.busy) == 0 {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[22]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ':', ' ', '%', '#', 'T', '\x00'})), pExpr)
					pNC.nNcErr++
				} else if wrong_num_args != 0 {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[44]int8{'w', 'r', 'o', 'n', 'g', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ', 't', 'o', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', '%', '#', 'T', '(', ')', '\x00'})), pExpr)
					pNC.nNcErr++
				} else if is_agg == 0 && pExpr.flags&uint32(16777216) != uint32(0) {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[48]int8{'F', 'I', 'L', 'T', 'E', 'R', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'o', 'n', '-', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ' ', '%', '#', 'T', '(', ')', '\x00'})), pExpr)
					pNC.nNcErr++
				}
				if is_agg != 0 {
					pNC.ncFlags &= ^(16384 | func() int32 {
						if !(pWin != nil) {
							return 1
						} else {
							return 0
						}
					}())
				}
			} else if pExpr.flags&uint32(16777216) != uint32(0) {
				is_agg = int32(1)
			}
			sqlite3WalkExprList(pWalker, pList)
			if is_agg != 0 {
				if pWin != nil {
					var pSel *struct_Select = pNC.pWinSelect
					func() int {
						_ = 0
						return 0
					}()
					if func() int32 {
						if int32(pParse.eParseMode) >= 2 {
							return 1
						} else {
							return 0
						}
					}() == 0 {
						sqlite3WindowUpdate(pParse, func() *struct_Window {
							if pSel != nil {
								return pSel.pWinDefn
							} else {
								return nil
							}
						}(), pWin, pDef)
						if pParse.db.mallocFailed != 0 {
							break
						}
					}
					sqlite3WalkExprList(pWalker, pWin.pPartition)
					sqlite3WalkExprList(pWalker, pWin.pOrderBy)
					sqlite3WalkExpr(pWalker, pWin.pFilter)
					sqlite3WindowLink(pSel, pWin)
					pNC.ncFlags |= int32(32768)
				} else {
					var pNC2 *struct_NameContext
					pExpr.op = uint8(168)
					pExpr.op2 = uint8(0)
					if pExpr.flags&uint32(16777216) != uint32(0) {
						sqlite3WalkExpr(pWalker, (*(**struct_Window)(unsafe.Pointer(&pExpr.y))).pFilter)
					}
					pNC2 = pNC
					for pNC2 != nil && sqlite3ReferencesSrcList(pParse, pExpr, pNC2.pSrcList) == 0 {
						pExpr.op2++
						pNC2 = pNC2.pNext
					}
					func() int {
						_ = 0
						return 0
					}()
					if pNC2 != nil && pDef != nil {
						func() int {
							_ = 0
							return 0
						}()
						func() int {
							_ = 0
							return 0
						}()
						pNC2.ncFlags |= int32(uint32(16) | (pDef.funcFlags^uint32(134217728))&uint32(4096|134217728))
					}
				}
				pNC.ncFlags |= savedAllowFlags
			}
			return int32(1)
		}
	case 138:
		fallthrough
	case 20:
	case 49:
		{
			if pExpr.flags&uint32(2048) != uint32(0) {
				var nRef int32 = pNC.nRef
				if pNC.ncFlags&46 != 0 {
					notValidImpl(pParse, pNC, (*int8)(unsafe.Pointer(&[11]int8{'s', 'u', 'b', 'q', 'u', 'e', 'r', 'i', 'e', 's', '\x00'})), pExpr, pExpr)
				} else {
					sqlite3WalkSelect(pWalker, *(**struct_Select)(unsafe.Pointer(&pExpr.x)))
				}
				func() int {
					_ = 0
					return 0
				}()
				if nRef != pNC.nRef {
					pExpr.flags |= uint32(32)
					pNC.ncFlags |= int32(64)
				}
			}
			break
		}
	case 156:
		{
			func() int {
				_ = 0
				return 0
			}()
			if pNC.ncFlags&(4|2|32|8) != 0 {
				notValidImpl(pParse, pNC, (*int8)(unsafe.Pointer(&[11]int8{'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', '\x00'})), pExpr, pExpr)
			}
			break
		}
	case 45:
		fallthrough
	case 171:
		{
			var pRight *struct_Expr = sqlite3ExprSkipCollateAndLikely(pExpr.pRight)
			func() int {
				_ = 0
				return 0
			}()
			if pRight != nil && (int32(pRight.op) == 59 || int32(pRight.op) == 170) {
				var rc int32 = resolveExprStep(pWalker, pRight)
				if rc == 2 {
					return int32(2)
				}
				if int32(pRight.op) == 170 {
					pExpr.op2 = pExpr.op
					pExpr.op = uint8(175)
					return int32(0)
				}
			}
		}
	case 48:
		fallthrough
	case 53:
		fallthrough
	case 52:
		fallthrough
	case 56:
		fallthrough
	case 55:
		fallthrough
	case 54:
		fallthrough
	case 57:
		{
			var nLeft int32
			var nRight int32
			if pParse.db.mallocFailed != 0 {
				break
			}
			func() int {
				_ = 0
				return 0
			}()
			nLeft = sqlite3ExprVectorSize(pExpr.pLeft)
			if int32(pExpr.op) == 48 {
				func() int {
					_ = 0
					return 0
				}()
				nRight = sqlite3ExprVectorSize((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(0)*28))).pExpr)
				if nRight == nLeft {
					nRight = sqlite3ExprVectorSize((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(1)*28))).pExpr)
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				nRight = sqlite3ExprVectorSize(pExpr.pRight)
			}
			if nLeft != nRight {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'r', 'o', 'w', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'i', 's', 'u', 's', 'e', 'd', '\x00'})))
				sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr)
			}
			break
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if pParse.nErr != 0 {
			return 2
		} else {
			return 0
		}
	}()
}
func resolveAsName(pParse *struct_Parse, pEList *struct_ExprList, pE *struct_Expr) int32 {
	var i int32
	func() int {
		_ = pParse
		return 0
	}()
	if int32(pE.op) == 59 {
		var zCol *int8
		func() int {
			_ = 0
			return 0
		}()
		zCol = pE.u.zToken
		for i = int32(0); i < pEList.nExpr; i++ {
			if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).Xbf_0&3) == 0 && sqlite3_stricmp((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName, zCol) == 0 {
				return i + 1
			}
		}
	}
	return int32(0)
}
func resolveOrderByTermToExprList(pParse *struct_Parse, pSelect *struct_Select, pE *struct_Expr) int32 {
	var i int32
	var pEList *struct_ExprList
	var nc struct_NameContext
	var db *struct_sqlite3
	var rc int32
	var savedSuppErr uint8
	func() int {
		_ = 0
		return 0
	}()
	pEList = pSelect.pEList
	__builtin___memset_chk(unsafe.Pointer(&nc), 0, 56, __builtin_object_size(unsafe.Pointer(&nc), 0))
	nc.pParse = pParse
	nc.pSrcList = pSelect.pSrc
	nc.uNC.pEList = pEList
	nc.ncFlags = int32(1 | 128 | 524288)
	nc.nNcErr = int32(0)
	db = pParse.db
	savedSuppErr = db.suppressErr
	db.suppressErr = uint8(1)
	rc = sqlite3ResolveExprNames(&nc, pE)
	db.suppressErr = savedSuppErr
	if rc != 0 {
		return int32(0)
	}
	for i = int32(0); i < pEList.nExpr; i++ {
		if sqlite3ExprCompare(nil, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr, pE, -1) < 2 {
			return i + 1
		}
	}
	return int32(0)
}
func resolveOutOfRangeError(pParse *struct_Parse, zType *int8, i int32, mx int32, pError *struct_Expr) {
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[56]int8{'%', 'r', ' ', '%', 's', ' ', 'B', 'Y', ' ', 't', 'e', 'r', 'm', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'r', 'a', 'n', 'g', 'e', ' ', '-', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'b', 'e', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', '1', ' ', 'a', 'n', 'd', ' ', '%', 'd', '\x00'})), i, zType, mx)
	sqlite3RecordErrorOffsetOfExpr(pParse.db, pError)
}
func resolveCompoundOrderBy(pParse *struct_Parse, pSelect *struct_Select) int32 {
	var i int32
	var pOrderBy *struct_ExprList
	var pEList *struct_ExprList
	var db *struct_sqlite3
	var moreToDo int32 = 1
	pOrderBy = pSelect.pOrderBy
	if uintptr(unsafe.Pointer(pOrderBy)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	db = pParse.db
	if pOrderBy.nExpr > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(2)*4)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 't', 'e', 'r', 'm', 's', ' ', 'i', 'n', ' ', 'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', ' ', 'c', 'l', 'a', 'u', 's', 'e', '\x00'})))
		return int32(1)
	}
	for i = int32(0); i < pOrderBy.nExpr; i++ {
		{
			_autoGo_34 := &(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).Xbf_0
			*_autoGo_34 = *_autoGo_34&^4 | uint32(0)&1<<2
		}
	}
	pSelect.pNext = (*struct_Select)(nil)
	for pSelect.pPrior != nil {
		pSelect.pPrior.pNext = pSelect
		pSelect = pSelect.pPrior
	}
	for pSelect != nil && moreToDo != 0 {
		var pItem *struct_ExprList_item
		moreToDo = int32(0)
		pEList = pSelect.pEList
		func() int {
			_ = 0
			return 0
		}()
		for func() *struct_ExprList_item {
			i = int32(0)
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a))
				return *_cgo_addr
			}()
		}(); i < pOrderBy.nExpr; func() *struct_ExprList_item {
			i++
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}() {
			var iCol int32 = -1
			var pE *struct_Expr
			var pDup *struct_Expr
			if pItem.Xbf_0>>2&1 != 0 {
				continue
			}
			pE = sqlite3ExprSkipCollateAndLikely(pItem.pExpr)
			if uintptr(unsafe.Pointer(pE)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			if sqlite3ExprIsInteger(pE, &iCol) != 0 {
				if iCol <= 0 || iCol > pEList.nExpr {
					resolveOutOfRangeError(pParse, (*int8)(unsafe.Pointer(&[6]int8{'O', 'R', 'D', 'E', 'R', '\x00'})), i+1, pEList.nExpr, pE)
					return int32(1)
				}
			} else {
				iCol = resolveAsName(pParse, pEList, pE)
				if iCol == 0 {
					pDup = sqlite3ExprDup(db, pE, 0)
					if !(db.mallocFailed != 0) {
						func() int {
							_ = 0
							return 0
						}()
						iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup)
						if int32(pParse.eParseMode) >= 2 && iCol > 0 {
							resolveOrderByTermToExprList(pParse, pSelect, pE)
						}
					}
					sqlite3ExprDelete(db, pDup)
				}
			}
			if iCol > 0 {
				if !(int32(pParse.eParseMode) >= 2) {
					var pNew *struct_Expr = sqlite3Expr(db, 155, nil)
					if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
						return int32(1)
					}
					pNew.flags |= uint32(1024)
					*(*int32)(unsafe.Pointer(&pNew.u)) = iCol
					if uintptr(unsafe.Pointer(pItem.pExpr)) == uintptr(unsafe.Pointer(pE)) {
						pItem.pExpr = pNew
					} else {
						var pParent *struct_Expr = pItem.pExpr
						func() int {
							_ = 0
							return 0
						}()
						for int32(pParent.pLeft.op) == 113 {
							pParent = pParent.pLeft
						}
						func() int {
							_ = 0
							return 0
						}()
						pParent.pLeft = pNew
					}
					sqlite3ExprDelete(db, pE)
					pItem.u.x.iOrderByCol = uint16(iCol)
				}
				{
					_autoGo_35 := &pItem.Xbf_0
					*_autoGo_35 = *_autoGo_35&^4 | uint32(1)&1<<2
				}
			} else {
				moreToDo = int32(1)
			}
		}
		pSelect = pSelect.pNext
	}
	for i = int32(0); i < pOrderBy.nExpr; i++ {
		if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).Xbf_0>>2&1) == 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[61]int8{'%', 'r', ' ', 'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', ' ', 't', 'e', 'r', 'm', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h', ' ', 'a', 'n', 'y', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'r', 'e', 's', 'u', 'l', 't', ' ', 's', 'e', 't', '\x00'})), i+1)
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3ResolveOrderGroupBy(pParse *struct_Parse, pSelect *struct_Select, pOrderBy *struct_ExprList, zType *int8) int32 {
	var i int32
	var db *struct_sqlite3 = pParse.db
	var pEList *struct_ExprList
	var pItem *struct_ExprList_item
	if uintptr(unsafe.Pointer(pOrderBy)) == uintptr(unsafe.Pointer(nil)) || int32(pParse.db.mallocFailed) != 0 || int32(pParse.eParseMode) >= 2 {
		return int32(0)
	}
	if pOrderBy.nExpr > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(2)*4)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[31]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 't', 'e', 'r', 'm', 's', ' ', 'i', 'n', ' ', '%', 's', ' ', 'B', 'Y', ' ', 'c', 'l', 'a', 'u', 's', 'e', '\x00'})), zType)
		return int32(1)
	}
	pEList = pSelect.pEList
	func() int {
		_ = 0
		return 0
	}()
	for func() *struct_ExprList_item {
		i = int32(0)
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pItem
			*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a))
			return *_cgo_addr
		}()
	}(); i < pOrderBy.nExpr; func() *struct_ExprList_item {
		i++
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		if pItem.u.x.iOrderByCol != 0 {
			if int32(pItem.u.x.iOrderByCol) > pEList.nExpr {
				resolveOutOfRangeError(pParse, zType, i+1, pEList.nExpr, nil)
				return int32(1)
			}
			resolveAlias(pParse, pEList, int32(pItem.u.x.iOrderByCol)-1, pItem.pExpr, 0)
		}
	}
	return int32(0)
}
func resolveRemoveWindowsCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	func() int {
		_ = pWalker
		return 0
	}()
	if pExpr.flags&uint32(16777216) != uint32(0) {
		var pWin *struct_Window = *(**struct_Window)(unsafe.Pointer(&pExpr.y))
		sqlite3WindowUnlinkFromSelect(pWin)
	}
	return int32(0)
}
func windowRemoveExprFromSelect(pSelect *struct_Select, pExpr *struct_Expr) {
	if pSelect.pWin != nil {
		var sWalker struct_Walker
		__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
		sWalker.xExprCallback = resolveRemoveWindowsCb
		*(**struct_Select)(unsafe.Pointer(&sWalker.u)) = pSelect
		sqlite3WalkExpr(&sWalker, pExpr)
	}
}
func resolveOrderGroupBy(pNC *struct_NameContext, pSelect *struct_Select, pOrderBy *struct_ExprList, zType *int8) int32 {
	var i int32
	var j int32
	var iCol int32
	var pItem *struct_ExprList_item
	var pParse *struct_Parse
	var nResult int32
	func() int {
		_ = 0
		return 0
	}()
	nResult = pSelect.pEList.nExpr
	pParse = pNC.pParse
	for func() *struct_ExprList_item {
		i = int32(0)
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pItem
			*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a))
			return *_cgo_addr
		}()
	}(); i < pOrderBy.nExpr; func() *struct_ExprList_item {
		i++
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		var pE *struct_Expr = pItem.pExpr
		var pE2 *struct_Expr = sqlite3ExprSkipCollateAndLikely(pE)
		if uintptr(unsafe.Pointer(pE2)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(0)))) != 'G' {
			iCol = resolveAsName(pParse, pSelect.pEList, pE2)
			if iCol > 0 {
				pItem.u.x.iOrderByCol = uint16(iCol)
				continue
			}
		}
		if sqlite3ExprIsInteger(pE2, &iCol) != 0 {
			if iCol < 1 || iCol > 65535 {
				resolveOutOfRangeError(pParse, zType, i+1, nResult, pE2)
				return int32(1)
			}
			pItem.u.x.iOrderByCol = uint16(iCol)
			continue
		}
		pItem.u.x.iOrderByCol = uint16(0)
		if sqlite3ResolveExprNames(pNC, pE) != 0 {
			return int32(1)
		}
		for j = int32(0); j < pSelect.pEList.nExpr; j++ {
			if sqlite3ExprCompare(nil, pE, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSelect.pEList.a)))) + uintptr(j)*28))).pExpr, -1) == 0 {
				windowRemoveExprFromSelect(pSelect, pE)
				pItem.u.x.iOrderByCol = uint16(j + 1)
			}
		}
	}
	return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType)
}
func resolveSelectStep(pWalker *struct_Walker, p *struct_Select) int32 {
	var pOuterNC *struct_NameContext
	var sNC struct_NameContext
	var isCompound int32
	var nCompound int32
	var pParse *struct_Parse
	var i int32
	var pGroupBy *struct_ExprList
	var pLeftmost *struct_Select
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	if p.selFlags&uint32(4) != 0 {
		return int32(1)
	}
	pOuterNC = pWalker.u.pNC
	pParse = pWalker.pParse
	db = pParse.db
	if p.selFlags&uint32(64) == uint32(0) {
		sqlite3SelectPrep(pParse, p, pOuterNC)
		return func() int32 {
			if pParse.nErr != 0 {
				return 2
			} else {
				return 1
			}
		}()
	}
	isCompound = func() int32 {
		if uintptr(unsafe.Pointer(p.pPrior)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	nCompound = int32(0)
	pLeftmost = p
	for p != nil {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		p.selFlags |= uint32(4)
		__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
		sNC.pParse = pParse
		sNC.pWinSelect = p
		if sqlite3ResolveExprNames(&sNC, p.pLimit) != 0 {
			return int32(2)
		}
		if p.selFlags&uint32(65536) != 0 {
			var pSub *struct_Select = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pSelect
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pSub.pOrderBy = p.pOrderBy
			p.pOrderBy = (*struct_ExprList)(nil)
		}
		for i = int32(0); i < p.pSrc.nSrc; i++ {
			var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(i)*112))
			if pItem.pSelect != nil && pItem.pSelect.selFlags&uint32(4) == uint32(0) {
				var nRef int32 = func() int32 {
					if pOuterNC != nil {
						return pOuterNC.nRef
					} else {
						return 0
					}
				}()
				var zSavedContext *int8 = pParse.zAuthContext
				if pItem.zName != nil {
					pParse.zAuthContext = pItem.zName
				}
				sqlite3ResolveSelectNames(pParse, pItem.pSelect, pOuterNC)
				pParse.zAuthContext = zSavedContext
				if pParse.nErr != 0 {
					return int32(2)
				}
				func() int {
					_ = 0
					return 0
				}()
				if pOuterNC != nil {
					func() int {
						_ = 0
						return 0
					}()
					{
						_autoGo_36 := &pItem.fg.Xbf_0
						*_autoGo_36 = *_autoGo_36&^8 | func() uint32 {
							if pOuterNC.nRef > nRef {
								return 1
							} else {
								return 0
							}
						}()&1<<3
					}
				}
			}
		}
		sNC.ncFlags = int32(1 | 16384)
		sNC.pSrcList = p.pSrc
		sNC.pNext = pOuterNC
		if sqlite3ResolveExprListNames(&sNC, p.pEList) != 0 {
			return int32(2)
		}
		sNC.ncFlags &= int32(^16384)
		func() int {
			_ = 0
			return 0
		}()
		pGroupBy = p.pGroupBy
		if pGroupBy != nil || sNC.ncFlags&16 != 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			p.selFlags |= uint32(8 | sNC.ncFlags&(4096|134217728))
		} else {
			sNC.ncFlags &= int32(^1)
		}
		func() int {
			_ = 0
			return 0
		}()
		sNC.uNC.pEList = p.pEList
		sNC.ncFlags |= int32(128)
		if p.pHaving != nil {
			if !(pGroupBy != nil) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[44]int8{'a', ' ', 'G', 'R', 'O', 'U', 'P', ' ', 'B', 'Y', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'i', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'b', 'e', 'f', 'o', 'r', 'e', ' ', 'H', 'A', 'V', 'I', 'N', 'G', '\x00'})))
				return int32(2)
			}
			if sqlite3ResolveExprNames(&sNC, p.pHaving) != 0 {
				return int32(2)
			}
		}
		if sqlite3ResolveExprNames(&sNC, p.pWhere) != 0 {
			return int32(2)
		}
		for i = int32(0); i < p.pSrc.nSrc; i++ {
			var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(i)*112))
			if int32(pItem.fg.Xbf_0>>2&1) != 0 && sqlite3ResolveExprListNames(&sNC, *(**struct_ExprList)(unsafe.Pointer(&pItem.u1))) != 0 {
				return int32(2)
			}
		}
		if int32(pParse.eParseMode) >= 2 {
			var pWin *struct_Window
			for pWin = p.pWinDefn; pWin != nil; pWin = pWin.pNextWin {
				if sqlite3ResolveExprListNames(&sNC, pWin.pOrderBy) != 0 || sqlite3ResolveExprListNames(&sNC, pWin.pPartition) != 0 {
					return int32(2)
				}
			}
		}
		sNC.pNext = (*struct_NameContext)(nil)
		sNC.ncFlags |= int32(1 | 16384)
		if p.selFlags&uint32(65536) != 0 {
			var pSub *struct_Select = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pSelect
			p.pOrderBy = pSub.pOrderBy
			pSub.pOrderBy = (*struct_ExprList)(nil)
		}
		if uintptr(unsafe.Pointer(p.pOrderBy)) != uintptr(unsafe.Pointer(nil)) && isCompound <= nCompound && resolveOrderGroupBy(&sNC, p, p.pOrderBy, (*int8)(unsafe.Pointer(&[6]int8{'O', 'R', 'D', 'E', 'R', '\x00'}))) != 0 {
			return int32(2)
		}
		if db.mallocFailed != 0 {
			return int32(2)
		}
		sNC.ncFlags &= int32(^16384)
		if pGroupBy != nil {
			var pItem *struct_ExprList_item
			if resolveOrderGroupBy(&sNC, p, pGroupBy, (*int8)(unsafe.Pointer(&[6]int8{'G', 'R', 'O', 'U', 'P', '\x00'}))) != 0 || int32(db.mallocFailed) != 0 {
				return int32(2)
			}
			for func() *struct_ExprList_item {
				i = int32(0)
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pGroupBy.a))
					return *_cgo_addr
				}()
			}(); i < pGroupBy.nExpr; func() *struct_ExprList_item {
				i++
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
					return
				}()
			}() {
				if pItem.pExpr.flags&uint32(16) != uint32(0) {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[59]int8{'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'G', 'R', 'O', 'U', 'P', ' ', 'B', 'Y', ' ', 'c', 'l', 'a', 'u', 's', 'e', '\x00'})))
					return int32(2)
				}
			}
		}
		if p.pNext != nil && p.pEList.nExpr != p.pNext.pEList.nExpr {
			sqlite3SelectWrongNumTermsError(pParse, p.pNext)
			return int32(2)
		}
		p = p.pPrior
		nCompound++
	}
	if isCompound != 0 && resolveCompoundOrderBy(pParse, pLeftmost) != 0 {
		return int32(2)
	}
	return int32(1)
}
func sqlite3ResolveExprNames(pNC *struct_NameContext, pExpr *struct_Expr) int32 {
	var savedHasAgg int32
	var w struct_Walker
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	savedHasAgg = pNC.ncFlags & (16 | 4096 | 32768 | 134217728)
	pNC.ncFlags &= int32(^(16 | 4096 | 32768 | 134217728))
	w.pParse = pNC.pParse
	w.xExprCallback = resolveExprStep
	w.xSelectCallback = func() func(*struct_Walker, *struct_Select) int32 {
		if pNC.ncFlags&524288 != 0 {
			return nil
		} else {
			return resolveSelectStep
		}
	}()
	w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
	w.u.pNC = pNC
	w.pParse.nHeight += pExpr.nHeight
	if sqlite3ExprCheckHeight(w.pParse, w.pParse.nHeight) != 0 {
		return int32(1)
	}
	sqlite3WalkExpr(&w, pExpr)
	w.pParse.nHeight -= pExpr.nHeight
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pExpr.flags |= uint32(pNC.ncFlags & (16 | 32768))
	pNC.ncFlags |= savedHasAgg
	return func() int32 {
		if pNC.nNcErr > 0 || w.pParse.nErr > 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3ResolveExprListNames(pNC *struct_NameContext, pList *struct_ExprList) int32 {
	var i int32
	var savedHasAgg int32 = 0
	var w struct_Walker
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	w.pParse = pNC.pParse
	w.xExprCallback = resolveExprStep
	w.xSelectCallback = resolveSelectStep
	w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
	w.u.pNC = pNC
	savedHasAgg = pNC.ncFlags & (16 | 4096 | 32768 | 134217728)
	pNC.ncFlags &= int32(^(16 | 4096 | 32768 | 134217728))
	for i = int32(0); i < pList.nExpr; i++ {
		var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr
		if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		w.pParse.nHeight += pExpr.nHeight
		if sqlite3ExprCheckHeight(w.pParse, w.pParse.nHeight) != 0 {
			return int32(2)
		}
		sqlite3WalkExpr(&w, pExpr)
		w.pParse.nHeight -= pExpr.nHeight
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pNC.ncFlags&(16|4096|32768|134217728) != 0 {
			pExpr.flags |= uint32(pNC.ncFlags & (16 | 32768))
			savedHasAgg |= pNC.ncFlags & (16 | 4096 | 32768 | 134217728)
			pNC.ncFlags &= int32(^(16 | 4096 | 32768 | 134217728))
		}
		if w.pParse.nErr > 0 {
			return int32(2)
		}
	}
	pNC.ncFlags |= savedHasAgg
	return int32(0)
}
func sqlite3ResolveSelectNames(pParse *struct_Parse, p *struct_Select, pOuterNC *struct_NameContext) {
	var w struct_Walker
	func() int {
		_ = 0
		return 0
	}()
	w.xExprCallback = resolveExprStep
	w.xSelectCallback = resolveSelectStep
	w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
	w.pParse = pParse
	w.u.pNC = pOuterNC
	sqlite3WalkSelect(&w, p)
}
func sqlite3ResolveSelfReference(pParse *struct_Parse, pTab *struct_Table, type_ int32, pExpr *struct_Expr, pList *struct_ExprList) int32 {
	var sSrc struct_SrcList
	var sNC struct_NameContext
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	__builtin___memset_chk(unsafe.Pointer(&sSrc), 0, 120, __builtin_object_size(unsafe.Pointer(&sSrc), 0))
	if pTab != nil {
		sSrc.nSrc = int32(1)
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&sSrc.a)))) + uintptr(0)*112))).zName = pTab.zName
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&sSrc.a)))) + uintptr(0)*112))).pTab = pTab
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&sSrc.a)))) + uintptr(0)*112))).iCursor = int32(-1)
		if uintptr(unsafe.Pointer(pTab.pSchema)) != uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(1)*32))).pSchema)) {
			type_ |= int32(262144)
		}
	}
	sNC.pParse = pParse
	sNC.pSrcList = &sSrc
	sNC.ncFlags = type_ | 65536
	if func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3ResolveExprNames(&sNC, pExpr)
		return *_cgo_addr
	}() != 0 {
		return rc
	}
	if pList != nil {
		rc = sqlite3ResolveExprListNames(&sNC, pList)
	}
	return rc
}
func sqlite3TableColumnAffinity(pTab *struct_Table, iCol int32) int8 {
	if iCol < 0 || iCol >= int32(pTab.nCol) {
		return int8(68)
	}
	return (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).affinity
}
func sqlite3ExprAffinity(pExpr *struct_Expr) int8 {
	var op int32
	for pExpr.flags&uint32(4096|131072) != uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		pExpr = pExpr.pLeft
		func() int {
			_ = 0
			return 0
		}()
	}
	op = int32(pExpr.op)
	if op == 176 {
		op = int32(pExpr.op2)
	}
	if op == 167 || op == 169 {
		func() int {
			_ = 0
			return 0
		}()
		if pExpr.y.pTab != nil {
			return sqlite3TableColumnAffinity(pExpr.y.pTab, int32(pExpr.iColumn))
		}
	}
	if op == 138 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		return sqlite3ExprAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pEList.a)))) + uintptr(0)*28))).pExpr)
	}
	if op == 36 {
		func() int {
			_ = 0
			return 0
		}()
		return sqlite3AffinityType(pExpr.u.zToken, nil)
	}
	if op == 178 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		return sqlite3ExprAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_Select)(unsafe.Pointer(&pExpr.pLeft.x))).pEList.a)))) + uintptr(pExpr.iColumn)*28))).pExpr)
	}
	if op == 177 {
		func() int {
			_ = 0
			return 0
		}()
		return sqlite3ExprAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(0)*28))).pExpr)
	}
	return pExpr.affExpr
}
func sqlite3ExprAddCollateToken(pParse *struct_Parse, pExpr *struct_Expr, pCollName *struct_Token, dequote int32) *struct_Expr {
	if pCollName.n > uint32(0) {
		var pNew *struct_Expr = sqlite3ExprAlloc(pParse.db, 113, pCollName, dequote)
		if pNew != nil {
			pNew.pLeft = pExpr
			pNew.flags |= uint32(256 | 4096)
			pExpr = pNew
		}
	}
	return pExpr
}
func sqlite3ExprAddCollateString(pParse *struct_Parse, pExpr *struct_Expr, zC *int8) *struct_Expr {
	var s struct_Token
	func() int {
		_ = 0
		return 0
	}()
	sqlite3TokenInit(&s, (*int8)(unsafe.Pointer(zC)))
	return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0)
}
func sqlite3ExprSkipCollate(pExpr *struct_Expr) *struct_Expr {
	for pExpr != nil && pExpr.flags&uint32(4096) != uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		pExpr = pExpr.pLeft
	}
	return pExpr
}
func sqlite3ExprSkipCollateAndLikely(pExpr *struct_Expr) *struct_Expr {
	for pExpr != nil && pExpr.flags&uint32(4096|262144) != uint32(0) {
		if pExpr.flags&uint32(262144) != uint32(0) {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(0)*28))).pExpr
		} else {
			func() int {
				_ = 0
				return 0
			}()
			pExpr = pExpr.pLeft
		}
	}
	return pExpr
}
func sqlite3ExprCollSeq(pParse *struct_Parse, pExpr *struct_Expr) *struct_CollSeq {
	var db *struct_sqlite3 = pParse.db
	var pColl *struct_CollSeq = nil
	var p *struct_Expr = pExpr
	for p != nil {
		var op int32 = int32(p.op)
		if op == 176 {
			op = int32(p.op2)
		}
		if op == 169 || op == 167 || op == 77 {
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(p.y.pTab)) != uintptr(unsafe.Pointer(nil)) {
				var j int32 = int32(p.iColumn)
				if j >= 0 {
					var zColl *int8 = sqlite3ColumnColl(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.y.pTab.aCol)) + uintptr(j)*20)))
					pColl = sqlite3FindCollSeq(db, db.enc, zColl, 0)
				}
				break
			}
		}
		if op == 36 || op == 174 {
			p = p.pLeft
			continue
		}
		if op == 177 {
			func() int {
				_ = 0
				return 0
			}()
			p = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.x.pList.a)))) + uintptr(0)*28))).pExpr
			continue
		}
		if op == 113 {
			func() int {
				_ = 0
				return 0
			}()
			pColl = sqlite3GetCollSeq(pParse, db.enc, nil, p.u.zToken)
			break
		}
		if p.flags&uint32(256) != 0 {
			if p.pLeft != nil && p.pLeft.flags&uint32(256) != uint32(0) {
				p = p.pLeft
			} else {
				var pNext *struct_Expr = p.pRight
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if uintptr(unsafe.Pointer(p.x.pList)) != uintptr(unsafe.Pointer(nil)) && !(db.mallocFailed != 0) {
					var i int32
					for i = int32(0); i < p.x.pList.nExpr; i++ {
						if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.x.pList.a)))) + uintptr(i)*28))).pExpr.flags&uint32(256) != uint32(0) {
							pNext = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.x.pList.a)))) + uintptr(i)*28))).pExpr
							break
						}
					}
				}
				p = pNext
			}
		} else {
			break
		}
	}
	if sqlite3CheckCollSeq(pParse, pColl) != 0 {
		pColl = (*struct_CollSeq)(nil)
	}
	return pColl
}
func sqlite3ExprNNCollSeq(pParse *struct_Parse, pExpr *struct_Expr) *struct_CollSeq {
	var p *struct_CollSeq = sqlite3ExprCollSeq(pParse, pExpr)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		p = pParse.db.pDfltColl
	}
	func() int {
		_ = 0
		return 0
	}()
	return p
}
func sqlite3ExprCollSeqMatch(pParse *struct_Parse, pE1 *struct_Expr, pE2 *struct_Expr) int32 {
	var pColl1 *struct_CollSeq = sqlite3ExprNNCollSeq(pParse, pE1)
	var pColl2 *struct_CollSeq = sqlite3ExprNNCollSeq(pParse, pE2)
	return func() int32 {
		if sqlite3StrICmp(pColl1.zName, pColl2.zName) == 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3CompareAffinity(pExpr *struct_Expr, aff2 int8) int8 {
	var aff1 int8 = sqlite3ExprAffinity(pExpr)
	if int32(aff1) > 64 && int32(aff2) > 64 {
		if int32(aff1) >= 67 || int32(aff2) >= 67 {
			return int8(67)
		} else {
			return int8(65)
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		return int8(func() int32 {
			if int32(aff1) <= 64 {
				return int32(aff2)
			} else {
				return int32(aff1)
			}
		}() | 64)
	}
}
func comparisonAffinity(pExpr *struct_Expr) int8 {
	var aff int8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	aff = sqlite3ExprAffinity(pExpr.pLeft)
	if pExpr.pRight != nil {
		aff = sqlite3CompareAffinity(pExpr.pRight, aff)
	} else if pExpr.flags&uint32(2048) != uint32(0) {
		aff = sqlite3CompareAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pEList.a)))) + uintptr(0)*28))).pExpr, aff)
	} else if int32(aff) == 0 {
		aff = int8(65)
	}
	return aff
}
func sqlite3IndexAffinityOk(pExpr *struct_Expr, idx_affinity int8) int32 {
	var aff int8 = comparisonAffinity(pExpr)
	if int32(aff) < 66 {
		return int32(1)
	}
	if int32(aff) == 66 {
		return func() int32 {
			if int32(idx_affinity) == 66 {
				return 1
			} else {
				return 0
			}
		}()
	}
	return func() int32 {
		if int32(idx_affinity) >= 67 {
			return 1
		} else {
			return 0
		}
	}()
}
func binaryCompareP5(pExpr1 *struct_Expr, pExpr2 *struct_Expr, jumpIfNull int32) uint8 {
	var aff uint8 = uint8(int8(sqlite3ExprAffinity(pExpr2)))
	aff = uint8(int32(uint8(sqlite3CompareAffinity(pExpr1, int8(aff)))) | int32(uint8(jumpIfNull)))
	return aff
}
func sqlite3BinaryCompareCollSeq(pParse *struct_Parse, pLeft *struct_Expr, pRight *struct_Expr) *struct_CollSeq {
	var pColl *struct_CollSeq
	func() int {
		_ = 0
		return 0
	}()
	if pLeft.flags&uint32(256) != 0 {
		pColl = sqlite3ExprCollSeq(pParse, pLeft)
	} else if pRight != nil && pRight.flags&uint32(256) != uint32(0) {
		pColl = sqlite3ExprCollSeq(pParse, pRight)
	} else {
		pColl = sqlite3ExprCollSeq(pParse, pLeft)
		if !(pColl != nil) {
			pColl = sqlite3ExprCollSeq(pParse, pRight)
		}
	}
	return pColl
}
func sqlite3ExprCompareCollSeq(pParse *struct_Parse, p *struct_Expr) *struct_CollSeq {
	if p.flags&uint32(512) != uint32(0) {
		return sqlite3BinaryCompareCollSeq(pParse, p.pRight, p.pLeft)
	} else {
		return sqlite3BinaryCompareCollSeq(pParse, p.pLeft, p.pRight)
	}
}
func codeCompare(pParse *struct_Parse, pLeft *struct_Expr, pRight *struct_Expr, opcode int32, in1 int32, in2 int32, dest int32, jumpIfNull int32, isCommuted int32) int32 {
	var p5 int32
	var addr int32
	var p4 *struct_CollSeq
	if pParse.nErr != 0 {
		return int32(0)
	}
	if isCommuted != 0 {
		p4 = sqlite3BinaryCompareCollSeq(pParse, pRight, pLeft)
	} else {
		p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight)
	}
	p5 = int32(binaryCompareP5(pLeft, pRight, jumpIfNull))
	addr = sqlite3VdbeAddOp4(pParse.pVdbe, opcode, in2, dest, in1, (*int8)(unsafe.Pointer(p4)), -2)
	sqlite3VdbeChangeP5(pParse.pVdbe, uint16(uint8(p5)))
	return addr
}
func sqlite3ExprIsVector(pExpr *struct_Expr) int32 {
	return func() int32 {
		if sqlite3ExprVectorSize(pExpr) > 1 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3ExprVectorSize(pExpr *struct_Expr) int32 {
	var op uint8 = pExpr.op
	if int32(op) == 176 {
		op = pExpr.op2
	}
	if int32(op) == 177 {
		func() int {
			_ = 0
			return 0
		}()
		return pExpr.x.pList.nExpr
	} else if int32(op) == 138 {
		func() int {
			_ = 0
			return 0
		}()
		return (*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pEList.nExpr
	} else {
		return int32(1)
	}
}
func sqlite3VectorFieldSubexpr(pVector *struct_Expr, i int32) *struct_Expr {
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3ExprIsVector(pVector) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pVector.op) == 138 || int32(pVector.op2) == 138 {
			func() int {
				_ = 0
				return 0
			}()
			return (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_Select)(unsafe.Pointer(&pVector.x))).pEList.a)))) + uintptr(i)*28))).pExpr
		} else {
			func() int {
				_ = 0
				return 0
			}()
			return (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pVector.x.pList.a)))) + uintptr(i)*28))).pExpr
		}
	}
	return pVector
}
func sqlite3ExprForVectorField(pParse *struct_Parse, pVector *struct_Expr, iField int32, nField int32) *struct_Expr {
	var pRet *struct_Expr
	if int32(pVector.op) == 138 {
		func() int {
			_ = 0
			return 0
		}()
		pRet = sqlite3PExpr(pParse, 178, nil, nil)
		if pRet != nil {
			pRet.iTable = nField
			pRet.iColumn = int16(iField)
			pRet.pLeft = pVector
		}
	} else {
		if int32(pVector.op) == 177 {
			var ppVector **struct_Expr
			func() int {
				_ = 0
				return 0
			}()
			ppVector = &(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pVector.x.pList.a)))) + uintptr(iField)*28))).pExpr
			pVector = *ppVector
			if int32(pParse.eParseMode) >= 2 {
				*ppVector = (*struct_Expr)(nil)
				return pVector
			}
		}
		pRet = sqlite3ExprDup(pParse.db, pVector, 0)
	}
	return pRet
}
func exprCodeSubselect(pParse *struct_Parse, pExpr *struct_Expr) int32 {
	var reg int32 = 0
	if int32(pExpr.op) == 138 {
		reg = sqlite3CodeSubselect(pParse, pExpr)
	}
	return reg
}
func exprVectorRegister(pParse *struct_Parse, pVector *struct_Expr, iField int32, regSelect int32, ppExpr **struct_Expr, pRegFree *int32) int32 {
	var op uint8 = pVector.op
	func() int {
		_ = 0
		return 0
	}()
	if int32(op) == 176 {
		*ppExpr = sqlite3VectorFieldSubexpr(pVector, iField)
		return pVector.iTable + iField
	}
	if int32(op) == 138 {
		func() int {
			_ = 0
			return 0
		}()
		*ppExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_Select)(unsafe.Pointer(&pVector.x))).pEList.a)))) + uintptr(iField)*28))).pExpr
		return regSelect + iField
	}
	if int32(op) == 177 {
		func() int {
			_ = 0
			return 0
		}()
		*ppExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pVector.x.pList.a)))) + uintptr(iField)*28))).pExpr
		return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree)
	}
	return int32(0)
}
func codeVectorCompare(pParse *struct_Parse, pExpr *struct_Expr, dest int32, op uint8, p5 uint8) {
	var v *struct_Vdbe = pParse.pVdbe
	var pLeft *struct_Expr = pExpr.pLeft
	var pRight *struct_Expr = pExpr.pRight
	var nLeft int32 = sqlite3ExprVectorSize(pLeft)
	var i int32
	var regLeft int32 = 0
	var regRight int32 = 0
	var opx uint8 = op
	var addrCmp int32 = 0
	var addrDone int32 = sqlite3VdbeMakeLabel(pParse)
	var isCommuted int32 = func() int32 {
		if pExpr.flags&uint32(512) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		return
	}
	if nLeft != sqlite3ExprVectorSize(pRight) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'r', 'o', 'w', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'i', 's', 'u', 's', 'e', 'd', '\x00'})))
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(op) == 55 {
		opx = uint8(56)
	}
	if int32(op) == 57 {
		opx = uint8(54)
	}
	if int32(op) == 52 {
		opx = uint8(53)
	}
	regLeft = exprCodeSubselect(pParse, pLeft)
	regRight = exprCodeSubselect(pParse, pRight)
	sqlite3VdbeAddOp2(v, 71, 1, dest)
	for i = int32(0); 1 != 0; i++ {
		var regFree1 int32 = 0
		var regFree2 int32 = 0
		var pL *struct_Expr = nil
		var pR *struct_Expr = nil
		var r1 int32
		var r2 int32
		func() int {
			_ = 0
			return 0
		}()
		if addrCmp != 0 {
			sqlite3VdbeJumpHere(v, addrCmp)
		}
		r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1)
		r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2)
		addrCmp = sqlite3VdbeCurrentAddr(v)
		codeCompare(pParse, pL, pR, int32(opx), r1, r2, addrDone, int32(p5), isCommuted)
		sqlite3ReleaseTempReg(pParse, regFree1)
		sqlite3ReleaseTempReg(pParse, regFree2)
		if (int32(opx) == 56 || int32(opx) == 54) && i < nLeft-1 {
			addrCmp = sqlite3VdbeAddOp0(v, 58)
		}
		if int32(p5) == 128 {
			sqlite3VdbeAddOp2(v, 71, 0, dest)
		} else {
			sqlite3VdbeAddOp3(v, 91, r1, dest, r2)
		}
		if i == nLeft-1 {
			break
		}
		if int32(opx) == 53 {
			sqlite3VdbeAddOp2(v, 51, dest, addrDone)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 11, 0, addrDone)
			if i == nLeft-2 {
				opx = op
			}
		}
	}
	sqlite3VdbeJumpHere(v, addrCmp)
	sqlite3VdbeResolveLabel(v, addrDone)
	if int32(op) == 52 {
		sqlite3VdbeAddOp2(v, 19, dest, dest)
	}
}
func sqlite3ExprCheckHeight(pParse *struct_Parse, nHeight int32) int32 {
	var rc int32 = 0
	var mxHeight int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.db.aLimit)))) + uintptr(3)*4))
	if nHeight > mxHeight {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[48]int8{'E', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 't', 'r', 'e', 'e', ' ', 'i', 's', ' ', 't', 'o', 'o', ' ', 'l', 'a', 'r', 'g', 'e', ' ', '(', 'm', 'a', 'x', 'i', 'm', 'u', 'm', ' ', 'd', 'e', 'p', 't', 'h', ' ', '%', 'd', ')', '\x00'})), mxHeight)
		rc = int32(1)
	}
	return rc
}
func heightOfExpr(p *struct_Expr, pnHeight *int32) {
	if p != nil {
		if p.nHeight > *pnHeight {
			*pnHeight = p.nHeight
		}
	}
}
func heightOfExprList(p *struct_ExprList, pnHeight *int32) {
	if p != nil {
		var i int32
		for i = int32(0); i < p.nExpr; i++ {
			heightOfExpr((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.a)))) + uintptr(i)*28))).pExpr, pnHeight)
		}
	}
}
func heightOfSelect(pSelect *struct_Select, pnHeight *int32) {
	var p *struct_Select
	for p = pSelect; p != nil; p = p.pPrior {
		heightOfExpr(p.pWhere, pnHeight)
		heightOfExpr(p.pHaving, pnHeight)
		heightOfExpr(p.pLimit, pnHeight)
		heightOfExprList(p.pEList, pnHeight)
		heightOfExprList(p.pGroupBy, pnHeight)
		heightOfExprList(p.pOrderBy, pnHeight)
	}
}
func exprSetHeight(p *struct_Expr) {
	var nHeight int32 = func() int32 {
		if p.pLeft != nil {
			return p.pLeft.nHeight
		} else {
			return 0
		}
	}()
	if p.pRight != nil && p.pRight.nHeight > nHeight {
		nHeight = p.pRight.nHeight
	}
	if p.flags&uint32(2048) != uint32(0) {
		heightOfSelect(*(**struct_Select)(unsafe.Pointer(&p.x)), &nHeight)
	} else if p.x.pList != nil {
		heightOfExprList(p.x.pList, &nHeight)
		p.flags |= uint32(256|2097152|4) & sqlite3ExprListFlags(p.x.pList)
	}
	p.nHeight = nHeight + 1
}
func sqlite3ExprSetHeightAndFlags(pParse *struct_Parse, p *struct_Expr) {
	if pParse.nErr != 0 {
		return
	}
	exprSetHeight(p)
	sqlite3ExprCheckHeight(pParse, p.nHeight)
}
func sqlite3SelectExprHeight(p *struct_Select) int32 {
	var nHeight int32 = 0
	heightOfSelect(p, &nHeight)
	return nHeight
}
func sqlite3ExprAlloc(db *struct_sqlite3, op int32, pToken *struct_Token, dequote int32) *struct_Expr {
	var pNew *struct_Expr
	var nExtra int32 = 0
	var iValue int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if pToken != nil {
		if op != 155 || uintptr(unsafe.Pointer(pToken.z)) == uintptr(unsafe.Pointer(nil)) || sqlite3GetInt32(pToken.z, &iValue) == 0 {
			nExtra = int32(pToken.n + uint32(1))
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	pNew = (*struct_Expr)(sqlite3DbMallocRawNN(db, uint64(72+uint(nExtra))))
	if pNew != nil {
		__builtin___memset_chk(unsafe.Pointer(pNew), 0, 72, __builtin_object_size(unsafe.Pointer(pNew), 0))
		pNew.op = uint8(op)
		pNew.iAgg = int16(-1)
		if pToken != nil {
			if nExtra == 0 {
				pNew.flags |= uint32(1024 | 8388608 | func() int32 {
					if iValue != 0 {
						return 268435456
					} else {
						return 536870912
					}
				}())
				*(*int32)(unsafe.Pointer(&pNew.u)) = iValue
			} else {
				pNew.u.zToken = (*int8)(unsafe.Pointer(&*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew)) + uintptr(1)*72))))
				func() int {
					_ = 0
					return 0
				}()
				if pToken.n != 0 {
					__builtin___memcpy_chk(unsafe.Pointer(pNew.u.zToken), unsafe.Pointer(pToken.z), uint(pToken.n), __builtin_object_size(unsafe.Pointer(pNew.u.zToken), 0))
				}
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.u.zToken)) + uintptr(pToken.n))) = int8(0)
				if dequote != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.u.zToken)) + uintptr(0))))))))&128 != 0 {
					sqlite3DequoteExpr(pNew)
				}
			}
		}
		pNew.nHeight = int32(1)
	}
	return pNew
}
func sqlite3Expr(db *struct_sqlite3, op int32, zToken *int8) *struct_Expr {
	var x struct_Token
	x.z = zToken
	x.n = uint32(sqlite3Strlen30(zToken))
	return sqlite3ExprAlloc(db, op, &x, 0)
}
func sqlite3ExprAttachSubtrees(db *struct_sqlite3, pRoot *struct_Expr, pLeft *struct_Expr, pRight *struct_Expr) {
	if uintptr(unsafe.Pointer(pRoot)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3ExprDelete(db, pLeft)
		sqlite3ExprDelete(db, pRight)
	} else {
		if pRight != nil {
			pRoot.pRight = pRight
			pRoot.flags |= uint32(256|2097152|4) & pRight.flags
		}
		if pLeft != nil {
			pRoot.pLeft = pLeft
			pRoot.flags |= uint32(256|2097152|4) & pLeft.flags
		}
		exprSetHeight(pRoot)
	}
}
func sqlite3PExpr(pParse *struct_Parse, op int32, pLeft *struct_Expr, pRight *struct_Expr) *struct_Expr {
	var p *struct_Expr
	p = (*struct_Expr)(sqlite3DbMallocRawNN(pParse.db, uint64(72)))
	if p != nil {
		__builtin___memset_chk(unsafe.Pointer(p), 0, 72, __builtin_object_size(unsafe.Pointer(p), 0))
		p.op = uint8(op & 255)
		p.iAgg = int16(-1)
		sqlite3ExprAttachSubtrees(pParse.db, p, pLeft, pRight)
		sqlite3ExprCheckHeight(pParse, p.nHeight)
	} else {
		sqlite3ExprDelete(pParse.db, pLeft)
		sqlite3ExprDelete(pParse.db, pRight)
	}
	return p
}
func sqlite3PExprAddSelect(pParse *struct_Parse, pExpr *struct_Expr, pSelect *struct_Select) {
	if pExpr != nil {
		*(**struct_Select)(unsafe.Pointer(&pExpr.x)) = pSelect
		pExpr.flags |= uint32(2048 | 2097152)
		sqlite3ExprSetHeightAndFlags(pParse, pExpr)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3SelectDelete(pParse.db, pSelect)
	}
}
func sqlite3ExprListToValues(pParse *struct_Parse, nElem int32, pEList *struct_ExprList) *struct_Select {
	var ii int32
	var pRet *struct_Select = nil
	func() int {
		_ = 0
		return 0
	}()
	for ii = int32(0); ii < pEList.nExpr; ii++ {
		var pSel *struct_Select
		var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(ii)*28))).pExpr
		var nExprElem int32
		if int32(pExpr.op) == 177 {
			func() int {
				_ = 0
				return 0
			}()
			nExprElem = pExpr.x.pList.nExpr
		} else {
			nExprElem = int32(1)
		}
		if nExprElem != nElem {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[44]int8{'I', 'N', '(', '.', '.', '.', ')', ' ', 'e', 'l', 'e', 'm', 'e', 'n', 't', ' ', 'h', 'a', 's', ' ', '%', 'd', ' ', 't', 'e', 'r', 'm', '%', 's', ' ', '-', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', '%', 'd', '\x00'})), nExprElem, func() *int8 {
				if nExprElem > 1 {
					return (*int8)(unsafe.Pointer(&[2]int8{'s', '\x00'}))
				} else {
					return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
				}
			}(), nElem)
			break
		}
		func() int {
			_ = 0
			return 0
		}()
		pSel = sqlite3SelectNew(pParse, pExpr.x.pList, nil, nil, nil, nil, nil, uint32(512), nil)
		pExpr.x.pList = (*struct_ExprList)(nil)
		if pSel != nil {
			if pRet != nil {
				pSel.op = uint8(135)
				pSel.pPrior = pRet
			}
			pRet = pSel
		}
	}
	if pRet != nil && pRet.pPrior != nil {
		pRet.selFlags |= uint32(1024)
	}
	sqlite3ExprListDelete(pParse.db, pEList)
	return pRet
}
func sqlite3ExprAnd(pParse *struct_Parse, pLeft *struct_Expr, pRight *struct_Expr) *struct_Expr {
	var db *struct_sqlite3 = pParse.db
	if uintptr(unsafe.Pointer(pLeft)) == uintptr(unsafe.Pointer(nil)) {
		return pRight
	} else if uintptr(unsafe.Pointer(pRight)) == uintptr(unsafe.Pointer(nil)) {
		return pLeft
	} else if (pLeft.flags&uint32(1|536870912) == uint32(536870912) || pRight.flags&uint32(1|536870912) == uint32(536870912)) && !(int32(pParse.eParseMode) >= 2) {
		sqlite3ExprDeferredDelete(pParse, pLeft)
		sqlite3ExprDeferredDelete(pParse, pRight)
		return sqlite3Expr(db, 155, (*int8)(unsafe.Pointer(&[2]int8{'0', '\x00'})))
	} else {
		return sqlite3PExpr(pParse, 44, pLeft, pRight)
	}
}
func sqlite3ExprFunction(pParse *struct_Parse, pList *struct_ExprList, pToken *struct_Token, eDistinct int32) *struct_Expr {
	var pNew *struct_Expr
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	pNew = sqlite3ExprAlloc(db, 172, pToken, 1)
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ExprListDelete(db, pList)
		return (*struct_Expr)(nil)
	}
	*(*int32)(unsafe.Pointer(&pNew.w)) = int32(uintptr(unsafe.Pointer(pToken.z)) - uintptr(unsafe.Pointer(pParse.zTail)))
	if pList != nil && pList.nExpr > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.db.aLimit)))) + uintptr(6)*4)) && !(pParse.nested != 0) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ', 'o', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', '%', 'T', '\x00'})), pToken)
	}
	pNew.x.pList = pList
	pNew.flags |= uint32(4)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ExprSetHeightAndFlags(pParse, pNew)
	if eDistinct == 1 {
		pNew.flags |= uint32(2)
	}
	return pNew
}
func sqlite3ExprFunctionUsable(pParse *struct_Parse, pExpr *struct_Expr, pDef *struct_FuncDef) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pExpr.flags&uint32(1073741824) != uint32(0) {
		if pDef.funcFlags&uint32(524288) != uint32(0) || pParse.db.flags&uint64(128) == uint64(0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[20]int8{'u', 'n', 's', 'a', 'f', 'e', ' ', 'u', 's', 'e', ' ', 'o', 'f', ' ', '%', '#', 'T', '(', ')', '\x00'})), pExpr)
		}
	}
}
func sqlite3ExprAssignVarNumber(pParse *struct_Parse, pExpr *struct_Expr, n uint32) {
	var db *struct_sqlite3 = pParse.db
	var z *int8
	var x int16
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	z = pExpr.u.zToken
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		x = int16(func() (_cgo_ret int16) {
			_cgo_addr := &pParse.nVar
			*_cgo_addr++
			return *_cgo_addr
		}())
	} else {
		var doAdd int32 = 0
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) == '?' {
			var i int64
			var bOk int32
			if n == uint32(2) {
				i = int64(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) - '0')
				bOk = int32(1)
			} else {
				bOk = func() int32 {
					if 0 == sqlite3Atoi64(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1))), &i, int32(n-uint32(1)), uint8(1)) {
						return 1
					} else {
						return 0
					}
				}()
			}
			if bOk == 0 || i < int64(1) || i > int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(9)*4))) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[43]int8{'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'b', 'e', 't', 'w', 'e', 'e', 'n', ' ', '?', '1', ' ', 'a', 'n', 'd', ' ', '?', '%', 'd', '\x00'})), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(9)*4)))
				sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr)
				return
			}
			x = int16(i)
			if int32(x) > int32(pParse.nVar) {
				pParse.nVar = int16(int32(x))
				doAdd = int32(1)
			} else if uintptr(unsafe.Pointer(sqlite3VListNumToName(pParse.pVList, int32(x)))) == uintptr(unsafe.Pointer(nil)) {
				doAdd = int32(1)
			}
		} else {
			x = int16(sqlite3VListNameToNum(pParse.pVList, z, int32(n)))
			if int32(x) == 0 {
				x = int16(func() (_cgo_ret int16) {
					_cgo_addr := &pParse.nVar
					*_cgo_addr++
					return *_cgo_addr
				}())
				doAdd = int32(1)
			}
		}
		if doAdd != 0 {
			pParse.pVList = sqlite3VListAdd(db, pParse.pVList, z, int32(n), int32(x))
		}
	}
	pExpr.iColumn = x
	if int32(x) > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(9)*4)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[23]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'S', 'Q', 'L', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', '\x00'})))
		sqlite3RecordErrorOffsetOfExpr(pParse.db, pExpr)
	}
}
func sqlite3ExprDeleteNN(db *struct_sqlite3, p *struct_Expr) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(p.flags&uint32(16384|8388608) != uint32(0)) {
		func() int {
			_ = 0
			return 0
		}()
		if p.pLeft != nil && int32(p.op) != 178 {
			sqlite3ExprDeleteNN(db, p.pLeft)
		}
		if p.pRight != nil {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3ExprDeleteNN(db, p.pRight)
		} else if p.flags&uint32(2048) != uint32(0) {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3SelectDelete(db, *(**struct_Select)(unsafe.Pointer(&p.x)))
		} else {
			sqlite3ExprListDelete(db, p.x.pList)
			if p.flags&uint32(16777216) != uint32(0) {
				sqlite3WindowDelete(db, *(**struct_Window)(unsafe.Pointer(&p.y)))
			}
		}
	}
	if p.flags&uint32(65536) != uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3DbFree(db, unsafe.Pointer(p.u.zToken))
	}
	if !(p.flags&uint32(134217728) != uint32(0)) {
		sqlite3DbFreeNN(db, unsafe.Pointer(p))
	}
}
func sqlite3ExprDelete(db *struct_sqlite3, p *struct_Expr) {
	if p != nil {
		sqlite3ExprDeleteNN(db, p)
	}
}
func sqlite3ExprDeferredDelete(pParse *struct_Parse, pExpr *struct_Expr) {
	pParse.pConstExpr = sqlite3ExprListAppend(pParse, pParse.pConstExpr, pExpr)
}
func sqlite3ExprUnmapAndDelete(pParse *struct_Parse, p *struct_Expr) {
	if p != nil {
		if int32(pParse.eParseMode) >= 2 {
			sqlite3RenameExprUnmap(pParse, p)
		}
		sqlite3ExprDeleteNN(pParse.db, p)
	}
}
func exprStructSize(p *struct_Expr) int32 {
	if p.flags&uint32(16384) != uint32(0) {
		return int32(16)
	}
	if p.flags&uint32(8192) != uint32(0) {
		return int32(44)
	}
	return int32(72)
}
func dupedExprStructSize(p *struct_Expr, flags int32) int32 {
	var nSize int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if 0 == flags || int32(p.op) == 178 || p.flags&uint32(16777216) != uint32(0) {
		nSize = int32(72)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if p.pLeft != nil || p.x.pList != nil {
			nSize = int32(44 | uint(8192))
		} else {
			func() int {
				_ = 0
				return 0
			}()
			nSize = int32(16 | uint(16384))
		}
	}
	return nSize
}
func dupedExprNodeSize(p *struct_Expr, flags int32) int32 {
	var nByte int32 = dupedExprStructSize(p, flags) & 4095
	if !(p.flags&uint32(1024) != uint32(0)) && p.u.zToken != nil {
		nByte += int32(strlen(p.u.zToken)&uint(1073741823) + uint(1))
	}
	return (nByte + 7) & ^7
}
func dupedExprSize(p *struct_Expr, flags int32) int32 {
	var nByte int32 = 0
	if p != nil {
		nByte = dupedExprNodeSize(p, flags)
		if flags&1 != 0 {
			nByte += dupedExprSize(p.pLeft, flags) + dupedExprSize(p.pRight, flags)
		}
	}
	return nByte
}
func exprDup(db *struct_sqlite3, p *struct_Expr, dupFlags int32, pzBuffer **uint8) *struct_Expr {
	var pNew *struct_Expr
	var zAlloc *uint8
	var staticFlag uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pzBuffer != nil {
		zAlloc = *pzBuffer
		staticFlag = uint32(134217728)
		func() int {
			_ = 0
			return 0
		}()
	} else {
		zAlloc = (*uint8)(sqlite3DbMallocRawNN(db, uint64(dupedExprSize(p, dupFlags))))
		staticFlag = uint32(0)
	}
	pNew = (*struct_Expr)(unsafe.Pointer(zAlloc))
	if pNew != nil {
		var nStructSize uint32 = uint32(dupedExprStructSize(p, dupFlags))
		var nNewSize int32 = int32(nStructSize & uint32(4095))
		var nToken int32
		if !(p.flags&uint32(1024) != uint32(0)) && p.u.zToken != nil {
			nToken = sqlite3Strlen30(p.u.zToken) + 1
		} else {
			nToken = int32(0)
		}
		if dupFlags != 0 {
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memcpy_chk(unsafe.Pointer(zAlloc), unsafe.Pointer(p), uint(nNewSize), __builtin_object_size(unsafe.Pointer(zAlloc), 0))
		} else {
			var nSize uint32 = uint32(exprStructSize(p))
			__builtin___memcpy_chk(unsafe.Pointer(zAlloc), unsafe.Pointer(p), uint(nSize), __builtin_object_size(unsafe.Pointer(zAlloc), 0))
			if uint(nSize) < 72 {
				__builtin___memset_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAlloc)) + uintptr(nSize)))), 0, 72-uint(nSize), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAlloc)) + uintptr(nSize)))), 0))
			}
		}
		pNew.flags &= uint32(4160659455)
		pNew.flags |= nStructSize & uint32(8192|16384)
		pNew.flags |= staticFlag
		if dupFlags != 0 {
		}
		if nToken != 0 {
			var zToken *int8 = func() (_cgo_ret *int8) {
				_cgo_addr := &pNew.u.zToken
				*_cgo_addr = (*int8)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAlloc)) + uintptr(nNewSize)))))
				return *_cgo_addr
			}()
			__builtin___memcpy_chk(unsafe.Pointer(zToken), unsafe.Pointer(p.u.zToken), uint(nToken), __builtin_object_size(unsafe.Pointer(zToken), 0))
		}
		if uint32(0) == (p.flags|pNew.flags)&uint32(16384|8388608) {
			if p.flags&uint32(2048) != uint32(0) {
				*(**struct_Select)(unsafe.Pointer(&pNew.x)) = sqlite3SelectDup(db, *(**struct_Select)(unsafe.Pointer(&p.x)), dupFlags)
			} else {
				pNew.x.pList = sqlite3ExprListDup(db, p.x.pList, dupFlags)
			}
		}
		if pNew.flags&uint32(8192|16384|16777216) != uint32(0) {
			*(*uintptr)(unsafe.Pointer(&zAlloc)) += uintptr(dupedExprNodeSize(p, dupFlags))
			if !(pNew.flags&uint32(16384|8388608) != uint32(0)) {
				pNew.pLeft = func() *struct_Expr {
					if p.pLeft != nil {
						return exprDup(db, p.pLeft, 1, &zAlloc)
					} else {
						return nil
					}
				}()
				pNew.pRight = func() *struct_Expr {
					if p.pRight != nil {
						return exprDup(db, p.pRight, 1, &zAlloc)
					} else {
						return nil
					}
				}()
			}
			if p.flags&uint32(16777216) != uint32(0) {
				*(**struct_Window)(unsafe.Pointer(&pNew.y)) = sqlite3WindowDup(db, pNew, *(**struct_Window)(unsafe.Pointer(&p.y)))
				func() int {
					_ = 0
					return 0
				}()
			}
			if pzBuffer != nil {
				*pzBuffer = zAlloc
			}
		} else if !(p.flags&uint32(16384|8388608) != uint32(0)) {
			if int32(pNew.op) == 178 {
				pNew.pLeft = p.pLeft
				func() int {
					_ = 0
					return 0
				}()
			} else {
				pNew.pLeft = sqlite3ExprDup(db, p.pLeft, 0)
			}
			pNew.pRight = sqlite3ExprDup(db, p.pRight, 0)
		}
	}
	return pNew
}
func sqlite3WithDup(db *struct_sqlite3, p *struct_With) *struct_With {
	var pRet *struct_With = nil
	if p != nil {
		var nByte int64 = int64(57 + 41*uint(p.nCte-1))
		pRet = (*struct_With)(sqlite3DbMallocZero(db, uint64(nByte)))
		if pRet != nil {
			var i int32
			pRet.nCte = p.nCte
			for i = int32(0); i < p.nCte; i++ {
				(*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pRet.a)))) + uintptr(i)*41))).pSelect = sqlite3SelectDup(db, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&p.a)))) + uintptr(i)*41))).pSelect, 0)
				(*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pRet.a)))) + uintptr(i)*41))).pCols = sqlite3ExprListDup(db, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&p.a)))) + uintptr(i)*41))).pCols, 0)
				(*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pRet.a)))) + uintptr(i)*41))).zName = sqlite3DbStrDup(db, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&p.a)))) + uintptr(i)*41))).zName)
			}
		}
	}
	return pRet
}
func gatherSelectWindowsCallback(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 172 && pExpr.flags&uint32(16777216) != uint32(0) {
		var pSelect *struct_Select = *(**struct_Select)(unsafe.Pointer(&pWalker.u))
		var pWin *struct_Window = *(**struct_Window)(unsafe.Pointer(&pExpr.y))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3WindowLink(pSelect, pWin)
	}
	return int32(0)
}
func gatherSelectWindowsSelectCallback(pWalker *struct_Walker, p *struct_Select) int32 {
	return func() int32 {
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(*(**struct_Select)(unsafe.Pointer(&pWalker.u)))) {
			return 0
		} else {
			return 1
		}
	}()
}
func gatherSelectWindows(p *struct_Select) {
	var w struct_Walker
	w.xExprCallback = gatherSelectWindowsCallback
	w.xSelectCallback = gatherSelectWindowsSelectCallback
	w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
	w.pParse = (*struct_Parse)(nil)
	*(**struct_Select)(unsafe.Pointer(&w.u)) = p
	sqlite3WalkSelect(&w, p)
}
func sqlite3ExprDup(db *struct_sqlite3, p *struct_Expr, flags int32) *struct_Expr {
	func() int {
		_ = 0
		return 0
	}()
	return func() *struct_Expr {
		if p != nil {
			return exprDup(db, p, flags, nil)
		} else {
			return nil
		}
	}()
}
func sqlite3ExprListDup(db *struct_sqlite3, p *struct_ExprList, flags int32) *struct_ExprList {
	var pNew *struct_ExprList
	var pItem *struct_ExprList_item
	var pOldItem *struct_ExprList_item
	var i int32
	var pPriorSelectColOld *struct_Expr = nil
	var pPriorSelectColNew *struct_Expr = nil
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_ExprList)(nil)
	}
	pNew = (*struct_ExprList)(sqlite3DbMallocRawNN(db, uint64(sqlite3DbMallocSize(db, unsafe.Pointer(p)))))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_ExprList)(nil)
	}
	pNew.nExpr = p.nExpr
	pNew.nAlloc = p.nAlloc
	pItem = (*struct_ExprList_item)(unsafe.Pointer(&pNew.a))
	pOldItem = (*struct_ExprList_item)(unsafe.Pointer(&p.a))
	for i = int32(0); i < p.nExpr; func() *struct_ExprList_item {
		func() *struct_ExprList_item {
			i++
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}()
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pOldItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		var pOldExpr *struct_Expr = pOldItem.pExpr
		var pNewExpr *struct_Expr
		pItem.pExpr = sqlite3ExprDup(db, pOldExpr, flags)
		if pOldExpr != nil && int32(pOldExpr.op) == 178 && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Expr) {
			_cgo_addr := &pNewExpr
			*_cgo_addr = pItem.pExpr
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			if pNewExpr.pRight != nil {
				pPriorSelectColOld = pOldExpr.pRight
				pPriorSelectColNew = pNewExpr.pRight
				pNewExpr.pLeft = pNewExpr.pRight
			} else {
				if uintptr(unsafe.Pointer(pOldExpr.pLeft)) != uintptr(unsafe.Pointer(pPriorSelectColOld)) {
					pPriorSelectColOld = pOldExpr.pLeft
					pPriorSelectColNew = sqlite3ExprDup(db, pPriorSelectColOld, flags)
					pNewExpr.pRight = pPriorSelectColNew
				}
				pNewExpr.pLeft = pPriorSelectColNew
			}
		}
		pItem.zEName = sqlite3DbStrDup(db, pOldItem.zEName)
		pItem.sortFlags = pOldItem.sortFlags
		{
			_autoGo_37 := &pItem.Xbf_0
			*_autoGo_37 = *_autoGo_37&^3 | pOldItem.Xbf_0&3&3
		}
		{
			_autoGo_38 := &pItem.Xbf_0
			*_autoGo_38 = *_autoGo_38&^4 | uint32(0)&1<<2
		}
		{
			_autoGo_39 := &pItem.Xbf_0
			*_autoGo_39 = *_autoGo_39&^32 | pOldItem.Xbf_0>>5&1&1<<5
		}
		{
			_autoGo_40 := &pItem.Xbf_0
			*_autoGo_40 = *_autoGo_40&^16 | pOldItem.Xbf_0>>4&1&1<<4
		}
		pItem.u = pOldItem.u
	}
	return pNew
}
func sqlite3SrcListDup(db *struct_sqlite3, p *struct_SrcList, flags int32) *struct_SrcList {
	var pNew *struct_SrcList
	var i int32
	var nByte int32
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_SrcList)(nil)
	}
	nByte = int32(120 + func() uint {
		if p.nSrc > 0 {
			return 112 * uint(p.nSrc-1)
		} else {
			return uint(0)
		}
	}())
	pNew = (*struct_SrcList)(sqlite3DbMallocRawNN(db, uint64(nByte)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_SrcList)(nil)
	}
	pNew.nSrc = int32(func() (_cgo_ret uint32) {
		_cgo_addr := &pNew.nAlloc
		*_cgo_addr = uint32(p.nSrc)
		return *_cgo_addr
	}())
	for i = int32(0); i < p.nSrc; i++ {
		var pNewItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pNew.a)))) + uintptr(i)*112))
		var pOldItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(i)*112))
		var pTab *struct_Table
		pNewItem.pSchema = pOldItem.pSchema
		pNewItem.zDatabase = sqlite3DbStrDup(db, pOldItem.zDatabase)
		pNewItem.zName = sqlite3DbStrDup(db, pOldItem.zName)
		pNewItem.zAlias = sqlite3DbStrDup(db, pOldItem.zAlias)
		pNewItem.fg = pOldItem.fg
		pNewItem.iCursor = pOldItem.iCursor
		pNewItem.addrFillSub = pOldItem.addrFillSub
		pNewItem.regReturn = pOldItem.regReturn
		if pNewItem.fg.Xbf_0>>1&1 != 0 {
			pNewItem.u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem.u1.zIndexedBy)
		}
		pNewItem.u2 = pOldItem.u2
		if pNewItem.fg.Xbf_0>>7&1 != 0 {
			(*(**struct_CteUse)(unsafe.Pointer(&pNewItem.u2))).nUse++
		}
		if pNewItem.fg.Xbf_0>>2&1 != 0 {
			*(**struct_ExprList)(unsafe.Pointer(&pNewItem.u1)) = sqlite3ExprListDup(db, *(**struct_ExprList)(unsafe.Pointer(&pOldItem.u1)), flags)
		}
		pTab = func() (_cgo_ret *struct_Table) {
			_cgo_addr := &pNewItem.pTab
			*_cgo_addr = pOldItem.pTab
			return *_cgo_addr
		}()
		if pTab != nil {
			pTab.nTabRef++
		}
		pNewItem.pSelect = sqlite3SelectDup(db, pOldItem.pSelect, flags)
		pNewItem.pOn = sqlite3ExprDup(db, pOldItem.pOn, flags)
		pNewItem.pUsing = sqlite3IdListDup(db, pOldItem.pUsing)
		pNewItem.colUsed = pOldItem.colUsed
	}
	return pNew
}
func sqlite3IdListDup(db *struct_sqlite3, p *struct_IdList) *struct_IdList {
	var pNew *struct_IdList
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_IdList)(nil)
	}
	pNew = (*struct_IdList)(sqlite3DbMallocRawNN(db, uint64(12)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_IdList)(nil)
	}
	pNew.nId = p.nId
	pNew.a = (*struct_IdList_item)(sqlite3DbMallocRawNN(db, uint64(uint(p.nId)*12)))
	if uintptr(unsafe.Pointer(pNew.a)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3DbFreeNN(db, unsafe.Pointer(pNew))
		return (*struct_IdList)(nil)
	}
	for i = int32(0); i < p.nId; i++ {
		var pNewItem *struct_IdList_item = &*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.a)) + uintptr(i)*12))
		var pOldItem *struct_IdList_item = &*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(p.a)) + uintptr(i)*12))
		pNewItem.zName = sqlite3DbStrDup(db, pOldItem.zName)
		pNewItem.idx = pOldItem.idx
	}
	return pNew
}
func sqlite3SelectDup(db *struct_sqlite3, pDup *struct_Select, flags int32) *struct_Select {
	var pRet *struct_Select = nil
	var pNext *struct_Select = nil
	var pp **struct_Select = &pRet
	var p *struct_Select
	func() int {
		_ = 0
		return 0
	}()
	for p = pDup; p != nil; p = p.pPrior {
		var pNew *struct_Select = (*struct_Select)(sqlite3DbMallocRawNN(db, uint64(128)))
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		pNew.pEList = sqlite3ExprListDup(db, p.pEList, flags)
		pNew.pSrc = sqlite3SrcListDup(db, p.pSrc, flags)
		pNew.pWhere = sqlite3ExprDup(db, p.pWhere, flags)
		pNew.pGroupBy = sqlite3ExprListDup(db, p.pGroupBy, flags)
		pNew.pHaving = sqlite3ExprDup(db, p.pHaving, flags)
		pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, flags)
		pNew.op = p.op
		pNew.pNext = pNext
		pNew.pPrior = (*struct_Select)(nil)
		pNew.pLimit = sqlite3ExprDup(db, p.pLimit, flags)
		pNew.iLimit = int32(0)
		pNew.iOffset = int32(0)
		pNew.selFlags = p.selFlags & uint32(4294967263)
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pNew.addrOpenEphm)))) + uintptr(0)*4)) = int32(-1)
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pNew.addrOpenEphm)))) + uintptr(1)*4)) = int32(-1)
		pNew.nSelectRow = p.nSelectRow
		pNew.pWith = sqlite3WithDup(db, p.pWith)
		pNew.pWin = (*struct_Window)(nil)
		pNew.pWinDefn = sqlite3WindowListDup(db, p.pWinDefn)
		if p.pWin != nil && int32(db.mallocFailed) == 0 {
			gatherSelectWindows(pNew)
		}
		pNew.selId = p.selId
		if db.mallocFailed != 0 {
			pNew.pNext = (*struct_Select)(nil)
			sqlite3SelectDelete(db, pNew)
			break
		}
		*pp = pNew
		pp = &pNew.pPrior
		pNext = pNew
	}
	return pRet
}

var zeroItem struct_ExprList_item = struct_ExprList_item{nil, nil, 0, 0, _cgoa_19{}}

func sqlite3ExprListAppendNew(db *struct_sqlite3, pExpr *struct_Expr) *struct_ExprList {
	var pItem *struct_ExprList_item
	var pList *struct_ExprList
	pList = (*struct_ExprList)(sqlite3DbMallocRawNN(db, uint64(36+28*uint(4))))
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ExprDelete(db, pExpr)
		return (*struct_ExprList)(nil)
	}
	pList.nAlloc = int32(4)
	pList.nExpr = int32(1)
	pItem = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))
	*pItem = zeroItem
	pItem.pExpr = pExpr
	return pList
}
func sqlite3ExprListAppendGrow(db *struct_sqlite3, pList *struct_ExprList, pExpr *struct_Expr) *struct_ExprList {
	var pItem *struct_ExprList_item
	var pNew *struct_ExprList
	pList.nAlloc *= int32(2)
	pNew = (*struct_ExprList)(sqlite3DbRealloc(db, unsafe.Pointer(pList), uint64(36+uint(pList.nAlloc-1)*28)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ExprListDelete(db, pList)
		sqlite3ExprDelete(db, pExpr)
		return (*struct_ExprList)(nil)
	} else {
		pList = pNew
	}
	pItem = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &pList.nExpr
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*28))
	*pItem = zeroItem
	pItem.pExpr = pExpr
	return pList
}
func sqlite3ExprListAppend(pParse *struct_Parse, pList *struct_ExprList, pExpr *struct_Expr) *struct_ExprList {
	var pItem *struct_ExprList_item
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3ExprListAppendNew(pParse.db, pExpr)
	}
	if pList.nAlloc < pList.nExpr+1 {
		return sqlite3ExprListAppendGrow(pParse.db, pList, pExpr)
	}
	pItem = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &pList.nExpr
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*28))
	*pItem = zeroItem
	pItem.pExpr = pExpr
	return pList
}
func sqlite3ExprListAppendVector(pParse *struct_Parse, pList *struct_ExprList, pColumns *struct_IdList, pExpr *struct_Expr) *struct_ExprList {
	var db *struct_sqlite3 = pParse.db
	var n int32
	var i int32
	var iFirst int32 = func() int32 {
		if pList != nil {
			return pList.nExpr
		} else {
			return 0
		}
	}()
	if uintptr(unsafe.Pointer(pColumns)) == uintptr(unsafe.Pointer(nil)) {
		goto vector_append_error
	}
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		goto vector_append_error
	}
	if int32(pExpr.op) != 138 && pColumns.nId != func() (_cgo_ret int32) {
		_cgo_addr := &n
		*_cgo_addr = sqlite3ExprVectorSize(pExpr)
		return *_cgo_addr
	}() {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', '%', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 's', '\x00'})), pColumns.nId, n)
		goto vector_append_error
	}
	for i = int32(0); i < pColumns.nId; i++ {
		var pSubExpr *struct_Expr = sqlite3ExprForVectorField(pParse, pExpr, i, pColumns.nId)
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pSubExpr)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		pList = sqlite3ExprListAppend(pParse, pList, pSubExpr)
		if pList != nil {
			func() int {
				_ = 0
				return 0
			}()
			(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(pList.nExpr-1)*28))).zEName = (*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumns.a)) + uintptr(i)*12))).zName
			(*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumns.a)) + uintptr(i)*12))).zName = (*int8)(nil)
		}
	}
	if !(db.mallocFailed != 0) && int32(pExpr.op) == 138 && uintptr(unsafe.Pointer(pList)) != uintptr(unsafe.Pointer(nil)) {
		var pFirst *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(iFirst)*28))).pExpr
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pFirst.pRight = pExpr
		pExpr = (*struct_Expr)(nil)
		pFirst.iTable = pColumns.nId
	}
vector_append_error:
	sqlite3ExprUnmapAndDelete(pParse, pExpr)
	sqlite3IdListDelete(db, pColumns)
	return pList
}
func sqlite3ExprListSetSortOrder(p *struct_ExprList, iSortOrder int32, eNulls int32) {
	var pItem *struct_ExprList_item
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pItem = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.a)))) + uintptr(p.nExpr-1)*28))
	func() int {
		_ = 0
		return 0
	}()
	if iSortOrder == -1 {
		iSortOrder = int32(0)
	}
	pItem.sortFlags = uint8(iSortOrder)
	if eNulls != -1 {
		{
			_autoGo_41 := &pItem.Xbf_0
			*_autoGo_41 = *_autoGo_41&^32 | uint32(1)&1<<5
		}
		if iSortOrder != eNulls {
			pItem.sortFlags |= uint8(2)
		}
	}
}
func sqlite3ExprListSetName(pParse *struct_Parse, pList *struct_ExprList, pName *struct_Token, dequote int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pList != nil {
		var pItem *struct_ExprList_item
		func() int {
			_ = 0
			return 0
		}()
		pItem = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(pList.nExpr-1)*28))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pItem.zEName = sqlite3DbStrNDup(pParse.db, pName.z, uint64(pName.n))
		if dequote != 0 {
			sqlite3Dequote(pItem.zEName)
			if int32(pParse.eParseMode) >= 2 {
				sqlite3RenameTokenMap(pParse, unsafe.Pointer(pItem.zEName), pName)
			}
		}
	}
}
func sqlite3ExprListSetSpan(pParse *struct_Parse, pList *struct_ExprList, zStart *int8, zEnd *int8) {
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pList != nil {
		var pItem *struct_ExprList_item = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(pList.nExpr-1)*28))
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pItem.zEName)) == uintptr(unsafe.Pointer(nil)) {
			pItem.zEName = sqlite3DbSpanDup(db, zStart, zEnd)
			{
				_autoGo_42 := &pItem.Xbf_0
				*_autoGo_42 = *_autoGo_42&^3 | uint32(1)&3
			}
		}
	}
}
func sqlite3ExprListCheckLength(pParse *struct_Parse, pEList *struct_ExprList, zObject *int8) {
	var mx int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.db.aLimit)))) + uintptr(2)*4))
	if pEList != nil && pEList.nExpr > mx {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[23]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'i', 'n', ' ', '%', 's', '\x00'})), zObject)
	}
}
func exprListDeleteNN(db *struct_sqlite3, pList *struct_ExprList) {
	var i int32 = pList.nExpr
	var pItem *struct_ExprList_item = (*struct_ExprList_item)(unsafe.Pointer(&pList.a))
	func() int {
		_ = 0
		return 0
	}()
	for {
		sqlite3ExprDelete(db, pItem.pExpr)
		sqlite3DbFree(db, unsafe.Pointer(pItem.zEName))
		*(*uintptr)(unsafe.Pointer(&pItem)) += 28
		if !(func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr--
			return *_cgo_addr
		}() > 0) {
			break
		}
	}
	sqlite3DbFreeNN(db, unsafe.Pointer(pList))
}
func sqlite3ExprListDelete(db *struct_sqlite3, pList *struct_ExprList) {
	if pList != nil {
		exprListDeleteNN(db, pList)
	}
}
func sqlite3ExprListFlags(pList *struct_ExprList) uint32 {
	var i int32
	var m uint32 = uint32(0)
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < pList.nExpr; i++ {
		var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr
		func() int {
			_ = 0
			return 0
		}()
		m |= pExpr.flags
	}
	return m
}
func sqlite3SelectWalkFail(pWalker *struct_Walker, NotUsed *struct_Select) int32 {
	func() int {
		_ = NotUsed
		return 0
	}()
	pWalker.eCode = uint16(0)
	return int32(2)
}
func sqlite3IsTrueOrFalse(zIn *int8) uint32 {
	if sqlite3StrICmp(zIn, (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'u', 'e', '\x00'}))) == 0 {
		return uint32(268435456)
	}
	if sqlite3StrICmp(zIn, (*int8)(unsafe.Pointer(&[6]int8{'f', 'a', 'l', 's', 'e', '\x00'}))) == 0 {
		return uint32(536870912)
	}
	return uint32(0)
}
func sqlite3ExprIdToTrueFalse(pExpr *struct_Expr) int32 {
	var v uint32
	func() int {
		_ = 0
		return 0
	}()
	if !(pExpr.flags&uint32(67108864|1024) != uint32(0)) && func() (_cgo_ret uint32) {
		_cgo_addr := &v
		*_cgo_addr = sqlite3IsTrueOrFalse(pExpr.u.zToken)
		return *_cgo_addr
	}() != uint32(0) {
		pExpr.op = uint8(170)
		pExpr.flags |= v
		return int32(1)
	}
	return int32(0)
}
func sqlite3ExprTruthValue(pExpr *struct_Expr) int32 {
	pExpr = sqlite3ExprSkipCollate((*struct_Expr)(unsafe.Pointer(pExpr)))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pExpr.u.zToken)) + uintptr(4)))) == 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3ExprSimplifiedAndOr(pExpr *struct_Expr) *struct_Expr {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pExpr.op) == 44 || int32(pExpr.op) == 43 {
		var pRight *struct_Expr = sqlite3ExprSimplifiedAndOr(pExpr.pRight)
		var pLeft *struct_Expr = sqlite3ExprSimplifiedAndOr(pExpr.pLeft)
		if pLeft.flags&uint32(1|268435456) == uint32(268435456) || pRight.flags&uint32(1|536870912) == uint32(536870912) {
			pExpr = func() *struct_Expr {
				if int32(pExpr.op) == 44 {
					return pRight
				} else {
					return pLeft
				}
			}()
		} else if pRight.flags&uint32(1|268435456) == uint32(268435456) || pLeft.flags&uint32(1|536870912) == uint32(536870912) {
			pExpr = func() *struct_Expr {
				if int32(pExpr.op) == 44 {
					return pLeft
				} else {
					return pRight
				}
			}()
		}
	}
	return pExpr
}
func exprNodeIsConstant(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pWalker.eCode) == 2 && pExpr.flags&uint32(1) != uint32(0) {
		pWalker.eCode = uint16(0)
		return int32(2)
	}
	switch int32(pExpr.op) {
	case 172:
		if (int32(pWalker.eCode) >= 4 || pExpr.flags&uint32(524288) != uint32(0)) && !(pExpr.flags&uint32(16777216) != uint32(0)) {
			if int32(pWalker.eCode) == 5 {
				pExpr.flags |= uint32(1073741824)
			}
			return int32(0)
		} else {
			pWalker.eCode = uint16(0)
			return int32(2)
		}
	case 59:
		if sqlite3ExprIdToTrueFalse(pExpr) != 0 {
			return int32(1)
		}
	case 167:
		fallthrough
	case 168:
		fallthrough
	case 169:
		if pExpr.flags&uint32(8) != uint32(0) && int32(pWalker.eCode) != 2 {
			return int32(0)
		}
		if int32(pWalker.eCode) == 3 && pExpr.iTable == *(*int32)(unsafe.Pointer(&pWalker.u)) {
			return int32(0)
		}
	case 179:
		fallthrough
	case 176:
		fallthrough
	case 141:
		pWalker.eCode = uint16(0)
		return int32(2)
	case 156:
		if int32(pWalker.eCode) == 5 {
			pExpr.op = uint8(121)
		} else if int32(pWalker.eCode) == 4 {
			pWalker.eCode = uint16(0)
			return int32(2)
		}
	default:
		return int32(0)
	}
}
func exprIsConst(p *struct_Expr, initFlag int32, iCur int32) int32 {
	var w struct_Walker
	w.eCode = uint16(initFlag)
	w.xExprCallback = exprNodeIsConstant
	w.xSelectCallback = sqlite3SelectWalkFail
	*(*int32)(unsafe.Pointer(&w.u)) = iCur
	sqlite3WalkExpr(&w, p)
	return int32(w.eCode)
}
func sqlite3ExprIsConstant(p *struct_Expr) int32 {
	return exprIsConst(p, 1, 0)
}
func sqlite3ExprIsConstantNotJoin(p *struct_Expr) int32 {
	return exprIsConst(p, 2, 0)
}
func sqlite3ExprIsTableConstant(p *struct_Expr, iCur int32) int32 {
	return exprIsConst(p, 3, iCur)
}
func exprNodeIsConstantOrGroupBy(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var pGroupBy *struct_ExprList = *(**struct_ExprList)(unsafe.Pointer(&pWalker.u))
	var i int32
	for i = int32(0); i < pGroupBy.nExpr; i++ {
		var p *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pGroupBy.a)))) + uintptr(i)*28))).pExpr
		if sqlite3ExprCompare(nil, pExpr, p, -1) < 2 {
			var pColl *struct_CollSeq = sqlite3ExprNNCollSeq(pWalker.pParse, p)
			if sqlite3IsBinary(pColl) != 0 {
				return int32(1)
			}
		}
	}
	if pExpr.flags&uint32(2048) != uint32(0) {
		pWalker.eCode = uint16(0)
		return int32(2)
	}
	return exprNodeIsConstant(pWalker, pExpr)
}
func sqlite3ExprIsConstantOrGroupBy(pParse *struct_Parse, p *struct_Expr, pGroupBy *struct_ExprList) int32 {
	var w struct_Walker
	w.eCode = uint16(1)
	w.xExprCallback = exprNodeIsConstantOrGroupBy
	w.xSelectCallback = (func(*struct_Walker, *struct_Select) int32)(nil)
	*(**struct_ExprList)(unsafe.Pointer(&w.u)) = pGroupBy
	w.pParse = pParse
	sqlite3WalkExpr(&w, p)
	return int32(w.eCode)
}
func sqlite3ExprIsConstantOrFunction(p *struct_Expr, isInit uint8) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return exprIsConst(p, 4+int32(isInit), 0)
}
func sqlite3ExprIsInteger(p *struct_Expr, pValue *int32) int32 {
	var rc int32 = 0
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.flags&uint32(1024) != 0 {
		*pValue = *(*int32)(unsafe.Pointer(&p.u))
		return int32(1)
	}
	switch int32(p.op) {
	case 174:
		{
			rc = sqlite3ExprIsInteger(p.pLeft, pValue)
			break
		}
	case 173:
		{
			var v int32 = 0
			if sqlite3ExprIsInteger(p.pLeft, &v) != 0 {
				func() int {
					_ = 0
					return 0
				}()
				*pValue = -v
				rc = int32(1)
			}
			break
		}
	default:
		break
	}
	return rc
}
func sqlite3ExprCanBeNull(p *struct_Expr) int32 {
	var op uint8
	func() int {
		_ = 0
		return 0
	}()
	for int32(p.op) == 174 || int32(p.op) == 173 {
		p = p.pLeft
		func() int {
			_ = 0
			return 0
		}()
	}
	op = p.op
	if int32(op) == 176 {
		op = p.op2
	}
	switch int32(op) {
	case 155:
		fallthrough
	case 117:
		fallthrough
	case 153:
		fallthrough
	case 154:
		return int32(0)
	case 167:
		func() int {
			_ = 0
			return 0
		}()
		return func() int32 {
			if p.flags&uint32(1048576) != uint32(0) || uintptr(unsafe.Pointer(p.y.pTab)) == uintptr(unsafe.Pointer(nil)) || int32(p.iColumn) >= 0 && uintptr(unsafe.Pointer(p.y.pTab.aCol)) != uintptr(unsafe.Pointer(nil)) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.y.pTab.aCol)) + uintptr(p.iColumn)*20))).Xbf_0&15) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	default:
		return int32(1)
	}
}
func sqlite3ExprNeedsNoAffinityChange(p *struct_Expr, aff int8) int32 {
	var op uint8
	var unaryMinus int32 = 0
	if int32(aff) == 65 {
		return int32(1)
	}
	for int32(p.op) == 174 || int32(p.op) == 173 {
		if int32(p.op) == 173 {
			unaryMinus = int32(1)
		}
		p = p.pLeft
	}
	op = p.op
	if int32(op) == 176 {
		op = p.op2
	}
	switch int32(op) {
	case 155:
		{
			return func() int32 {
				if int32(aff) >= 67 {
					return 1
				} else {
					return 0
				}
			}()
		}
	case 153:
		{
			return func() int32 {
				if int32(aff) >= 67 {
					return 1
				} else {
					return 0
				}
			}()
		}
	case 117:
		{
			return func() int32 {
				if !(unaryMinus != 0) && int32(aff) == 66 {
					return 1
				} else {
					return 0
				}
			}()
		}
	case 154:
		{
			return func() int32 {
				if !(unaryMinus != 0) {
					return 1
				} else {
					return 0
				}
			}()
		}
	case 167:
		{
			func() int {
				_ = 0
				return 0
			}()
			return func() int32 {
				if int32(aff) >= 67 && int32(p.iColumn) < 0 {
					return 1
				} else {
					return 0
				}
			}()
		}
	default:
		{
			return int32(0)
		}
	}
}
func sqlite3IsRowid(z *int8) int32 {
	if sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[8]int8{'_', 'R', 'O', 'W', 'I', 'D', '_', '\x00'}))) == 0 {
		return int32(1)
	}
	if sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[6]int8{'R', 'O', 'W', 'I', 'D', '\x00'}))) == 0 {
		return int32(1)
	}
	if sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[4]int8{'O', 'I', 'D', '\x00'}))) == 0 {
		return int32(1)
	}
	return int32(0)
}
func isCandidateForInOpt(pX *struct_Expr) *struct_Select {
	var p *struct_Select
	var pSrc *struct_SrcList
	var pEList *struct_ExprList
	var pTab *struct_Table
	var i int32
	if !(pX.flags&uint32(2048) != uint32(0)) {
		return (*struct_Select)(nil)
	}
	if pX.flags&uint32(32) != uint32(0) {
		return (*struct_Select)(nil)
	}
	p = *(**struct_Select)(unsafe.Pointer(&pX.x))
	if p.pPrior != nil {
		return (*struct_Select)(nil)
	}
	if p.selFlags&uint32(1|8) != 0 {
		return (*struct_Select)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	if p.pLimit != nil {
		return (*struct_Select)(nil)
	}
	if p.pWhere != nil {
		return (*struct_Select)(nil)
	}
	pSrc = p.pSrc
	func() int {
		_ = 0
		return 0
	}()
	if pSrc.nSrc != 1 {
		return (*struct_Select)(nil)
	}
	if (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).pSelect != nil {
		return (*struct_Select)(nil)
	}
	pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).pTab
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTab.eTabType) == 1 {
		return (*struct_Select)(nil)
	}
	pEList = p.pEList
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < pEList.nExpr; i++ {
		var pRes *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr
		if int32(pRes.op) != 167 {
			return (*struct_Select)(nil)
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	return p
}
func sqlite3SetHasNullFlag(v *struct_Vdbe, iCur int32, regHasNull int32) {
	var addr1 int32
	sqlite3VdbeAddOp2(v, 71, 0, regHasNull)
	addr1 = sqlite3VdbeAddOp1(v, 38, iCur)
	sqlite3VdbeAddOp3(v, 93, iCur, 0, regHasNull)
	sqlite3VdbeChangeP5(v, uint16(128))
	sqlite3VdbeJumpHere(v, addr1)
}
func sqlite3InRhsIsConstant(pIn *struct_Expr) int32 {
	var pLHS *struct_Expr
	var res int32
	func() int {
		_ = 0
		return 0
	}()
	pLHS = pIn.pLeft
	pIn.pLeft = (*struct_Expr)(nil)
	res = sqlite3ExprIsConstant(pIn)
	pIn.pLeft = pLHS
	return res
}
func sqlite3FindInIndex(pParse *struct_Parse, pX *struct_Expr, inFlags uint32, prRhsHasNull *int32, aiMap *int32, piTab *int32) int32 {
	var p *struct_Select
	var eType int32 = 0
	var iTab int32 = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var mustBeUnique int32
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	func() int {
		_ = 0
		return 0
	}()
	mustBeUnique = func() int32 {
		if inFlags&uint32(4) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	if prRhsHasNull != nil && pX.flags&uint32(2048) != uint32(0) {
		var i int32
		var pEList *struct_ExprList = (*(**struct_Select)(unsafe.Pointer(&pX.x))).pEList
		for i = int32(0); i < pEList.nExpr; i++ {
			if sqlite3ExprCanBeNull((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr) != 0 {
				break
			}
		}
		if i == pEList.nExpr {
			prRhsHasNull = (*int32)(nil)
		}
	}
	if pParse.nErr == 0 && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Select) {
		_cgo_addr := &p
		*_cgo_addr = isCandidateForInOpt(pX)
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		var db *struct_sqlite3 = pParse.db
		var pTab *struct_Table
		var iDb int32
		var pEList *struct_ExprList = p.pEList
		var nExpr int32 = pEList.nExpr
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pTab
		iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3CodeVerifySchema(pParse, iDb)
		sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(0), pTab.zName)
		func() int {
			_ = 0
			return 0
		}()
		if nExpr == 1 && int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(0)*28))).pExpr.iColumn) < 0 {
			var iAddr int32 = sqlite3VdbeAddOp0(v, 17)
			sqlite3OpenTable(pParse, iTab, iDb, pTab, 101)
			eType = int32(1)
			sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[47]int8{'U', 'S', 'I', 'N', 'G', ' ', 'R', 'O', 'W', 'I', 'D', ' ', 'S', 'E', 'A', 'R', 'C', 'H', ' ', 'O', 'N', ' ', 'T', 'A', 'B', 'L', 'E', ' ', '%', 's', ' ', 'F', 'O', 'R', ' ', 'I', 'N', '-', 'O', 'P', 'E', 'R', 'A', 'T', 'O', 'R', '\x00'})), pTab.zName)
			sqlite3VdbeJumpHere(v, iAddr)
		} else {
			var pIdx *struct_Index
			var affinity_ok int32 = 1
			var i int32
			for i = int32(0); i < nExpr && affinity_ok != 0; i++ {
				var pLhs *struct_Expr = sqlite3VectorFieldSubexpr(pX.pLeft, i)
				var iCol int32 = int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr.iColumn)
				var idxaff int8 = sqlite3TableColumnAffinity(pTab, iCol)
				var cmpaff int8 = sqlite3CompareAffinity(pLhs, idxaff)
				switch int32(cmpaff) {
				case 65:
					break
				case 66:
					func() int {
						_ = 0
						return 0
					}()
					break
				default:
					affinity_ok = func() int32 {
						if int32(idxaff) >= 67 {
							return 1
						} else {
							return 0
						}
					}()
				}
			}
			if affinity_ok != 0 {
				for pIdx = pTab.pIndex; pIdx != nil && eType == 0; pIdx = pIdx.pNext {
					var colUsed uint64
					var mCol uint64
					if int32(pIdx.nColumn) < nExpr {
						continue
					}
					if uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) != uintptr(unsafe.Pointer(nil)) {
						continue
					}
					if int32(pIdx.nColumn) >= int32(8*uint(8))-1 {
						continue
					}
					if mustBeUnique != 0 {
						if int32(pIdx.nKeyCol) > nExpr || int32(pIdx.nColumn) > nExpr && !(int32(pIdx.onError) != 0) {
							continue
						}
					}
					colUsed = uint64(0)
					for i = int32(0); i < nExpr; i++ {
						var pLhs *struct_Expr = sqlite3VectorFieldSubexpr(pX.pLeft, i)
						var pRhs *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr
						var pReq *struct_CollSeq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs)
						var j int32
						func() int {
							_ = 0
							return 0
						}()
						for j = int32(0); j < nExpr; j++ {
							if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2))) != int32(pRhs.iColumn) {
								continue
							}
							func() int {
								_ = 0
								return 0
							}()
							if uintptr(unsafe.Pointer(pReq)) != uintptr(unsafe.Pointer(nil)) && sqlite3StrICmp(pReq.zName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(j)*8))) != 0 {
								continue
							}
							break
						}
						if j == nExpr {
							break
						}
						mCol = uint64(1) << j
						if mCol&colUsed != 0 {
							break
						}
						colUsed |= mCol
						if aiMap != nil {
							*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiMap)) + uintptr(i)*4)) = j
						}
					}
					func() int {
						_ = 0
						return 0
					}()
					if colUsed == uint64(1)<<nExpr-uint64(1) {
						var iAddr int32 = sqlite3VdbeAddOp0(v, 17)
						sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[31]int8{'U', 'S', 'I', 'N', 'G', ' ', 'I', 'N', 'D', 'E', 'X', ' ', '%', 's', ' ', 'F', 'O', 'R', ' ', 'I', 'N', '-', 'O', 'P', 'E', 'R', 'A', 'T', 'O', 'R', '\x00'})), pIdx.zName)
						sqlite3VdbeAddOp3(v, 101, iTab, int32(pIdx.tnum), iDb)
						sqlite3VdbeSetP4KeyInfo(pParse, pIdx)
						func() int {
							_ = 0
							return 0
						}()
						eType = 3 + int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(0))))
						if prRhsHasNull != nil {
							*prRhsHasNull = func() (_cgo_ret int32) {
								_cgo_addr := &pParse.nMem
								*_cgo_addr++
								return *_cgo_addr
							}()
							if nExpr == 1 {
								sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull)
							}
						}
						sqlite3VdbeJumpHere(v, iAddr)
					}
				}
			}
		}
	}
	if eType == 0 && inFlags&uint32(1) != 0 && pX.flags&uint32(2048) == uint32(0) && (!(sqlite3InRhsIsConstant(pX) != 0) || pX.x.pList.nExpr <= 2) {
		eType = int32(5)
	}
	if eType == 0 {
		var savedNQueryLoop uint32 = pParse.nQueryLoop
		var rMayHaveNull int32 = 0
		eType = int32(2)
		if inFlags&uint32(4) != 0 {
			pParse.nQueryLoop = uint32(0)
		} else if prRhsHasNull != nil {
			*prRhsHasNull = func() (_cgo_ret int32) {
				_cgo_addr := &rMayHaveNull
				*_cgo_addr = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
				return *_cgo_addr
			}()
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3CodeRhsOfIN(pParse, pX, iTab)
		if rMayHaveNull != 0 {
			sqlite3SetHasNullFlag(v, iTab, rMayHaveNull)
		}
		pParse.nQueryLoop = savedNQueryLoop
	}
	if aiMap != nil && eType != 3 && eType != 4 {
		var i int32
		var n int32
		n = sqlite3ExprVectorSize(pX.pLeft)
		for i = int32(0); i < n; i++ {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiMap)) + uintptr(i)*4)) = i
		}
	}
	*piTab = iTab
	return eType
}
func exprINAffinity(pParse *struct_Parse, pExpr *struct_Expr) *int8 {
	var pLeft *struct_Expr = pExpr.pLeft
	var nVal int32 = sqlite3ExprVectorSize(pLeft)
	var pSelect *struct_Select = func() *struct_Select {
		if pExpr.flags&uint32(2048) != uint32(0) {
			return *(**struct_Select)(unsafe.Pointer(&pExpr.x))
		} else {
			return nil
		}
	}()
	var zRet *int8
	func() int {
		_ = 0
		return 0
	}()
	zRet = (*int8)(sqlite3DbMallocRaw(pParse.db, uint64(nVal+1)))
	if zRet != nil {
		var i int32
		for i = int32(0); i < nVal; i++ {
			var pA *struct_Expr = sqlite3VectorFieldSubexpr(pLeft, i)
			var a int8 = sqlite3ExprAffinity(pA)
			if pSelect != nil {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRet)) + uintptr(i))) = sqlite3CompareAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSelect.pEList.a)))) + uintptr(i)*28))).pExpr, a)
			} else {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRet)) + uintptr(i))) = a
			}
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRet)) + uintptr(nVal))) = int8('\x00')
	}
	return zRet
}
func sqlite3SubselectError(pParse *struct_Parse, nActual int32, nExpect int32) {
	if pParse.nErr == 0 {
		var zFmt *int8 = (*int8)(unsafe.Pointer(&[44]int8{'s', 'u', 'b', '-', 's', 'e', 'l', 'e', 'c', 't', ' ', 'r', 'e', 't', 'u', 'r', 'n', 's', ' ', '%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', '-', ' ', 'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', '%', 'd', '\x00'}))
		sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect)
	}
}
func sqlite3VectorErrorMsg(pParse *struct_Parse, pExpr *struct_Expr) {
	if pExpr.flags&uint32(2048) != uint32(0) {
		sqlite3SubselectError(pParse, (*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pEList.nExpr, 1)
	} else {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'r', 'o', 'w', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'i', 's', 'u', 's', 'e', 'd', '\x00'})))
	}
}
func sqlite3CodeRhsOfIN(pParse *struct_Parse, pExpr *struct_Expr, iTab int32) {
	var addrOnce int32 = 0
	var addr int32
	var pLeft *struct_Expr
	var pKeyInfo *struct_KeyInfo = nil
	var nVal int32
	var v *struct_Vdbe
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	if !(pExpr.flags&uint32(32) != uint32(0)) && pParse.iSelfTab == 0 {
		if pExpr.flags&uint32(33554432) != uint32(0) {
			addrOnce = sqlite3VdbeAddOp0(v, 17)
			if pExpr.flags&uint32(2048) != uint32(0) {
				sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[23]int8{'R', 'E', 'U', 'S', 'E', ' ', 'L', 'I', 'S', 'T', ' ', 'S', 'U', 'B', 'Q', 'U', 'E', 'R', 'Y', ' ', '%', 'd', '\x00'})), (*(**struct_Select)(unsafe.Pointer(&pExpr.x))).selId)
			}
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 12, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).iAddr)
			sqlite3VdbeAddOp2(v, 113, iTab, pExpr.iTable)
			sqlite3VdbeJumpHere(v, addrOnce)
			return
		}
		func() int {
			_ = 0
			return 0
		}()
		pExpr.flags |= uint32(33554432)
		func() int {
			_ = 0
			return 0
		}()
		(*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		(*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).iAddr = sqlite3VdbeAddOp2(v, 71, 0, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn) + 1
		addrOnce = sqlite3VdbeAddOp0(v, 17)
	}
	pLeft = pExpr.pLeft
	nVal = sqlite3ExprVectorSize(pLeft)
	pExpr.iTable = iTab
	addr = sqlite3VdbeAddOp2(v, 116, pExpr.iTable, nVal)
	pKeyInfo = sqlite3KeyInfoAlloc(pParse.db, nVal, 1)
	if pExpr.flags&uint32(2048) != uint32(0) {
		var pSelect *struct_Select = *(**struct_Select)(unsafe.Pointer(&pExpr.x))
		var pEList *struct_ExprList = pSelect.pEList
		sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[19]int8{'%', 's', 'L', 'I', 'S', 'T', ' ', 'S', 'U', 'B', 'Q', 'U', 'E', 'R', 'Y', ' ', '%', 'd', '\x00'})), func() *int8 {
			if addrOnce != 0 {
				return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[12]int8{'C', 'O', 'R', 'R', 'E', 'L', 'A', 'T', 'E', 'D', ' ', '\x00'}))
			}
		}(), pSelect.selId)
		if pEList.nExpr == nVal {
			var pCopy *struct_Select
			var dest struct_SelectDest
			var i int32
			var rc int32
			sqlite3SelectDestInit(&dest, 11, iTab)
			dest.zAffSdst = exprINAffinity(pParse, pExpr)
			pSelect.iLimit = int32(0)
			pCopy = sqlite3SelectDup(pParse.db, pSelect, 0)
			rc = func() int32 {
				if int32(pParse.db.mallocFailed) != 0 {
					return 1
				} else {
					return sqlite3Select(pParse, pCopy, &dest)
				}
			}()
			sqlite3SelectDelete(pParse.db, pCopy)
			sqlite3DbFree(pParse.db, unsafe.Pointer(dest.zAffSdst))
			if rc != 0 {
				sqlite3KeyInfoUnref(pKeyInfo)
				return
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < nVal; i++ {
				var p *struct_Expr = sqlite3VectorFieldSubexpr(pLeft, i)
				*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(i)*8)) = sqlite3BinaryCompareCollSeq(pParse, p, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr)
			}
		}
	} else if uintptr(unsafe.Pointer(pExpr.x.pList)) != uintptr(unsafe.Pointer(nil)) {
		var affinity int8
		var i int32
		var pList *struct_ExprList = pExpr.x.pList
		var pItem *struct_ExprList_item
		var r1 int32
		var r2 int32
		affinity = sqlite3ExprAffinity(pLeft)
		if int32(affinity) <= 64 {
			affinity = int8(65)
		} else if int32(affinity) == 69 {
			affinity = int8(67)
		}
		if pKeyInfo != nil {
			func() int {
				_ = 0
				return 0
			}()
			*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl)))) + uintptr(0)*8)) = sqlite3ExprCollSeq(pParse, pExpr.pLeft)
		}
		r1 = sqlite3GetTempReg(pParse)
		r2 = sqlite3GetTempReg(pParse)
		for func() *struct_ExprList_item {
			i = pList.nExpr
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pList.a))
				return *_cgo_addr
			}()
		}(); i > 0; func() *struct_ExprList_item {
			i--
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}() {
			var pE2 *struct_Expr = pItem.pExpr
			if addrOnce != 0 && !(sqlite3ExprIsConstant(pE2) != 0) {
				sqlite3VdbeChangeToNoop(v, addrOnce)
				pExpr.flags &= uint32(4261412863)
				addrOnce = int32(0)
			}
			sqlite3ExprCode(pParse, pE2, r1)
			sqlite3VdbeAddOp4(v, 96, r1, 1, r2, &affinity, 1)
			sqlite3VdbeAddOp4Int(v, 137, iTab, r2, r1, 1)
		}
		sqlite3ReleaseTempReg(pParse, r1)
		sqlite3ReleaseTempReg(pParse, r2)
	}
	if pKeyInfo != nil {
		sqlite3VdbeChangeP4(v, addr, (*int8)(unsafe.Pointer(pKeyInfo)), -9)
	}
	if addrOnce != 0 {
		sqlite3VdbeJumpHere(v, addrOnce)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp1(v, 67, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn)
		sqlite3VdbeChangeP1(v, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).iAddr-1, sqlite3VdbeCurrentAddr(v)-1)
		sqlite3ClearTempRegCache(pParse)
	}
}
func sqlite3CodeSubselect(pParse *struct_Parse, pExpr *struct_Expr) int32 {
	var addrOnce int32 = 0
	var rReg int32 = 0
	var pSel *struct_Select
	var dest struct_SelectDest
	var nReg int32
	var pLimit *struct_Expr
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pSel = *(**struct_Select)(unsafe.Pointer(&pExpr.x))
	if pExpr.flags&uint32(33554432) != uint32(0) {
		sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[18]int8{'R', 'E', 'U', 'S', 'E', ' ', 'S', 'U', 'B', 'Q', 'U', 'E', 'R', 'Y', ' ', '%', 'd', '\x00'})), pSel.selId)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp2(v, 12, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).iAddr)
		return pExpr.iTable
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pExpr.flags |= uint32(33554432)
	(*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	(*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).iAddr = sqlite3VdbeAddOp2(v, 71, 0, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn) + 1
	if !(pExpr.flags&uint32(32) != uint32(0)) {
		addrOnce = sqlite3VdbeAddOp0(v, 17)
	}
	sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[21]int8{'%', 's', 'S', 'C', 'A', 'L', 'A', 'R', ' ', 'S', 'U', 'B', 'Q', 'U', 'E', 'R', 'Y', ' ', '%', 'd', '\x00'})), func() *int8 {
		if addrOnce != 0 {
			return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
		} else {
			return (*int8)(unsafe.Pointer(&[12]int8{'C', 'O', 'R', 'R', 'E', 'L', 'A', 'T', 'E', 'D', ' ', '\x00'}))
		}
	}(), pSel.selId)
	nReg = func() int32 {
		if int32(pExpr.op) == 138 {
			return pSel.pEList.nExpr
		} else {
			return 1
		}
	}()
	sqlite3SelectDestInit(&dest, 0, pParse.nMem+1)
	pParse.nMem += nReg
	if int32(pExpr.op) == 138 {
		dest.eDest = uint8(10)
		dest.iSdst = dest.iSDParm
		dest.nSdst = nReg
		sqlite3VdbeAddOp3(v, 74, 0, dest.iSDParm, dest.iSDParm+nReg-1)
	} else {
		dest.eDest = uint8(3)
		sqlite3VdbeAddOp2(v, 71, 0, dest.iSDParm)
	}
	if pSel.pLimit != nil {
		var db *struct_sqlite3 = pParse.db
		pLimit = sqlite3Expr(db, 155, (*int8)(unsafe.Pointer(&[2]int8{'0', '\x00'})))
		if pLimit != nil {
			pLimit.affExpr = int8(67)
			pLimit = sqlite3PExpr(pParse, 52, sqlite3ExprDup(db, pSel.pLimit.pLeft, 0), pLimit)
		}
		sqlite3ExprDelete(db, pSel.pLimit.pLeft)
		pSel.pLimit.pLeft = pLimit
	} else {
		pLimit = sqlite3Expr(pParse.db, 155, (*int8)(unsafe.Pointer(&[2]int8{'1', '\x00'})))
		pSel.pLimit = sqlite3PExpr(pParse, 148, pLimit, nil)
	}
	pSel.iLimit = int32(0)
	if sqlite3Select(pParse, pSel, &dest) != 0 {
		pExpr.op2 = pExpr.op
		pExpr.op = uint8(182)
		return int32(0)
	}
	pExpr.iTable = func() (_cgo_ret int32) {
		_cgo_addr := &rReg
		*_cgo_addr = dest.iSDParm
		return *_cgo_addr
	}()
	if addrOnce != 0 {
		sqlite3VdbeJumpHere(v, addrOnce)
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeAddOp1(v, 67, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).regReturn)
	sqlite3VdbeChangeP1(v, (*(*_cgoa_18)(unsafe.Pointer(&pExpr.y))).iAddr-1, sqlite3VdbeCurrentAddr(v)-1)
	sqlite3ClearTempRegCache(pParse)
	return rReg
}
func sqlite3ExprCheckIN(pParse *struct_Parse, pIn *struct_Expr) int32 {
	var nVector int32 = sqlite3ExprVectorSize(pIn.pLeft)
	if pIn.flags&uint32(2048) != uint32(0) && !(pParse.db.mallocFailed != 0) {
		if nVector != (*(**struct_Select)(unsafe.Pointer(&pIn.x))).pEList.nExpr {
			sqlite3SubselectError(pParse, (*(**struct_Select)(unsafe.Pointer(&pIn.x))).pEList.nExpr, nVector)
			return int32(1)
		}
	} else if nVector != 1 {
		sqlite3VectorErrorMsg(pParse, pIn.pLeft)
		return int32(1)
	}
	return int32(0)
}
func sqlite3ExprCodeIN(pParse *struct_Parse, pExpr *struct_Expr, destIfFalse int32, destIfNull int32) {
	var rRhsHasNull int32 = 0
	var eType int32
	var rLhs int32
	var rLhsOrig int32
	var v *struct_Vdbe
	var aiMap *int32 = nil
	var zAff *int8 = nil
	var nVector int32
	var iDummy int32
	var pLeft *struct_Expr
	var i int32
	var destStep2 int32
	var destStep6 int32 = 0
	var addrTruthOp int32
	var destNotNull int32
	var addrTop int32
	var iTab int32 = 0
	var okConstFactor uint8 = pParse.okConstFactor
	func() int {
		_ = 0
		return 0
	}()
	pLeft = pExpr.pLeft
	if sqlite3ExprCheckIN(pParse, pExpr) != 0 {
		return
	}
	zAff = exprINAffinity(pParse, pExpr)
	nVector = sqlite3ExprVectorSize(pExpr.pLeft)
	aiMap = (*int32)(sqlite3DbMallocZero(pParse.db, uint64(uint(nVector)*(4+1)+uint(1))))
	if pParse.db.mallocFailed != 0 {
		goto sqlite3ExprCodeIN_oom_error
	}
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	eType = sqlite3FindInIndex(pParse, pExpr, uint32(2|1), func() *int32 {
		if destIfFalse == destIfNull {
			return nil
		} else {
			return &rRhsHasNull
		}
	}(), aiMap, &iTab)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pParse.okConstFactor = uint8(0)
	rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy)
	pParse.okConstFactor = okConstFactor
	for i = int32(0); i < nVector && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiMap)) + uintptr(i)*4)) == i; i++ {
	}
	if i == nVector {
		rLhs = rLhsOrig
	} else {
		rLhs = sqlite3GetTempRange(pParse, nVector)
		for i = int32(0); i < nVector; i++ {
			sqlite3VdbeAddOp3(v, 79, rLhsOrig+i, rLhs+*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiMap)) + uintptr(i)*4)), 0)
		}
	}
	if eType == 5 {
		var pList *struct_ExprList
		var pColl *struct_CollSeq
		var labelOk int32 = sqlite3VdbeMakeLabel(pParse)
		var r2 int32
		var regToFree int32
		var regCkNull int32 = 0
		var ii int32
		func() int {
			_ = 0
			return 0
		}()
		pList = pExpr.x.pList
		pColl = sqlite3ExprCollSeq(pParse, pExpr.pLeft)
		if destIfNull != destIfFalse {
			regCkNull = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp3(v, 102, rLhs, rLhs, regCkNull)
		}
		for ii = int32(0); ii < pList.nExpr; ii++ {
			r2 = sqlite3ExprCodeTemp(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(ii)*28))).pExpr, &regToFree)
			if regCkNull != 0 && sqlite3ExprCanBeNull((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(ii)*28))).pExpr) != 0 {
				sqlite3VdbeAddOp3(v, 102, regCkNull, r2, regCkNull)
			}
			sqlite3ReleaseTempReg(pParse, regToFree)
			if ii < pList.nExpr-1 || destIfNull != destIfFalse {
				var op int32 = func() int32 {
					if rLhs != r2 {
						return 53
					} else {
						return 51
					}
				}()
				sqlite3VdbeAddOp4(v, op, rLhs, labelOk, r2, (*int8)(unsafe.Pointer(pColl)), -2)
				sqlite3VdbeChangeP5(v, uint16(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(0)))))
			} else {
				var op int32 = func() int32 {
					if rLhs != r2 {
						return 52
					} else {
						return 50
					}
				}()
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp4(v, op, rLhs, destIfFalse, r2, (*int8)(unsafe.Pointer(pColl)), -2)
				sqlite3VdbeChangeP5(v, uint16(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(0))))|16))
			}
		}
		if regCkNull != 0 {
			sqlite3VdbeAddOp2(v, 50, regCkNull, destIfNull)
			sqlite3VdbeGoto(v, destIfFalse)
		}
		sqlite3VdbeResolveLabel(v, labelOk)
		sqlite3ReleaseTempReg(pParse, regCkNull)
		goto sqlite3ExprCodeIN_finished
	}
	if destIfNull == destIfFalse {
		destStep2 = destIfFalse
	} else {
		destStep2 = func() (_cgo_ret int32) {
			_cgo_addr := &destStep6
			*_cgo_addr = sqlite3VdbeMakeLabel(pParse)
			return *_cgo_addr
		}()
	}
	for i = int32(0); i < nVector; i++ {
		var p *struct_Expr = sqlite3VectorFieldSubexpr(pExpr.pLeft, i)
		if pParse.nErr != 0 {
			goto sqlite3ExprCodeIN_oom_error
		}
		if sqlite3ExprCanBeNull(p) != 0 {
			sqlite3VdbeAddOp2(v, 50, rLhs+i, destStep2)
		}
	}
	if eType == 1 {
		sqlite3VdbeAddOp3(v, 32, iTab, destIfFalse, rLhs)
		addrTruthOp = sqlite3VdbeAddOp0(v, 11)
	} else {
		sqlite3VdbeAddOp4(v, 95, rLhs, nVector, 0, zAff, nVector)
		if destIfFalse == destIfNull {
			sqlite3VdbeAddOp4Int(v, 30, iTab, destIfFalse, rLhs, nVector)
			goto sqlite3ExprCodeIN_finished
		}
		addrTruthOp = sqlite3VdbeAddOp4Int(v, 31, iTab, 0, rLhs, nVector)
	}
	if rRhsHasNull != 0 && nVector == 1 {
		sqlite3VdbeAddOp2(v, 51, rRhsHasNull, destIfFalse)
	}
	if destIfFalse == destIfNull {
		sqlite3VdbeGoto(v, destIfFalse)
	}
	if destStep6 != 0 {
		sqlite3VdbeResolveLabel(v, destStep6)
	}
	addrTop = sqlite3VdbeAddOp2(v, 38, iTab, destIfFalse)
	if nVector > 1 {
		destNotNull = sqlite3VdbeMakeLabel(pParse)
	} else {
		destNotNull = destIfFalse
	}
	for i = int32(0); i < nVector; i++ {
		var p *struct_Expr
		var pColl *struct_CollSeq
		var r3 int32 = sqlite3GetTempReg(pParse)
		p = sqlite3VectorFieldSubexpr(pLeft, i)
		pColl = sqlite3ExprCollSeq(pParse, p)
		sqlite3VdbeAddOp3(v, 93, iTab, i, r3)
		sqlite3VdbeAddOp4(v, 52, rLhs+i, destNotNull, r3, (*int8)(unsafe.Pointer(pColl)), -2)
		sqlite3ReleaseTempReg(pParse, r3)
	}
	sqlite3VdbeAddOp2(v, 11, 0, destIfNull)
	if nVector > 1 {
		sqlite3VdbeResolveLabel(v, destNotNull)
		sqlite3VdbeAddOp2(v, 5, iTab, addrTop+1)
		sqlite3VdbeAddOp2(v, 11, 0, destIfFalse)
	}
	sqlite3VdbeJumpHere(v, addrTruthOp)
sqlite3ExprCodeIN_finished:
	if rLhs != rLhsOrig {
		sqlite3ReleaseTempReg(pParse, rLhs)
	}
sqlite3ExprCodeIN_oom_error:
	sqlite3DbFree(pParse.db, unsafe.Pointer(aiMap))
	sqlite3DbFree(pParse.db, unsafe.Pointer(zAff))
}
func codeReal(v *struct_Vdbe, z *int8, negateFlag int32, iMem int32) {
	if uintptr(unsafe.Pointer(z)) != uintptr(unsafe.Pointer(nil)) {
		var value float64
		sqlite3AtoF(z, &value, sqlite3Strlen30(z), uint8(1))
		func() int {
			_ = 0
			return 0
		}()
		if negateFlag != 0 {
			value = -value
		}
		sqlite3VdbeAddOp4Dup8(v, 153, 0, iMem, 0, (*uint8)(unsafe.Pointer(&value)), -13)
	}
}
func codeInteger(pParse *struct_Parse, pExpr *struct_Expr, negFlag int32, iMem int32) {
	var v *struct_Vdbe = pParse.pVdbe
	if pExpr.flags&uint32(1024) != 0 {
		var i int32 = *(*int32)(unsafe.Pointer(&pExpr.u))
		func() int {
			_ = 0
			return 0
		}()
		if negFlag != 0 {
			i = -i
		}
		sqlite3VdbeAddOp2(v, 71, i, iMem)
	} else {
		var c int32
		var value int64
		var z *int8 = pExpr.u.zToken
		func() int {
			_ = 0
			return 0
		}()
		c = sqlite3DecOrHexToI64(z, &value)
		if c == 3 && !(negFlag != 0) || c == 2 || negFlag != 0 && value == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
			if sqlite3_strnicmp(z, (*int8)(unsafe.Pointer(&[3]int8{'0', 'x', '\x00'})), 2) == 0 {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'h', 'e', 'x', ' ', 'l', 'i', 't', 'e', 'r', 'a', 'l', ' ', 't', 'o', 'o', ' ', 'b', 'i', 'g', ':', ' ', '%', 's', '%', '#', 'T', '\x00'})), func() *int8 {
					if negFlag != 0 {
						return (*int8)(unsafe.Pointer(&[2]int8{'-', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
					}
				}(), pExpr)
			} else {
				codeReal(v, z, negFlag, iMem)
			}
		} else {
			if negFlag != 0 {
				value = func() int64 {
					if c == 3 {
						return int64(-1) - (int64(4294967295) | int64(2147483647)<<32)
					} else {
						return -value
					}
				}()
			}
			sqlite3VdbeAddOp4Dup8(v, 72, 0, iMem, 0, (*uint8)(unsafe.Pointer(&value)), -14)
		}
	}
}
func sqlite3ExprCodeLoadIndexColumn(pParse *struct_Parse, pIdx *struct_Index, iTabCur int32, iIdxCol int32, regOut int32) {
	var iTabCol int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(iIdxCol)*2))
	if int32(iTabCol) == -2 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pParse.iSelfTab = iTabCur + 1
		sqlite3ExprCodeCopy(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(iIdxCol)*28))).pExpr, regOut)
		pParse.iSelfTab = int32(0)
	} else {
		sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pIdx.pTable, iTabCur, int32(iTabCol), regOut)
	}
}
func sqlite3ExprCodeGeneratedColumn(pParse *struct_Parse, pTab *struct_Table, pCol *struct_Column, regOut int32) {
	var iAddr int32
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pParse.iSelfTab > 0 {
		iAddr = sqlite3VdbeAddOp3(v, 22, pParse.iSelfTab-1, 0, regOut)
	} else {
		iAddr = int32(0)
	}
	sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), regOut)
	if int32(pCol.affinity) >= 66 {
		sqlite3VdbeAddOp4(v, 95, regOut, 1, 0, &pCol.affinity, 1)
	}
	if iAddr != 0 {
		sqlite3VdbeJumpHere(v, iAddr)
	}
}
func sqlite3ExprCodeGetColumnOfTable(v *struct_Vdbe, pTab *struct_Table, iTabCur int32, iCol int32, regOut int32) {
	var pCol *struct_Column
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3VdbeAddOp3(v, 93, iTabCur, iCol, regOut)
		return
	}
	if iCol < 0 || iCol == int32(pTab.iPKey) {
		sqlite3VdbeAddOp2(v, 134, iTabCur, regOut)
	} else {
		var op int32
		var x int32
		if int32(pTab.eTabType) == 1 {
			op = int32(174)
			x = iCol
		} else if int32(func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			*_cgo_addr = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
			return *_cgo_addr
		}().colFlags)&32 != 0 {
			var pParse *struct_Parse = sqlite3VdbeParser(v)
			if int32(pCol.colFlags)&256 != 0 {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'l', 'o', 'o', 'p', ' ', 'o', 'n', ' ', '"', '%', 's', '"', '\x00'})), pCol.zCnName)
			} else {
				var savedSelfTab int32 = pParse.iSelfTab
				pCol.colFlags |= uint16(256)
				pParse.iSelfTab = iTabCur + 1
				sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, regOut)
				pParse.iSelfTab = savedSelfTab
				pCol.colFlags &= uint16(^256)
			}
			return
		} else if !(pTab.tabFlags&uint32(128) == uint32(0)) {
			x = int32(sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), int16(iCol)))
			op = int32(93)
		} else {
			x = int32(sqlite3TableColumnToStorage(pTab, int16(iCol)))
			op = int32(93)
		}
		sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut)
		sqlite3ColumnDefault(v, pTab, iCol, regOut)
	}
}
func sqlite3ExprCodeGetColumn(pParse *struct_Parse, pTab *struct_Table, iColumn int32, iTable int32, iReg int32, p5 uint8) int32 {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ExprCodeGetColumnOfTable(pParse.pVdbe, pTab, iTable, iColumn, iReg)
	if p5 != 0 {
		var pOp *struct_VdbeOp = sqlite3VdbeGetOp(pParse.pVdbe, -1)
		if int32(pOp.opcode) == 93 {
			pOp.p5 = uint16(p5)
		}
	}
	return iReg
}
func sqlite3ExprCodeMove(pParse *struct_Parse, iFrom int32, iTo int32, nReg int32) {
	sqlite3VdbeAddOp3(pParse.pVdbe, 78, iFrom, iTo, nReg)
}
func exprToRegister(pExpr *struct_Expr, iReg int32) {
	var p *struct_Expr = sqlite3ExprSkipCollateAndLikely(pExpr)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	p.op2 = p.op
	p.op = uint8(176)
	p.iTable = iReg
	p.flags &= uint32(4294963199)
}
func exprCodeVector(pParse *struct_Parse, p *struct_Expr, piFreeable *int32) int32 {
	var iResult int32
	var nResult int32 = sqlite3ExprVectorSize(p)
	if nResult == 1 {
		iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable)
	} else {
		*piFreeable = int32(0)
		if int32(p.op) == 138 {
			iResult = sqlite3CodeSubselect(pParse, p)
		} else {
			var i int32
			iResult = pParse.nMem + 1
			pParse.nMem += nResult
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < nResult; i++ {
				sqlite3ExprCodeFactorable(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.x.pList.a)))) + uintptr(i)*28))).pExpr, i+iResult)
			}
		}
	}
	return iResult
}
func setDoNotMergeFlagOnCopy(v *struct_Vdbe) {
	if int32(sqlite3VdbeGetOp(v, -1).opcode) == 79 {
		sqlite3VdbeChangeP5(v, uint16(1))
	}
}
func exprCodeInlineFunction(pParse *struct_Parse, pFarg *struct_ExprList, iFuncId int32, target int32) int32 {
	var nFarg int32
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nFarg = pFarg.nExpr
	func() int {
		_ = 0
		return 0
	}()
	switch iFuncId {
	case 0:
		{
			var endCoalesce int32 = sqlite3VdbeMakeLabel(pParse)
			var i int32
			func() int {
				_ = 0
				return 0
			}()
			sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr, target)
			for i = int32(1); i < nFarg; i++ {
				sqlite3VdbeAddOp2(v, 51, target, endCoalesce)
				sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(i)*28))).pExpr, target)
			}
			setDoNotMergeFlagOnCopy(v)
			sqlite3VdbeResolveLabel(v, endCoalesce)
			break
		}
	case 5:
		{
			var caseExpr struct_Expr
			__builtin___memset_chk(unsafe.Pointer(&caseExpr), 0, 72, __builtin_object_size(unsafe.Pointer(&caseExpr), 0))
			caseExpr.op = uint8(157)
			caseExpr.x.pList = pFarg
			return sqlite3ExprCodeTarget(pParse, &caseExpr, target)
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			target = sqlite3ExprCodeTarget(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr, target)
			break
		}
	case 3:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 71, sqlite3ExprCompare(nil, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(1)*28))).pExpr, -1), target)
			break
		}
	case 2:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 71, sqlite3ExprImpliesExpr(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(1)*28))).pExpr, -1), target)
			break
		}
	case 1:
		{
			var pA1 *struct_Expr
			func() int {
				_ = 0
				return 0
			}()
			pA1 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(1)*28))).pExpr
			if int32(pA1.op) == 167 {
				sqlite3VdbeAddOp2(v, 71, sqlite3ExprImpliesNonNullRow((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr, pA1.iTable), target)
			} else {
				sqlite3VdbeAddOp2(v, 74, 0, target)
			}
			break
		}
	case 4:
		{
			var azAff [5]*int8 = [5]*int8{(*int8)(unsafe.Pointer(&[5]int8{'b', 'l', 'o', 'b', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'e', 'x', 't', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'n', 'u', 'm', 'e', 'r', 'i', 'c', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'r', 'e', 'a', 'l', '\x00'}))}
			var aff int8
			func() int {
				_ = 0
				return 0
			}()
			aff = sqlite3ExprAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr)
			sqlite3VdbeLoadString(v, target, func() *int8 {
				if int32(aff) <= 64 {
					return (*int8)(unsafe.Pointer((*int8)(unsafe.Pointer(&[5]int8{'n', 'o', 'n', 'e', '\x00'}))))
				} else {
					return *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azAff)))) + uintptr(int32(aff)-65)*8))
				}
			}())
			break
		}
	}
	return target
}
func sqlite3ExprCodeTarget(pParse *struct_Parse, pExpr *struct_Expr, target int32) int32 {
	var v *struct_Vdbe = pParse.pVdbe
	var op int32
	var inReg int32 = target
	var regFree1 int32 = 0
	var regFree2 int32 = 0
	var r1 int32
	var r2 int32
	var tempX struct_Expr
	var p5 int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
expr_code_doover:
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		op = int32(121)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		op = int32(pExpr.op)
	}
	switch op {
	case 169:
		{
			var pAggInfo *struct_AggInfo = pExpr.pAggInfo
			var pCol *struct_AggInfo_col
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pCol = &*(*struct_AggInfo_col)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aCol)) + uintptr(pExpr.iAgg)*28))
			if !(pAggInfo.directMode != 0) {
				func() int {
					_ = 0
					return 0
				}()
				return pCol.iMem
			} else if pAggInfo.useSortingIdx != 0 {
				var pTab *struct_Table = pCol.pTab
				sqlite3VdbeAddOp3(v, 93, pAggInfo.sortingIdxPTab, int32(pCol.iSorterColumn), target)
				if int32(pCol.iColumn) < 0 {
				} else if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(pCol.iColumn)*20))).affinity) == 69 {
					sqlite3VdbeAddOp1(v, 86, target)
				}
				return target
			}
		}
	case 167:
		{
			var iTab int32 = pExpr.iTable
			var iReg int32
			if pExpr.flags&uint32(8) != uint32(0) {
				var aff int32
				iReg = sqlite3ExprCodeTarget(pParse, pExpr.pLeft, target)
				func() int {
					_ = 0
					return 0
				}()
				if pExpr.y.pTab != nil {
					aff = int32(sqlite3TableColumnAffinity(pExpr.y.pTab, int32(pExpr.iColumn)))
				} else {
					aff = int32(pExpr.affExpr)
				}
				if aff > 65 {
					var zAff [8]int8 = [8]int8{'B', '\x00', 'C', '\x00', 'D', '\x00', 'E', '\x00'}
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					sqlite3VdbeAddOp4(v, 95, iReg, 1, 0, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zAff)))) + uintptr((aff-'B')*2))), -1)
				}
				return iReg
			}
			if iTab < 0 {
				if pParse.iSelfTab < 0 {
					var pCol *struct_Column
					var pTab *struct_Table
					var iSrc int32
					var iCol int32 = int32(pExpr.iColumn)
					func() int {
						_ = 0
						return 0
					}()
					pTab = pExpr.y.pTab
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					if iCol < 0 {
						return -1 - pParse.iSelfTab
					}
					pCol = (*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
					iSrc = int32(sqlite3TableColumnToStorage(pTab, int16(iCol))) - pParse.iSelfTab
					if int32(pCol.colFlags)&96 != 0 {
						if int32(pCol.colFlags)&256 != 0 {
							sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'l', 'o', 'o', 'p', ' ', 'o', 'n', ' ', '"', '%', 's', '"', '\x00'})), pCol.zCnName)
							return int32(0)
						}
						pCol.colFlags |= uint16(256)
						if int32(pCol.colFlags)&128 != 0 {
							sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, iSrc)
						}
						pCol.colFlags &= uint16(^(256 | 128))
						return iSrc
					} else if int32(pCol.affinity) == 69 {
						sqlite3VdbeAddOp2(v, 80, iSrc, target)
						sqlite3VdbeAddOp1(v, 86, target)
						return target
					} else {
						return iSrc
					}
				} else {
					iTab = pParse.iSelfTab - 1
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			iReg = sqlite3ExprCodeGetColumn(pParse, pExpr.y.pTab, int32(pExpr.iColumn), iTab, target, pExpr.op2)
			if uintptr(unsafe.Pointer(pExpr.y.pTab)) == uintptr(unsafe.Pointer(nil)) && int32(pExpr.affExpr) == 69 {
				sqlite3VdbeAddOp1(v, 86, iReg)
			}
			return iReg
		}
	case 155:
		{
			codeInteger(pParse, pExpr, 0, target)
			return target
		}
	case 170:
		{
			sqlite3VdbeAddOp2(v, 71, sqlite3ExprTruthValue(pExpr), target)
			return target
		}
	case 153:
		{
			func() int {
				_ = 0
				return 0
			}()
			codeReal(v, pExpr.u.zToken, 0, target)
			return target
		}
	case 117:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeLoadString(v, target, pExpr.u.zToken)
			return target
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 74, 0, target)
			return target
		}
	case 154:
		{
			var n int32
			var z *int8
			var zBlob *int8
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			z = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pExpr.u.zToken)) + uintptr(2)))
			n = sqlite3Strlen30(z) - 1
			func() int {
				_ = 0
				return 0
			}()
			zBlob = (*int8)(sqlite3HexToBlob(sqlite3VdbeDb(v), z, n))
			sqlite3VdbeAddOp4(v, 76, n/2, target, 0, zBlob, -7)
			return target
		}
	case 156:
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 77, int32(pExpr.iColumn), target)
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pExpr.u.zToken)) + uintptr(1)))) != 0 {
				var z *int8 = sqlite3VListNumToName(pParse.pVList, int32(pExpr.iColumn))
				func() int {
					_ = 0
					return 0
				}()
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.pVList)) + uintptr(0)*4)) = int32(0)
				sqlite3VdbeAppendP4(v, unsafe.Pointer((*int8)(unsafe.Pointer(z))), -1)
			}
			return target
		}
	case 176:
		{
			return pExpr.iTable
		}
	case 36:
		{
			inReg = sqlite3ExprCodeTarget(pParse, pExpr.pLeft, target)
			if inReg != target {
				sqlite3VdbeAddOp2(v, 80, inReg, target)
				inReg = target
			}
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 87, target, int32(sqlite3AffinityType(pExpr.u.zToken, nil)))
			return inReg
		}
	case 45:
		fallthrough
	case 171:
		op = func() int32 {
			if op == 45 {
				return 53
			} else {
				return 52
			}
		}()
		p5 = int32(128)
	case 56:
		fallthrough
	case 55:
		fallthrough
	case 54:
		fallthrough
	case 57:
		fallthrough
	case 52:
		fallthrough
	case 53:
		{
			var pLeft *struct_Expr = pExpr.pLeft
			if sqlite3ExprIsVector(pLeft) != 0 {
				codeVectorCompare(pParse, pExpr, target, uint8(op), uint8(p5))
			} else {
				r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1)
				r2 = sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2)
				sqlite3VdbeAddOp2(v, 71, 1, inReg)
				codeCompare(pParse, pLeft, pExpr.pRight, op, r1, r2, sqlite3VdbeCurrentAddr(v)+2, p5, func() int32 {
					if pExpr.flags&uint32(512) != uint32(0) {
						return 1
					} else {
						return 0
					}
				}())
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if p5 == 128 {
					sqlite3VdbeAddOp2(v, 71, 0, inReg)
				} else {
					sqlite3VdbeAddOp3(v, 91, r1, inReg, r2)
				}
			}
			break
		}
	case 44:
		fallthrough
	case 43:
		fallthrough
	case 106:
		fallthrough
	case 108:
		fallthrough
	case 107:
		fallthrough
	case 110:
		fallthrough
	case 102:
		fallthrough
	case 103:
		fallthrough
	case 109:
		fallthrough
	case 104:
		fallthrough
	case 105:
		fallthrough
	case 111:
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
			r2 = sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2)
			sqlite3VdbeAddOp3(v, op, r2, r1, target)
			break
		}
	case 173:
		{
			var pLeft *struct_Expr = pExpr.pLeft
			func() int {
				_ = 0
				return 0
			}()
			if int32(pLeft.op) == 155 {
				codeInteger(pParse, pLeft, 1, target)
				return target
			} else if int32(pLeft.op) == 153 {
				func() int {
					_ = 0
					return 0
				}()
				codeReal(v, pLeft.u.zToken, 1, target)
				return target
			} else {
				tempX.op = uint8(155)
				tempX.flags = uint32(1024 | 16384)
				*(*int32)(unsafe.Pointer(&tempX.u)) = int32(0)
				r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1)
				r2 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree2)
				sqlite3VdbeAddOp3(v, 107, r2, r1, target)
			}
			break
		}
	case 114:
		fallthrough
	case 19:
		{
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
			sqlite3VdbeAddOp2(v, op, r1, inReg)
			break
		}
	case 175:
		{
			var isTrue int32
			var bNormal int32
			r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
			isTrue = sqlite3ExprTruthValue(pExpr.pRight)
			bNormal = func() int32 {
				if int32(pExpr.op2) == 45 {
					return 1
				} else {
					return 0
				}
			}()
			sqlite3VdbeAddOp4Int(v, 90, r1, inReg, func() int32 {
				if !(isTrue != 0) {
					return 1
				} else {
					return 0
				}
			}(), isTrue^bNormal)
			break
		}
	case 50:
		fallthrough
	case 51:
		{
			var addr int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 71, 1, target)
			r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
			addr = sqlite3VdbeAddOp1(v, op, r1)
			sqlite3VdbeAddOp2(v, 71, 0, target)
			sqlite3VdbeJumpHere(v, addr)
			break
		}
	case 168:
		{
			var pInfo *struct_AggInfo = pExpr.pAggInfo
			if uintptr(unsafe.Pointer(pInfo)) == uintptr(unsafe.Pointer(nil)) || int32(pExpr.iAgg) < 0 || int32(pExpr.iAgg) >= pInfo.nFunc {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'m', 'i', 's', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ':', ' ', '%', '#', 'T', '(', ')', '\x00'})), pExpr)
			} else {
				return (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pInfo.aFunc)) + uintptr(pExpr.iAgg)*28))).iMem
			}
			break
		}
	case 172:
		{
			var pFarg *struct_ExprList
			var nFarg int32
			var pDef *struct_FuncDef
			var zId *int8
			var constMask uint32 = uint32(0)
			var i int32
			var db *struct_sqlite3 = pParse.db
			var enc uint8 = db.enc
			var pColl *struct_CollSeq = nil
			if pExpr.flags&uint32(16777216) != uint32(0) {
				return (*(**struct_Window)(unsafe.Pointer(&pExpr.y))).regResult
			}
			if int32(pParse.okConstFactor) != 0 && sqlite3ExprIsConstantNotJoin(pExpr) != 0 {
				return sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1)
			}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pFarg = pExpr.x.pList
			nFarg = func() int32 {
				if pFarg != nil {
					return pFarg.nExpr
				} else {
					return 0
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			zId = pExpr.u.zToken
			pDef = sqlite3FindFunction(db, zId, nFarg, enc, uint8(0))
			if uintptr(unsafe.Pointer(pDef)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pDef.xFinalize)) != uintptr(unsafe.Pointer(nil)) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[24]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ':', ' ', '%', '#', 'T', '(', ')', '\x00'})), pExpr)
				break
			}
			if pDef.funcFlags&uint32(4194304) != 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				return exprCodeInlineFunction(pParse, pFarg, int32(int(pDef.pUserData)), target)
			} else if pDef.funcFlags&uint32(524288|2097152) != 0 {
				sqlite3ExprFunctionUsable(pParse, pExpr, pDef)
			}
			for i = int32(0); i < nFarg; i++ {
				if i < 32 && sqlite3ExprIsConstant((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(i)*28))).pExpr) != 0 {
					constMask |= uint32(1) << i
				}
				if pDef.funcFlags&uint32(32) != uint32(0) && !(pColl != nil) {
					pColl = sqlite3ExprCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(i)*28))).pExpr)
				}
			}
			if pFarg != nil {
				if constMask != 0 {
					r1 = pParse.nMem + 1
					pParse.nMem += nFarg
				} else {
					r1 = sqlite3GetTempRange(pParse, nFarg)
				}
				if pDef.funcFlags&uint32(64|128) != uint32(0) {
					var exprOp uint8
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					exprOp = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr.op
					if int32(exprOp) == 167 || int32(exprOp) == 169 {
						func() int {
							_ = 0
							return 0
						}()
						func() int {
							_ = 0
							return 0
						}()
						(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr.op2 = uint8(pDef.funcFlags & uint32(64|128))
					}
				}
				sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, uint8(1|2))
			} else {
				r1 = int32(0)
			}
			if nFarg >= 2 && pExpr.flags&uint32(128) != uint32(0) {
				pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(1)*28))).pExpr)
			} else if nFarg > 0 {
				pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFarg.a)))) + uintptr(0)*28))).pExpr)
			}
			if pDef.funcFlags&uint32(32) != 0 {
				if !(pColl != nil) {
					pColl = db.pDfltColl
				}
				sqlite3VdbeAddOp4(v, 84, 0, 0, 0, (*int8)(unsafe.Pointer(pColl)), -2)
			}
			{
				sqlite3VdbeAddFunctionCall(pParse, int32(constMask), r1, target, nFarg, pDef, int32(pExpr.op2))
			}
			if nFarg != 0 {
				if constMask == uint32(0) {
					sqlite3ReleaseTempRange(pParse, r1, nFarg)
				} else {
				}
			}
			return target
		}
	case 20:
		fallthrough
	case 138:
		{
			var nCol int32
			if pParse.db.mallocFailed != 0 {
				return int32(0)
			} else if op == 138 && pExpr.flags&uint32(2048) != uint32(0) && func() (_cgo_ret int32) {
				_cgo_addr := &nCol
				*_cgo_addr = (*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pEList.nExpr
				return *_cgo_addr
			}() != 1 {
				sqlite3SubselectError(pParse, nCol, 1)
			} else {
				return sqlite3CodeSubselect(pParse, pExpr)
			}
			break
		}
	case 178:
		{
			var n int32
			if pExpr.pLeft.iTable == 0 {
				pExpr.pLeft.iTable = sqlite3CodeSubselect(pParse, pExpr.pLeft)
			}
			func() int {
				_ = 0
				return 0
			}()
			n = sqlite3ExprVectorSize(pExpr.pLeft)
			if pExpr.iTable != n {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'a', 's', 's', 'i', 'g', 'n', 'e', 'd', ' ', '%', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 's', '\x00'})), pExpr.iTable, n)
			}
			return pExpr.pLeft.iTable + int32(pExpr.iColumn)
		}
	case 49:
		{
			var destIfFalse int32 = sqlite3VdbeMakeLabel(pParse)
			var destIfNull int32 = sqlite3VdbeMakeLabel(pParse)
			sqlite3VdbeAddOp2(v, 74, 0, target)
			sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull)
			sqlite3VdbeAddOp2(v, 71, 1, target)
			sqlite3VdbeResolveLabel(v, destIfFalse)
			sqlite3VdbeAddOp2(v, 85, target, 0)
			sqlite3VdbeResolveLabel(v, destIfNull)
			return target
		}
	case 48:
		{
			exprCodeBetween(pParse, pExpr, target, nil, 0)
			return target
		}
	case 181:
		fallthrough
	case 113:
		fallthrough
	case 174:
		{
			pExpr = pExpr.pLeft
			goto expr_code_doover
		}
	case 77:
		{
			var pTab *struct_Table
			var iCol int32
			var p1 int32
			func() int {
				_ = 0
				return 0
			}()
			pTab = pExpr.y.pTab
			iCol = int32(pExpr.iColumn)
			p1 = pExpr.iTable*(int32(pTab.nCol)+1) + 1 + int32(sqlite3TableColumnToStorage(pTab, int16(iCol)))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 156, p1, target)
			if iCol >= 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).affinity) == 69 {
				sqlite3VdbeAddOp1(v, 86, target)
			}
			break
		}
	case 177:
		{
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'r', 'o', 'w', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'i', 's', 'u', 's', 'e', 'd', '\x00'})))
			break
		}
	case 179:
		{
			var addrINR int32
			var okConstFactor uint8 = pParse.okConstFactor
			addrINR = sqlite3VdbeAddOp1(v, 22, pExpr.iTable)
			pParse.okConstFactor = uint8(0)
			inReg = sqlite3ExprCodeTarget(pParse, pExpr.pLeft, target)
			pParse.okConstFactor = okConstFactor
			sqlite3VdbeJumpHere(v, addrINR)
			sqlite3VdbeChangeP3(v, addrINR, inReg)
			break
		}
	case 157:
		{
			var endLabel int32
			var nextCase int32
			var nExpr int32
			var i int32
			var pEList *struct_ExprList
			var aListelem *struct_ExprList_item
			var opCompare struct_Expr
			var pX *struct_Expr
			var pTest *struct_Expr = nil
			var pDel *struct_Expr = nil
			var db *struct_sqlite3 = pParse.db
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pEList = pExpr.x.pList
			aListelem = (*struct_ExprList_item)(unsafe.Pointer(&pEList.a))
			nExpr = pEList.nExpr
			endLabel = sqlite3VdbeMakeLabel(pParse)
			if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Expr) {
				_cgo_addr := &pX
				*_cgo_addr = pExpr.pLeft
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) {
				pDel = sqlite3ExprDup(db, pX, 0)
				if db.mallocFailed != 0 {
					sqlite3ExprDelete(db, pDel)
					break
				}
				exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1))
				__builtin___memset_chk(unsafe.Pointer(&opCompare), 0, 72, __builtin_object_size(unsafe.Pointer(&opCompare), 0))
				opCompare.op = uint8(53)
				opCompare.pLeft = pDel
				pTest = &opCompare
				regFree1 = int32(0)
			}
			for i = int32(0); i < nExpr-1; i = i + 2 {
				if pX != nil {
					func() int {
						_ = 0
						return 0
					}()
					opCompare.pRight = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(aListelem)) + uintptr(i)*28))).pExpr
				} else {
					pTest = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(aListelem)) + uintptr(i)*28))).pExpr
				}
				nextCase = sqlite3VdbeMakeLabel(pParse)
				sqlite3ExprIfFalse(pParse, pTest, nextCase, 16)
				sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(aListelem)) + uintptr(i+1)*28))).pExpr, target)
				sqlite3VdbeGoto(v, endLabel)
				sqlite3VdbeResolveLabel(v, nextCase)
			}
			if nExpr&1 != 0 {
				sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(nExpr-1)*28))).pExpr, target)
			} else {
				sqlite3VdbeAddOp2(v, 74, 0, target)
			}
			sqlite3ExprDelete(db, pDel)
			setDoNotMergeFlagOnCopy(v)
			sqlite3VdbeResolveLabel(v, endLabel)
			break
		}
	case 71:
		{
			func() int {
				_ = 0
				return 0
			}()
			if !(pParse.pTriggerTab != nil) && !(pParse.nested != 0) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[50]int8{'R', 'A', 'I', 'S', 'E', '(', ')', ' ', 'm', 'a', 'y', ' ', 'o', 'n', 'l', 'y', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'd', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'a', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', '-', 'p', 'r', 'o', 'g', 'r', 'a', 'm', '\x00'})))
				return int32(0)
			}
			if int32(pExpr.affExpr) == 2 {
				sqlite3MayAbort(pParse)
			}
			func() int {
				_ = 0
				return 0
			}()
			if int32(pExpr.affExpr) == 4 {
				sqlite3VdbeAddOp4(v, 70, 0, 4, 0, pExpr.u.zToken, 0)
			} else {
				sqlite3HaltConstraint(pParse, func() int32 {
					if pParse.pTriggerTab != nil {
						return 19 | 7<<8
					} else {
						return 1
					}
				}(), int32(pExpr.affExpr), pExpr.u.zToken, int8(0), uint8(0))
			}
			break
		}
	}
	sqlite3ReleaseTempReg(pParse, regFree1)
	sqlite3ReleaseTempReg(pParse, regFree2)
	return inReg
}
func sqlite3ExprCodeRunJustOnce(pParse *struct_Parse, pExpr *struct_Expr, regDest int32) int32 {
	var p *struct_ExprList
	func() int {
		_ = 0
		return 0
	}()
	p = pParse.pConstExpr
	if regDest < 0 && p != nil {
		var pItem *struct_ExprList_item
		var i int32
		for func() int32 {
			pItem = (*struct_ExprList_item)(unsafe.Pointer(&p.a))
			return func() (_cgo_ret int32) {
				_cgo_addr := &i
				*_cgo_addr = p.nExpr
				return *_cgo_addr
			}()
		}(); i > 0; func() int32 {
			*(*uintptr)(unsafe.Pointer(&pItem)) += 28
			return func() (_cgo_ret int32) {
				_cgo_addr := &i
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}()
		}() {
			if int32(pItem.Xbf_0>>3&1) != 0 && sqlite3ExprCompare(nil, pItem.pExpr, pExpr, -1) == 0 {
				return *(*int32)(unsafe.Pointer(&pItem.u))
			}
		}
	}
	pExpr = sqlite3ExprDup(pParse.db, pExpr, 0)
	if uintptr(unsafe.Pointer(pExpr)) != uintptr(unsafe.Pointer(nil)) && pExpr.flags&uint32(4) != uint32(0) {
		var v *struct_Vdbe = pParse.pVdbe
		var addr int32
		func() int {
			_ = 0
			return 0
		}()
		addr = sqlite3VdbeAddOp0(v, 17)
		pParse.okConstFactor = uint8(0)
		if !(pParse.db.mallocFailed != 0) {
			if regDest < 0 {
				regDest = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
			}
			sqlite3ExprCode(pParse, pExpr, regDest)
		}
		pParse.okConstFactor = uint8(1)
		sqlite3ExprDelete(pParse.db, pExpr)
		sqlite3VdbeJumpHere(v, addr)
	} else {
		p = sqlite3ExprListAppend(pParse, p, pExpr)
		if p != nil {
			var pItem *struct_ExprList_item = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.a)))) + uintptr(p.nExpr-1)*28))
			{
				_autoGo_43 := &pItem.Xbf_0
				*_autoGo_43 = *_autoGo_43&^8 | func() uint32 {
					if regDest < 0 {
						return 1
					} else {
						return 0
					}
				}()&1<<3
			}
			if regDest < 0 {
				regDest = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
			}
			*(*int32)(unsafe.Pointer(&pItem.u)) = regDest
		}
		pParse.pConstExpr = p
	}
	return regDest
}
func sqlite3ExprCodeTemp(pParse *struct_Parse, pExpr *struct_Expr, pReg *int32) int32 {
	var r2 int32
	pExpr = sqlite3ExprSkipCollateAndLikely(pExpr)
	if int32(pParse.okConstFactor) != 0 && uintptr(unsafe.Pointer(pExpr)) != uintptr(unsafe.Pointer(nil)) && int32(pExpr.op) != 176 && sqlite3ExprIsConstantNotJoin(pExpr) != 0 {
		*pReg = int32(0)
		r2 = sqlite3ExprCodeRunJustOnce(pParse, pExpr, -1)
	} else {
		var r1 int32 = sqlite3GetTempReg(pParse)
		r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1)
		if r2 == r1 {
			*pReg = r1
		} else {
			sqlite3ReleaseTempReg(pParse, r1)
			*pReg = int32(0)
		}
	}
	return r2
}
func sqlite3ExprCode(pParse *struct_Parse, pExpr *struct_Expr, target int32) {
	var inReg int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pParse.pVdbe)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	inReg = sqlite3ExprCodeTarget(pParse, pExpr, target)
	if inReg != target {
		var op uint8
		if pExpr != nil && pExpr.flags&uint32(2097152) != uint32(0) {
			op = uint8(79)
		} else {
			op = uint8(80)
		}
		sqlite3VdbeAddOp2(pParse.pVdbe, int32(op), inReg, target)
	}
}
func sqlite3ExprCodeCopy(pParse *struct_Parse, pExpr *struct_Expr, target int32) {
	var db *struct_sqlite3 = pParse.db
	pExpr = sqlite3ExprDup(db, pExpr, 0)
	if !(db.mallocFailed != 0) {
		sqlite3ExprCode(pParse, pExpr, target)
	}
	sqlite3ExprDelete(db, pExpr)
}
func sqlite3ExprCodeFactorable(pParse *struct_Parse, pExpr *struct_Expr, target int32) {
	if int32(pParse.okConstFactor) != 0 && sqlite3ExprIsConstantNotJoin(pExpr) != 0 {
		sqlite3ExprCodeRunJustOnce(pParse, pExpr, target)
	} else {
		sqlite3ExprCodeCopy(pParse, pExpr, target)
	}
}
func sqlite3ExprCodeExprList(pParse *struct_Parse, pList *struct_ExprList, target int32, srcReg int32, flags uint8) int32 {
	var pItem *struct_ExprList_item
	var i int32
	var j int32
	var n int32
	var copyOp uint8 = uint8(func() int32 {
		if int32(flags)&1 != 0 {
			return 79
		} else {
			return 80
		}
	}())
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	n = pList.nExpr
	if !(pParse.okConstFactor != 0) {
		flags &= uint8(^2)
	}
	for func() int32 {
		pItem = (*struct_ExprList_item)(unsafe.Pointer(&pList.a))
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); i < n; func() *struct_ExprList_item {
		i++
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		var pExpr *struct_Expr = pItem.pExpr
		if int32(flags)&4 != 0 && func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = int32(pItem.u.x.iOrderByCol)
			return *_cgo_addr
		}() > 0 {
			if int32(flags)&8 != 0 {
				i--
				n--
			} else {
				sqlite3VdbeAddOp2(v, int32(copyOp), j+srcReg-1, target+i)
			}
		} else if int32(flags)&2 != 0 && sqlite3ExprIsConstantNotJoin(pExpr) != 0 {
			sqlite3ExprCodeRunJustOnce(pParse, pExpr, target+i)
		} else {
			var inReg int32 = sqlite3ExprCodeTarget(pParse, pExpr, target+i)
			if inReg != target+i {
				var pOp *struct_VdbeOp
				if int32(copyOp) == 79 && int32(func() (_cgo_ret *struct_VdbeOp) {
					_cgo_addr := &pOp
					*_cgo_addr = sqlite3VdbeGetOp(v, -1)
					return *_cgo_addr
				}().opcode) == 79 && pOp.p1+pOp.p3+1 == inReg && pOp.p2+pOp.p3+1 == target+i && int32(pOp.p5) == 0 {
					pOp.p3++
				} else {
					sqlite3VdbeAddOp2(v, int32(copyOp), inReg, target+i)
				}
			}
		}
	}
	return n
}
func exprCodeBetween(pParse *struct_Parse, pExpr *struct_Expr, dest int32, xJump func(*struct_Parse, *struct_Expr, int32, int32), jumpIfNull int32) {
	var exprAnd struct_Expr
	var compLeft struct_Expr
	var compRight struct_Expr
	var regFree1 int32 = 0
	var pDel *struct_Expr = nil
	var db *struct_sqlite3 = pParse.db
	__builtin___memset_chk(unsafe.Pointer(&compLeft), 0, 72, __builtin_object_size(unsafe.Pointer(&compLeft), 0))
	__builtin___memset_chk(unsafe.Pointer(&compRight), 0, 72, __builtin_object_size(unsafe.Pointer(&compRight), 0))
	__builtin___memset_chk(unsafe.Pointer(&exprAnd), 0, 72, __builtin_object_size(unsafe.Pointer(&exprAnd), 0))
	func() int {
		_ = 0
		return 0
	}()
	pDel = sqlite3ExprDup(db, pExpr.pLeft, 0)
	if int32(db.mallocFailed) == 0 {
		exprAnd.op = uint8(44)
		exprAnd.pLeft = &compLeft
		exprAnd.pRight = &compRight
		compLeft.op = uint8(57)
		compLeft.pLeft = pDel
		compLeft.pRight = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(0)*28))).pExpr
		compRight.op = uint8(55)
		compRight.pLeft = pDel
		compRight.pRight = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(1)*28))).pExpr
		exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1))
		if xJump != nil {
			xJump(pParse, &exprAnd, dest, jumpIfNull)
		} else {
			pDel.flags |= uint32(1)
			sqlite3ExprCodeTarget(pParse, &exprAnd, dest)
		}
		sqlite3ReleaseTempReg(pParse, regFree1)
	}
	sqlite3ExprDelete(db, pDel)
}
func sqlite3ExprIfTrue(pParse *struct_Parse, pExpr *struct_Expr, dest int32, jumpIfNull int32) {

	var v *struct_Vdbe = pParse.pVdbe
	var op int32 = 0
	var regFree1 int32 = 0
	var regFree2 int32 = 0
	var r1 int32
	var r2 int32
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	op = int32(pExpr.op)
	_cgo_nm, _cgo_tag := true, op
	if _cgo_nm && _cgo_tag != 44 {
		goto _cgol_1
	}
	_cgo_nm = false
_cgol_1:
	if _cgo_nm && _cgo_tag != 43 {
		goto _cgol_2
	}
	_cgo_nm = false
	{
		var pAlt *struct_Expr = sqlite3ExprSimplifiedAndOr(pExpr)
		if uintptr(unsafe.Pointer(pAlt)) != uintptr(unsafe.Pointer(pExpr)) {
			sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull)
		} else if op == 44 {
			var d2 int32 = sqlite3VdbeMakeLabel(pParse)
			sqlite3ExprIfFalse(pParse, pExpr.pLeft, d2, jumpIfNull^16)
			sqlite3ExprIfTrue(pParse, pExpr.pRight, dest, jumpIfNull)
			sqlite3VdbeResolveLabel(v, d2)
		} else {
			sqlite3ExprIfTrue(pParse, pExpr.pLeft, dest, jumpIfNull)
			sqlite3ExprIfTrue(pParse, pExpr.pRight, dest, jumpIfNull)
		}
		goto _cgol_3
	}
_cgol_2:
	if _cgo_nm && _cgo_tag != 19 {
		goto _cgol_4
	}
	_cgo_nm = false
	{
		sqlite3ExprIfFalse(pParse, pExpr.pLeft, dest, jumpIfNull)
		goto _cgol_3
	}
_cgol_4:
	if _cgo_nm && _cgo_tag != 175 {
		goto _cgol_5
	}
	_cgo_nm = false
	{
		var isNot int32
		var isTrue int32
		isNot = func() int32 {
			if int32(pExpr.op2) == 171 {
				return 1
			} else {
				return 0
			}
		}()
		isTrue = sqlite3ExprTruthValue(pExpr.pRight)
		if isTrue^isNot != 0 {
			sqlite3ExprIfTrue(pParse, pExpr.pLeft, dest, func() int32 {
				if isNot != 0 {
					return 16
				} else {
					return 0
				}
			}())
		} else {
			sqlite3ExprIfFalse(pParse, pExpr.pLeft, dest, func() int32 {
				if isNot != 0 {
					return 16
				} else {
					return 0
				}
			}())
		}
		goto _cgol_3
	}
_cgol_5:
	if _cgo_nm && _cgo_tag != 45 {
		goto _cgol_6
	}
	_cgo_nm = false
_cgol_6:
	if _cgo_nm && _cgo_tag != 171 {
		goto _cgol_7
	}
	_cgo_nm = false
	op = func() int32 {
		if op == 45 {
			return 53
		} else {
			return 52
		}
	}()
	jumpIfNull = int32(128)
_cgol_7:
	if _cgo_nm && _cgo_tag != 56 {
		goto _cgol_8
	}
	_cgo_nm = false
_cgol_8:
	if _cgo_nm && _cgo_tag != 55 {
		goto _cgol_9
	}
	_cgo_nm = false
_cgol_9:
	if _cgo_nm && _cgo_tag != 54 {
		goto _cgol_10
	}
	_cgo_nm = false
_cgol_10:
	if _cgo_nm && _cgo_tag != 57 {
		goto _cgol_11
	}
	_cgo_nm = false
_cgol_11:
	if _cgo_nm && _cgo_tag != 52 {
		goto _cgol_12
	}
	_cgo_nm = false
_cgol_12:
	if _cgo_nm && _cgo_tag != 53 {
		goto _cgol_13
	}
	_cgo_nm = false
	if !(sqlite3ExprIsVector(pExpr.pLeft) != 0) {
		goto _cgol_14
	}
	goto default_expr
_cgol_14:
	r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
	r2 = sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2)
	codeCompare(pParse, pExpr.pLeft, pExpr.pRight, op, r1, r2, dest, jumpIfNull, func() int32 {
		if pExpr.flags&uint32(512) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}())
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	goto _cgol_3
_cgol_13:
	if _cgo_nm && _cgo_tag != 50 {
		goto _cgol_15
	}
	_cgo_nm = false
_cgol_15:
	if _cgo_nm && _cgo_tag != 51 {
		goto _cgol_16
	}
	_cgo_nm = false
	{
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
		sqlite3VdbeAddOp2(v, op, r1, dest)
		goto _cgol_3
	}
_cgol_16:
	if _cgo_nm && _cgo_tag != 48 {
		goto _cgol_17
	}
	_cgo_nm = false
	{
		exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull)
		goto _cgol_3
	}
_cgol_17:
	if _cgo_nm && _cgo_tag != 49 {
		goto _cgol_18
	}
	_cgo_nm = false
	{
		var destIfFalse int32 = sqlite3VdbeMakeLabel(pParse)
		var destIfNull int32 = func() int32 {
			if jumpIfNull != 0 {
				return dest
			} else {
				return destIfFalse
			}
		}()
		sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull)
		sqlite3VdbeGoto(v, dest)
		sqlite3VdbeResolveLabel(v, destIfFalse)
		goto _cgol_3
	}
_cgol_19:
	_cgo_nm = false
default_expr:
	if pExpr.flags&uint32(1|268435456) == uint32(268435456) {
		sqlite3VdbeGoto(v, dest)
	} else if pExpr.flags&uint32(1|536870912) == uint32(536870912) {
	} else {
		r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1)
		sqlite3VdbeAddOp3(v, 18, r1, dest, func() int32 {
			if jumpIfNull != 0 {
				return 1
			} else {
				return 0
			}
		}())
	}
	goto _cgol_3
	goto _cgol_3
_cgol_18:
	goto _cgol_19
_cgol_3:
	sqlite3ReleaseTempReg(pParse, regFree1)
	sqlite3ReleaseTempReg(pParse, regFree2)
}
func sqlite3ExprIfFalse(pParse *struct_Parse, pExpr *struct_Expr, dest int32, jumpIfNull int32) {

	var v *struct_Vdbe = pParse.pVdbe
	var op int32 = 0
	var regFree1 int32 = 0
	var regFree2 int32 = 0
	var r1 int32
	var r2 int32
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	op = int32(pExpr.op) + 50&1 ^ 1 - 50&1
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	_cgo_nm, _cgo_tag := true, int32(pExpr.op)
	if _cgo_nm && _cgo_tag != 44 {
		goto _cgol_1
	}
	_cgo_nm = false
_cgol_1:
	if _cgo_nm && _cgo_tag != 43 {
		goto _cgol_2
	}
	_cgo_nm = false
	{
		var pAlt *struct_Expr = sqlite3ExprSimplifiedAndOr(pExpr)
		if uintptr(unsafe.Pointer(pAlt)) != uintptr(unsafe.Pointer(pExpr)) {
			sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull)
		} else if int32(pExpr.op) == 44 {
			sqlite3ExprIfFalse(pParse, pExpr.pLeft, dest, jumpIfNull)
			sqlite3ExprIfFalse(pParse, pExpr.pRight, dest, jumpIfNull)
		} else {
			var d2 int32 = sqlite3VdbeMakeLabel(pParse)
			sqlite3ExprIfTrue(pParse, pExpr.pLeft, d2, jumpIfNull^16)
			sqlite3ExprIfFalse(pParse, pExpr.pRight, dest, jumpIfNull)
			sqlite3VdbeResolveLabel(v, d2)
		}
		goto _cgol_3
	}
_cgol_2:
	if _cgo_nm && _cgo_tag != 19 {
		goto _cgol_4
	}
	_cgo_nm = false
	{
		sqlite3ExprIfTrue(pParse, pExpr.pLeft, dest, jumpIfNull)
		goto _cgol_3
	}
_cgol_4:
	if _cgo_nm && _cgo_tag != 175 {
		goto _cgol_5
	}
	_cgo_nm = false
	{
		var isNot int32
		var isTrue int32
		isNot = func() int32 {
			if int32(pExpr.op2) == 171 {
				return 1
			} else {
				return 0
			}
		}()
		isTrue = sqlite3ExprTruthValue(pExpr.pRight)
		if isTrue^isNot != 0 {
			sqlite3ExprIfFalse(pParse, pExpr.pLeft, dest, func() int32 {
				if isNot != 0 {
					return 0
				} else {
					return 16
				}
			}())
		} else {
			sqlite3ExprIfTrue(pParse, pExpr.pLeft, dest, func() int32 {
				if isNot != 0 {
					return 0
				} else {
					return 16
				}
			}())
		}
		goto _cgol_3
	}
_cgol_5:
	if _cgo_nm && _cgo_tag != 45 {
		goto _cgol_6
	}
	_cgo_nm = false
_cgol_6:
	if _cgo_nm && _cgo_tag != 171 {
		goto _cgol_7
	}
	_cgo_nm = false
	op = func() int32 {
		if int32(pExpr.op) == 45 {
			return 52
		} else {
			return 53
		}
	}()
	jumpIfNull = int32(128)
_cgol_7:
	if _cgo_nm && _cgo_tag != 56 {
		goto _cgol_8
	}
	_cgo_nm = false
_cgol_8:
	if _cgo_nm && _cgo_tag != 55 {
		goto _cgol_9
	}
	_cgo_nm = false
_cgol_9:
	if _cgo_nm && _cgo_tag != 54 {
		goto _cgol_10
	}
	_cgo_nm = false
_cgol_10:
	if _cgo_nm && _cgo_tag != 57 {
		goto _cgol_11
	}
	_cgo_nm = false
_cgol_11:
	if _cgo_nm && _cgo_tag != 52 {
		goto _cgol_12
	}
	_cgo_nm = false
_cgol_12:
	if _cgo_nm && _cgo_tag != 53 {
		goto _cgol_13
	}
	_cgo_nm = false
	if !(sqlite3ExprIsVector(pExpr.pLeft) != 0) {
		goto _cgol_14
	}
	goto default_expr
_cgol_14:
	r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
	r2 = sqlite3ExprCodeTemp(pParse, pExpr.pRight, &regFree2)
	codeCompare(pParse, pExpr.pLeft, pExpr.pRight, op, r1, r2, dest, jumpIfNull, func() int32 {
		if pExpr.flags&uint32(512) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}())
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	goto _cgol_3
_cgol_13:
	if _cgo_nm && _cgo_tag != 50 {
		goto _cgol_15
	}
	_cgo_nm = false
_cgol_15:
	if _cgo_nm && _cgo_tag != 51 {
		goto _cgol_16
	}
	_cgo_nm = false
	{
		r1 = sqlite3ExprCodeTemp(pParse, pExpr.pLeft, &regFree1)
		sqlite3VdbeAddOp2(v, op, r1, dest)
		goto _cgol_3
	}
_cgol_16:
	if _cgo_nm && _cgo_tag != 48 {
		goto _cgol_17
	}
	_cgo_nm = false
	{
		exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull)
		goto _cgol_3
	}
_cgol_17:
	if _cgo_nm && _cgo_tag != 49 {
		goto _cgol_18
	}
	_cgo_nm = false
	{
		if jumpIfNull != 0 {
			sqlite3ExprCodeIN(pParse, pExpr, dest, dest)
		} else {
			var destIfNull int32 = sqlite3VdbeMakeLabel(pParse)
			sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull)
			sqlite3VdbeResolveLabel(v, destIfNull)
		}
		goto _cgol_3
	}
_cgol_19:
	_cgo_nm = false
default_expr:
	if pExpr.flags&uint32(1|536870912) == uint32(536870912) {
		sqlite3VdbeGoto(v, dest)
	} else if pExpr.flags&uint32(1|268435456) == uint32(268435456) {
	} else {
		r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1)
		sqlite3VdbeAddOp3(v, 20, r1, dest, func() int32 {
			if jumpIfNull != 0 {
				return 1
			} else {
				return 0
			}
		}())
	}
	goto _cgol_3
	goto _cgol_3
_cgol_18:
	goto _cgol_19
_cgol_3:
	sqlite3ReleaseTempReg(pParse, regFree1)
	sqlite3ReleaseTempReg(pParse, regFree2)
}
func sqlite3ExprIfFalseDup(pParse *struct_Parse, pExpr *struct_Expr, dest int32, jumpIfNull int32) {
	var db *struct_sqlite3 = pParse.db
	var pCopy *struct_Expr = sqlite3ExprDup(db, pExpr, 0)
	if int32(db.mallocFailed) == 0 {
		sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull)
	}
	sqlite3ExprDelete(db, pCopy)
}
func exprCompareVariable(pParse *struct_Parse, pVar *struct_Expr, pExpr *struct_Expr) int32 {
	var res int32 = 0
	var iVar int32
	var pL *struct_sqlite3_value
	var pR *struct_sqlite3_value = nil
	sqlite3ValueFromExpr(pParse.db, pExpr, uint8(1), uint8(65), &pR)
	if pR != nil {
		iVar = int32(pVar.iColumn)
		sqlite3VdbeSetVarmask(pParse.pVdbe, iVar)
		pL = sqlite3VdbeGetBoundValue(pParse.pReprepare, iVar, uint8(65))
		if pL != nil {
			if sqlite3_value_type(pL) == 3 {
				sqlite3_value_text(pL)
			}
			res = func() int32 {
				if 0 == sqlite3MemCompare(pL, pR, nil) {
					return 1
				} else {
					return 0
				}
			}()
		}
		sqlite3ValueFree(pR)
		sqlite3ValueFree(pL)
	}
	return res
}
func sqlite3ExprCompare(pParse *struct_Parse, pA *struct_Expr, pB *struct_Expr, iTab int32) int32 {
	var combinedFlags uint32
	if uintptr(unsafe.Pointer(pA)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pB)) == uintptr(unsafe.Pointer(nil)) {
		return func() int32 {
			if uintptr(unsafe.Pointer(pB)) == uintptr(unsafe.Pointer(pA)) {
				return 0
			} else {
				return 2
			}
		}()
	}
	if pParse != nil && int32(pA.op) == 156 && exprCompareVariable(pParse, pA, pB) != 0 {
		return int32(0)
	}
	combinedFlags = pA.flags | pB.flags
	if combinedFlags&uint32(1024) != 0 {
		if pA.flags&pB.flags&uint32(1024) != uint32(0) && *(*int32)(unsafe.Pointer(&pA.u)) == *(*int32)(unsafe.Pointer(&pB.u)) {
			return int32(0)
		}
		return int32(2)
	}
	if int32(pA.op) != int32(pB.op) || int32(pA.op) == 71 {
		if int32(pA.op) == 113 && sqlite3ExprCompare(pParse, pA.pLeft, pB, iTab) < 2 {
			return int32(1)
		}
		if int32(pB.op) == 113 && sqlite3ExprCompare(pParse, pA, pB.pLeft, iTab) < 2 {
			return int32(1)
		}
		return int32(2)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pA.u.zToken != nil {
		if int32(pA.op) == 172 || int32(pA.op) == 168 {
			if sqlite3StrICmp(pA.u.zToken, pB.u.zToken) != 0 {
				return int32(2)
			}
			func() int {
				_ = 0
				return 0
			}()
			if func() int32 {
				if pA.flags&uint32(16777216) != uint32(0) {
					return 1
				} else {
					return 0
				}
			}() != func() int32 {
				if pB.flags&uint32(16777216) != uint32(0) {
					return 1
				} else {
					return 0
				}
			}() {
				return int32(2)
			}
			if pA.flags&uint32(16777216) != uint32(0) {
				if sqlite3WindowCompare(pParse, *(**struct_Window)(unsafe.Pointer(&pA.y)), *(**struct_Window)(unsafe.Pointer(&pB.y)), 1) != 0 {
					return int32(2)
				}
			}
		} else if int32(pA.op) == 121 {
			return int32(0)
		} else if int32(pA.op) == 113 {
			if sqlite3_stricmp(pA.u.zToken, pB.u.zToken) != 0 {
				return int32(2)
			}
		} else if uintptr(unsafe.Pointer(pB.u.zToken)) != uintptr(unsafe.Pointer(nil)) && int32(pA.op) != 167 && int32(pA.op) != 169 && strcmp(pA.u.zToken, pB.u.zToken) != 0 {
			return int32(2)
		}
	}
	if pA.flags&uint32(2|512) != pB.flags&uint32(2|512) {
		return int32(2)
	}
	if combinedFlags&uint32(16384) == uint32(0) {
		if combinedFlags&uint32(2048) != 0 {
			return int32(2)
		}
		if combinedFlags&uint32(8) == uint32(0) && sqlite3ExprCompare(pParse, pA.pLeft, pB.pLeft, iTab) != 0 {
			return int32(2)
		}
		if sqlite3ExprCompare(pParse, pA.pRight, pB.pRight, iTab) != 0 {
			return int32(2)
		}
		if sqlite3ExprListCompare(pA.x.pList, pB.x.pList, iTab) != 0 {
			return int32(2)
		}
		if int32(pA.op) != 117 && int32(pA.op) != 170 && combinedFlags&uint32(8192) == uint32(0) {
			if int32(pA.iColumn) != int32(pB.iColumn) {
				return int32(2)
			}
			if int32(pA.op2) != int32(pB.op2) && int32(pA.op) == 175 {
				return int32(2)
			}
			if int32(pA.op) != 49 && pA.iTable != pB.iTable && pA.iTable != iTab {
				return int32(2)
			}
		}
	}
	return int32(0)
}
func sqlite3ExprListCompare(pA *struct_ExprList, pB *struct_ExprList, iTab int32) int32 {
	var i int32
	if uintptr(unsafe.Pointer(pA)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pB)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pA)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pB)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	if pA.nExpr != pB.nExpr {
		return int32(1)
	}
	for i = int32(0); i < pA.nExpr; i++ {
		var res int32
		var pExprA *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pA.a)))) + uintptr(i)*28))).pExpr
		var pExprB *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pB.a)))) + uintptr(i)*28))).pExpr
		if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pA.a)))) + uintptr(i)*28))).sortFlags) != int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pB.a)))) + uintptr(i)*28))).sortFlags) {
			return int32(1)
		}
		if func() (_cgo_ret int32) {
			_cgo_addr := &res
			*_cgo_addr = sqlite3ExprCompare(nil, pExprA, pExprB, iTab)
			return *_cgo_addr
		}() != 0 {
			return res
		}
	}
	return int32(0)
}
func sqlite3ExprCompareSkip(pA *struct_Expr, pB *struct_Expr, iTab int32) int32 {
	return sqlite3ExprCompare(nil, sqlite3ExprSkipCollateAndLikely(pA), sqlite3ExprSkipCollateAndLikely(pB), iTab)
}
func exprImpliesNotNull(pParse *struct_Parse, p *struct_Expr, pNN *struct_Expr, iTab int32, seenNot int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3ExprCompare(pParse, p, pNN, iTab) == 0 {
		return func() int32 {
			if int32(pNN.op) != 121 {
				return 1
			} else {
				return 0
			}
		}()
	}
	switch int32(p.op) {
	case 49:
		{
			if seenNot != 0 && p.flags&uint32(2048) != uint32(0) {
				return int32(0)
			}
			func() int {
				_ = 0
				return 0
			}()
			return exprImpliesNotNull(pParse, p.pLeft, pNN, iTab, 1)
		}
	case 48:
		{
			var pList *struct_ExprList
			func() int {
				_ = 0
				return 0
			}()
			pList = p.x.pList
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if seenNot != 0 {
				return int32(0)
			}
			if exprImpliesNotNull(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr, pNN, iTab, 1) != 0 || exprImpliesNotNull(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(1)*28))).pExpr, pNN, iTab, 1) != 0 {
				return int32(1)
			}
			return exprImpliesNotNull(pParse, p.pLeft, pNN, iTab, 1)
		}
	case 53:
		fallthrough
	case 52:
		fallthrough
	case 56:
		fallthrough
	case 55:
		fallthrough
	case 54:
		fallthrough
	case 57:
		fallthrough
	case 106:
		fallthrough
	case 107:
		fallthrough
	case 103:
		fallthrough
	case 104:
		fallthrough
	case 105:
		fallthrough
	case 111:
		seenNot = int32(1)
	case 108:
		fallthrough
	case 110:
		fallthrough
	case 102:
		fallthrough
	case 109:
		{
			if exprImpliesNotNull(pParse, p.pRight, pNN, iTab, seenNot) != 0 {
				return int32(1)
			}
		}
	case 181:
		fallthrough
	case 113:
		fallthrough
	case 174:
		fallthrough
	case 173:
		{
			return exprImpliesNotNull(pParse, p.pLeft, pNN, iTab, seenNot)
		}
	case 175:
		{
			if seenNot != 0 {
				return int32(0)
			}
			if int32(p.op2) != 45 {
				return int32(0)
			}
			return exprImpliesNotNull(pParse, p.pLeft, pNN, iTab, 1)
		}
	case 114:
		fallthrough
	case 19:
		{
			return exprImpliesNotNull(pParse, p.pLeft, pNN, iTab, 1)
		}
	}
	return int32(0)
}
func sqlite3ExprImpliesExpr(pParse *struct_Parse, pE1 *struct_Expr, pE2 *struct_Expr, iTab int32) int32 {
	if sqlite3ExprCompare(pParse, pE1, pE2, iTab) == 0 {
		return int32(1)
	}
	if int32(pE2.op) == 43 && (sqlite3ExprImpliesExpr(pParse, pE1, pE2.pLeft, iTab) != 0 || sqlite3ExprImpliesExpr(pParse, pE1, pE2.pRight, iTab) != 0) {
		return int32(1)
	}
	if int32(pE2.op) == 51 && exprImpliesNotNull(pParse, pE1, pE2.pLeft, iTab, 0) != 0 {
		return int32(1)
	}
	return int32(0)
}
func impliesNotNullRow(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if pExpr.flags&uint32(1) != uint32(0) {
		return int32(1)
	}
	switch int32(pExpr.op) {
	case 171:
		fallthrough
	case 50:
		fallthrough
	case 51:
		fallthrough
	case 45:
		fallthrough
	case 43:
		fallthrough
	case 177:
		fallthrough
	case 157:
		fallthrough
	case 49:
		fallthrough
	case 172:
		fallthrough
	case 175:
		return int32(1)
	case 167:
		if *(*int32)(unsafe.Pointer(&pWalker.u)) == pExpr.iTable {
			pWalker.eCode = uint16(1)
			return int32(2)
		}
		return int32(1)
	case 44:
		if int32(pWalker.eCode) == 0 {
			sqlite3WalkExpr(pWalker, pExpr.pLeft)
			if pWalker.eCode != 0 {
				pWalker.eCode = uint16(0)
				sqlite3WalkExpr(pWalker, pExpr.pRight)
			}
		}
		return int32(1)
	case 48:
		if sqlite3WalkExpr(pWalker, pExpr.pLeft) == 2 {
			func() int {
				_ = 0
				return 0
			}()
			return int32(2)
		}
		return int32(1)
	case 53:
		fallthrough
	case 52:
		fallthrough
	case 56:
		fallthrough
	case 55:
		fallthrough
	case 54:
		fallthrough
	case 57:
		{
			var pLeft *struct_Expr = pExpr.pLeft
			var pRight *struct_Expr = pExpr.pRight
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(pLeft.op) == 167 && uintptr(unsafe.Pointer(pLeft.y.pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pLeft.y.pTab.eTabType) == 1 || int32(pRight.op) == 167 && uintptr(unsafe.Pointer(pRight.y.pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pRight.y.pTab.eTabType) == 1 {
				return int32(1)
			}
		}
	default:
		return int32(0)
	}
}
func sqlite3ExprImpliesNonNullRow(p *struct_Expr, iTab int32) int32 {
	var w struct_Walker
	p = sqlite3ExprSkipCollateAndLikely(p)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if int32(p.op) == 51 {
		p = p.pLeft
	} else {
		for int32(p.op) == 44 {
			if sqlite3ExprImpliesNonNullRow(p.pLeft, iTab) != 0 {
				return int32(1)
			}
			p = p.pRight
		}
	}
	w.xExprCallback = impliesNotNullRow
	w.xSelectCallback = (func(*struct_Walker, *struct_Select) int32)(nil)
	w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
	w.eCode = uint16(0)
	*(*int32)(unsafe.Pointer(&w.u)) = iTab
	sqlite3WalkExpr(&w, p)
	return int32(w.eCode)
}

type struct_IdxCover struct {
	pIdx *struct_Index
	iCur int32
}

func exprIdxCover(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 167 && pExpr.iTable == (*(**struct_IdxCover)(unsafe.Pointer(&pWalker.u))).iCur && int32(sqlite3TableColumnToIndex((*(**struct_IdxCover)(unsafe.Pointer(&pWalker.u))).pIdx, pExpr.iColumn)) < 0 {
		pWalker.eCode = uint16(1)
		return int32(2)
	}
	return int32(0)
}
func sqlite3ExprCoveredByIndex(pExpr *struct_Expr, iCur int32, pIdx *struct_Index) int32 {
	var w struct_Walker
	var xcov struct_IdxCover
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	xcov.iCur = iCur
	xcov.pIdx = pIdx
	w.xExprCallback = exprIdxCover
	*(**struct_IdxCover)(unsafe.Pointer(&w.u)) = &xcov
	sqlite3WalkExpr(&w, pExpr)
	return func() int32 {
		if !(w.eCode != 0) {
			return 1
		} else {
			return 0
		}
	}()
}

type struct_RefSrcList struct {
	db        *struct_sqlite3
	pRef      *struct_SrcList
	nExclude  int64
	aiExclude *int32
}

func selectRefEnter(pWalker *struct_Walker, pSelect *struct_Select) int32 {
	var p *struct_RefSrcList = *(**struct_RefSrcList)(unsafe.Pointer(&pWalker.u))
	var pSrc *struct_SrcList = pSelect.pSrc
	var i int64
	var j int64
	var piNew *int32
	if pSrc.nSrc == 0 {
		return int32(0)
	}
	j = p.nExclude
	p.nExclude += int64(pSrc.nSrc)
	piNew = (*int32)(sqlite3DbRealloc(p.db, unsafe.Pointer(p.aiExclude), uint64(p.nExclude)*uint64(4)))
	if uintptr(unsafe.Pointer(piNew)) == uintptr(unsafe.Pointer(nil)) {
		p.nExclude = int64(0)
		return int32(2)
	} else {
		p.aiExclude = piNew
	}
	for i = int64(0); i < int64(pSrc.nSrc); func() int64 {
		i++
		return func() (_cgo_ret int64) {
			_cgo_addr := &j
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aiExclude)) + uintptr(j)*4)) = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).iCursor
	}
	return int32(0)
}
func selectRefLeave(pWalker *struct_Walker, pSelect *struct_Select) {
	var p *struct_RefSrcList = *(**struct_RefSrcList)(unsafe.Pointer(&pWalker.u))
	var pSrc *struct_SrcList = pSelect.pSrc
	if p.nExclude != 0 {
		func() int {
			_ = 0
			return 0
		}()
		p.nExclude -= int64(pSrc.nSrc)
	}
}
func exprRefToSrcList(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 167 || int32(pExpr.op) == 169 {
		var i int32
		var p *struct_RefSrcList = *(**struct_RefSrcList)(unsafe.Pointer(&pWalker.u))
		var pSrc *struct_SrcList = p.pRef
		var nSrc int32 = func() int32 {
			if pSrc != nil {
				return pSrc.nSrc
			} else {
				return 0
			}
		}()
		for i = int32(0); i < nSrc; i++ {
			if pExpr.iTable == (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).iCursor {
				pWalker.eCode |= uint16(1)
				return int32(0)
			}
		}
		for i = int32(0); int64(i) < p.nExclude && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aiExclude)) + uintptr(i)*4)) != pExpr.iTable; i++ {
		}
		if int64(i) >= p.nExclude {
			pWalker.eCode |= uint16(2)
		}
	}
	return int32(0)
}
func sqlite3ReferencesSrcList(pParse *struct_Parse, pExpr *struct_Expr, pSrcList *struct_SrcList) int32 {
	var w struct_Walker
	var x struct_RefSrcList
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	__builtin___memset_chk(unsafe.Pointer(&x), 0, 32, __builtin_object_size(unsafe.Pointer(&x), 0))
	w.xExprCallback = exprRefToSrcList
	w.xSelectCallback = selectRefEnter
	w.xSelectCallback2 = selectRefLeave
	*(**struct_RefSrcList)(unsafe.Pointer(&w.u)) = &x
	x.db = pParse.db
	x.pRef = pSrcList
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3WalkExprList(&w, pExpr.x.pList)
	if pExpr.flags&uint32(16777216) != uint32(0) {
		sqlite3WalkExpr(&w, (*(**struct_Window)(unsafe.Pointer(&pExpr.y))).pFilter)
	}
	sqlite3DbFree(pParse.db, unsafe.Pointer(x.aiExclude))
	if int32(w.eCode)&1 != 0 {
		return int32(1)
	} else if w.eCode != 0 {
		return int32(0)
	} else {
		return int32(-1)
	}
}
func agginfoPersistExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if !(pExpr.flags&uint32(16384|8192) != uint32(0)) && uintptr(unsafe.Pointer(pExpr.pAggInfo)) != uintptr(unsafe.Pointer(nil)) {
		var pAggInfo *struct_AggInfo = pExpr.pAggInfo
		var iAgg int32 = int32(pExpr.iAgg)
		var pParse *struct_Parse = pWalker.pParse
		var db *struct_sqlite3 = pParse.db
		func() int {
			_ = 0
			return 0
		}()
		if int32(pExpr.op) == 169 {
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer((*(*struct_AggInfo_col)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aCol)) + uintptr(iAgg)*28))).pCExpr)) == uintptr(unsafe.Pointer(pExpr)) {
				pExpr = sqlite3ExprDup(db, pExpr, 0)
				if pExpr != nil {
					(*(*struct_AggInfo_col)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aCol)) + uintptr(iAgg)*28))).pCExpr = pExpr
					sqlite3ExprDeferredDelete(pParse, pExpr)
				}
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer((*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(iAgg)*28))).pFExpr)) == uintptr(unsafe.Pointer(pExpr)) {
				pExpr = sqlite3ExprDup(db, pExpr, 0)
				if pExpr != nil {
					(*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(iAgg)*28))).pFExpr = pExpr
					sqlite3ExprDeferredDelete(pParse, pExpr)
				}
			}
		}
	}
	return int32(0)
}
func sqlite3AggInfoPersistWalkerInit(pWalker *struct_Walker, pParse *struct_Parse) {
	__builtin___memset_chk(unsafe.Pointer(pWalker), 0, 48, __builtin_object_size(unsafe.Pointer(pWalker), 0))
	pWalker.pParse = pParse
	pWalker.xExprCallback = agginfoPersistExprCb
	pWalker.xSelectCallback = sqlite3SelectWalkNoop
}
func addAggInfoColumn(db *struct_sqlite3, pInfo *struct_AggInfo) int32 {
	var i int32
	pInfo.aCol = (*struct_AggInfo_col)(sqlite3ArrayAllocate(db, unsafe.Pointer(pInfo.aCol), int32(28), &pInfo.nColumn, &i))
	return i
}
func addAggInfoFunc(db *struct_sqlite3, pInfo *struct_AggInfo) int32 {
	var i int32
	pInfo.aFunc = (*struct_AggInfo_func)(sqlite3ArrayAllocate(db, unsafe.Pointer(pInfo.aFunc), int32(28), &pInfo.nFunc, &i))
	return i
}
func analyzeAggregate(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var i int32
	var pNC *struct_NameContext = pWalker.u.pNC
	var pParse *struct_Parse = pNC.pParse
	var pSrcList *struct_SrcList = pNC.pSrcList
	var pAggInfo *struct_AggInfo = *(**struct_AggInfo)(unsafe.Pointer(&pNC.uNC))
	func() int {
		_ = 0
		return 0
	}()
	switch int32(pExpr.op) {
	case 169:
		fallthrough
	case 167:
		{
			if uintptr(unsafe.Pointer(pSrcList)) != uintptr(unsafe.Pointer(nil)) {
				var pItem *struct_SrcItem = (*struct_SrcItem)(unsafe.Pointer(&pSrcList.a))
				for i = int32(0); i < pSrcList.nSrc; func() *struct_SrcItem {
					i++
					return func() (_cgo_ret *struct_SrcItem) {
						_cgo_addr := &pItem
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
						return
					}()
				}() {
					var pCol *struct_AggInfo_col
					func() int {
						_ = 0
						return 0
					}()
					if pExpr.iTable == pItem.iCursor {
						var k int32
						pCol = pAggInfo.aCol
						for k = int32(0); k < pAggInfo.nColumn; func() *struct_AggInfo_col {
							k++
							return func() (_cgo_ret *struct_AggInfo_col) {
								_cgo_addr := &pCol
								_cgo_ret = *_cgo_addr
								*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
								return
							}()
						}() {
							if pCol.iTable == pExpr.iTable && int32(pCol.iColumn) == int32(pExpr.iColumn) {
								break
							}
						}
						if k >= pAggInfo.nColumn && func() (_cgo_ret int32) {
							_cgo_addr := &k
							*_cgo_addr = addAggInfoColumn(pParse.db, pAggInfo)
							return *_cgo_addr
						}() >= 0 {
							pCol = &*(*struct_AggInfo_col)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aCol)) + uintptr(k)*28))
							func() int {
								_ = 0
								return 0
							}()
							pCol.pTab = pExpr.y.pTab
							pCol.iTable = pExpr.iTable
							pCol.iColumn = pExpr.iColumn
							pCol.iMem = func() (_cgo_ret int32) {
								_cgo_addr := &pParse.nMem
								*_cgo_addr++
								return *_cgo_addr
							}()
							pCol.iSorterColumn = int16(-1)
							pCol.pCExpr = pExpr
							if pAggInfo.pGroupBy != nil {
								var j int32
								var n int32
								var pGB *struct_ExprList = pAggInfo.pGroupBy
								var pTerm *struct_ExprList_item = (*struct_ExprList_item)(unsafe.Pointer(&pGB.a))
								n = pGB.nExpr
								for j = int32(0); j < n; func() *struct_ExprList_item {
									j++
									return func() (_cgo_ret *struct_ExprList_item) {
										_cgo_addr := &pTerm
										_cgo_ret = *_cgo_addr
										*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
										return
									}()
								}() {
									var pE *struct_Expr = pTerm.pExpr
									if int32(pE.op) == 167 && pE.iTable == pExpr.iTable && int32(pE.iColumn) == int32(pExpr.iColumn) {
										pCol.iSorterColumn = int16(j)
										break
									}
								}
							}
							if int32(pCol.iSorterColumn) < 0 {
								pCol.iSorterColumn = int16(func() (_cgo_ret int32) {
									_cgo_addr := &pAggInfo.nSortingColumn
									_cgo_ret = *_cgo_addr
									*_cgo_addr++
									return
								}())
							}
						}
						pExpr.pAggInfo = pAggInfo
						pExpr.op = uint8(169)
						pExpr.iAgg = int16(k)
						break
					}
				}
			}
			return int32(1)
		}
	case 168:
		{
			if pNC.ncFlags&131072 == 0 && pWalker.walkerDepth == int32(pExpr.op2) {
				var pItem *struct_AggInfo_func = pAggInfo.aFunc
				for i = int32(0); i < pAggInfo.nFunc; func() *struct_AggInfo_func {
					i++
					return func() (_cgo_ret *struct_AggInfo_func) {
						_cgo_addr := &pItem
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
						return
					}()
				}() {
					if uintptr(unsafe.Pointer(pItem.pFExpr)) == uintptr(unsafe.Pointer(pExpr)) {
						break
					}
					if sqlite3ExprCompare(nil, pItem.pFExpr, pExpr, -1) == 0 {
						break
					}
				}
				if i >= pAggInfo.nFunc {
					var enc uint8 = pParse.db.enc
					i = addAggInfoFunc(pParse.db, pAggInfo)
					if i >= 0 {
						func() int {
							_ = 0
							return 0
						}()
						pItem = &*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(i)*28))
						pItem.pFExpr = pExpr
						pItem.iMem = func() (_cgo_ret int32) {
							_cgo_addr := &pParse.nMem
							*_cgo_addr++
							return *_cgo_addr
						}()
						func() int {
							_ = 0
							return 0
						}()
						pItem.pFunc = sqlite3FindFunction(pParse.db, pExpr.u.zToken, func() int32 {
							if pExpr.x.pList != nil {
								return pExpr.x.pList.nExpr
							} else {
								return 0
							}
						}(), enc, uint8(0))
						if pExpr.flags&uint32(2) != 0 {
							pItem.iDistinct = func() (_cgo_ret int32) {
								_cgo_addr := &pParse.nTab
								_cgo_ret = *_cgo_addr
								*_cgo_addr++
								return
							}()
						} else {
							pItem.iDistinct = int32(-1)
						}
					}
				}
				func() int {
					_ = 0
					return 0
				}()
				pExpr.iAgg = int16(i)
				pExpr.pAggInfo = pAggInfo
				return int32(1)
			} else {
				return int32(0)
			}
		}
	}
	return int32(0)
}
func sqlite3ExprAnalyzeAggregates(pNC *struct_NameContext, pExpr *struct_Expr) {
	var w struct_Walker
	w.xExprCallback = analyzeAggregate
	w.xSelectCallback = sqlite3WalkerDepthIncrease
	w.xSelectCallback2 = sqlite3WalkerDepthDecrease
	w.walkerDepth = int32(0)
	w.u.pNC = pNC
	w.pParse = (*struct_Parse)(nil)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3WalkExpr(&w, pExpr)
}
func sqlite3ExprAnalyzeAggList(pNC *struct_NameContext, pList *struct_ExprList) {
	var pItem *struct_ExprList_item
	var i int32
	if pList != nil {
		for func() int32 {
			pItem = (*struct_ExprList_item)(unsafe.Pointer(&pList.a))
			return func() (_cgo_ret int32) {
				_cgo_addr := &i
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
		}(); i < pList.nExpr; func() *struct_ExprList_item {
			i++
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}() {
			sqlite3ExprAnalyzeAggregates(pNC, pItem.pExpr)
		}
	}
}
func sqlite3GetTempReg(pParse *struct_Parse) int32 {
	if int32(pParse.nTempReg) == 0 {
		return func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
	}
	return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.aTempReg)))) + uintptr(func() (_cgo_ret uint8) {
		_cgo_addr := &pParse.nTempReg
		*_cgo_addr--
		return *_cgo_addr
	}())*4))
}
func sqlite3ReleaseTempReg(pParse *struct_Parse, iReg int32) {
	if iReg != 0 {
		if int32(pParse.nTempReg) < int32(32/4) {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.aTempReg)))) + uintptr(func() (_cgo_ret uint8) {
				_cgo_addr := &pParse.nTempReg
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*4)) = iReg
		}
	}
}
func sqlite3GetTempRange(pParse *struct_Parse, nReg int32) int32 {
	var i int32
	var n int32
	if nReg == 1 {
		return sqlite3GetTempReg(pParse)
	}
	i = pParse.iRangeReg
	n = pParse.nRangeReg
	if nReg <= n {
		pParse.iRangeReg += nReg
		pParse.nRangeReg -= nReg
	} else {
		i = pParse.nMem + 1
		pParse.nMem += nReg
	}
	return i
}
func sqlite3ReleaseTempRange(pParse *struct_Parse, iReg int32, nReg int32) {
	if nReg == 1 {
		sqlite3ReleaseTempReg(pParse, iReg)
		return
	}
	if nReg > pParse.nRangeReg {
		pParse.nRangeReg = nReg
		pParse.iRangeReg = iReg
	}
}
func sqlite3ClearTempRegCache(pParse *struct_Parse) {
	pParse.nTempReg = uint8(0)
	pParse.nRangeReg = int32(0)
}
func isAlterableTable(pParse *struct_Parse, pTab *struct_Table) int32 {
	if 0 == sqlite3_strnicmp(pTab.zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) || pTab.tabFlags&uint32(32768) != uint32(0) || pTab.tabFlags&uint32(4096) != uint32(0) && sqlite3ReadOnlyShadowTables(pParse.db) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'a', 'l', 't', 'e', 'r', 'e', 'd', '\x00'})), pTab.zName)
		return int32(1)
	}
	return int32(0)
}
func renameTestSchema(pParse *struct_Parse, zDb *int8, bTemp int32, zWhen *int8, bNoDQS int32) {
	pParse.colNamesSet = uint8(1)
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[175]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', '1', ' ', 'F', 'R', 'O', 'M', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', '%', '%', '\'', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'e', 's', 't', '(', '%', 'Q', ',', ' ', 's', 'q', 'l', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', '%', 'd', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ')', '=', 'N', 'U', 'L', 'L', ' ', '\x00'})), zDb, zDb, bTemp, zWhen, bNoDQS)
	if bTemp == 0 {
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[174]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', '1', ' ', 'F', 'R', 'O', 'M', ' ', 't', 'e', 'm', 'p', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', '%', '%', '\'', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'e', 's', 't', '(', '%', 'Q', ',', ' ', 's', 'q', 'l', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', '1', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ')', '=', 'N', 'U', 'L', 'L', ' ', '\x00'})), zDb, zWhen, bNoDQS)
	}
}
func renameFixQuotes(pParse *struct_Parse, zDb *int8, bTemp int32) {
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[147]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 'q', 'u', 'o', 't', 'e', 'f', 'i', 'x', '(', '%', 'Q', ',', ' ', 's', 'q', 'l', ')', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', '%', '%', '\'', '\x00'})), zDb, zDb)
	if bTemp == 0 {
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[151]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', 't', 'e', 'm', 'p', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 'q', 'u', 'o', 't', 'e', 'f', 'i', 'x', '(', '\'', 't', 'e', 'm', 'p', '\'', ',', ' ', 's', 'q', 'l', ')', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', '%', '%', '\'', '\x00'})))
	}
}
func renameReloadSchema(pParse *struct_Parse, iDb int32, p5 uint16) {
	var v *struct_Vdbe = pParse.pVdbe
	if v != nil {
		sqlite3ChangeCookie(pParse, iDb)
		sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, iDb, nil, p5)
		if iDb != 1 {
			sqlite3VdbeAddParseSchemaOp(pParse.pVdbe, 1, nil, p5)
		}
	}
}
func sqlite3AlterRenameTable(pParse *struct_Parse, pSrc *struct_SrcList, pName *struct_Token) {
	var iDb int32
	var zDb *int8
	var pTab *struct_Table
	var zName *int8 = nil
	var db *struct_sqlite3 = pParse.db
	var nTabName int32
	var zTabName *int8
	var v *struct_Vdbe
	var pVTab *struct_VTable = nil
	if db.mallocFailed != 0 {
		goto exit_rename_table
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pTab = sqlite3LocateTableItem(pParse, uint32(0), &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112)))
	if !(pTab != nil) {
		goto exit_rename_table
	}
	iDb = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
	zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	zName = sqlite3NameFromToken(db, pName)
	if !(zName != nil) {
		goto exit_rename_table
	}
	if sqlite3FindTable(db, zName, zDb) != nil || sqlite3FindIndex(db, zName, zDb) != nil || sqlite3IsShadowTableOf(db, pTab, zName) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[59]int8{'t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'a', 'n', 'o', 't', 'h', 'e', 'r', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'o', 'r', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'w', 'i', 't', 'h', ' ', 't', 'h', 'i', 's', ' ', 'n', 'a', 'm', 'e', ':', ' ', '%', 's', '\x00'})), zName)
		goto exit_rename_table
	}
	if 0 != isAlterableTable(pParse, pTab) {
		goto exit_rename_table
	}
	if 0 != sqlite3CheckObjectName(pParse, zName, (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'})), zName) {
		goto exit_rename_table
	}
	if int32(pTab.eTabType) == 2 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'v', 'i', 'e', 'w', ' ', '%', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'a', 'l', 't', 'e', 'r', 'e', 'd', '\x00'})), pTab.zName)
		goto exit_rename_table
	}
	if sqlite3AuthCheck(pParse, 26, zDb, pTab.zName, nil) != 0 {
		goto exit_rename_table
	}
	if sqlite3ViewGetColumnNames(pParse, pTab) != 0 {
		goto exit_rename_table
	}
	if int32(pTab.eTabType) == 1 {
		pVTab = sqlite3GetVTable(db, pTab)
		if uintptr(unsafe.Pointer(pVTab.pVtab.pModule.xRename)) == uintptr(unsafe.Pointer(nil)) {
			pVTab = (*struct_VTable)(nil)
		}
	}
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		goto exit_rename_table
	}
	sqlite3MayAbort(pParse)
	zTabName = pTab.zName
	nTabName = sqlite3Utf8CharLen(zTabName, -1)
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[184]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'a', 'b', 'l', 'e', '(', '%', 'Q', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', 's', 'q', 'l', ',', ' ', '%', 'Q', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ')', ' ', 'W', 'H', 'E', 'R', 'E', ' ', '(', 't', 'y', 'p', 'e', '!', '=', '\'', 'i', 'n', 'd', 'e', 'x', '\'', ' ', 'O', 'R', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'C', 'O', 'L', 'L', 'A', 'T', 'E', ' ', 'n', 'o', 'c', 'a', 's', 'e', ')', 'A', 'N', 'D', ' ', ' ', ' ', 'n', 'a', 'm', 'e', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', '\x00'})), zDb, zDb, zTabName, zName, iDb == 1, zTabName)
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[305]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', ' ', '=', ' ', '%', 'Q', ',', ' ', 'n', 'a', 'm', 'e', ' ', '=', ' ', 'C', 'A', 'S', 'E', ' ', 'W', 'H', 'E', 'N', ' ', 't', 'y', 'p', 'e', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', ' ', 'T', 'H', 'E', 'N', ' ', '%', 'Q', ' ', 'W', 'H', 'E', 'N', ' ', 'n', 'a', 'm', 'e', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', 'a', 'u', 't', 'o', 'i', 'n', 'd', 'e', 'x', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', ' ', ' ', ' ', ' ', ' ', ' ', 'A', 'N', 'D', ' ', 't', 'y', 'p', 'e', '=', '\'', 'i', 'n', 'd', 'e', 'x', '\'', ' ', 'T', 'H', 'E', 'N', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', '_', 'a', 'u', 't', 'o', 'i', 'n', 'd', 'e', 'x', '_', '\'', ' ', '|', '|', ' ', '%', 'Q', ' ', '|', '|', ' ', 's', 'u', 'b', 's', 't', 'r', '(', 'n', 'a', 'm', 'e', ',', '%', 'd', '+', '1', '8', ')', ' ', 'E', 'L', 'S', 'E', ' ', 'n', 'a', 'm', 'e', ' ', 'E', 'N', 'D', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'C', 'O', 'L', 'L', 'A', 'T', 'E', ' ', 'n', 'o', 'c', 'a', 's', 'e', ' ', 'A', 'N', 'D', ' ', '(', 't', 'y', 'p', 'e', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', ' ', 'O', 'R', ' ', 't', 'y', 'p', 'e', '=', '\'', 'i', 'n', 'd', 'e', 'x', '\'', ' ', 'O', 'R', ' ', 't', 'y', 'p', 'e', '=', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', ')', ';', '\x00'})), zDb, zName, zName, zName, nTabName, zTabName)
	if sqlite3FindTable(db, (*int8)(unsafe.Pointer(&[16]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', '\x00'})), zDb) != nil {
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[58]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 's', 'e', 't', ' ', 'n', 'a', 'm', 'e', ' ', '=', ' ', '%', 'Q', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', ' ', '=', ' ', '%', 'Q', '\x00'})), zDb, zName, pTab.zName)
	}
	if iDb != 1 {
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[265]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'a', 'b', 'l', 'e', '(', '%', 'Q', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', 's', 'q', 'l', ',', ' ', '%', 'Q', ',', ' ', '%', 'Q', ',', ' ', '1', ')', ',', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', ' ', '=', ' ', 'C', 'A', 'S', 'E', ' ', 'W', 'H', 'E', 'N', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'C', 'O', 'L', 'L', 'A', 'T', 'E', ' ', 'n', 'o', 'c', 'a', 's', 'e', ' ', 'A', 'N', 'D', ' ', ' ', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'e', 's', 't', '(', '%', 'Q', ',', ' ', 's', 'q', 'l', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', '1', ',', ' ', '\'', 'a', 'f', 't', 'e', 'r', ' ', 'r', 'e', 'n', 'a', 'm', 'e', '\'', ',', ' ', '0', ')', ' ', 'T', 'H', 'E', 'N', ' ', '%', 'Q', ' ', 'E', 'L', 'S', 'E', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', ' ', 'E', 'N', 'D', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', ' ', 'I', 'N', ' ', '(', '\'', 'v', 'i', 'e', 'w', '\'', ',', ' ', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', ')', '\x00'})), zDb, zTabName, zName, zTabName, zDb, zName)
	}
	if pVTab != nil {
		var i int32 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeLoadString(v, i, zName)
		sqlite3VdbeAddOp4(v, 175, i, 0, 0, (*int8)(unsafe.Pointer(pVTab)), -12)
	}
	renameReloadSchema(pParse, iDb, uint16(1))
	renameTestSchema(pParse, zDb, func() int32 {
		if iDb == 1 {
			return 1
		} else {
			return 0
		}
	}(), (*int8)(unsafe.Pointer(&[13]int8{'a', 'f', 't', 'e', 'r', ' ', 'r', 'e', 'n', 'a', 'm', 'e', '\x00'})), 0)
exit_rename_table:
	sqlite3SrcListDelete(db, pSrc)
	sqlite3DbFree(db, unsafe.Pointer(zName))
}
func sqlite3ErrorIfNotEmpty(pParse *struct_Parse, zDb *int8, zTab *int8, zErr *int8) {
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[38]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', 'r', 'a', 'i', 's', 'e', '(', 'A', 'B', 'O', 'R', 'T', ',', '%', 'Q', ')', ' ', 'F', 'R', 'O', 'M', ' ', '"', '%', 'w', '"', '.', '"', '%', 'w', '"', '\x00'})), zErr, zDb, zTab)
}
func sqlite3AlterFinishAddColumn(pParse *struct_Parse, pColDef *struct_Token) {
	var pNew *struct_Table
	var pTab *struct_Table
	var iDb int32
	var zDb *int8
	var zTab *int8
	var zCol *int8
	var pCol *struct_Column
	var pDflt *struct_Expr
	var db *struct_sqlite3
	var v *struct_Vdbe
	var r1 int32
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	pNew = pParse.pNewTable
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iDb = sqlite3SchemaToIndex(db, pNew.pSchema)
	zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	zTab = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.zName)) + uintptr(16)))
	pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aCol)) + uintptr(int32(pNew.nCol)-1)*20))
	pDflt = sqlite3ColumnExpr(pNew, pCol)
	pTab = sqlite3FindTable(db, zTab, zDb)
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3AuthCheck(pParse, 26, zDb, pTab.zName, nil) != 0 {
		return
	}
	if int32(pCol.colFlags)&1 != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[32]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})))
		return
	}
	if pNew.pIndex != nil {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'U', 'N', 'I', 'Q', 'U', 'E', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})))
		return
	}
	if int32(pCol.colFlags)&96 == 0 {
		func() int {
			_ = 0
			return 0
		}()
		if pDflt != nil && int32(pDflt.pLeft.op) == 121 {
			pDflt = (*struct_Expr)(nil)
		}
		func() int {
			_ = 0
			return 0
		}()
		if db.flags&uint64(16384) != 0 && pNew.u.tab.pFKey != nil && pDflt != nil {
			sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, (*int8)(unsafe.Pointer(&[59]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'R', 'E', 'F', 'E', 'R', 'E', 'N', 'C', 'E', 'S', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'o', 'n', '-', 'N', 'U', 'L', 'L', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'v', 'a', 'l', 'u', 'e', '\x00'})))
		}
		if int32(pCol.Xbf_0&15) != 0 && !(pDflt != nil) {
			sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, (*int8)(unsafe.Pointer(&[53]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'N', 'O', 'T', ' ', 'N', 'U', 'L', 'L', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'w', 'i', 't', 'h', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'N', 'U', 'L', 'L', '\x00'})))
		}
		if pDflt != nil {
			var pVal *struct_sqlite3_value = nil
			var rc int32
			rc = sqlite3ValueFromExpr(db, pDflt, uint8(1), uint8(65), &pVal)
			func() int {
				_ = 0
				return 0
			}()
			if rc != 0 {
				func() int {
					_ = 0
					return 0
				}()
				return
			}
			if !(pVal != nil) {
				sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, (*int8)(unsafe.Pointer(&[46]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'w', 'i', 't', 'h', ' ', 'n', 'o', 'n', '-', 'c', 'o', 'n', 's', 't', 'a', 'n', 't', ' ', 'd', 'e', 'f', 'a', 'u', 'l', 't', '\x00'})))
			}
			sqlite3ValueFree(pVal)
		}
	} else if int32(pCol.colFlags)&64 != 0 {
		sqlite3ErrorIfNotEmpty(pParse, zDb, zTab, (*int8)(unsafe.Pointer(&[27]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'S', 'T', 'O', 'R', 'E', 'D', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})))
	}
	zCol = sqlite3DbStrNDup(db, (*int8)(unsafe.Pointer(pColDef.z)), uint64(pColDef.n))
	if zCol != nil {
		var zEnd *int8 = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zCol)) + uintptr(pColDef.n-uint32(1))))
		for uintptr(unsafe.Pointer(zEnd)) > uintptr(unsafe.Pointer(zCol)) && (int32(*zEnd) == ';' || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*zEnd)))))&1 != 0) {
			*func() (_cgo_ret *int8) {
				_cgo_addr := &zEnd
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))--
				return
			}() = int8('\x00')
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[146]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 'p', 'r', 'i', 'n', 't', 'f', '(', '\'', '%', '%', '.', '%', 'd', 's', ',', ' ', '\'', ',', 's', 'q', 'l', ')', ' ', '|', '|', ' ', '%', 'Q', ' ', '|', '|', ' ', 's', 'u', 'b', 's', 't', 'r', '(', 's', 'q', 'l', ',', '1', '+', 'l', 'e', 'n', 'g', 't', 'h', '(', 'p', 'r', 'i', 'n', 't', 'f', '(', '\'', '%', '%', '.', '%', 'd', 's', '\'', ',', 's', 'q', 'l', ')', ')', ')', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', ' ', '=', ' ', '\'', 't', 'a', 'b', 'l', 'e', '\'', ' ', 'A', 'N', 'D', ' ', 'n', 'a', 'm', 'e', ' ', '=', ' ', '%', 'Q', '\x00'})), zDb, pNew.u.tab.addColOffset, zCol, pNew.u.tab.addColOffset, zTab)
		sqlite3DbFree(db, unsafe.Pointer(zCol))
	}
	v = sqlite3GetVdbe(pParse)
	if v != nil {
		r1 = sqlite3GetTempReg(pParse)
		sqlite3VdbeAddOp3(v, 98, iDb, r1, 2)
		sqlite3VdbeUsesBtree(v, iDb)
		sqlite3VdbeAddOp2(v, 85, r1, -2)
		sqlite3VdbeAddOp2(v, 49, r1, sqlite3VdbeCurrentAddr(v)+2)
		sqlite3VdbeAddOp3(v, 99, iDb, 2, 3)
		sqlite3ReleaseTempReg(pParse, r1)
		renameReloadSchema(pParse, iDb, uint16(3))
		if uintptr(unsafe.Pointer(pNew.pCheck)) != uintptr(unsafe.Pointer(nil)) || int32(pCol.Xbf_0&15) != 0 && int32(pCol.colFlags)&96 != 0 {
			sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[230]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', 'C', 'A', 'S', 'E', ' ', 'W', 'H', 'E', 'N', ' ', 'q', 'u', 'i', 'c', 'k', '_', 'c', 'h', 'e', 'c', 'k', ' ', 'G', 'L', 'O', 'B', ' ', '\'', 'C', 'H', 'E', 'C', 'K', '*', '\'', ' ', 'T', 'H', 'E', 'N', ' ', 'r', 'a', 'i', 's', 'e', '(', 'A', 'B', 'O', 'R', 'T', ',', '\'', 'C', 'H', 'E', 'C', 'K', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', '\'', ')', ' ', 'E', 'L', 'S', 'E', ' ', 'r', 'a', 'i', 's', 'e', '(', 'A', 'B', 'O', 'R', 'T', ',', '\'', 'N', 'O', 'T', ' ', 'N', 'U', 'L', 'L', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', '\'', ')', ' ', 'E', 'N', 'D', ' ', ' ', 'F', 'R', 'O', 'M', ' ', 'p', 'r', 'a', 'g', 'm', 'a', '_', 'q', 'u', 'i', 'c', 'k', '_', 'c', 'h', 'e', 'c', 'k', '(', '%', 'Q', ',', '%', 'Q', ')', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'q', 'u', 'i', 'c', 'k', '_', 'c', 'h', 'e', 'c', 'k', ' ', 'G', 'L', 'O', 'B', ' ', '\'', 'C', 'H', 'E', 'C', 'K', '*', '\'', ' ', 'O', 'R', ' ', 'q', 'u', 'i', 'c', 'k', '_', 'c', 'h', 'e', 'c', 'k', ' ', 'G', 'L', 'O', 'B', ' ', '\'', 'N', 'U', 'L', 'L', '*', '\'', '\x00'})), zTab, zDb)
		}
	}
}
func sqlite3AlterBeginAddColumn(pParse *struct_Parse, pSrc *struct_SrcList) {
	var pNew *struct_Table
	var pTab *struct_Table
	var iDb int32
	var i int32
	var nAlloc int32
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		goto exit_begin_add_column
	}
	pTab = sqlite3LocateTableItem(pParse, uint32(0), &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112)))
	if !(pTab != nil) {
		goto exit_begin_add_column
	}
	if int32(pTab.eTabType) == 1 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'a', 'l', 't', 'e', 'r', 'e', 'd', '\x00'})))
		goto exit_begin_add_column
	}
	if int32(pTab.eTabType) == 2 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'C', 'a', 'n', 'n', 'o', 't', ' ', 'a', 'd', 'd', ' ', 'a', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 't', 'o', ' ', 'a', ' ', 'v', 'i', 'e', 'w', '\x00'})))
		goto exit_begin_add_column
	}
	if 0 != isAlterableTable(pParse, pTab) {
		goto exit_begin_add_column
	}
	sqlite3MayAbort(pParse)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	pNew = (*struct_Table)(sqlite3DbMallocZero(db, uint64(104)))
	if !(pNew != nil) {
		goto exit_begin_add_column
	}
	pParse.pNewTable = pNew
	pNew.nTabRef = uint32(1)
	pNew.nCol = pTab.nCol
	func() int {
		_ = 0
		return 0
	}()
	nAlloc = (int32(pNew.nCol)-1)/8*8 + 8
	func() int {
		_ = 0
		return 0
	}()
	pNew.aCol = (*struct_Column)(sqlite3DbMallocZero(db, uint64(20*uint(nAlloc))))
	pNew.zName = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'a', 'l', 't', 'e', 'r', 't', 'a', 'b', '_', '%', 's', '\x00'})), pTab.zName)
	if !(pNew.aCol != nil) || !(pNew.zName != nil) {
		func() int {
			_ = 0
			return 0
		}()
		goto exit_begin_add_column
	}
	__builtin___memcpy_chk(unsafe.Pointer(pNew.aCol), unsafe.Pointer(pTab.aCol), 20*uint(pNew.nCol), __builtin_object_size(unsafe.Pointer(pNew.aCol), 0))
	for i = int32(0); i < int32(pNew.nCol); i++ {
		var pCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aCol)) + uintptr(i)*20))
		pCol.zCnName = sqlite3DbStrDup(db, pCol.zCnName)
		pCol.hName = sqlite3StrIHash(pCol.zCnName)
	}
	func() int {
		_ = 0
		return 0
	}()
	pNew.u.tab.pDfltList = sqlite3ExprListDup(db, pTab.u.tab.pDfltList, 0)
	pNew.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	pNew.u.tab.addColOffset = pTab.u.tab.addColOffset
	pNew.nTabRef = uint32(1)
exit_begin_add_column:
	sqlite3SrcListDelete(db, pSrc)
	return
}
func isRealTable(pParse *struct_Parse, pTab *struct_Table, bDrop int32) int32 {
	var zType *int8 = nil
	if int32(pTab.eTabType) == 2 {
		zType = (*int8)(unsafe.Pointer(&[5]int8{'v', 'i', 'e', 'w', '\x00'}))
	}
	if int32(pTab.eTabType) == 1 {
		zType = (*int8)(unsafe.Pointer(&[14]int8{'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', '\x00'}))
	}
	if zType != nil {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', '%', 's', ' ', '%', 's', ' ', '"', '%', 's', '"', '\x00'})), func() *int8 {
			if bDrop != 0 {
				return (*int8)(unsafe.Pointer(&[17]int8{'d', 'r', 'o', 'p', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'f', 'r', 'o', 'm', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[18]int8{'r', 'e', 'n', 'a', 'm', 'e', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'o', 'f', '\x00'}))
			}
		}(), zType, pTab.zName)
		return int32(1)
	}
	return int32(0)
}
func sqlite3AlterRenameColumn(pParse *struct_Parse, pSrc *struct_SrcList, pOld *struct_Token, pNew *struct_Token) {
	var db *struct_sqlite3 = pParse.db
	var pTab *struct_Table
	var iCol int32
	var zOld *int8 = nil
	var zNew *int8 = nil
	var zDb *int8
	var iSchema int32
	var bQuote int32
	pTab = sqlite3LocateTableItem(pParse, uint32(0), &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112)))
	if !(pTab != nil) {
		goto exit_rename_column
	}
	if 0 != isAlterableTable(pParse, pTab) {
		goto exit_rename_column
	}
	if 0 != isRealTable(pParse, pTab, 0) {
		goto exit_rename_column
	}
	iSchema = sqlite3SchemaToIndex(db, pTab.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iSchema)*32))).zDbSName
	if sqlite3AuthCheck(pParse, 26, zDb, pTab.zName, nil) != 0 {
		goto exit_rename_column
	}
	zOld = sqlite3NameFromToken(db, pOld)
	if !(zOld != nil) {
		goto exit_rename_column
	}
	for iCol = int32(0); iCol < int32(pTab.nCol); iCol++ {
		if 0 == sqlite3StrICmp((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName, zOld) {
			break
		}
	}
	if iCol == int32(pTab.nCol) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[21]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ':', ' ', '"', '%', 'T', '"', '\x00'})), pOld)
		goto exit_rename_column
	}
	renameTestSchema(pParse, zDb, func() int32 {
		if iSchema == 1 {
			return 1
		} else {
			return 0
		}
	}(), (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), 0)
	renameFixQuotes(pParse, zDb, func() int32 {
		if iSchema == 1 {
			return 1
		} else {
			return 0
		}
	}())
	sqlite3MayAbort(pParse)
	zNew = sqlite3NameFromToken(db, pNew)
	if !(zNew != nil) {
		goto exit_rename_column
	}
	func() int {
		_ = 0
		return 0
	}()
	bQuote = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.z)) + uintptr(0)))))))) & 128
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[182]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 'c', 'o', 'l', 'u', 'm', 'n', '(', 's', 'q', 'l', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', '%', 'Q', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ',', ' ', '%', 'd', ')', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', ' ', 'N', 'O', 'T', ' ', 'L', 'I', 'K', 'E', ' ', '\'', 's', 'q', 'l', 'i', 't', 'e', 'X', '_', '%', '%', '\'', ' ', 'E', 'S', 'C', 'A', 'P', 'E', ' ', '\'', 'X', '\'', ' ', ' ', 'A', 'N', 'D', ' ', '(', 't', 'y', 'p', 'e', ' ', '!', '=', ' ', '\'', 'i', 'n', 'd', 'e', 'x', '\'', ' ', 'O', 'R', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', ' ', '=', ' ', '%', 'Q', ')', '\x00'})), zDb, zDb, pTab.zName, iCol, zNew, bQuote, iSchema == 1, pTab.zName)
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[131]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', 't', 'e', 'm', 'p', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 'c', 'o', 'l', 'u', 'm', 'n', '(', 's', 'q', 'l', ',', ' ', 't', 'y', 'p', 'e', ',', ' ', 'n', 'a', 'm', 'e', ',', ' ', '%', 'Q', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ',', ' ', '%', 'Q', ',', ' ', '%', 'd', ',', ' ', '1', ')', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', ' ', 'I', 'N', ' ', '(', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', ',', ' ', '\'', 'v', 'i', 'e', 'w', '\'', ')', '\x00'})), zDb, pTab.zName, iCol, zNew, bQuote)
	renameReloadSchema(pParse, iSchema, uint16(1))
	renameTestSchema(pParse, zDb, func() int32 {
		if iSchema == 1 {
			return 1
		} else {
			return 0
		}
	}(), (*int8)(unsafe.Pointer(&[13]int8{'a', 'f', 't', 'e', 'r', ' ', 'r', 'e', 'n', 'a', 'm', 'e', '\x00'})), 1)
exit_rename_column:
	sqlite3SrcListDelete(db, pSrc)
	sqlite3DbFree(db, unsafe.Pointer(zOld))
	sqlite3DbFree(db, unsafe.Pointer(zNew))
	return
}

type struct_RenameToken struct {
	p     unsafe.Pointer
	t     struct_Token
	pNext *struct_RenameToken
}
type RenameCtx = struct_RenameCtx
type struct_RenameCtx struct {
	pList *struct_RenameToken
	nList int32
	iCol  int32
	pTab  *struct_Table
	zOld  *int8
}

func sqlite3RenameTokenMap(pParse *struct_Parse, pPtr unsafe.Pointer, pToken *struct_Token) unsafe.Pointer {
	var pNew *struct_RenameToken
	func() int {
		_ = 0
		return 0
	}()
	if int32(pParse.eParseMode) != 3 {
		pNew = (*struct_RenameToken)(sqlite3DbMallocZero(pParse.db, uint64(32)))
		if pNew != nil {
			pNew.p = pPtr
			pNew.t = *pToken
			pNew.pNext = pParse.pRename
			pParse.pRename = pNew
		}
	}
	return pPtr
}
func sqlite3RenameTokenRemap(pParse *struct_Parse, pTo unsafe.Pointer, pFrom unsafe.Pointer) {
	var p *struct_RenameToken
	for p = pParse.pRename; p != nil; p = p.pNext {
		if uintptr(unsafe.Pointer(p.p)) == uintptr(unsafe.Pointer(pFrom)) {
			p.p = pTo
			break
		}
	}
}
func renameUnmapExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var pParse *struct_Parse = pWalker.pParse
	sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer(pExpr))
	if pExpr.flags&uint32(16777216|33554432) == uint32(0) {
		sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer(&pExpr.y.pTab))
	}
	return int32(0)
}
func renameWalkWith(pWalker *struct_Walker, pSelect *struct_Select) {
	var pWith *struct_With = pSelect.pWith
	if pWith != nil {
		var pParse *struct_Parse = pWalker.pParse
		var i int32
		var pCopy *struct_With = nil
		func() int {
			_ = 0
			return 0
		}()
		if (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pWith.a)))) + uintptr(0)*41))).pSelect.selFlags&uint32(64) == uint32(0) {
			pCopy = sqlite3WithDup(pParse.db, pWith)
			pCopy = sqlite3WithPush(pParse, pCopy, uint8(1))
		}
		for i = int32(0); i < pWith.nCte; i++ {
			var p *struct_Select = (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pWith.a)))) + uintptr(i)*41))).pSelect
			var sNC struct_NameContext
			__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
			sNC.pParse = pParse
			if pCopy != nil {
				sqlite3SelectPrep(sNC.pParse, p, &sNC)
			}
			if sNC.pParse.db.mallocFailed != 0 {
				return
			}
			sqlite3WalkSelect(pWalker, p)
			sqlite3RenameExprlistUnmap(pParse, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pWith.a)))) + uintptr(i)*41))).pCols)
		}
		if pCopy != nil && uintptr(unsafe.Pointer(pParse.pWith)) == uintptr(unsafe.Pointer(pCopy)) {
			pParse.pWith = pCopy.pOuter
		}
	}
}
func unmapColumnIdlistNames(pParse *struct_Parse, pIdList *struct_IdList) {
	if pIdList != nil {
		var ii int32
		for ii = int32(0); ii < pIdList.nId; ii++ {
			sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdList.a)) + uintptr(ii)*12))).zName))
		}
	}
}
func renameUnmapSelectCb(pWalker *struct_Walker, p *struct_Select) int32 {
	var pParse *struct_Parse = pWalker.pParse
	var i int32
	if pParse.nErr != 0 {
		return int32(2)
	}
	if p.selFlags&uint32(2097152|67108864) != 0 {
		return int32(1)
	}
	if p.pEList != nil {
		var pList *struct_ExprList = p.pEList
		for i = int32(0); i < pList.nExpr; i++ {
			if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).zEName != nil && int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).Xbf_0&3) == 0 {
				sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).zEName))
			}
		}
	}
	if p.pSrc != nil {
		var pSrc *struct_SrcList = p.pSrc
		for i = int32(0); i < pSrc.nSrc; i++ {
			sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).zName))
			sqlite3WalkExpr(pWalker, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).pOn)
			unmapColumnIdlistNames(pParse, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).pUsing)
		}
	}
	renameWalkWith(pWalker, p)
	return int32(0)
}
func sqlite3RenameExprUnmap(pParse *struct_Parse, pExpr *struct_Expr) {
	var eMode uint8 = pParse.eParseMode
	var sWalker struct_Walker
	__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
	sWalker.pParse = pParse
	sWalker.xExprCallback = renameUnmapExprCb
	sWalker.xSelectCallback = renameUnmapSelectCb
	pParse.eParseMode = uint8(3)
	sqlite3WalkExpr(&sWalker, pExpr)
	pParse.eParseMode = eMode
}
func sqlite3RenameExprlistUnmap(pParse *struct_Parse, pEList *struct_ExprList) {
	if pEList != nil {
		var i int32
		var sWalker struct_Walker
		__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
		sWalker.pParse = pParse
		sWalker.xExprCallback = renameUnmapExprCb
		sqlite3WalkExprList(&sWalker, pEList)
		for i = int32(0); i < pEList.nExpr; i++ {
			if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).Xbf_0&3) == 0 {
				sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName))
			}
		}
	}
}
func renameTokenFree(db *struct_sqlite3, pToken *struct_RenameToken) {
	var pNext *struct_RenameToken
	var p *struct_RenameToken
	for p = pToken; p != nil; p = pNext {
		pNext = p.pNext
		sqlite3DbFree(db, unsafe.Pointer(p))
	}
}
func renameTokenFind(pParse *struct_Parse, pCtx *struct_RenameCtx, pPtr unsafe.Pointer) *struct_RenameToken {
	var pp **struct_RenameToken
	if uintptr(unsafe.Pointer(pPtr)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_RenameToken)(nil)
	}
	for pp = &pParse.pRename; *pp != nil; pp = &(*pp).pNext {
		if uintptr(unsafe.Pointer((*pp).p)) == uintptr(unsafe.Pointer(pPtr)) {
			var pToken *struct_RenameToken = *pp
			if pCtx != nil {
				*pp = pToken.pNext
				pToken.pNext = pCtx.pList
				pCtx.pList = pToken
				pCtx.nList++
			}
			return pToken
		}
	}
	return (*struct_RenameToken)(nil)
}
func renameColumnSelectCb(pWalker *struct_Walker, p *struct_Select) int32 {
	if p.selFlags&uint32(2097152|67108864) != 0 {
		return int32(1)
	}
	renameWalkWith(pWalker, p)
	return int32(0)
}
func renameColumnExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var p *struct_RenameCtx = *(**struct_RenameCtx)(unsafe.Pointer(&pWalker.u))
	if int32(pExpr.op) == 77 && int32(pExpr.iColumn) == p.iCol && uintptr(unsafe.Pointer(pWalker.pParse.pTriggerTab)) == uintptr(unsafe.Pointer(p.pTab)) {
		renameTokenFind(pWalker.pParse, p, unsafe.Pointer(pExpr))
	} else if int32(pExpr.op) == 167 && int32(pExpr.iColumn) == p.iCol && pExpr.flags&uint32(16777216|33554432) == uint32(0) && uintptr(unsafe.Pointer(p.pTab)) == uintptr(unsafe.Pointer(pExpr.y.pTab)) {
		renameTokenFind(pWalker.pParse, p, unsafe.Pointer(pExpr))
	}
	return int32(0)
}
func renameColumnTokenNext(pCtx *struct_RenameCtx) *struct_RenameToken {
	var pBest *struct_RenameToken = pCtx.pList
	var pToken *struct_RenameToken
	var pp **struct_RenameToken
	for pToken = pBest.pNext; pToken != nil; pToken = pToken.pNext {
		if uintptr(unsafe.Pointer(pToken.t.z)) > uintptr(unsafe.Pointer(pBest.t.z)) {
			pBest = pToken
		}
	}
	for pp = &pCtx.pList; uintptr(unsafe.Pointer(*pp)) != uintptr(unsafe.Pointer(pBest)); pp = &(*pp).pNext {
	}
	*pp = pBest.pNext
	return pBest
}
func renameColumnParseError(pCtx *struct_sqlite3_context, zWhen *int8, pType *struct_sqlite3_value, pObject *struct_sqlite3_value, pParse *struct_Parse) {
	var zT *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(pType)))
	var zN *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(pObject)))
	var zErr *int8
	zErr = sqlite3MPrintf(pParse.db, (*int8)(unsafe.Pointer(&[23]int8{'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', '%', 's', ' ', '%', 's', '%', 's', '%', 's', ':', ' ', '%', 's', '\x00'})), zT, zN, func() *int8 {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zWhen)) + uintptr(0)))) != 0 {
			return (*int8)(unsafe.Pointer(&[2]int8{' ', '\x00'}))
		} else {
			return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
		}
	}(), zWhen, pParse.zErrMsg)
	sqlite3_result_error(pCtx, zErr, -1)
	sqlite3DbFree(pParse.db, unsafe.Pointer(zErr))
}
func renameColumnElistNames(pParse *struct_Parse, pCtx *struct_RenameCtx, pEList *struct_ExprList, zOld *int8) {
	if pEList != nil {
		var i int32
		for i = int32(0); i < pEList.nExpr; i++ {
			var zName *int8 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName
			if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).Xbf_0&3) == 0 && uintptr(unsafe.Pointer(zName)) != uintptr(unsafe.Pointer(nil)) && 0 == sqlite3_stricmp(zName, zOld) {
				renameTokenFind(pParse, pCtx, unsafe.Pointer(zName))
			}
		}
	}
}
func renameColumnIdlistNames(pParse *struct_Parse, pCtx *struct_RenameCtx, pIdList *struct_IdList, zOld *int8) {
	if pIdList != nil {
		var i int32
		for i = int32(0); i < pIdList.nId; i++ {
			var zName *int8 = (*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdList.a)) + uintptr(i)*12))).zName
			if 0 == sqlite3_stricmp(zName, zOld) {
				renameTokenFind(pParse, pCtx, unsafe.Pointer(zName))
			}
		}
	}
}
func renameParseSql(p *struct_Parse, zDb *int8, db *struct_sqlite3, zSql *int8, bTemp int32) int32 {
	var rc int32
	sqlite3ParseObjectInit(p, db)
	if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	if sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[8]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', '\x00'})), 7) != 0 {
		return sqlite3CorruptError(109967)
	}
	db.init.iDb = uint8(func() int32 {
		if bTemp != 0 {
			return 1
		} else {
			return sqlite3FindDbName(db, zDb)
		}
	}())
	p.eParseMode = uint8(2)
	p.db = db
	p.nQueryLoop = uint32(1)
	rc = sqlite3RunParser(p, zSql)
	if db.mallocFailed != 0 {
		rc = int32(7)
	}
	if rc == 0 && (uintptr(unsafe.Pointer(p.pNewTable)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(p.pNewIndex)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(p.pNewTrigger)) == uintptr(unsafe.Pointer(nil))) {
		rc = sqlite3CorruptError(109978)
	}
	db.init.iDb = uint8(0)
	return rc
}
func renameEditSql(pCtx *struct_sqlite3_context, pRename *struct_RenameCtx, zSql *int8, zNew *int8, bQuote int32) int32 {
	var nNew int64 = int64(sqlite3Strlen30(zNew))
	var nSql int64 = int64(sqlite3Strlen30(zSql))
	var db *struct_sqlite3 = sqlite3_context_db_handle(pCtx)
	var rc int32 = 0
	var zQuot *int8 = nil
	var zOut *int8
	var nQuot int64 = int64(0)
	var zBuf1 *int8 = nil
	var zBuf2 *int8 = nil
	if zNew != nil {
		zQuot = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[6]int8{'"', '%', 'w', '"', ' ', '\x00'})), zNew)
		if uintptr(unsafe.Pointer(zQuot)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		} else {
			nQuot = int64(sqlite3Strlen30(zQuot) - 1)
		}
		func() int {
			_ = 0
			return 0
		}()
		zOut = (*int8)(sqlite3DbMallocZero(db, uint64(nSql+int64(pRename.nList)*nQuot+int64(1))))
	} else {
		zOut = (*int8)(sqlite3DbMallocZero(db, uint64((nSql*int64(2)+int64(1))*int64(3))))
		if zOut != nil {
			zBuf1 = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(nSql*int64(2)+int64(1))))
			zBuf2 = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(nSql*int64(4)+int64(2))))
		}
	}
	if zOut != nil {
		var nOut int32 = int32(nSql)
		__builtin___memcpy_chk(unsafe.Pointer(zOut), unsafe.Pointer(zSql), uint(nSql), __builtin_object_size(unsafe.Pointer(zOut), 0))
		for pRename.pList != nil {
			var iOff int32
			var nReplace uint32
			var zReplace *int8
			var pBest *struct_RenameToken = renameColumnTokenNext(pRename)
			if zNew != nil {
				if bQuote == 0 && sqlite3IsIdChar(uint8(*pBest.t.z)) != 0 {
					nReplace = uint32(nNew)
					zReplace = zNew
				} else {
					nReplace = uint32(nQuot)
					zReplace = zQuot
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBest.t.z)) + uintptr(pBest.t.n)))) == '"' {
						nReplace++
					}
				}
			} else {
				__builtin___memcpy_chk(unsafe.Pointer(zBuf1), unsafe.Pointer(pBest.t.z), uint(pBest.t.n), __builtin_object_size(unsafe.Pointer(zBuf1), 0))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBuf1)) + uintptr(pBest.t.n))) = int8(0)
				sqlite3Dequote(zBuf1)
				sqlite3_snprintf(int32(nSql*int64(2)), zBuf2, (*int8)(unsafe.Pointer(&[5]int8{'%', 'Q', '%', 's', '\x00'})), zBuf1, func() *int8 {
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pBest.t.z)) + uintptr(pBest.t.n)))) == '\'' {
						return (*int8)(unsafe.Pointer(&[2]int8{' ', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
					}
				}())
				zReplace = zBuf2
				nReplace = uint32(sqlite3Strlen30(zReplace))
			}
			iOff = int32(uintptr(unsafe.Pointer(pBest.t.z)) - uintptr(unsafe.Pointer(zSql)))
			if pBest.t.n != nReplace {
				__builtin___memmove_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(uint32(iOff)+nReplace)))), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(uint32(iOff)+pBest.t.n)))), uint(uint32(nOut)-(uint32(iOff)+pBest.t.n)), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(uint32(iOff)+nReplace)))), 0))
				nOut += int32(nReplace - pBest.t.n)
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(nOut))) = int8('\x00')
			}
			__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(iOff)))), unsafe.Pointer(zReplace), uint(nReplace), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(iOff)))), 0))
			sqlite3DbFree(db, unsafe.Pointer(pBest))
		}
		sqlite3_result_text(pCtx, zOut, -1, (func(unsafe.Pointer))(-1))
		sqlite3DbFree(db, unsafe.Pointer(zOut))
	} else {
		rc = int32(7)
	}
	sqlite3_free(unsafe.Pointer(zQuot))
	return rc
}
func renameResolveTrigger(pParse *struct_Parse) int32 {
	var db *struct_sqlite3 = pParse.db
	var pNew *struct_Trigger = pParse.pNewTrigger
	var pStep *struct_TriggerStep
	var sNC struct_NameContext
	var rc int32 = 0
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	sNC.pParse = pParse
	func() int {
		_ = 0
		return 0
	}()
	pParse.pTriggerTab = sqlite3FindTable(db, pNew.table, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(sqlite3SchemaToIndex(db, pNew.pTabSchema))*32))).zDbSName)
	pParse.eTriggerOp = pNew.op
	if pParse.pTriggerTab != nil {
		rc = sqlite3ViewGetColumnNames(pParse, pParse.pTriggerTab)
	}
	if rc == 0 && pNew.pWhen != nil {
		rc = sqlite3ResolveExprNames(&sNC, pNew.pWhen)
	}
	for pStep = pNew.step_list; rc == 0 && pStep != nil; pStep = pStep.pNext {
		if pStep.pSelect != nil {
			sqlite3SelectPrep(pParse, pStep.pSelect, &sNC)
			if pParse.nErr != 0 {
				rc = pParse.rc
			}
		}
		if rc == 0 && pStep.zTarget != nil {
			var pSrc *struct_SrcList = sqlite3TriggerStepSrc(pParse, pStep)
			if pSrc != nil {
				var i int32
				for i = int32(0); i < pSrc.nSrc && rc == 0; i++ {
					var p *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))
					p.iCursor = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nTab
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
					if p.pSelect != nil {
						sqlite3SelectPrep(pParse, p.pSelect, nil)
						sqlite3ExpandSubquery(pParse, p)
						func() int {
							_ = 0
							return 0
						}()
						func() int {
							_ = 0
							return 0
						}()
						sqlite3SelectPrep(pParse, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pStep.pFrom.a)))) + uintptr(i-1)*112))).pSelect, nil)
					} else {
						p.pTab = sqlite3LocateTableItem(pParse, uint32(0), p)
						if uintptr(unsafe.Pointer(p.pTab)) == uintptr(unsafe.Pointer(nil)) {
							rc = int32(1)
						} else {
							p.pTab.nTabRef++
							rc = sqlite3ViewGetColumnNames(pParse, p.pTab)
						}
					}
				}
				if rc == 0 && int32(db.mallocFailed) != 0 {
					rc = int32(7)
				}
				sNC.pSrcList = pSrc
				if rc == 0 && pStep.pWhere != nil {
					rc = sqlite3ResolveExprNames(&sNC, pStep.pWhere)
				}
				if rc == 0 {
					rc = sqlite3ResolveExprListNames(&sNC, pStep.pExprList)
				}
				func() int {
					_ = 0
					return 0
				}()
				if pStep.pUpsert != nil && rc == 0 {
					var pUpsert *struct_Upsert = pStep.pUpsert
					pUpsert.pUpsertSrc = pSrc
					*(**struct_Upsert)(unsafe.Pointer(&sNC.uNC)) = pUpsert
					sNC.ncFlags = int32(512)
					rc = sqlite3ResolveExprListNames(&sNC, pUpsert.pUpsertTarget)
					if rc == 0 {
						var pUpsertSet *struct_ExprList = pUpsert.pUpsertSet
						rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet)
					}
					if rc == 0 {
						rc = sqlite3ResolveExprNames(&sNC, pUpsert.pUpsertWhere)
					}
					if rc == 0 {
						rc = sqlite3ResolveExprNames(&sNC, pUpsert.pUpsertTargetWhere)
					}
					sNC.ncFlags = int32(0)
				}
				sNC.pSrcList = (*struct_SrcList)(nil)
				sqlite3SrcListDelete(db, pSrc)
			} else {
				rc = int32(7)
			}
		}
	}
	return rc
}
func renameWalkTrigger(pWalker *struct_Walker, pTrigger *struct_Trigger) {
	var pStep *struct_TriggerStep
	sqlite3WalkExpr(pWalker, pTrigger.pWhen)
	for pStep = pTrigger.step_list; pStep != nil; pStep = pStep.pNext {
		sqlite3WalkSelect(pWalker, pStep.pSelect)
		sqlite3WalkExpr(pWalker, pStep.pWhere)
		sqlite3WalkExprList(pWalker, pStep.pExprList)
		if pStep.pUpsert != nil {
			var pUpsert *struct_Upsert = pStep.pUpsert
			sqlite3WalkExprList(pWalker, pUpsert.pUpsertTarget)
			sqlite3WalkExprList(pWalker, pUpsert.pUpsertSet)
			sqlite3WalkExpr(pWalker, pUpsert.pUpsertWhere)
			sqlite3WalkExpr(pWalker, pUpsert.pUpsertTargetWhere)
		}
		if pStep.pFrom != nil {
			var i int32
			for i = int32(0); i < pStep.pFrom.nSrc; i++ {
				sqlite3WalkSelect(pWalker, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pStep.pFrom.a)))) + uintptr(i)*112))).pSelect)
			}
		}
	}
}
func renameParseCleanup(pParse *struct_Parse) {
	var db *struct_sqlite3 = pParse.db
	var pIdx *struct_Index
	if pParse.pVdbe != nil {
		sqlite3VdbeFinalize(pParse.pVdbe)
	}
	sqlite3DeleteTable(db, pParse.pNewTable)
	for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Index) {
		_cgo_addr := &pIdx
		*_cgo_addr = pParse.pNewIndex
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		pParse.pNewIndex = pIdx.pNext
		sqlite3FreeIndex(db, pIdx)
	}
	sqlite3DeleteTrigger(db, pParse.pNewTrigger)
	sqlite3DbFree(db, unsafe.Pointer(pParse.zErrMsg))
	renameTokenFree(db, pParse.pRename)
	sqlite3ParseObjectReset(pParse)
}
func renameColumnFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var sCtx struct_RenameCtx
	var zSql *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var zDb *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)))))
	var zTable *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))))
	var iCol int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(5)*8)))
	var zNew *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(6)*8)))))
	var bQuote int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(7)*8)))
	var bTemp int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(8)*8)))
	var zOld *int8
	var rc int32
	var sParse struct_Parse
	var sWalker struct_Walker
	var pIdx *struct_Index
	var i int32
	var pTab *struct_Table
	var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32 = db.xAuth
	func() int {
		_ = NotUsed
		return 0
	}()
	if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uintptr(unsafe.Pointer(zTable)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uintptr(unsafe.Pointer(zNew)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if iCol < 0 {
		return
	}
	sqlite3BtreeEnterAll(db)
	pTab = sqlite3FindTable(db, zTable, zDb)
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) || iCol >= int32(pTab.nCol) {
		sqlite3BtreeLeaveAll(db)
		return
	}
	zOld = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName
	__builtin___memset_chk(unsafe.Pointer(&sCtx), 0, 32, __builtin_object_size(unsafe.Pointer(&sCtx), 0))
	sCtx.iCol = func() int32 {
		if iCol == int32(pTab.iPKey) {
			return -1
		} else {
			return iCol
		}
	}()
	db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
	rc = renameParseSql(&sParse, zDb, db, zSql, bTemp)
	__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
	sWalker.pParse = &sParse
	sWalker.xExprCallback = renameColumnExprCb
	sWalker.xSelectCallback = renameColumnSelectCb
	*(**struct_RenameCtx)(unsafe.Pointer(&sWalker.u)) = &sCtx
	sCtx.pTab = pTab
	if rc != 0 {
		goto renameColumnFunc_done
	}
	if sParse.pNewTable != nil {
		if int32(sParse.pNewTable.eTabType) == 2 {
			var pSelect *struct_Select = (*(*_cgoa_12)(unsafe.Pointer(&sParse.pNewTable.u))).pSelect
			pSelect.selFlags &= uint32(4292870143)
			sParse.rc = int32(0)
			sqlite3SelectPrep(&sParse, pSelect, nil)
			rc = func() int32 {
				if int32(db.mallocFailed) != 0 {
					return 7
				} else {
					return sParse.rc
				}
			}()
			if rc == 0 {
				sqlite3WalkSelect(&sWalker, pSelect)
			}
			if rc != 0 {
				goto renameColumnFunc_done
			}
		} else if int32(sParse.pNewTable.eTabType) == 0 {
			var bFKOnly int32 = sqlite3_stricmp(zTable, sParse.pNewTable.zName)
			var pFKey *struct_FKey
			sCtx.pTab = sParse.pNewTable
			if bFKOnly == 0 {
				if iCol < int32(sParse.pNewTable.nCol) {
					renameTokenFind(&sParse, &sCtx, unsafe.Pointer((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(sParse.pNewTable.aCol)) + uintptr(iCol)*20))).zCnName))
				}
				if sCtx.iCol < 0 {
					renameTokenFind(&sParse, &sCtx, unsafe.Pointer(&sParse.pNewTable.iPKey))
				}
				sqlite3WalkExprList(&sWalker, sParse.pNewTable.pCheck)
				for pIdx = sParse.pNewTable.pIndex; pIdx != nil; pIdx = pIdx.pNext {
					sqlite3WalkExprList(&sWalker, pIdx.aColExpr)
				}
				for pIdx = sParse.pNewIndex; pIdx != nil; pIdx = pIdx.pNext {
					sqlite3WalkExprList(&sWalker, pIdx.aColExpr)
				}
				for i = int32(0); i < int32(sParse.pNewTable.nCol); i++ {
					var pExpr *struct_Expr = sqlite3ColumnExpr(sParse.pNewTable, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(sParse.pNewTable.aCol)) + uintptr(i)*20)))
					sqlite3WalkExpr(&sWalker, pExpr)
				}
			}
			func() int {
				_ = 0
				return 0
			}()
			for pFKey = sParse.pNewTable.u.tab.pFKey; pFKey != nil; pFKey = pFKey.pNextFrom {
				for i = int32(0); i < pFKey.nCol; i++ {
					if bFKOnly == 0 && (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).iFrom == iCol {
						renameTokenFind(&sParse, &sCtx, unsafe.Pointer(&*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))))
					}
					if 0 == sqlite3_stricmp(pFKey.zTo, zTable) && 0 == sqlite3_stricmp((*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).zCol, zOld) {
						renameTokenFind(&sParse, &sCtx, unsafe.Pointer((*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).zCol))
					}
				}
			}
		}
	} else if sParse.pNewIndex != nil {
		sqlite3WalkExprList(&sWalker, sParse.pNewIndex.aColExpr)
		sqlite3WalkExpr(&sWalker, sParse.pNewIndex.pPartIdxWhere)
	} else {
		var pStep *struct_TriggerStep
		rc = renameResolveTrigger(&sParse)
		if rc != 0 {
			goto renameColumnFunc_done
		}
		for pStep = sParse.pNewTrigger.step_list; pStep != nil; pStep = pStep.pNext {
			if pStep.zTarget != nil {
				var pTarget *struct_Table = sqlite3LocateTable(&sParse, uint32(0), pStep.zTarget, zDb)
				if uintptr(unsafe.Pointer(pTarget)) == uintptr(unsafe.Pointer(pTab)) {
					if pStep.pUpsert != nil {
						var pUpsertSet *struct_ExprList = pStep.pUpsert.pUpsertSet
						renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld)
					}
					renameColumnIdlistNames(&sParse, &sCtx, pStep.pIdList, zOld)
					renameColumnElistNames(&sParse, &sCtx, pStep.pExprList, zOld)
				}
			}
		}
		if uintptr(unsafe.Pointer(sParse.pTriggerTab)) == uintptr(unsafe.Pointer(pTab)) {
			renameColumnIdlistNames(&sParse, &sCtx, sParse.pNewTrigger.pColumns, zOld)
		}
		renameWalkTrigger(&sWalker, sParse.pNewTrigger)
	}
	func() int {
		_ = 0
		return 0
	}()
	rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote)
renameColumnFunc_done:
	if rc != 0 {
		if rc == 1 && sqlite3WritableSchema(db) != 0 {
			sqlite3_result_value(context, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		} else if sParse.zErrMsg != nil {
			renameColumnParseError(context, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)), &sParse)
		} else {
			sqlite3_result_error_code(context, rc)
		}
	}
	renameParseCleanup(&sParse)
	renameTokenFree(db, sCtx.pList)
	db.xAuth = xAuth
	sqlite3BtreeLeaveAll(db)
}
func renameTableExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var p *struct_RenameCtx = *(**struct_RenameCtx)(unsafe.Pointer(&pWalker.u))
	if int32(pExpr.op) == 167 && pExpr.flags&uint32(16777216|33554432) == uint32(0) && uintptr(unsafe.Pointer(p.pTab)) == uintptr(unsafe.Pointer(pExpr.y.pTab)) {
		renameTokenFind(pWalker.pParse, p, unsafe.Pointer(&pExpr.y.pTab))
	}
	return int32(0)
}
func renameTableSelectCb(pWalker *struct_Walker, pSelect *struct_Select) int32 {
	var i int32
	var p *struct_RenameCtx = *(**struct_RenameCtx)(unsafe.Pointer(&pWalker.u))
	var pSrc *struct_SrcList = pSelect.pSrc
	if pSelect.selFlags&uint32(2097152|67108864) != 0 {
		return int32(1)
	}
	if uintptr(unsafe.Pointer(pSrc)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		return int32(2)
	}
	for i = int32(0); i < pSrc.nSrc; i++ {
		var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))
		if uintptr(unsafe.Pointer(pItem.pTab)) == uintptr(unsafe.Pointer(p.pTab)) {
			renameTokenFind(pWalker.pParse, p, unsafe.Pointer(pItem.zName))
		}
	}
	renameWalkWith(pWalker, pSelect)
	return int32(0)
}
func renameTableFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var zDb *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var zInput *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)))))
	var zOld *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))))
	var zNew *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(5)*8)))))
	var bTemp int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(6)*8)))
	func() int {
		_ = NotUsed
		return 0
	}()
	if zInput != nil && zOld != nil && zNew != nil {
		var sParse struct_Parse
		var rc int32
		var bQuote int32 = 1
		var sCtx struct_RenameCtx
		var sWalker struct_Walker
		var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32 = db.xAuth
		db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
		sqlite3BtreeEnterAll(db)
		__builtin___memset_chk(unsafe.Pointer(&sCtx), 0, 32, __builtin_object_size(unsafe.Pointer(&sCtx), 0))
		sCtx.pTab = sqlite3FindTable(db, zOld, zDb)
		__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
		sWalker.pParse = &sParse
		sWalker.xExprCallback = renameTableExprCb
		sWalker.xSelectCallback = renameTableSelectCb
		*(**struct_RenameCtx)(unsafe.Pointer(&sWalker.u)) = &sCtx
		rc = renameParseSql(&sParse, zDb, db, zInput, bTemp)
		if rc == 0 {
			var isLegacy int32 = int32(db.flags & uint64(67108864))
			if sParse.pNewTable != nil {
				var pTab *struct_Table = sParse.pNewTable
				if int32(pTab.eTabType) == 2 {
					if isLegacy == 0 {
						var pSelect *struct_Select = (*(*_cgoa_12)(unsafe.Pointer(&pTab.u))).pSelect
						var sNC struct_NameContext
						__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
						sNC.pParse = &sParse
						func() int {
							_ = 0
							return 0
						}()
						pSelect.selFlags &= uint32(4292870143)
						sqlite3SelectPrep(&sParse, (*(*_cgoa_12)(unsafe.Pointer(&pTab.u))).pSelect, &sNC)
						if sParse.nErr != 0 {
							rc = sParse.rc
						} else {
							sqlite3WalkSelect(&sWalker, (*(*_cgoa_12)(unsafe.Pointer(&pTab.u))).pSelect)
						}
					}
				} else {
					if (isLegacy == 0 || db.flags&uint64(16384) != 0) && !(int32(pTab.eTabType) == 1) {
						var pFKey *struct_FKey
						func() int {
							_ = 0
							return 0
						}()
						for pFKey = pTab.u.tab.pFKey; pFKey != nil; pFKey = pFKey.pNextFrom {
							if sqlite3_stricmp(pFKey.zTo, zOld) == 0 {
								renameTokenFind(&sParse, &sCtx, unsafe.Pointer(pFKey.zTo))
							}
						}
					}
					if sqlite3_stricmp(zOld, pTab.zName) == 0 {
						sCtx.pTab = pTab
						if isLegacy == 0 {
							sqlite3WalkExprList(&sWalker, pTab.pCheck)
						}
						renameTokenFind(&sParse, &sCtx, unsafe.Pointer(pTab.zName))
					}
				}
			} else if sParse.pNewIndex != nil {
				renameTokenFind(&sParse, &sCtx, unsafe.Pointer(sParse.pNewIndex.zName))
				if isLegacy == 0 {
					sqlite3WalkExpr(&sWalker, sParse.pNewIndex.pPartIdxWhere)
				}
			} else {
				var pTrigger *struct_Trigger = sParse.pNewTrigger
				var pStep *struct_TriggerStep
				if 0 == sqlite3_stricmp(sParse.pNewTrigger.table, zOld) && uintptr(unsafe.Pointer(sCtx.pTab.pSchema)) == uintptr(unsafe.Pointer(pTrigger.pTabSchema)) {
					renameTokenFind(&sParse, &sCtx, unsafe.Pointer(sParse.pNewTrigger.table))
				}
				if isLegacy == 0 {
					rc = renameResolveTrigger(&sParse)
					if rc == 0 {
						renameWalkTrigger(&sWalker, pTrigger)
						for pStep = pTrigger.step_list; pStep != nil; pStep = pStep.pNext {
							if pStep.zTarget != nil && 0 == sqlite3_stricmp(pStep.zTarget, zOld) {
								renameTokenFind(&sParse, &sCtx, unsafe.Pointer(pStep.zTarget))
							}
						}
					}
				}
			}
		}
		if rc == 0 {
			rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote)
		}
		if rc != 0 {
			if rc == 1 && sqlite3WritableSchema(db) != 0 {
				sqlite3_result_value(context, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)))
			} else if sParse.zErrMsg != nil {
				renameColumnParseError(context, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)), &sParse)
			} else {
				sqlite3_result_error_code(context, rc)
			}
		}
		renameParseCleanup(&sParse)
		renameTokenFree(db, sCtx.pList)
		sqlite3BtreeLeaveAll(db)
		db.xAuth = xAuth
	}
	return
}
func renameQuotefixExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 117 && pExpr.flags&uint32(64) != 0 {
		renameTokenFind(pWalker.pParse, *(**struct_RenameCtx)(unsafe.Pointer(&pWalker.u)), unsafe.Pointer(pExpr))
	}
	return int32(0)
}
func renameQuotefixFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var zDb *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var zInput *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
	var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32 = db.xAuth
	db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
	sqlite3BtreeEnterAll(db)
	func() int {
		_ = NotUsed
		return 0
	}()
	if zDb != nil && zInput != nil {
		var rc int32
		var sParse struct_Parse
		rc = renameParseSql(&sParse, zDb, db, zInput, 0)
		if rc == 0 {
			var sCtx struct_RenameCtx
			var sWalker struct_Walker
			__builtin___memset_chk(unsafe.Pointer(&sCtx), 0, 32, __builtin_object_size(unsafe.Pointer(&sCtx), 0))
			__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
			sWalker.pParse = &sParse
			sWalker.xExprCallback = renameQuotefixExprCb
			sWalker.xSelectCallback = renameColumnSelectCb
			*(**struct_RenameCtx)(unsafe.Pointer(&sWalker.u)) = &sCtx
			if sParse.pNewTable != nil {
				if int32(sParse.pNewTable.eTabType) == 2 {
					var pSelect *struct_Select = (*(*_cgoa_12)(unsafe.Pointer(&sParse.pNewTable.u))).pSelect
					pSelect.selFlags &= uint32(4292870143)
					sParse.rc = int32(0)
					sqlite3SelectPrep(&sParse, pSelect, nil)
					rc = func() int32 {
						if int32(db.mallocFailed) != 0 {
							return 7
						} else {
							return sParse.rc
						}
					}()
					if rc == 0 {
						sqlite3WalkSelect(&sWalker, pSelect)
					}
				} else {
					var i int32
					sqlite3WalkExprList(&sWalker, sParse.pNewTable.pCheck)
					for i = int32(0); i < int32(sParse.pNewTable.nCol); i++ {
						sqlite3WalkExpr(&sWalker, sqlite3ColumnExpr(sParse.pNewTable, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(sParse.pNewTable.aCol)) + uintptr(i)*20))))
					}
				}
			} else if sParse.pNewIndex != nil {
				sqlite3WalkExprList(&sWalker, sParse.pNewIndex.aColExpr)
				sqlite3WalkExpr(&sWalker, sParse.pNewIndex.pPartIdxWhere)
			} else {
				rc = renameResolveTrigger(&sParse)
				if rc == 0 {
					renameWalkTrigger(&sWalker, sParse.pNewTrigger)
				}
			}
			if rc == 0 {
				rc = renameEditSql(context, &sCtx, zInput, nil, 0)
			}
			renameTokenFree(db, sCtx.pList)
		}
		if rc != 0 {
			if sqlite3WritableSchema(db) != 0 && rc == 1 {
				sqlite3_result_value(context, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
			} else {
				sqlite3_result_error_code(context, rc)
			}
		}
		renameParseCleanup(&sParse)
	}
	db.xAuth = xAuth
	sqlite3BtreeLeaveAll(db)
}
func renameTableTest(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var zDb *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var zInput *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
	var bTemp int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))
	var isLegacy int32 = int32(db.flags & uint64(67108864))
	var zWhen *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(5)*8)))))
	var bNoDQS int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(6)*8)))
	var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32 = db.xAuth
	db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
	func() int {
		_ = NotUsed
		return 0
	}()
	if zDb != nil && zInput != nil {
		var rc int32
		var sParse struct_Parse
		var flags int32 = int32(db.flags)
		if bNoDQS != 0 {
			db.flags &= uint64(18446744072098938879)
		}
		rc = renameParseSql(&sParse, zDb, db, zInput, bTemp)
		db.flags |= uint64(flags & (1073741824 | 536870912))
		if rc == 0 {
			if isLegacy == 0 && sParse.pNewTable != nil && int32(sParse.pNewTable.eTabType) == 2 {
				var sNC struct_NameContext
				__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
				sNC.pParse = &sParse
				sqlite3SelectPrep(&sParse, (*(*_cgoa_12)(unsafe.Pointer(&sParse.pNewTable.u))).pSelect, &sNC)
				if sParse.nErr != 0 {
					rc = sParse.rc
				}
			} else if sParse.pNewTrigger != nil {
				if isLegacy == 0 {
					rc = renameResolveTrigger(&sParse)
				}
				if rc == 0 {
					var i1 int32 = sqlite3SchemaToIndex(db, sParse.pNewTrigger.pTabSchema)
					var i2 int32 = sqlite3FindDbName(db, zDb)
					if i1 == i2 {
						sqlite3_result_int(context, 1)
					}
				}
			}
		}
		if rc != 0 && zWhen != nil && !(sqlite3WritableSchema(db) != 0) {
			renameColumnParseError(context, zWhen, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)), &sParse)
		}
		renameParseCleanup(&sParse)
	}
	db.xAuth = xAuth
}
func dropColumnFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var iSchema int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	var zSql *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
	var iCol int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)))
	var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iSchema)*32))).zDbSName
	var rc int32
	var sParse struct_Parse
	var pCol *struct_RenameToken
	var pTab *struct_Table
	var zEnd *int8
	var zNew *int8 = nil
	var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32 = db.xAuth
	db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
	func() int {
		_ = NotUsed
		return 0
	}()
	rc = renameParseSql(&sParse, zDb, db, zSql, func() int32 {
		if iSchema == 1 {
			return 1
		} else {
			return 0
		}
	}())
	if rc != 0 {
		goto drop_column_done
	}
	pTab = sParse.pNewTable
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) || int32(pTab.nCol) == 1 || iCol >= int32(pTab.nCol) {
		rc = sqlite3CorruptError(110899)
		goto drop_column_done
	}
	pCol = renameTokenFind(&sParse, nil, unsafe.Pointer((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName))
	if iCol < int32(pTab.nCol)-1 {
		var pEnd *struct_RenameToken
		pEnd = renameTokenFind(&sParse, nil, unsafe.Pointer((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol+1)*20))).zCnName))
		zEnd = (*int8)(unsafe.Pointer(pEnd.t.z))
	} else {
		func() int {
			_ = 0
			return 0
		}()
		zEnd = (*int8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(pTab.u.tab.addColOffset)))))
		for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.t.z)) + uintptr(0)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.t.z)) + uintptr(0)))) != ',' {
			*(*uintptr)(unsafe.Pointer(&pCol.t.z))--
		}
	}
	zNew = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[7]int8{'%', '.', '*', 's', '%', 's', '\x00'})), uintptr(unsafe.Pointer(pCol.t.z))-uintptr(unsafe.Pointer(zSql)), zSql, zEnd)
	sqlite3_result_text(context, zNew, -1, (func(unsafe.Pointer))(-1))
	sqlite3_free(unsafe.Pointer(zNew))
drop_column_done:
	renameParseCleanup(&sParse)
	db.xAuth = xAuth
	if rc != 0 {
		sqlite3_result_error_code(context, rc)
	}
}
func sqlite3AlterDropColumn(pParse *struct_Parse, pSrc *struct_SrcList, pName *struct_Token) {
	var db *struct_sqlite3 = pParse.db
	var pTab *struct_Table
	var iDb int32
	var zDb *int8
	var zCol *int8 = nil
	var iCol int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		goto exit_drop_column
	}
	pTab = sqlite3LocateTableItem(pParse, uint32(0), &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112)))
	if !(pTab != nil) {
		goto exit_drop_column
	}
	if 0 != isAlterableTable(pParse, pTab) {
		goto exit_drop_column
	}
	if 0 != isRealTable(pParse, pTab, 1) {
		goto exit_drop_column
	}
	zCol = sqlite3NameFromToken(db, pName)
	if uintptr(unsafe.Pointer(zCol)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		goto exit_drop_column
	}
	iCol = sqlite3ColumnIndex(pTab, zCol)
	if iCol < 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[21]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ':', ' ', '"', '%', 'T', '"', '\x00'})), pName)
		goto exit_drop_column
	}
	if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).colFlags)&(1|8) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'd', 'r', 'o', 'p', ' ', '%', 's', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ':', ' ', '"', '%', 's', '"', '\x00'})), func() *int8 {
			if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).colFlags)&1 != 0 {
				return (*int8)(unsafe.Pointer(&[12]int8{'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[7]int8{'U', 'N', 'I', 'Q', 'U', 'E', '\x00'}))
			}
		}(), zCol)
		goto exit_drop_column
	}
	if int32(pTab.nCol) <= 1 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[48]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'd', 'r', 'o', 'p', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '"', '%', 's', '"', ':', ' ', 'n', 'o', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'e', 'x', 'i', 's', 't', '\x00'})), zCol)
		goto exit_drop_column
	}
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	if sqlite3AuthCheck(pParse, 26, zDb, pTab.zName, zCol) != 0 {
		goto exit_drop_column
	}
	renameTestSchema(pParse, zDb, func() int32 {
		if iDb == 1 {
			return 1
		} else {
			return 0
		}
	}(), (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), 0)
	renameFixQuotes(pParse, zDb, func() int32 {
		if iDb == 1 {
			return 1
		} else {
			return 0
		}
	}())
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[121]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 's', 'q', 'l', ' ', '=', ' ', 's', 'q', 'l', 'i', 't', 'e', '_', 'd', 'r', 'o', 'p', '_', 'c', 'o', 'l', 'u', 'm', 'n', '(', '%', 'd', ',', ' ', 's', 'q', 'l', ',', ' ', '%', 'd', ')', ' ', 'W', 'H', 'E', 'R', 'E', ' ', '(', 't', 'y', 'p', 'e', '=', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', ' ', 'A', 'N', 'D', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'C', 'O', 'L', 'L', 'A', 'T', 'E', ' ', 'n', 'o', 'c', 'a', 's', 'e', ')', '\x00'})), zDb, iDb, iCol, pTab.zName)
	renameReloadSchema(pParse, iDb, uint16(2))
	renameTestSchema(pParse, zDb, func() int32 {
		if iDb == 1 {
			return 1
		} else {
			return 0
		}
	}(), (*int8)(unsafe.Pointer(&[18]int8{'a', 'f', 't', 'e', 'r', ' ', 'd', 'r', 'o', 'p', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})), 1)
	if pParse.nErr == 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).colFlags)&32 == 0 {
		var i int32
		var addr int32
		var reg int32
		var regRec int32
		var pPk *struct_Index = nil
		var nField int32 = 0
		var iCur int32
		var v *struct_Vdbe = sqlite3GetVdbe(pParse)
		iCur = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		sqlite3OpenTable(pParse, iCur, iDb, pTab, 112)
		addr = sqlite3VdbeAddOp1(v, 38, iCur)
		reg = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		if pTab.tabFlags&uint32(128) == uint32(0) {
			sqlite3VdbeAddOp2(v, 134, iCur, reg)
			pParse.nMem += int32(pTab.nCol)
		} else {
			pPk = sqlite3PrimaryKeyIndex(pTab)
			pParse.nMem += int32(pPk.nColumn)
			for i = int32(0); i < int32(pPk.nKeyCol); i++ {
				sqlite3VdbeAddOp3(v, 93, iCur, i, reg+i+1)
			}
			nField = int32(pPk.nKeyCol)
		}
		regRec = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		for i = int32(0); i < int32(pTab.nCol); i++ {
			if i != iCol && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 == 0 {
				var regOut int32
				if pPk != nil {
					var iPos int32 = int32(sqlite3TableColumnToIndex(pPk, int16(i)))
					var iColPos int32 = int32(sqlite3TableColumnToIndex(pPk, int16(iCol)))
					if iPos < int32(pPk.nKeyCol) {
						continue
					}
					regOut = reg + 1 + iPos - func() int32 {
						if iPos > iColPos {
							return 1
						} else {
							return 0
						}
					}()
				} else {
					regOut = reg + 1 + nField
				}
				if i == int32(pTab.iPKey) {
					sqlite3VdbeAddOp2(v, 74, 0, regOut)
				} else {
					sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOut)
				}
				nField++
			}
		}
		if nField == 0 {
			pParse.nMem++
			sqlite3VdbeAddOp2(v, 74, 0, reg+1)
			nField = int32(1)
		}
		sqlite3VdbeAddOp3(v, 96, reg+1, nField, regRec)
		if pPk != nil {
			sqlite3VdbeAddOp4Int(v, 137, iCur, regRec, reg+1, int32(pPk.nKeyCol))
		} else {
			sqlite3VdbeAddOp3(v, 127, iCur, regRec, reg)
		}
		sqlite3VdbeChangeP5(v, uint16(2))
		sqlite3VdbeAddOp2(v, 5, iCur, addr+1)
		sqlite3VdbeJumpHere(v, addr)
	}
exit_drop_column:
	sqlite3DbFree(db, unsafe.Pointer(zCol))
	sqlite3SrcListDelete(db, pSrc)
}
func sqlite3AlterFunctions() {
	var aAlterTableFuncs [5]struct_FuncDef = [5]struct_FuncDef{struct_FuncDef{int8(9), uint32(8388608 | 262144 | 1 | 2048), nil, nil, renameColumnFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[21]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(7), uint32(8388608 | 262144 | 1 | 2048), nil, nil, renameTableFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[20]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'a', 'b', 'l', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(7), uint32(8388608 | 262144 | 1 | 2048), nil, nil, renameTableTest, nil, nil, nil, (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 't', 'e', 's', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 262144 | 1 | 2048), nil, nil, dropColumnFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'd', 'r', 'o', 'p', '_', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 262144 | 1 | 2048), nil, nil, renameQuotefixFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[23]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 'n', 'a', 'm', 'e', '_', 'q', 'u', 'o', 't', 'e', 'f', 'i', 'x', '\x00'})), _cgoa_9{nil}}}
	sqlite3InsertBuiltinFuncs((*struct_FuncDef)(unsafe.Pointer(&aAlterTableFuncs)), int32(360/72))
}
func openStatTable(pParse *struct_Parse, iDb int32, iStatCur int32, zWhere *int8, zWhereType *int8) {
	type _cgoa_75 struct {
		zName *int8
		zCols *int8
	}
	var aTable [3]_cgoa_75 = [3]_cgoa_75{_cgoa_75{(*int8)(unsafe.Pointer(&[13]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '1', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'t', 'b', 'l', ',', 'i', 'd', 'x', ',', 's', 't', 'a', 't', '\x00'}))}, _cgoa_75{(*int8)(unsafe.Pointer(&[13]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '4', '\x00'})), nil}, _cgoa_75{(*int8)(unsafe.Pointer(&[13]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '3', '\x00'})), nil}}
	var i int32
	var db *struct_sqlite3 = pParse.db
	var pDb *struct_Db
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var aRoot [3]uint32
	var aCreateTbl [3]uint8
	const nToOpen int32 = 1
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	for i = int32(0); i < int32(48/16); i++ {
		var zTab *int8 = (*(*_cgoa_75)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_75)(unsafe.Pointer(&aTable)))) + uintptr(i)*16))).zName
		var pStat *struct_Table
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCreateTbl)))) + uintptr(i))) = uint8(0)
		if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
			_cgo_addr := &pStat
			*_cgo_addr = sqlite3FindTable(db, zTab, pDb.zDbSName)
			return *_cgo_addr
		}())) == uintptr(unsafe.Pointer(nil)) {
			if i < nToOpen {
				sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[23]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'A', 'B', 'L', 'E', ' ', '%', 'Q', '.', '%', 's', '(', '%', 's', ')', '\x00'})), pDb.zDbSName, zTab, (*(*_cgoa_75)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_75)(unsafe.Pointer(&aTable)))) + uintptr(i)*16))).zCols)
				*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aRoot)))) + uintptr(i)*4)) = uint32(pParse.regRoot)
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCreateTbl)))) + uintptr(i))) = uint8(16)
			}
		} else {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aRoot)))) + uintptr(i)*4)) = pStat.tnum
			sqlite3TableLock(pParse, iDb, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aRoot)))) + uintptr(i)*4)), uint8(1), zTab)
			if zWhere != nil {
				sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[30]int8{'D', 'E', 'L', 'E', 'T', 'E', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', '%', 's', ' ', 'W', 'H', 'E', 'R', 'E', ' ', '%', 's', '=', '%', 'Q', '\x00'})), pDb.zDbSName, zTab, zWhereType, zWhere)
			} else {
				sqlite3VdbeAddOp2(v, 144, int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aRoot)))) + uintptr(i)*4))), iDb)
			}
		}
	}
	for i = int32(0); i < nToOpen; i++ {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp4Int(v, 112, iStatCur+i, int32(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&aRoot)))) + uintptr(i)*4))), iDb, 3)
		sqlite3VdbeChangeP5(v, uint16(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCreateTbl)))) + uintptr(i)))))
	}
}

type StatAccum = struct_StatAccum
type StatSample = struct_StatSample
type struct_StatSample struct {
	anEq  *uint32
	anDLt *uint32
}
type struct_StatAccum struct {
	db         *struct_sqlite3
	nEst       uint32
	nRow       uint32
	nLimit     int32
	nCol       int32
	nKeyCol    int32
	nSkipAhead uint8
	current    struct_StatSample
}

func statAccumDestructor(pOld unsafe.Pointer) {
	var p *struct_StatAccum = (*struct_StatAccum)(pOld)
	sqlite3DbFree(p.db, unsafe.Pointer(p))
}
func statInit(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_StatAccum
	var nCol int32
	var nKeyCol int32
	var nColUp int32
	var n int32
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		_ = argc
		return 0
	}()
	nCol = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	func() int {
		_ = 0
		return 0
	}()
	nColUp = func() int32 {
		if true {
			return (nCol + 1) & ^1
		} else {
			return nCol
		}
	}()
	nKeyCol = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	n = int32(48 + 4*uint(nColUp) + 4*uint(nColUp))
	p = (*struct_StatAccum)(sqlite3DbMallocZero(db, uint64(n)))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_result_error_nomem(context)
		return
	}
	p.db = db
	p.nEst = uint32(sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8))))
	p.nRow = uint32(0)
	p.nLimit = int32(sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8))))
	p.nCol = nCol
	p.nKeyCol = nKeyCol
	p.nSkipAhead = uint8(0)
	p.current.anDLt = (*uint32)(unsafe.Pointer(&*(*struct_StatAccum)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*48))))
	p.current.anEq = &*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anDLt)) + uintptr(nColUp)*4))
	sqlite3_result_blob(context, unsafe.Pointer(p), int32(48), statAccumDestructor)
}

var statInitFuncdef struct_FuncDef = struct_FuncDef{int8(4), uint32(1), nil, nil, statInit, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'s', 't', 'a', 't', '_', 'i', 'n', 'i', 't', '\x00'})), _cgoa_9{nil}}

func statPush(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var i int32
	var p *struct_StatAccum = (*struct_StatAccum)(sqlite3_value_blob(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	var iChng int32 = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	func() int {
		_ = argc
		return 0
	}()
	func() int {
		_ = context
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.nRow == uint32(0) {
		for i = int32(0); i < p.nCol; i++ {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anEq)) + uintptr(i)*4)) = uint32(1)
		}
	} else {
		for i = int32(0); i < iChng; i++ {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anEq)) + uintptr(i)*4))++
		}
		for i = iChng; i < p.nCol; i++ {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anDLt)) + uintptr(i)*4))++
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anEq)) + uintptr(i)*4)) = uint32(1)
		}
	}
	p.nRow++
	if p.nLimit != 0 && p.nRow > uint32(p.nLimit)*uint32(int32(p.nSkipAhead)+1) {
		p.nSkipAhead++
		sqlite3_result_int(context, func() int32 {
			if *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anDLt)) + uintptr(0)*4)) > uint32(0) {
				return 1
			} else {
				return 0
			}
		}())
	}
}

var statPushFuncdef struct_FuncDef = struct_FuncDef{int8(2 + 0), uint32(1), nil, nil, statPush, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'s', 't', 'a', 't', '_', 'p', 'u', 's', 'h', '\x00'})), _cgoa_9{nil}}

func statGet(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_StatAccum = (*struct_StatAccum)(sqlite3_value_blob(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	func() int {
		_ = 0
		return 0
	}()
	{
		var sStat struct_sqlite3_str
		var i int32
		sqlite3StrAccumInit(&sStat, nil, nil, 0, (p.nKeyCol+1)*100)
		sqlite3_str_appendf(&sStat, (*int8)(unsafe.Pointer(&[5]int8{'%', 'l', 'l', 'u', '\x00'})), func() uint64 {
			if int32(p.nSkipAhead) != 0 {
				return uint64(p.nEst)
			} else {
				return uint64(p.nRow)
			}
		}())
		for i = int32(0); i < p.nKeyCol; i++ {
			var nDistinct uint64 = uint64(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.current.anDLt)) + uintptr(i)*4)) + uint32(1))
			var iVal uint64 = (uint64(p.nRow) + nDistinct - uint64(1)) / nDistinct
			sqlite3_str_appendf(&sStat, (*int8)(unsafe.Pointer(&[6]int8{' ', '%', 'l', 'l', 'u', '\x00'})), iVal)
			func() int {
				_ = 0
				return 0
			}()
		}
		sqlite3ResultStrAccum(context, &sStat)
	}
	func() int {
		_ = argc
		return 0
	}()
}

var statGetFuncdef struct_FuncDef = struct_FuncDef{int8(1 + 0), uint32(1), nil, nil, statGet, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'s', 't', 'a', 't', '_', 'g', 'e', 't', '\x00'})), _cgoa_9{nil}}

func callStatGet(pParse *struct_Parse, regStat int32, iParam int32, regOut int32) {
	func() int {
		_ = iParam
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeAddFunctionCall(pParse, 0, regStat, regOut, 1+0, &statGetFuncdef, 0)
}
func analyzeOneTable(pParse *struct_Parse, pTab *struct_Table, pOnlyIdx *struct_Index, iStatCur int32, iMem int32, iTab int32) {
	var db *struct_sqlite3 = pParse.db
	var pIdx *struct_Index
	var iIdxCur int32
	var iTabCur int32
	var v *struct_Vdbe
	var i int32
	var jZeroRows int32 = -1
	var iDb int32
	var needTableCnt uint8 = uint8(1)
	var regNewRowid int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regStat int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regChng int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regRowid int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regTemp int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regTemp2 int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regTabname int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regIdxname int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regStat1 int32 = func() (_cgo_ret int32) {
		_cgo_addr := &iMem
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var regPrev int32 = iMem
	pParse.nMem = func() int32 {
		if pParse.nMem > iMem {
			return pParse.nMem
		} else {
			return iMem
		}
	}()
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if !(int32(pTab.eTabType) == 0) {
		return
	}
	if sqlite3_strlike((*int8)(unsafe.Pointer(&[10]int8{'s', 'q', 'l', 'i', 't', 'e', '\\', '_', '%', '\x00'})), pTab.zName, uint32('\\')) == 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3AuthCheck(pParse, 28, pTab.zName, nil, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName) != 0 {
		return
	}
	sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(0), pTab.zName)
	iTabCur = func() (_cgo_ret int32) {
		_cgo_addr := &iTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	iIdxCur = func() (_cgo_ret int32) {
		_cgo_addr := &iTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	pParse.nTab = func() int32 {
		if pParse.nTab > iTab {
			return pParse.nTab
		} else {
			return iTab
		}
	}()
	sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 101)
	sqlite3VdbeLoadString(v, regTabname, pTab.zName)
	for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
		var nCol int32
		var addrRewind int32
		var addrNextRow int32
		var zIdxName *int8
		var nColTest int32
		if pOnlyIdx != nil && uintptr(unsafe.Pointer(pOnlyIdx)) != uintptr(unsafe.Pointer(pIdx)) {
			continue
		}
		if uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) == uintptr(unsafe.Pointer(nil)) {
			needTableCnt = uint8(0)
		}
		if !(pTab.tabFlags&uint32(128) == uint32(0)) && int32(pIdx.Xbf_0&3) == 2 {
			nCol = int32(pIdx.nKeyCol)
			zIdxName = pTab.zName
			nColTest = nCol - 1
		} else {
			nCol = int32(pIdx.nColumn)
			zIdxName = pIdx.zName
			nColTest = func() int32 {
				if int32(pIdx.Xbf_0>>3&1) != 0 {
					return int32(pIdx.nKeyCol) - 1
				} else {
					return nCol - 1
				}
			}()
		}
		sqlite3VdbeLoadString(v, regIdxname, zIdxName)
		pParse.nMem = func() int32 {
			if pParse.nMem > regPrev+nColTest {
				return pParse.nMem
			} else {
				return regPrev + nColTest
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp3(v, 101, iIdxCur, int32(pIdx.tnum), iDb)
		sqlite3VdbeSetP4KeyInfo(pParse, pIdx)
		sqlite3VdbeAddOp2(v, 71, nCol, regStat+1)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp2(v, 71, int32(pIdx.nKeyCol), regRowid)
		{
			addrRewind = sqlite3VdbeAddOp1(v, 38, iIdxCur)
			sqlite3VdbeAddOp3(v, 97, iIdxCur, regTemp, 1)
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp2(v, 71, db.nAnalysisLimit, regTemp2)
		sqlite3VdbeAddFunctionCall(pParse, 0, regStat+1, regStat, 4, &statInitFuncdef, 0)
		sqlite3VdbeAddOp2(v, 71, 0, regChng)
		addrNextRow = sqlite3VdbeCurrentAddr(v)
		if nColTest > 0 {
			var endDistinctTest int32 = sqlite3VdbeMakeLabel(pParse)
			var aGotoChng *int32
			aGotoChng = (*int32)(sqlite3DbMallocRawNN(db, uint64(4*uint(nColTest))))
			if uintptr(unsafe.Pointer(aGotoChng)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			sqlite3VdbeAddOp0(v, 11)
			addrNextRow = sqlite3VdbeCurrentAddr(v)
			if nColTest == 1 && int32(pIdx.nKeyCol) == 1 && int32(pIdx.onError) != 0 {
				sqlite3VdbeAddOp2(v, 51, regPrev, endDistinctTest)
			}
			for i = int32(0); i < nColTest; i++ {
				var pColl *int8 = (*int8)(unsafe.Pointer(sqlite3LocateCollSeq(pParse, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(i)*8)))))
				sqlite3VdbeAddOp2(v, 71, i, regChng)
				sqlite3VdbeAddOp3(v, 93, iIdxCur, i, regTemp)
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aGotoChng)) + uintptr(i)*4)) = sqlite3VdbeAddOp4(v, 52, regTemp, 0, regPrev+i, pColl, -2)
				sqlite3VdbeChangeP5(v, uint16(128))
			}
			sqlite3VdbeAddOp2(v, 71, nColTest, regChng)
			sqlite3VdbeGoto(v, endDistinctTest)
			sqlite3VdbeJumpHere(v, addrNextRow-1)
			for i = int32(0); i < nColTest; i++ {
				sqlite3VdbeJumpHere(v, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aGotoChng)) + uintptr(i)*4)))
				sqlite3VdbeAddOp3(v, 93, iIdxCur, i, regPrev+i)
			}
			sqlite3VdbeResolveLabel(v, endDistinctTest)
			sqlite3DbFree(db, unsafe.Pointer(aGotoChng))
		}
		func() int {
			_ = 0
			return 0
		}()
		{
			sqlite3VdbeAddFunctionCall(pParse, 1, regStat, regTemp, 2+0, &statPushFuncdef, 0)
			if db.nAnalysisLimit != 0 {
				var j1 int32
				var j2 int32
				var j3 int32
				j1 = sqlite3VdbeAddOp1(v, 50, regTemp)
				j2 = sqlite3VdbeAddOp1(v, 18, regTemp)
				j3 = sqlite3VdbeAddOp4Int(v, 26, iIdxCur, 0, regPrev, 1)
				sqlite3VdbeJumpHere(v, j1)
				sqlite3VdbeAddOp2(v, 5, iIdxCur, addrNextRow)
				sqlite3VdbeJumpHere(v, j2)
				sqlite3VdbeJumpHere(v, j3)
			} else {
				sqlite3VdbeAddOp2(v, 5, iIdxCur, addrNextRow)
			}
		}
		callStatGet(pParse, regStat, 0, regStat1)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp4(v, 96, regTabname, 3, regTemp, (*int8)(unsafe.Pointer(&[4]int8{'B', 'B', 'B', '\x00'})), 0)
		sqlite3VdbeAddOp2(v, 126, iStatCur, regNewRowid)
		sqlite3VdbeAddOp3(v, 127, iStatCur, regTemp, regNewRowid)
		sqlite3VdbeChangeP5(v, uint16(8))
		sqlite3VdbeJumpHere(v, addrRewind)
	}
	if uintptr(unsafe.Pointer(pOnlyIdx)) == uintptr(unsafe.Pointer(nil)) && int32(needTableCnt) != 0 {
		sqlite3VdbeAddOp2(v, 97, iTabCur, regStat1)
		jZeroRows = sqlite3VdbeAddOp1(v, 20, regStat1)
		sqlite3VdbeAddOp2(v, 74, 0, regIdxname)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp4(v, 96, regTabname, 3, regTemp, (*int8)(unsafe.Pointer(&[4]int8{'B', 'B', 'B', '\x00'})), 0)
		sqlite3VdbeAddOp2(v, 126, iStatCur, regNewRowid)
		sqlite3VdbeAddOp3(v, 127, iStatCur, regTemp, regNewRowid)
		sqlite3VdbeChangeP5(v, uint16(8))
		sqlite3VdbeJumpHere(v, jZeroRows)
	}
}
func loadAnalysis(pParse *struct_Parse, iDb int32) {
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	if v != nil {
		sqlite3VdbeAddOp1(v, 149, iDb)
	}
}
func analyzeDatabase(pParse *struct_Parse, iDb int32) {
	var db *struct_sqlite3 = pParse.db
	var pSchema *struct_Schema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	var k *struct_HashElem
	var iStatCur int32
	var iMem int32
	var iTab int32
	sqlite3BeginWriteOperation(pParse, 0, iDb)
	iStatCur = pParse.nTab
	pParse.nTab += int32(3)
	openStatTable(pParse, iDb, iStatCur, nil, nil)
	iMem = pParse.nMem + 1
	iTab = pParse.nTab
	func() int {
		_ = 0
		return 0
	}()
	for k = (&pSchema.tblHash).first; k != nil; k = k.next {
		var pTab *struct_Table = (*struct_Table)(k.data)
		analyzeOneTable(pParse, pTab, nil, iStatCur, iMem, iTab)
	}
	loadAnalysis(pParse, iDb)
}
func analyzeTable(pParse *struct_Parse, pTab *struct_Table, pOnlyIdx *struct_Index) {
	var iDb int32
	var iStatCur int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iDb = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
	sqlite3BeginWriteOperation(pParse, 0, iDb)
	iStatCur = pParse.nTab
	pParse.nTab += int32(3)
	if pOnlyIdx != nil {
		openStatTable(pParse, iDb, iStatCur, pOnlyIdx.zName, (*int8)(unsafe.Pointer(&[4]int8{'i', 'd', 'x', '\x00'})))
	} else {
		openStatTable(pParse, iDb, iStatCur, pTab.zName, (*int8)(unsafe.Pointer(&[4]int8{'t', 'b', 'l', '\x00'})))
	}
	analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur, pParse.nMem+1, pParse.nTab)
	loadAnalysis(pParse, iDb)
}
func sqlite3Analyze(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token) {
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	var i int32
	var z *int8
	var zDb *int8
	var pTab *struct_Table
	var pIdx *struct_Index
	var pTableName *struct_Token
	var v *struct_Vdbe
	func() int {
		_ = 0
		return 0
	}()
	if 0 != sqlite3ReadSchema(pParse) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pName1)) == uintptr(unsafe.Pointer(nil)) {
		for i = int32(0); i < db.nDb; i++ {
			if i == 1 {
				continue
			}
			analyzeDatabase(pParse, i)
		}
	} else if pName2.n == uint32(0) && func() (_cgo_ret int32) {
		_cgo_addr := &iDb
		*_cgo_addr = sqlite3FindDb(db, pName1)
		return *_cgo_addr
	}() >= 0 {
		analyzeDatabase(pParse, iDb)
	} else {
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName)
		if iDb >= 0 {
			zDb = func() *int8 {
				if pName2.n != 0 {
					return (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
				} else {
					return nil
				}
			}()
			z = sqlite3NameFromToken(db, pTableName)
			if z != nil {
				if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Index) {
					_cgo_addr := &pIdx
					*_cgo_addr = sqlite3FindIndex(db, z, zDb)
					return *_cgo_addr
				}())) != uintptr(unsafe.Pointer(nil)) {
					analyzeTable(pParse, pIdx.pTable, pIdx)
				} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
					_cgo_addr := &pTab
					*_cgo_addr = sqlite3LocateTable(pParse, uint32(0), z, zDb)
					return *_cgo_addr
				}())) != uintptr(unsafe.Pointer(nil)) {
					analyzeTable(pParse, pTab, nil)
				}
				sqlite3DbFree(db, unsafe.Pointer(z))
			}
		}
	}
	if int32(db.nSqlExec) == 0 && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Vdbe) {
		_cgo_addr := &v
		*_cgo_addr = sqlite3GetVdbe(pParse)
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		sqlite3VdbeAddOp0(v, 165)
	}
}

type analysisInfo = struct_analysisInfo
type struct_analysisInfo struct {
	db        *struct_sqlite3
	zDatabase *int8
}

func decodeIntArray(zIntArray *int8, nOut int32, aOut *uint32, aLog *int16, pIndex *struct_Index) {
	var z *int8 = zIntArray
	var c int32
	var i int32
	var v uint32
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); int32(*z) != 0 && i < nOut; i++ {
		v = uint32(0)
		for func() (_cgo_ret int32) {
			_cgo_addr := &c
			*_cgo_addr = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))))
			return *_cgo_addr
		}() >= '0' && c <= '9' {
			v = v*uint32(10) + uint32(c) - uint32('0')
			*(*uintptr)(unsafe.Pointer(&z))++
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = aOut
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(aLog)) + uintptr(i)*2)) = sqlite3LogEst(uint64(v))
		if int32(*z) == ' ' {
			*(*uintptr)(unsafe.Pointer(&z))++
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	{
		{
			_autoGo_44 := &pIndex.Xbf_0
			*_autoGo_44 = *_autoGo_44&^4 | uint32(0)&1<<2
		}
		{
			_autoGo_45 := &pIndex.Xbf_0
			*_autoGo_45 = *_autoGo_45&^64 | uint32(0)&1<<6
		}
		for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))) != 0 {
			if sqlite3_strglob((*int8)(unsafe.Pointer(&[11]int8{'u', 'n', 'o', 'r', 'd', 'e', 'r', 'e', 'd', '*', '\x00'})), z) == 0 {
				{
					_autoGo_46 := &pIndex.Xbf_0
					*_autoGo_46 = *_autoGo_46&^4 | uint32(1)&1<<2
				}
			} else if sqlite3_strglob((*int8)(unsafe.Pointer(&[10]int8{'s', 'z', '=', '[', '0', '-', '9', ']', '*', '\x00'})), z) == 0 {
				var sz int32 = sqlite3Atoi((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(3))))
				if sz < 2 {
					sz = int32(2)
				}
				pIndex.szIdxRow = sqlite3LogEst(uint64(sz))
			} else if sqlite3_strglob((*int8)(unsafe.Pointer(&[12]int8{'n', 'o', 's', 'k', 'i', 'p', 's', 'c', 'a', 'n', '*', '\x00'})), z) == 0 {
				{
					_autoGo_47 := &pIndex.Xbf_0
					*_autoGo_47 = *_autoGo_47&^64 | uint32(1)&1<<6
				}
			}
			for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) != ' ' {
				*(*uintptr)(unsafe.Pointer(&z))++
			}
			for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) == ' ' {
				*(*uintptr)(unsafe.Pointer(&z))++
			}
		}
	}
}
func analysisLoader(pData unsafe.Pointer, argc int32, argv **int8, NotUsed **int8) int32 {
	var pInfo *struct_analysisInfo = (*struct_analysisInfo)(pData)
	var pIndex *struct_Index
	var pTable *struct_Table
	var z *int8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = argc
			return 0
		}()
	}()
	if uintptr(unsafe.Pointer(argv)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)))) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	pTable = sqlite3FindTable(pInfo.db, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)), pInfo.zDatabase)
	if uintptr(unsafe.Pointer(pTable)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))) == uintptr(unsafe.Pointer(nil)) {
		pIndex = (*struct_Index)(nil)
	} else if sqlite3_stricmp(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))) == 0 {
		pIndex = sqlite3PrimaryKeyIndex(pTable)
	} else {
		pIndex = sqlite3FindIndex(pInfo.db, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)), pInfo.zDatabase)
	}
	z = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8))
	if pIndex != nil {
		var aiRowEst *uint32 = nil
		var nCol int32 = int32(pIndex.nKeyCol) + 1
		{
			_autoGo_48 := &pIndex.Xbf_0
			*_autoGo_48 = *_autoGo_48&^4 | uint32(0)&1<<2
		}
		decodeIntArray((*int8)(unsafe.Pointer(z)), nCol, aiRowEst, pIndex.aiRowLogEst, pIndex)
		{
			_autoGo_49 := &pIndex.Xbf_0
			*_autoGo_49 = *_autoGo_49&^128 | uint32(1)&1<<7
		}
		if uintptr(unsafe.Pointer(pIndex.pPartIdxWhere)) == uintptr(unsafe.Pointer(nil)) {
			pTable.nRowLogEst = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiRowLogEst)) + uintptr(0)*2))
			pTable.tabFlags |= uint32(16)
		}
	} else {
		var fakeIdx struct_Index
		fakeIdx.szIdxRow = pTable.szTabRow
		decodeIntArray((*int8)(unsafe.Pointer(z)), 1, nil, &pTable.nRowLogEst, &fakeIdx)
		pTable.szTabRow = fakeIdx.szIdxRow
		pTable.tabFlags |= uint32(16)
	}
	return int32(0)
}
func sqlite3DeleteIndexSamples(db *struct_sqlite3, pIdx *struct_Index) {
	func() int {
		_ = db
		return 0
	}()
	func() int {
		_ = pIdx
		return 0
	}()
}
func sqlite3AnalysisLoad(db *struct_sqlite3, iDb int32) int32 {
	var sInfo struct_analysisInfo
	var i *struct_HashElem
	var zSql *int8
	var rc int32 = 0
	var pSchema *struct_Schema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	var pStat1 *struct_Table
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for i = (&pSchema.tblHash).first; i != nil; i = i.next {
		var pTab *struct_Table = (*struct_Table)(i.data)
		pTab.tabFlags &= uint32(4294967279)
	}
	for i = (&pSchema.idxHash).first; i != nil; i = i.next {
		var pIdx *struct_Index = (*struct_Index)(i.data)
		{
			_autoGo_50 := &pIdx.Xbf_0
			*_autoGo_50 = *_autoGo_50&^128 | uint32(0)&1<<7
		}
	}
	sInfo.db = db
	sInfo.zDatabase = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	if func() (_cgo_ret *struct_Table) {
		_cgo_addr := &pStat1
		*_cgo_addr = sqlite3FindTable(db, (*int8)(unsafe.Pointer(&[13]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '1', '\x00'})), sInfo.zDatabase)
		return *_cgo_addr
	}() != nil && int32(pStat1.eTabType) == 0 {
		zSql = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[41]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', 't', 'b', 'l', ',', 'i', 'd', 'x', ',', 's', 't', 'a', 't', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '1', '\x00'})), sInfo.zDatabase)
		if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
		} else {
			rc = sqlite3_exec(db, zSql, analysisLoader, unsafe.Pointer(&sInfo), nil)
			sqlite3DbFree(db, unsafe.Pointer(zSql))
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	for i = (&pSchema.idxHash).first; i != nil; i = i.next {
		var pIdx *struct_Index = (*struct_Index)(i.data)
		if !(pIdx.Xbf_0>>7&1 != 0) {
			sqlite3DefaultRowEst(pIdx)
		}
	}
	if rc == 7 {
		sqlite3OomFault(db)
	}
	return rc
}
func resolveAttachExpr(pName *struct_NameContext, pExpr *struct_Expr) int32 {
	var rc int32 = 0
	if pExpr != nil {
		if int32(pExpr.op) != 59 {
			rc = sqlite3ResolveExprNames(pName, pExpr)
		} else {
			pExpr.op = uint8(117)
		}
	}
	return rc
}
func sqlite3DbIsNamed(db *struct_sqlite3, iDb int32, zName *int8) int32 {
	return func() int32 {
		if sqlite3StrICmp((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, zName) == 0 || iDb == 0 && sqlite3StrICmp((*int8)(unsafe.Pointer(&[5]int8{'m', 'a', 'i', 'n', '\x00'})), zName) == 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func attachFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var i int32
	var rc int32 = 0
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var zName *int8
	var zFile *int8
	var zPath *int8 = nil
	var zErr *int8 = nil
	var flags uint32
	var aNew *struct_Db
	var pNew *struct_Db
	var zErrDyn *int8 = nil
	var pVfs *struct_sqlite3_vfs
	func() int {
		_ = NotUsed
		return 0
	}()
	zFile = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	zName = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
	if uintptr(unsafe.Pointer(zFile)) == uintptr(unsafe.Pointer(nil)) {
		zFile = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	}
	if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
		zName = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	}
	if db.init.Xbf_0>>2&1 != 0 {
		pVfs = sqlite3_vfs_find((*int8)(unsafe.Pointer(&[6]int8{'m', 'e', 'm', 'd', 'b', '\x00'})))
		if uintptr(unsafe.Pointer(pVfs)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		pNew = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(db.init.iDb)*32))
		if pNew.pBt != nil {
			sqlite3BtreeClose(pNew.pBt)
		}
		pNew.pBt = (*struct_Btree)(nil)
		pNew.pSchema = (*struct_Schema)(nil)
		rc = sqlite3BtreeOpen(pVfs, (*int8)(unsafe.Pointer(&[3]int8{'x', '\x00', '\x00'})), db, &pNew.pBt, 0, 256)
	} else {
		if db.nDb >= *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(7)*4))+2 {
			zErrDyn = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[37]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'a', 't', 't', 'a', 'c', 'h', 'e', 'd', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', 's', ' ', '-', ' ', 'm', 'a', 'x', ' ', '%', 'd', '\x00'})), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(7)*4)))
			goto attach_error
		}
		for i = int32(0); i < db.nDb; i++ {
			func() int {
				_ = 0
				return 0
			}()
			if sqlite3DbIsNamed(db, i, zName) != 0 {
				zErrDyn = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[30]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 's', ' ', 'i', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'i', 'n', ' ', 'u', 's', 'e', '\x00'})), zName)
				goto attach_error
			}
		}
		if uintptr(unsafe.Pointer(db.aDb)) == uintptr(unsafe.Pointer((*struct_Db)(unsafe.Pointer(&db.aDbStatic)))) {
			aNew = (*struct_Db)(sqlite3DbMallocRawNN(db, uint64(32*uint(3))))
			if uintptr(unsafe.Pointer(aNew)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
			__builtin___memcpy_chk(unsafe.Pointer(aNew), unsafe.Pointer(db.aDb), 32*uint(2), __builtin_object_size(unsafe.Pointer(aNew), 0))
		} else {
			aNew = (*struct_Db)(sqlite3DbRealloc(db, unsafe.Pointer(db.aDb), uint64(32*uint(db.nDb+1))))
			if uintptr(unsafe.Pointer(aNew)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
		}
		db.aDb = aNew
		pNew = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(db.nDb)*32))
		__builtin___memset_chk(unsafe.Pointer(pNew), 0, 32, __builtin_object_size(unsafe.Pointer(pNew), 0))
		flags = db.openFlags
		rc = sqlite3ParseUri(db.pVfs.zName, zFile, &flags, &pVfs, &zPath, &zErr)
		if rc != 0 {
			if rc == 7 {
				sqlite3OomFault(db)
			}
			sqlite3_result_error(context, zErr, -1)
			sqlite3_free(unsafe.Pointer(zErr))
			return
		}
		func() int {
			_ = 0
			return 0
		}()
		flags |= uint32(256)
		rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew.pBt, 0, int32(flags))
		db.nDb++
		pNew.zDbSName = sqlite3DbStrDup(db, zName)
	}
	db.noSharedCache = uint8(0)
	if rc == 19 {
		rc = int32(1)
		zErrDyn = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[29]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'i', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'a', 't', 't', 'a', 'c', 'h', 'e', 'd', '\x00'})))
	} else if rc == 0 {
		var pPager *struct_Pager
		pNew.pSchema = sqlite3SchemaGet(db, pNew.pBt)
		if !(pNew.pSchema != nil) {
			rc = int32(7)
		} else if int32(pNew.pSchema.file_format) != 0 && int32(pNew.pSchema.enc) != int32(db.enc) {
			zErrDyn = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[68]int8{'a', 't', 't', 'a', 'c', 'h', 'e', 'd', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', 's', ' ', 'm', 'u', 's', 't', ' ', 'u', 's', 'e', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 't', 'e', 'x', 't', ' ', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 'a', 's', ' ', 'm', 'a', 'i', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})))
			rc = int32(1)
		}
		sqlite3BtreeEnter(pNew.pBt)
		pPager = sqlite3BtreePager(pNew.pBt)
		sqlite3PagerLockingMode(pPager, int32(db.dfltLockMode))
		sqlite3BtreeSecureDelete(pNew.pBt, sqlite3BtreeSecureDelete((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt, -1))
		sqlite3BtreeSetPagerFlags(pNew.pBt, uint32(uint64(3)|db.flags&uint64(56)))
		sqlite3BtreeLeave(pNew.pBt)
	}
	pNew.safety_level = uint8(2 + 1)
	if rc == 0 && uintptr(unsafe.Pointer(pNew.zDbSName)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(7)
	}
	sqlite3_free_filename(zPath)
	if rc == 0 {
		sqlite3BtreeEnterAll(db)
		db.init.iDb = uint8(0)
		db.mDbFlags &= uint32(4294967279)
		if !(db.init.Xbf_0>>2&1 != 0) {
			rc = sqlite3Init(db, &zErrDyn)
		}
		sqlite3BtreeLeaveAll(db)
		func() int {
			_ = 0
			return 0
		}()
	}
	if rc != 0 {
		if !(db.init.Xbf_0>>2&1 != 0) {
			var iDb int32 = db.nDb - 1
			func() int {
				_ = 0
				return 0
			}()
			if (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt != nil {
				sqlite3BtreeClose((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt)
				(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt = (*struct_Btree)(nil)
				(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema = (*struct_Schema)(nil)
			}
			sqlite3ResetAllSchemasOfConnection(db)
			db.nDb = iDb
			if rc == 7 || rc == 10|12<<8 {
				sqlite3OomFault(db)
				sqlite3DbFree(db, unsafe.Pointer(zErrDyn))
				zErrDyn = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
			} else if uintptr(unsafe.Pointer(zErrDyn)) == uintptr(unsafe.Pointer(nil)) {
				zErrDyn = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[28]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'o', 'p', 'e', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ':', ' ', '%', 's', '\x00'})), zFile)
			}
		}
		goto attach_error
	}
	return
attach_error:
	if zErrDyn != nil {
		sqlite3_result_error(context, zErrDyn, -1)
		sqlite3DbFree(db, unsafe.Pointer(zErrDyn))
	}
	if rc != 0 {
		sqlite3_result_error_code(context, rc)
	}
}
func detachFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var zName *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var i int32
	var pDb *struct_Db = nil
	var pEntry *struct_HashElem
	var zErr [128]int8
	func() int {
		_ = NotUsed
		return 0
	}()
	if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
		zName = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	}
	for i = int32(0); i < db.nDb; i++ {
		pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))
		if uintptr(unsafe.Pointer(pDb.pBt)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if sqlite3DbIsNamed(db, i, zName) != 0 {
			break
		}
	}
	if i >= db.nDb {
		sqlite3_snprintf(int32(128), (*int8)(unsafe.Pointer(&zErr)), (*int8)(unsafe.Pointer(&[21]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ':', ' ', '%', 's', '\x00'})), zName)
		goto detach_error
	}
	if i < 2 {
		sqlite3_snprintf(int32(128), (*int8)(unsafe.Pointer(&zErr)), (*int8)(unsafe.Pointer(&[26]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'd', 'e', 't', 'a', 'c', 'h', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 's', '\x00'})), zName)
		goto detach_error
	}
	if sqlite3BtreeTxnState(pDb.pBt) != 0 || sqlite3BtreeIsInBackup(pDb.pBt) != 0 {
		sqlite3_snprintf(int32(128), (*int8)(unsafe.Pointer(&zErr)), (*int8)(unsafe.Pointer(&[22]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 's', ' ', 'i', 's', ' ', 'l', 'o', 'c', 'k', 'e', 'd', '\x00'})), zName)
		goto detach_error
	}
	func() int {
		_ = 0
		return 0
	}()
	pEntry = (&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.trigHash).first
	for pEntry != nil {
		var pTrig *struct_Trigger = (*struct_Trigger)(pEntry.data)
		if uintptr(unsafe.Pointer(pTrig.pTabSchema)) == uintptr(unsafe.Pointer(pDb.pSchema)) {
			pTrig.pTabSchema = pTrig.pSchema
		}
		pEntry = pEntry.next
	}
	sqlite3BtreeClose(pDb.pBt)
	pDb.pBt = (*struct_Btree)(nil)
	pDb.pSchema = (*struct_Schema)(nil)
	sqlite3CollapseDatabaseArray(db)
	return
detach_error:
	sqlite3_result_error(context, (*int8)(unsafe.Pointer(&zErr)), -1)
}
func codeAttach(pParse *struct_Parse, type_ int32, pFunc *struct_FuncDef, pAuthArg *struct_Expr, pFilename *struct_Expr, pDbname *struct_Expr, pKey *struct_Expr) {
	var rc int32
	var sName struct_NameContext
	var v *struct_Vdbe
	var db *struct_sqlite3 = pParse.db
	var regArgs int32
	if pParse.nErr != 0 {
		goto attach_end
	}
	__builtin___memset_chk(unsafe.Pointer(&sName), 0, 56, __builtin_object_size(unsafe.Pointer(&sName), 0))
	sName.pParse = pParse
	if 0 != resolveAttachExpr(&sName, pFilename) || 0 != resolveAttachExpr(&sName, pDbname) || 0 != resolveAttachExpr(&sName, pKey) {
		goto attach_end
	}
	if pAuthArg != nil {
		var zAuthArg *int8
		if int32(pAuthArg.op) == 117 {
			func() int {
				_ = 0
				return 0
			}()
			zAuthArg = pAuthArg.u.zToken
		} else {
			zAuthArg = (*int8)(nil)
		}
		rc = sqlite3AuthCheck(pParse, type_, zAuthArg, nil, nil)
		if rc != 0 {
			goto attach_end
		}
	}
	v = sqlite3GetVdbe(pParse)
	regArgs = sqlite3GetTempRange(pParse, 4)
	sqlite3ExprCode(pParse, pFilename, regArgs)
	sqlite3ExprCode(pParse, pDbname, regArgs+1)
	sqlite3ExprCode(pParse, pKey, regArgs+2)
	func() int {
		_ = 0
		return 0
	}()
	if v != nil {
		sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-int32(pFunc.nArg), regArgs+3, int32(pFunc.nArg), pFunc, 0)
		sqlite3VdbeAddOp1(v, 165, func() int32 {
			if type_ == 24 {
				return 1
			} else {
				return 0
			}
		}())
	}
attach_end:
	sqlite3ExprDelete(db, pFilename)
	sqlite3ExprDelete(db, pDbname)
	sqlite3ExprDelete(db, pKey)
}
func sqlite3Detach(pParse *struct_Parse, pDbname *struct_Expr) {
	var detach_func struct_FuncDef = struct_FuncDef{int8(1), uint32(1), nil, nil, detachFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'd', 'e', 't', 'a', 'c', 'h', '\x00'})), _cgoa_9{nil}}
	codeAttach(pParse, 25, &detach_func, pDbname, nil, nil, pDbname)
}
func sqlite3Attach(pParse *struct_Parse, p *struct_Expr, pDbname *struct_Expr, pKey *struct_Expr) {
	var attach_func struct_FuncDef = struct_FuncDef{int8(3), uint32(1), nil, nil, attachFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'a', 't', 't', 'a', 'c', 'h', '\x00'})), _cgoa_9{nil}}
	codeAttach(pParse, 24, &attach_func, p, p, pDbname, pKey)
}
func fixExprCb(p *struct_Walker, pExpr *struct_Expr) int32 {
	var pFix *struct_DbFixer = *(**struct_DbFixer)(unsafe.Pointer(&p.u))
	if !(pFix.bTemp != 0) {
		pExpr.flags |= uint32(1073741824)
	}
	if int32(pExpr.op) == 156 {
		if pFix.pParse.db.init.busy != 0 {
			pExpr.op = uint8(121)
		} else {
			sqlite3ErrorMsg(pFix.pParse, (*int8)(unsafe.Pointer(&[24]int8{'%', 's', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'u', 's', 'e', ' ', 'v', 'a', 'r', 'i', 'a', 'b', 'l', 'e', 's', '\x00'})), pFix.zType)
			return int32(2)
		}
	}
	return int32(0)
}
func fixSelectCb(p *struct_Walker, pSelect *struct_Select) int32 {
	var pFix *struct_DbFixer = *(**struct_DbFixer)(unsafe.Pointer(&p.u))
	var i int32
	var pItem *struct_SrcItem
	var db *struct_sqlite3 = pFix.pParse.db
	var iDb int32 = sqlite3FindDbName(db, pFix.zDb)
	var pList *struct_SrcList = pSelect.pSrc
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	for func() *struct_SrcItem {
		i = int32(0)
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pList.a))
			return *_cgo_addr
		}()
	}(); i < pList.nSrc; func() *struct_SrcItem {
		i++
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		if int32(pFix.bTemp) == 0 {
			if pItem.zDatabase != nil {
				if iDb != sqlite3FindDbName(db, pItem.zDatabase) {
					sqlite3ErrorMsg(pFix.pParse, (*int8)(unsafe.Pointer(&[46]int8{'%', 's', ' ', '%', 'T', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'o', 'b', 'j', 'e', 'c', 't', 's', ' ', 'i', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 's', '\x00'})), pFix.zType, pFix.pName, pItem.zDatabase)
					return int32(2)
				}
				sqlite3DbFree(db, unsafe.Pointer(pItem.zDatabase))
				pItem.zDatabase = (*int8)(nil)
				{
					_autoGo_51 := &pItem.fg.Xbf_0
					*_autoGo_51 = *_autoGo_51&^256 | uint32(1)&1<<8
				}
			}
			pItem.pSchema = pFix.pSchema
			{
				_autoGo_52 := &pItem.fg.Xbf_0
				*_autoGo_52 = *_autoGo_52&^64 | uint32(1)&1<<6
			}
		}
		if sqlite3WalkExpr(&pFix.w, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pList.a)))) + uintptr(i)*112))).pOn) != 0 {
			return int32(2)
		}
	}
	if pSelect.pWith != nil {
		for i = int32(0); i < pSelect.pWith.nCte; i++ {
			if sqlite3WalkSelect(p, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pSelect.pWith.a)))) + uintptr(i)*41))).pSelect) != 0 {
				return int32(2)
			}
		}
	}
	return int32(0)
}
func sqlite3FixInit(pFix *struct_DbFixer, pParse *struct_Parse, iDb int32, zType *int8, pName *struct_Token) {
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	pFix.pParse = pParse
	pFix.zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	pFix.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	pFix.zType = zType
	pFix.pName = pName
	pFix.bTemp = func() uint8 {
		if iDb == 1 {
			return 1
		} else {
			return 0
		}
	}()
	pFix.w.pParse = pParse
	pFix.w.xExprCallback = fixExprCb
	pFix.w.xSelectCallback = fixSelectCb
	pFix.w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback
	pFix.w.walkerDepth = int32(0)
	pFix.w.eCode = uint16(0)
	*(**struct_DbFixer)(unsafe.Pointer(&pFix.w.u)) = pFix
}
func sqlite3FixSrcList(pFix *struct_DbFixer, pList *struct_SrcList) int32 {
	var res int32 = 0
	if pList != nil {
		var s struct_Select
		__builtin___memset_chk(unsafe.Pointer(&s), 0, 128, __builtin_object_size(unsafe.Pointer(&s), 0))
		s.pSrc = pList
		res = sqlite3WalkSelect(&pFix.w, &s)
	}
	return res
}
func sqlite3FixSelect(pFix *struct_DbFixer, pSelect *struct_Select) int32 {
	return sqlite3WalkSelect(&pFix.w, pSelect)
}
func sqlite3FixExpr(pFix *struct_DbFixer, pExpr *struct_Expr) int32 {
	return sqlite3WalkExpr(&pFix.w, pExpr)
}
func sqlite3FixTriggerStep(pFix *struct_DbFixer, pStep *struct_TriggerStep) int32 {
	for pStep != nil {
		if sqlite3WalkSelect(&pFix.w, pStep.pSelect) != 0 || sqlite3WalkExpr(&pFix.w, pStep.pWhere) != 0 || sqlite3WalkExprList(&pFix.w, pStep.pExprList) != 0 || sqlite3FixSrcList(pFix, pStep.pFrom) != 0 {
			return int32(1)
		}
		{
			var pUp *struct_Upsert
			for pUp = pStep.pUpsert; pUp != nil; pUp = pUp.pNextUpsert {
				if sqlite3WalkExprList(&pFix.w, pUp.pUpsertTarget) != 0 || sqlite3WalkExpr(&pFix.w, pUp.pUpsertTargetWhere) != 0 || sqlite3WalkExprList(&pFix.w, pUp.pUpsertSet) != 0 || sqlite3WalkExpr(&pFix.w, pUp.pUpsertWhere) != 0 {
					return int32(1)
				}
			}
		}
		pStep = pStep.pNext
	}
	return int32(0)
}
func sqlite3_set_authorizer(db *struct_sqlite3, xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32, pArg unsafe.Pointer) int32 {
	sqlite3_mutex_enter(db.mutex)
	db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(xAuth)
	db.pAuthArg = pArg
	if db.xAuth != nil {
		sqlite3ExpirePreparedStatements(db, 1)
	}
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqliteAuthBadReturnCode(pParse *struct_Parse) {
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[23]int8{'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'e', 'r', ' ', 'm', 'a', 'l', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', '\x00'})))
	pParse.rc = int32(1)
}
func sqlite3AuthReadCol(pParse *struct_Parse, zTab *int8, zCol *int8, iDb int32) int32 {
	var db *struct_sqlite3 = pParse.db
	var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	var rc int32
	if db.init.busy != 0 {
		return int32(0)
	}
	rc = db.xAuth(db.pAuthArg, 20, zTab, zCol, zDb, pParse.zAuthContext)
	if rc == 1 {
		var z *int8 = sqlite3_mprintf((*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 's', '\x00'})), zTab, zCol)
		if db.nDb > 2 || iDb != 0 {
			z = sqlite3_mprintf((*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 'z', '\x00'})), zDb, z)
		}
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'a', 'c', 'c', 'e', 's', 's', ' ', 't', 'o', ' ', '%', 'z', ' ', 'i', 's', ' ', 'p', 'r', 'o', 'h', 'i', 'b', 'i', 't', 'e', 'd', '\x00'})), z)
		pParse.rc = int32(23)
	} else if rc != 2 && rc != 0 {
		sqliteAuthBadReturnCode(pParse)
	}
	return rc
}
func sqlite3AuthRead(pParse *struct_Parse, pExpr *struct_Expr, pSchema *struct_Schema, pTabList *struct_SrcList) {
	var pTab *struct_Table = nil
	var zCol *int8
	var iSrc int32
	var iDb int32
	var iCol int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iDb = sqlite3SchemaToIndex(pParse.db, pSchema)
	if iDb < 0 {
		return
	}
	if int32(pExpr.op) == 77 {
		pTab = pParse.pTriggerTab
	} else {
		func() int {
			_ = 0
			return 0
		}()
		for iSrc = int32(0); iSrc < pTabList.nSrc; iSrc++ {
			if pExpr.iTable == (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(iSrc)*112))).iCursor {
				pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(iSrc)*112))).pTab
				break
			}
		}
	}
	iCol = int32(pExpr.iColumn)
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if iCol >= 0 {
		func() int {
			_ = 0
			return 0
		}()
		zCol = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName
	} else if int32(pTab.iPKey) >= 0 {
		func() int {
			_ = 0
			return 0
		}()
		zCol = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(pTab.iPKey)*20))).zCnName
	} else {
		zCol = (*int8)(unsafe.Pointer(&[6]int8{'R', 'O', 'W', 'I', 'D', '\x00'}))
	}
	func() int {
		_ = 0
		return 0
	}()
	if 2 == sqlite3AuthReadCol(pParse, pTab.zName, zCol, iDb) {
		pExpr.op = uint8(121)
	}
}
func sqlite3AuthCheck(pParse *struct_Parse, code int32, zArg1 *int8, zArg2 *int8, zArg3 *int8) int32 {
	var db *struct_sqlite3 = pParse.db
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(db.xAuth)) == uintptr(unsafe.Pointer(nil)) || int32(db.init.busy) != 0 || int32(pParse.eParseMode) != 0 {
		return int32(0)
	}
	rc = db.xAuth(db.pAuthArg, code, zArg1, zArg2, zArg3, pParse.zAuthContext)
	if rc == 1 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[15]int8{'n', 'o', 't', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'e', 'd', '\x00'})))
		pParse.rc = int32(23)
	} else if rc != 0 && rc != 2 {
		rc = int32(1)
		sqliteAuthBadReturnCode(pParse)
	}
	return rc
}
func sqlite3AuthContextPush(pParse *struct_Parse, pContext *struct_AuthContext, zContext *int8) {
	func() int {
		_ = 0
		return 0
	}()
	pContext.pParse = pParse
	pContext.zAuthContext = pParse.zAuthContext
	pParse.zAuthContext = zContext
}
func sqlite3AuthContextPop(pContext *struct_AuthContext) {
	if pContext.pParse != nil {
		pContext.pParse.zAuthContext = pContext.zAuthContext
		pContext.pParse = (*struct_Parse)(nil)
	}
}

type struct_TableLock struct {
	iDb         int32
	iTab        uint32
	isWriteLock uint8
	zLockName   *int8
}

func lockTable(pParse *struct_Parse, iDb int32, iTab uint32, isWriteLock uint8, zName *int8) {
	var pToplevel *struct_Parse
	var i int32
	var nBytes int32
	var p *struct_TableLock
	func() int {
		_ = 0
		return 0
	}()
	pToplevel = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	for i = int32(0); i < pToplevel.nTableLock; i++ {
		p = &*(*struct_TableLock)(unsafe.Pointer(uintptr(unsafe.Pointer(pToplevel.aTableLock)) + uintptr(i)*24))
		if p.iDb == iDb && p.iTab == iTab {
			p.isWriteLock = func() uint8 {
				if int32(p.isWriteLock) != 0 || int32(isWriteLock) != 0 {
					return 1
				} else {
					return 0
				}
			}()
			return
		}
	}
	nBytes = int32(24 * uint(pToplevel.nTableLock+1))
	pToplevel.aTableLock = (*struct_TableLock)(sqlite3DbReallocOrFree(pToplevel.db, unsafe.Pointer(pToplevel.aTableLock), uint64(nBytes)))
	if pToplevel.aTableLock != nil {
		p = &*(*struct_TableLock)(unsafe.Pointer(uintptr(unsafe.Pointer(pToplevel.aTableLock)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &pToplevel.nTableLock
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*24))
		p.iDb = iDb
		p.iTab = iTab
		p.isWriteLock = isWriteLock
		p.zLockName = zName
	} else {
		pToplevel.nTableLock = int32(0)
		sqlite3OomFault(pToplevel.db)
	}
}
func sqlite3TableLock(pParse *struct_Parse, iDb int32, iTab uint32, isWriteLock uint8, zName *int8) {
	if iDb == 1 {
		return
	}
	if !(sqlite3BtreeSharable((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(iDb)*32))).pBt) != 0) {
		return
	}
	lockTable(pParse, iDb, iTab, isWriteLock, zName)
}
func codeTableLocks(pParse *struct_Parse) {
	var i int32
	var pVdbe *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < pParse.nTableLock; i++ {
		var p *struct_TableLock = &*(*struct_TableLock)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aTableLock)) + uintptr(i)*24))
		var p1 int32 = p.iDb
		sqlite3VdbeAddOp4(pVdbe, 168, p1, int32(p.iTab), int32(p.isWriteLock), p.zLockName, -1)
	}
}
func sqlite3FinishCoding(pParse *struct_Parse) {
	var db *struct_sqlite3
	var v *struct_Vdbe
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nested != 0 {
		return
	}
	if pParse.nErr != 0 {
		if db.mallocFailed != 0 {
			pParse.rc = int32(7)
		}
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	v = pParse.pVdbe
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		if db.init.busy != 0 {
			pParse.rc = int32(101)
			return
		}
		v = sqlite3GetVdbe(pParse)
		if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
			pParse.rc = int32(1)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if v != nil {
		if pParse.bReturning != 0 {
			var pReturning *struct_Returning = pParse.u1.pReturning
			var addrRewind int32
			var i int32
			var reg int32
			if pReturning.nRetCol == 0 {
				func() int {
					_ = 0
					return 0
				}()
			} else {
				sqlite3VdbeAddOp0(v, 82)
				addrRewind = sqlite3VdbeAddOp1(v, 38, pReturning.iRetCur)
				reg = pReturning.iRetReg
				for i = int32(0); i < pReturning.nRetCol; i++ {
					sqlite3VdbeAddOp3(v, 93, pReturning.iRetCur, i, reg+i)
				}
				sqlite3VdbeAddOp2(v, 83, reg, i)
				sqlite3VdbeAddOp2(v, 5, pReturning.iRetCur, addrRewind+1)
				sqlite3VdbeJumpHere(v, addrRewind)
			}
		}
		sqlite3VdbeAddOp0(v, 70)
		if int32(db.mallocFailed) == 0 && (pParse.cookieMask != uint32(0) || pParse.pConstExpr != nil) {
			var iDb int32
			var i int32
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeJumpHere(v, 0)
			for iDb = int32(0); iDb < db.nDb; iDb++ {
				var pSchema *struct_Schema
				if func() int32 {
					if pParse.cookieMask&(uint32(1)<<iDb) != uint32(0) {
						return 1
					} else {
						return 0
					}
				}() == 0 {
					continue
				}
				sqlite3VdbeUsesBtree(v, iDb)
				pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
				sqlite3VdbeAddOp4Int(v, 2, iDb, func() int32 {
					if pParse.writeMask&(uint32(1)<<iDb) != uint32(0) {
						return 1
					} else {
						return 0
					}
				}(), pSchema.schema_cookie, pSchema.iGeneration)
				if int32(db.init.busy) == 0 {
					sqlite3VdbeChangeP5(v, uint16(1))
				}
			}
			for i = int32(0); i < pParse.nVtabLock; i++ {
				var vtab *int8 = (*int8)(unsafe.Pointer(sqlite3GetVTable(db, *(**struct_Table)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.apVtabLock)) + uintptr(i)*8)))))
				sqlite3VdbeAddOp4(v, 169, 0, 0, 0, vtab, -12)
			}
			pParse.nVtabLock = int32(0)
			codeTableLocks(pParse)
			sqlite3AutoincrementBegin(pParse)
			if pParse.pConstExpr != nil {
				var pEL *struct_ExprList = pParse.pConstExpr
				pParse.okConstFactor = uint8(0)
				for i = int32(0); i < pEL.nExpr; i++ {
					var iReg int32 = *(*int32)(unsafe.Pointer(&(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEL.a)))) + uintptr(i)*28))).u))
					if iReg > 0 {
						sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEL.a)))) + uintptr(i)*28))).pExpr, iReg)
					}
				}
			}
			if pParse.bReturning != 0 {
				var pRet *struct_Returning = pParse.u1.pReturning
				if pRet.nRetCol == 0 {
					func() int {
						_ = 0
						return 0
					}()
				} else {
					sqlite3VdbeAddOp2(v, 116, pRet.iRetCur, pRet.nRetCol)
				}
			}
			sqlite3VdbeGoto(v, 1)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr == 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeMakeReady(v, pParse)
		pParse.rc = int32(101)
	} else {
		pParse.rc = int32(1)
	}
}
func sqlite3NestedParse(pParse *struct_Parse, zFormat *int8, __cgo_args ...interface {
}) {
	var zSql *int8
	var db *struct_sqlite3 = pParse.db
	var savedDbFlags uint32 = db.mDbFlags
	var saveBuf [136]int8
	if pParse.nErr != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	zSql = sqlite3VMPrintf(db, zFormat, __cgo_args...)
	if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		if !(db.mallocFailed != 0) {
			pParse.rc = int32(18)
		}
		pParse.nErr++
		return
	}
	pParse.nested++
	__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&saveBuf))), unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), 392-264, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&saveBuf))), 0))
	__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), 0, 392-264, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), 0))
	db.mDbFlags |= uint32(2)
	sqlite3RunParser(pParse, zSql)
	sqlite3DbFree(db, unsafe.Pointer(pParse.zErrMsg))
	pParse.zErrMsg = (*int8)(nil)
	db.mDbFlags = savedDbFlags
	sqlite3DbFree(db, unsafe.Pointer(zSql))
	__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), unsafe.Pointer((*int8)(unsafe.Pointer(&saveBuf))), 392-264, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), 0))
	pParse.nested--
}
func sqlite3FindTable(db *struct_sqlite3, zName *int8, zDatabase *int8) *struct_Table {
	var p *struct_Table = nil
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	if zDatabase != nil {
		for i = int32(0); i < db.nDb; i++ {
			if sqlite3StrICmp(zDatabase, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).zDbSName) == 0 {
				break
			}
		}
		if i >= db.nDb {
			if sqlite3StrICmp(zDatabase, (*int8)(unsafe.Pointer(&[5]int8{'m', 'a', 'i', 'n', '\x00'}))) == 0 {
				i = int32(0)
			} else {
				return (*struct_Table)(nil)
			}
		}
		p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.tblHash, zName))
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) && sqlite3_strnicmp(zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) == 0 {
			if i == 1 {
				if sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})))) + uintptr(7)))) == 0 || sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})))) + uintptr(7)))) == 0 || sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'})))) + uintptr(7)))) == 0 {
					p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.tblHash, (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))))
				}
			} else if sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})))) + uintptr(7)))) == 0 {
				p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.tblHash, (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))))
			}
		}
	} else {
		p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.tblHash, zName))
		if p != nil {
			return p
		}
		p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.tblHash, zName))
		if p != nil {
			return p
		}
		for i = int32(2); i < db.nDb; i++ {
			func() int {
				_ = 0
				return 0
			}()
			p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.tblHash, zName))
			if p != nil {
				break
			}
		}
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) && sqlite3_strnicmp(zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) == 0 {
			if sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})))) + uintptr(7)))) == 0 {
				p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.tblHash, (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))))
			} else if sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})))) + uintptr(7)))) == 0 {
				p = (*struct_Table)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.tblHash, (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))))
			}
		}
	}
	return p
}
func sqlite3LocateTable(pParse *struct_Parse, flags uint32, zName *int8, zDbase *int8) *struct_Table {
	var p *struct_Table
	var db *struct_sqlite3 = pParse.db
	if db.mDbFlags&uint32(16) == uint32(0) && 0 != sqlite3ReadSchema(pParse) {
		return (*struct_Table)(nil)
	}
	p = sqlite3FindTable(db, zName, zDbase)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		if int32(pParse.disableVtab) == 0 && int32(db.init.busy) == 0 {
			var pMod *struct_Module = (*struct_Module)(sqlite3HashFind(&db.aModule, zName))
			if uintptr(unsafe.Pointer(pMod)) == uintptr(unsafe.Pointer(nil)) && sqlite3_strnicmp(zName, (*int8)(unsafe.Pointer(&[8]int8{'p', 'r', 'a', 'g', 'm', 'a', '_', '\x00'})), 7) == 0 {
				pMod = sqlite3PragmaVtabRegister(db, zName)
			}
			if pMod != nil && sqlite3VtabEponymousTableInit(pParse, pMod) != 0 {
				return pMod.pEpoTab
			}
		}
		if flags&uint32(2) != 0 {
			return (*struct_Table)(nil)
		}
		pParse.checkSchema = uint8(1)
	} else if int32(p.eTabType) == 1 && int32(pParse.disableVtab) != 0 {
		p = (*struct_Table)(nil)
	}
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		var zMsg *int8 = func() *int8 {
			if flags&uint32(1) != 0 {
				return (*int8)(unsafe.Pointer(&[13]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'v', 'i', 'e', 'w', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 't', 'a', 'b', 'l', 'e', '\x00'}))
			}
		}()
		if zDbase != nil {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[10]int8{'%', 's', ':', ' ', '%', 's', '.', '%', 's', '\x00'})), zMsg, zDbase, zName)
		} else {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[7]int8{'%', 's', ':', ' ', '%', 's', '\x00'})), zMsg, zName)
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
	}
	return p
}
func sqlite3LocateTableItem(pParse *struct_Parse, flags uint32, p *struct_SrcItem) *struct_Table {
	var zDb *int8
	func() int {
		_ = 0
		return 0
	}()
	if p.pSchema != nil {
		var iDb int32 = sqlite3SchemaToIndex(pParse.db, p.pSchema)
		zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(iDb)*32))).zDbSName
	} else {
		zDb = p.zDatabase
	}
	return sqlite3LocateTable(pParse, flags, p.zName, zDb)
}
func sqlite3PreferredTableName(zName *int8) *int8 {
	if sqlite3_strnicmp(zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) == 0 {
		if sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'})))) + uintptr(7)))) == 0 {
			return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'}))
		}
		if sqlite3StrICmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(7))), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'})))) + uintptr(7)))) == 0 {
			return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'}))
		}
	}
	return zName
}
func sqlite3FindIndex(db *struct_sqlite3, zName *int8, zDb *int8) *struct_Index {
	var p *struct_Index = nil
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nDb; i++ {
		var j int32 = func() int32 {
			if i < 2 {
				return i ^ 1
			} else {
				return i
			}
		}()
		var pSchema *struct_Schema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(j)*32))).pSchema
		func() int {
			_ = 0
			return 0
		}()
		if zDb != nil && sqlite3DbIsNamed(db, j, zDb) == 0 {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		p = (*struct_Index)(sqlite3HashFind(&pSchema.idxHash, zName))
		if p != nil {
			break
		}
	}
	return p
}
func sqlite3FreeIndex(db *struct_sqlite3, p *struct_Index) {
	sqlite3DeleteIndexSamples(db, p)
	sqlite3ExprDelete(db, p.pPartIdxWhere)
	sqlite3ExprListDelete(db, p.aColExpr)
	sqlite3DbFree(db, unsafe.Pointer(p.zColAff))
	if p.Xbf_0>>4&1 != 0 {
		sqlite3DbFree(db, unsafe.Pointer(p.azColl))
	}
	sqlite3DbFree(db, unsafe.Pointer(p))
}
func sqlite3UnlinkAndDeleteIndex(db *struct_sqlite3, iDb int32, zIdxName *int8) {
	var pIndex *struct_Index
	var pHash *struct_Hash
	func() int {
		_ = 0
		return 0
	}()
	pHash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.idxHash
	pIndex = (*struct_Index)(sqlite3HashInsert(pHash, zIdxName, nil))
	if pIndex != nil {
		if uintptr(unsafe.Pointer(pIndex.pTable.pIndex)) == uintptr(unsafe.Pointer(pIndex)) {
			pIndex.pTable.pIndex = pIndex.pNext
		} else {
			var p *struct_Index
			p = pIndex.pTable.pIndex
			for p != nil && uintptr(unsafe.Pointer(p.pNext)) != uintptr(unsafe.Pointer(pIndex)) {
				p = p.pNext
			}
			if p != nil && uintptr(unsafe.Pointer(p.pNext)) == uintptr(unsafe.Pointer(pIndex)) {
				p.pNext = pIndex.pNext
			}
		}
		sqlite3FreeIndex(db, pIndex)
	}
	db.mDbFlags |= uint32(1)
}
func sqlite3CollapseDatabaseArray(db *struct_sqlite3) {
	var i int32
	var j int32
	for i = func() (_cgo_ret int32) {
		_cgo_addr := &j
		*_cgo_addr = int32(2)
		return *_cgo_addr
	}(); i < db.nDb; i++ {
		var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))
		if uintptr(unsafe.Pointer(pDb.pBt)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3DbFree(db, unsafe.Pointer(pDb.zDbSName))
			pDb.zDbSName = (*int8)(nil)
			continue
		}
		if j < i {
			*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(j)*32)) = *(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))
		}
		j++
	}
	db.nDb = j
	if db.nDb <= 2 && uintptr(unsafe.Pointer(db.aDb)) != uintptr(unsafe.Pointer((*struct_Db)(unsafe.Pointer(&db.aDbStatic)))) {
		__builtin___memcpy_chk(unsafe.Pointer((*struct_Db)(unsafe.Pointer(&db.aDbStatic))), unsafe.Pointer(db.aDb), uint(2)*32, __builtin_object_size(unsafe.Pointer((*struct_Db)(unsafe.Pointer(&db.aDbStatic))), 0))
		sqlite3DbFree(db, unsafe.Pointer(db.aDb))
		db.aDb = (*struct_Db)(unsafe.Pointer(&db.aDbStatic))
	}
}
func sqlite3ResetOneSchema(db *struct_sqlite3, iDb int32) {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	if iDb >= 0 {
		func() int {
			_ = 0
			return 0
		}()
		(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.schemaFlags |= uint16(8)
		(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.schemaFlags |= uint16(8)
		db.mDbFlags &= uint32(4294967279)
	}
	if db.nSchemaLock == uint32(0) {
		for i = int32(0); i < db.nDb; i++ {
			if int32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.schemaFlags)&8 == 8 {
				sqlite3SchemaClear(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema))
			}
		}
	}
}
func sqlite3ResetAllSchemasOfConnection(db *struct_sqlite3) {
	var i int32
	sqlite3BtreeEnterAll(db)
	for i = int32(0); i < db.nDb; i++ {
		var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))
		if pDb.pSchema != nil {
			if db.nSchemaLock == uint32(0) {
				sqlite3SchemaClear(unsafe.Pointer(pDb.pSchema))
			} else {
				(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.schemaFlags |= uint16(8)
			}
		}
	}
	db.mDbFlags &= uint32(4294967278)
	sqlite3VtabUnlockList(db)
	sqlite3BtreeLeaveAll(db)
	if db.nSchemaLock == uint32(0) {
		sqlite3CollapseDatabaseArray(db)
	}
}
func sqlite3CommitInternalChanges(db *struct_sqlite3) {
	db.mDbFlags &= uint32(4294967294)
}
func sqlite3ColumnSetExpr(pParse *struct_Parse, pTab *struct_Table, pCol *struct_Column, pExpr *struct_Expr) {
	var pList *struct_ExprList
	func() int {
		_ = 0
		return 0
	}()
	pList = pTab.u.tab.pDfltList
	if int32(pCol.iDflt) == 0 || uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) || pList.nExpr < int32(pCol.iDflt) {
		pCol.iDflt = uint16(func() int32 {
			if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return pList.nExpr + 1
			}
		}())
		pTab.u.tab.pDfltList = sqlite3ExprListAppend(pParse, pList, pExpr)
	} else {
		sqlite3ExprDelete(pParse.db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(int32(pCol.iDflt)-1)*28))).pExpr)
		(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(int32(pCol.iDflt)-1)*28))).pExpr = pExpr
	}
}
func sqlite3ColumnExpr(pTab *struct_Table, pCol *struct_Column) *struct_Expr {
	if int32(pCol.iDflt) == 0 {
		return (*struct_Expr)(nil)
	}
	if !(int32(pTab.eTabType) == 0) {
		return (*struct_Expr)(nil)
	}
	if uintptr(unsafe.Pointer(pTab.u.tab.pDfltList)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_Expr)(nil)
	}
	if pTab.u.tab.pDfltList.nExpr < int32(pCol.iDflt) {
		return (*struct_Expr)(nil)
	}
	return (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pTab.u.tab.pDfltList.a)))) + uintptr(int32(pCol.iDflt)-1)*28))).pExpr
}
func sqlite3ColumnSetColl(db *struct_sqlite3, pCol *struct_Column, zColl *int8) {
	var nColl int64
	var n int64
	var zNew *int8
	func() int {
		_ = 0
		return 0
	}()
	n = int64(sqlite3Strlen30(pCol.zCnName) + 1)
	if int32(pCol.colFlags)&4 != 0 {
		n += int64(sqlite3Strlen30((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.zCnName))+uintptr(n)))) + 1)
	}
	nColl = int64(sqlite3Strlen30(zColl) + 1)
	zNew = (*int8)(sqlite3DbRealloc(db, unsafe.Pointer(pCol.zCnName), uint64(nColl+n)))
	if zNew != nil {
		pCol.zCnName = zNew
		__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.zCnName))+uintptr(n)))), unsafe.Pointer(zColl), uint(nColl), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.zCnName))+uintptr(n)))), 0))
		pCol.colFlags |= uint16(512)
	}
}
func sqlite3ColumnColl(pCol *struct_Column) *int8 {
	var z *int8
	if int32(pCol.colFlags)&512 == 0 {
		return (*int8)(nil)
	}
	z = pCol.zCnName
	for *z != 0 {
		*(*uintptr)(unsafe.Pointer(&z))++
	}
	if int32(pCol.colFlags)&4 != 0 {
		for {
			*(*uintptr)(unsafe.Pointer(&z))++
			if !(*z != 0) {
				break
			}
		}
	}
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))
}
func sqlite3DeleteColumnNames(db *struct_sqlite3, pTable *struct_Table) {
	var i int32
	var pCol *struct_Column
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Column) {
		_cgo_addr := &pCol
		*_cgo_addr = pTable.aCol
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		for i = int32(0); i < int32(pTable.nCol); func() *struct_Column {
			i++
			return func() (_cgo_ret *struct_Column) {
				_cgo_addr := &pCol
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
				return
			}()
		}() {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3DbFree(db, unsafe.Pointer(pCol.zCnName))
		}
		sqlite3DbFree(db, unsafe.Pointer(pTable.aCol))
		if int32(pTable.eTabType) == 0 {
			sqlite3ExprListDelete(db, pTable.u.tab.pDfltList)
		}
		if uintptr(unsafe.Pointer(db)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil)) {
			pTable.aCol = (*struct_Column)(nil)
			pTable.nCol = int16(0)
			if int32(pTable.eTabType) == 0 {
				pTable.u.tab.pDfltList = (*struct_ExprList)(nil)
			}
		}
	}
}
func deleteTable(db *struct_sqlite3, pTable *struct_Table) {
	var pIndex *struct_Index
	var pNext *struct_Index
	for pIndex = pTable.pIndex; pIndex != nil; pIndex = pNext {
		pNext = pIndex.pNext
		func() int {
			_ = 0
			return 0
		}()
		if (uintptr(unsafe.Pointer(db)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil))) && !(int32(pTable.eTabType) == 1) {
			var zName *int8 = pIndex.zName
			sqlite3HashInsert(&pIndex.pSchema.idxHash, zName, nil)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
		}
		sqlite3FreeIndex(db, pIndex)
	}
	if int32(pTable.eTabType) == 0 {
		sqlite3FkDelete(db, pTable)
	} else if int32(pTable.eTabType) == 1 {
		sqlite3VtabClear(db, pTable)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3SelectDelete(db, (*(*_cgoa_12)(unsafe.Pointer(&pTable.u))).pSelect)
	}
	sqlite3DeleteColumnNames(db, pTable)
	sqlite3DbFree(db, unsafe.Pointer(pTable.zName))
	sqlite3DbFree(db, unsafe.Pointer(pTable.zColAff))
	sqlite3ExprListDelete(db, pTable.pCheck)
	sqlite3DbFree(db, unsafe.Pointer(pTable))
	func() int {
		_ = 0
		return 0
	}()
}
func sqlite3DeleteTable(db *struct_sqlite3, pTable *struct_Table) {
	if !(pTable != nil) {
		return
	}
	if (!(db != nil) || uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil))) && func() (_cgo_ret uint32) {
		_cgo_addr := &pTable.nTabRef
		*_cgo_addr--
		return *_cgo_addr
	}() > uint32(0) {
		return
	}
	deleteTable(db, pTable)
}
func sqlite3UnlinkAndDeleteTable(db *struct_sqlite3, iDb int32, zTabName *int8) {
	var p *struct_Table
	var pDb *struct_Db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	p = (*struct_Table)(sqlite3HashInsert(&pDb.pSchema.tblHash, zTabName, nil))
	sqlite3DeleteTable(db, p)
	db.mDbFlags |= uint32(1)
}
func sqlite3NameFromToken(db *struct_sqlite3, pName *struct_Token) *int8 {
	var zName *int8
	if pName != nil {
		zName = sqlite3DbStrNDup(db, (*int8)(unsafe.Pointer(pName.z)), uint64(pName.n))
		sqlite3Dequote(zName)
	} else {
		zName = (*int8)(nil)
	}
	return zName
}
func sqlite3OpenSchemaTable(p *struct_Parse, iDb int32) {
	var v *struct_Vdbe = sqlite3GetVdbe(p)
	sqlite3TableLock(p, iDb, uint32(1), uint8(1), (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'})))
	sqlite3VdbeAddOp4Int(v, 112, 0, 1, iDb, 5)
	if p.nTab == 0 {
		p.nTab = int32(1)
	}
}
func sqlite3FindDbName(db *struct_sqlite3, zName *int8) int32 {
	var i int32 = -1
	if zName != nil {
		var pDb *struct_Db
		for func() *struct_Db {
			i = db.nDb - 1
			return func() (_cgo_ret *struct_Db) {
				_cgo_addr := &pDb
				*_cgo_addr = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))
				return *_cgo_addr
			}()
		}(); i >= 0; func() *struct_Db {
			i--
			return func() (_cgo_ret *struct_Db) {
				_cgo_addr := &pDb
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) -= 32
				return
			}()
		}() {
			if 0 == sqlite3_stricmp(pDb.zDbSName, zName) {
				break
			}
			if i == 0 && 0 == sqlite3_stricmp((*int8)(unsafe.Pointer(&[5]int8{'m', 'a', 'i', 'n', '\x00'})), zName) {
				break
			}
		}
	}
	return i
}
func sqlite3FindDb(db *struct_sqlite3, pName *struct_Token) int32 {
	var i int32
	var zName *int8
	zName = sqlite3NameFromToken(db, pName)
	i = sqlite3FindDbName(db, zName)
	sqlite3DbFree(db, unsafe.Pointer(zName))
	return i
}
func sqlite3TwoPartName(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token, pUnqual **struct_Token) int32 {
	var iDb int32
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pName2.n > uint32(0) {
		if db.init.busy != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[17]int8{'c', 'o', 'r', 'r', 'u', 'p', 't', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})))
			return int32(-1)
		}
		*pUnqual = pName2
		iDb = sqlite3FindDb(db, pName1)
		if iDb < 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[20]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 'T', '\x00'})), pName1)
			return int32(-1)
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		iDb = int32(db.init.iDb)
		*pUnqual = pName1
	}
	return iDb
}
func sqlite3WritableSchema(db *struct_sqlite3) int32 {
	return func() int32 {
		if db.flags&uint64(1|268435456) == uint64(1) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3CheckObjectName(pParse *struct_Parse, zName *int8, zType *int8, zTblName *int8) int32 {
	var db *struct_sqlite3 = pParse.db
	if sqlite3WritableSchema(db) != 0 || int32(db.init.Xbf_0>>1&1) != 0 || !(sqlite3Config.bExtraSchemaChecks != 0) {
		return int32(0)
	}
	if db.init.busy != 0 {
		if sqlite3_stricmp(zType, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(db.init.azInit)) + uintptr(0)*8))) != 0 || sqlite3_stricmp(zName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(db.init.azInit)) + uintptr(1)*8))) != 0 || sqlite3_stricmp(zTblName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(db.init.azInit)) + uintptr(2)*8))) != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})))
			return int32(1)
		}
	} else if int32(pParse.nested) == 0 && 0 == sqlite3_strnicmp(zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) || sqlite3ReadOnlyShadowTables(db) != 0 && sqlite3ShadowTableName(db, zName) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[42]int8{'o', 'b', 'j', 'e', 'c', 't', ' ', 'n', 'a', 'm', 'e', ' ', 'r', 'e', 's', 'e', 'r', 'v', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'i', 'n', 't', 'e', 'r', 'n', 'a', 'l', ' ', 'u', 's', 'e', ':', ' ', '%', 's', '\x00'})), zName)
		return int32(1)
	}
	return int32(0)
}
func sqlite3PrimaryKeyIndex(pTab *struct_Table) *struct_Index {
	var p *struct_Index
	for p = pTab.pIndex; p != nil && !(int32(p.Xbf_0&3) == 2); p = p.pNext {
	}
	return p
}
func sqlite3TableColumnToIndex(pIdx *struct_Index, iCol int16) int16 {
	var i int32
	for i = int32(0); i < int32(pIdx.nColumn); i++ {
		if int32(iCol) == int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))) {
			return int16(i)
		}
	}
	return int16(-1)
}
func sqlite3StorageColumnToTable(pTab *struct_Table, iCol int16) int16 {
	if pTab.tabFlags&uint32(32) != 0 {
		var i int32
		for i = int32(0); i <= int32(iCol); i++ {
			if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 != 0 {
				iCol++
			}
		}
	}
	return iCol
}
func sqlite3TableColumnToStorage(pTab *struct_Table, iCol int16) int16 {
	var i int32
	var n int16
	func() int {
		_ = 0
		return 0
	}()
	if pTab.tabFlags&uint32(32) == uint32(0) || int32(iCol) < 0 {
		return iCol
	}
	for func() int16 {
		i = int32(0)
		return func() (_cgo_ret int16) {
			_cgo_addr := &n
			*_cgo_addr = int16(0)
			return *_cgo_addr
		}()
	}(); i < int32(iCol); i++ {
		if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 == 0 {
			n++
		}
	}
	if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 != 0 {
		return int16(int32(pTab.nNVCol) + i - int32(n))
	} else {
		return n
	}
}
func sqlite3ForceNotReadOnly(pParse *struct_Parse) {
	var iReg int32 = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	if v != nil {
		sqlite3VdbeAddOp3(v, 7, 0, iReg, -1)
		sqlite3VdbeUsesBtree(v, 0)
	}
}
func sqlite3StartTable(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token, isTemp int32, isView int32, isVirtual int32, noErr int32) {
	var pTable *struct_Table
	var zName *int8 = nil
	var db *struct_sqlite3 = pParse.db
	var v *struct_Vdbe
	var iDb int32
	var pName *struct_Token
	if int32(db.init.busy) != 0 && db.init.newTnum == uint32(1) {
		iDb = int32(db.init.iDb)
		zName = sqlite3DbStrDup(db, func() *int8 {
			if true && iDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}())
		pName = pName1
	} else {
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName)
		if iDb < 0 {
			return
		}
		if true && isTemp != 0 && pName2.n > uint32(0) && iDb != 1 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[41]int8{'t', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'n', 'a', 'm', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'u', 'n', 'q', 'u', 'a', 'l', 'i', 'f', 'i', 'e', 'd', '\x00'})))
			return
		}
		if true && isTemp != 0 {
			iDb = int32(1)
		}
		zName = sqlite3NameFromToken(db, pName)
		if int32(pParse.eParseMode) >= 2 {
			sqlite3RenameTokenMap(pParse, unsafe.Pointer(zName), pName)
		}
	}
	pParse.sNameToken = *pName
	if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if sqlite3CheckObjectName(pParse, zName, func() *int8 {
		if isView != 0 {
			return (*int8)(unsafe.Pointer(&[5]int8{'v', 'i', 'e', 'w', '\x00'}))
		} else {
			return (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'}))
		}
	}(), zName) != 0 {
		goto begin_table_error
	}
	if int32(db.init.iDb) == 1 {
		isTemp = int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	{
		var aCode [4]uint8 = [4]uint8{uint8(2), uint8(4), uint8(8), uint8(6)}
		var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
		if sqlite3AuthCheck(pParse, 18, func() *int8 {
			if true && isTemp == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}(), nil, zDb) != 0 {
			goto begin_table_error
		}
		if !(isVirtual != 0) && sqlite3AuthCheck(pParse, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCode)))) + uintptr(isTemp+2*isView)))), zName, nil, zDb) != 0 {
			goto begin_table_error
		}
	}
	if !(int32(pParse.eParseMode) != 0) {
		var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
		if 0 != sqlite3ReadSchema(pParse) {
			goto begin_table_error
		}
		pTable = sqlite3FindTable(db, zName, zDb)
		if pTable != nil {
			if !(noErr != 0) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[21]int8{'%', 's', ' ', '%', 'T', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'e', 'x', 'i', 's', 't', 's', '\x00'})), func() *int8 {
					if int32(pTable.eTabType) == 2 {
						return (*int8)(unsafe.Pointer(&[5]int8{'v', 'i', 'e', 'w', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'}))
					}
				}(), pName)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3CodeVerifySchema(pParse, iDb)
				sqlite3ForceNotReadOnly(pParse)
			}
			goto begin_table_error
		}
		if uintptr(unsafe.Pointer(sqlite3FindIndex(db, zName, zDb))) != uintptr(unsafe.Pointer(nil)) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[35]int8{'t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'a', 'n', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'n', 'a', 'm', 'e', 'd', ' ', '%', 's', '\x00'})), zName)
			goto begin_table_error
		}
	}
	pTable = (*struct_Table)(sqlite3DbMallocZero(db, uint64(104)))
	if uintptr(unsafe.Pointer(pTable)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		pParse.rc = int32(7)
		pParse.nErr++
		goto begin_table_error
	}
	pTable.zName = zName
	pTable.iPKey = int16(-1)
	pTable.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	pTable.nTabRef = uint32(1)
	pTable.nRowLogEst = int16(200)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pParse.pNewTable = pTable
	if !(db.init.busy != 0) && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Vdbe) {
		_cgo_addr := &v
		*_cgo_addr = sqlite3GetVdbe(pParse)
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		var addr1 int32
		var fileFormat int32
		var reg1 int32
		var reg2 int32
		var reg3 int32
		var nullRow [6]int8 = [6]int8{int8(6), int8(0), int8(0), int8(0), int8(0), int8(0)}
		sqlite3BeginWriteOperation(pParse, 1, iDb)
		if isVirtual != 0 {
			sqlite3VdbeAddOp0(v, 169)
		}
		reg1 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.regRowid
			*_cgo_addr = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			return *_cgo_addr
		}()
		reg2 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.regRoot
			*_cgo_addr = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			return *_cgo_addr
		}()
		reg3 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp3(v, 98, iDb, reg3, 2)
		sqlite3VdbeUsesBtree(v, iDb)
		addr1 = sqlite3VdbeAddOp1(v, 18, reg3)
		fileFormat = func() int32 {
			if db.flags&uint64(2) != uint64(0) {
				return 1
			} else {
				return 4
			}
		}()
		sqlite3VdbeAddOp3(v, 99, iDb, 2, fileFormat)
		sqlite3VdbeAddOp3(v, 99, iDb, 5, int32(db.enc))
		sqlite3VdbeJumpHere(v, addr1)
		if isView != 0 || isVirtual != 0 {
			sqlite3VdbeAddOp2(v, 71, 0, reg2)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			*(*int32)(unsafe.Pointer(&pParse.u1)) = sqlite3VdbeAddOp3(v, 146, iDb, reg2, 1)
		}
		sqlite3OpenSchemaTable(pParse, iDb)
		sqlite3VdbeAddOp2(v, 126, 0, reg1)
		sqlite3VdbeAddOp4(v, 76, 6, reg3, 0, (*int8)(unsafe.Pointer(&nullRow)), -1)
		sqlite3VdbeAddOp3(v, 127, 0, reg3, reg1)
		sqlite3VdbeChangeP5(v, uint16(8))
		sqlite3VdbeAddOp0(v, 121)
	}
	return
begin_table_error:
	pParse.checkSchema = uint8(1)
	sqlite3DbFree(db, unsafe.Pointer(zName))
	return
}
func sqlite3DeleteReturning(db *struct_sqlite3, pRet *struct_Returning) {
	var pHash *struct_Hash
	pHash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.trigHash
	sqlite3HashInsert(pHash, (*int8)(unsafe.Pointer(&[17]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 't', 'u', 'r', 'n', 'i', 'n', 'g', '\x00'})), nil)
	sqlite3ExprListDelete(db, pRet.pReturnEL)
	sqlite3DbFree(db, unsafe.Pointer(pRet))
}
func sqlite3AddReturning(pParse *struct_Parse, pList *struct_ExprList) {
	var pRet *struct_Returning
	var pHash *struct_Hash
	var db *struct_sqlite3 = pParse.db
	if pParse.pNewTrigger != nil {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'u', 's', 'e', ' ', 'R', 'E', 'T', 'U', 'R', 'N', 'I', 'N', 'G', ' ', 'i', 'n', ' ', 'a', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\x00'})))
	} else {
		func() int {
			_ = 0
			return 0
		}()
	}
	pParse.bReturning = uint8(1)
	pRet = (*struct_Returning)(sqlite3DbMallocZero(db, uint64(196)))
	if uintptr(unsafe.Pointer(pRet)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ExprListDelete(db, pList)
		return
	}
	pParse.u1.pReturning = pRet
	pRet.pParse = pParse
	pRet.pReturnEL = pList
	sqlite3ParserAddCleanup(pParse, (func(*struct_sqlite3, unsafe.Pointer))(sqlite3DeleteReturning), unsafe.Pointer(pRet))
	if db.mallocFailed != 0 {
		return
	}
	pRet.retTrig.zName = (*int8)(unsafe.Pointer(&[17]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 't', 'u', 'r', 'n', 'i', 'n', 'g', '\x00'}))
	pRet.retTrig.op = uint8(150)
	pRet.retTrig.tr_tm = uint8(2)
	pRet.retTrig.bReturning = uint8(1)
	pRet.retTrig.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema
	pRet.retTrig.pTabSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema
	pRet.retTrig.step_list = &pRet.retTStep
	pRet.retTStep.op = uint8(150)
	pRet.retTStep.pTrig = &pRet.retTrig
	pRet.retTStep.pExprList = pList
	pHash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.trigHash
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(sqlite3HashInsert(pHash, (*int8)(unsafe.Pointer(&[17]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'r', 'e', 't', 'u', 'r', 'n', 'i', 'n', 'g', '\x00'})), unsafe.Pointer(&pRet.retTrig)))) == uintptr(unsafe.Pointer(unsafe.Pointer(&pRet.retTrig))) {
		sqlite3OomFault(db)
	}
}
func sqlite3AddColumn(pParse *struct_Parse, sName struct_Token, sType struct_Token) {
	var p *struct_Table
	var i int32
	var z *int8
	var zType *int8
	var pCol *struct_Column
	var db *struct_sqlite3 = pParse.db
	var hName uint8
	var aNew *struct_Column
	var eType uint8 = uint8(0)
	var szEst uint8 = uint8(1)
	var affinity int8 = int8(65)
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
		_cgo_addr := &p
		*_cgo_addr = pParse.pNewTable
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if int32(p.nCol)+1 > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(2)*4)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[23]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'o', 'n', ' ', '%', 's', '\x00'})), p.zName)
		return
	}
	if !(int32(pParse.eParseMode) >= 2) {
		sqlite3DequoteToken(&sName)
	}
	if sType.n >= uint32(16) && sqlite3_strnicmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(sType.z))+uintptr(sType.n-uint32(6)))), (*int8)(unsafe.Pointer(&[7]int8{'a', 'l', 'w', 'a', 'y', 's', '\x00'})), 6) == 0 {
		sType.n -= uint32(6)
		for sType.n > uint32(0) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(sType.z)) + uintptr(sType.n-uint32(1)))))))))&1 != 0 {
			sType.n--
		}
		if sType.n >= uint32(9) && sqlite3_strnicmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(sType.z))+uintptr(sType.n-uint32(9)))), (*int8)(unsafe.Pointer(&[10]int8{'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', '\x00'})), 9) == 0 {
			sType.n -= uint32(9)
			for sType.n > uint32(0) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(sType.z)) + uintptr(sType.n-uint32(1)))))))))&1 != 0 {
				sType.n--
			}
		}
	}
	if sType.n >= uint32(3) {
		sqlite3DequoteToken(&sType)
		for i = int32(0); i < 6; i++ {
			if sType.n == uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3StdTypeLen)))) + uintptr(i)))) && sqlite3_strnicmp(sType.z, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&sqlite3StdType)))) + uintptr(i)*8)), int32(sType.n)) == 0 {
				sType.n = uint32(0)
				eType = uint8(i + 1)
				affinity = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sqlite3StdTypeAffinity)))) + uintptr(i)))
				if int32(affinity) <= 66 {
					szEst = uint8(5)
				}
				break
			}
		}
	}
	z = (*int8)(sqlite3DbMallocRaw(db, uint64(int64(sName.n)+int64(1)+int64(sType.n)+func() int64 {
		if sType.n > uint32(0) {
			return 1
		} else {
			return 0
		}
	}())))
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if int32(pParse.eParseMode) >= 2 {
		sqlite3RenameTokenMap(pParse, unsafe.Pointer(z), &sName)
	}
	__builtin___memcpy_chk(unsafe.Pointer(z), unsafe.Pointer(sName.z), uint(sName.n), __builtin_object_size(unsafe.Pointer(z), 0))
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(sName.n))) = int8(0)
	sqlite3Dequote(z)
	hName = sqlite3StrIHash(z)
	for i = int32(0); i < int32(p.nCol); i++ {
		if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(i)*20))).hName) == int32(hName) && sqlite3StrICmp(z, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(i)*20))).zCnName) == 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[26]int8{'d', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'n', 'a', 'm', 'e', ':', ' ', '%', 's', '\x00'})), z)
			sqlite3DbFree(db, unsafe.Pointer(z))
			return
		}
	}
	aNew = (*struct_Column)(sqlite3DbRealloc(db, unsafe.Pointer(p.aCol), uint64(int64(p.nCol)+int64(1))*uint64(20)))
	if uintptr(unsafe.Pointer(aNew)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3DbFree(db, unsafe.Pointer(z))
		return
	}
	p.aCol = aNew
	pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(p.nCol)*20))
	__builtin___memset_chk(unsafe.Pointer(pCol), 0, 20, __builtin_object_size(unsafe.Pointer(pCol), 0))
	pCol.zCnName = z
	pCol.hName = hName
	if sType.n == uint32(0) {
		pCol.affinity = affinity
		{
			_autoGo_53 := &pCol.Xbf_0
			*_autoGo_53 = *_autoGo_53&^240 | uint32(eType)&15<<4
		}
		pCol.szEst = szEst
	} else {
		zType = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(sqlite3Strlen30(z)))))) + uintptr(1)))
		__builtin___memcpy_chk(unsafe.Pointer(zType), unsafe.Pointer(sType.z), uint(sType.n), __builtin_object_size(unsafe.Pointer(zType), 0))
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(sType.n))) = int8(0)
		sqlite3Dequote(zType)
		pCol.affinity = sqlite3AffinityType(zType, pCol)
		pCol.colFlags |= uint16(4)
	}
	p.nCol++
	p.nNVCol++
	pParse.constraintName.n = uint32(0)
}
func sqlite3AddNotNull(pParse *struct_Parse, onError int32) {
	var p *struct_Table
	var pCol *struct_Column
	p = pParse.pNewTable
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || int32(p.nCol) < 1 {
		return
	}
	pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(int32(p.nCol)-1)*20))
	{
		_autoGo_54 := &pCol.Xbf_0
		*_autoGo_54 = *_autoGo_54&^15 | uint32(uint8(onError))&15
	}
	p.tabFlags |= uint32(2048)
	if int32(pCol.colFlags)&8 != 0 {
		var pIdx *struct_Index
		for pIdx = p.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			func() int {
				_ = 0
				return 0
			}()
			if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(0)*2))) == int32(p.nCol)-1 {
				{
					_autoGo_55 := &pIdx.Xbf_0
					*_autoGo_55 = *_autoGo_55&^8 | uint32(1)&1<<3
				}
			}
		}
	}
}
func sqlite3AffinityType(zIn *int8, pCol *struct_Column) int8 {
	var h uint32 = uint32(0)
	var aff int8 = int8(67)
	var zChar *int8 = nil
	func() int {
		_ = 0
		return 0
	}()
	for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(0))) != 0 {
		h = h<<8 + uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(int32(*zIn)&255))))
		*(*uintptr)(unsafe.Pointer(&zIn))++
		if h == uint32('c'<<24+'h'<<16+'a'<<8+'r') {
			aff = int8(66)
			zChar = zIn
		} else if h == uint32('c'<<24+'l'<<16+'o'<<8+'b') {
			aff = int8(66)
		} else if h == uint32('t'<<24+'e'<<16+'x'<<8+'t') {
			aff = int8(66)
		} else if h == uint32('b'<<24+'l'<<16+'o'<<8+'b') && (int32(aff) == 67 || int32(aff) == 69) {
			aff = int8(65)
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(0)))) == '(' {
				zChar = zIn
			}
		} else if h == uint32('r'<<24+'e'<<16+'a'<<8+'l') && int32(aff) == 67 {
			aff = int8(69)
		} else if h == uint32('f'<<24+'l'<<16+'o'<<8+'a') && int32(aff) == 67 {
			aff = int8(69)
		} else if h == uint32('d'<<24+'o'<<16+'u'<<8+'b') && int32(aff) == 67 {
			aff = int8(69)
		} else if h&uint32(16777215) == uint32('i'<<16+'n'<<8+'t') {
			aff = int8(68)
			break
		}
	}
	if pCol != nil {
		var v int32 = 0
		if int32(aff) < 67 {
			if zChar != nil {
				for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zChar)) + uintptr(0))) != 0 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zChar)) + uintptr(0))))))))&4 != 0 {
						sqlite3GetInt32(zChar, &v)
						break
					}
					*(*uintptr)(unsafe.Pointer(&zChar))++
				}
			} else {
				v = int32(16)
			}
		}
		v = v/4 + 1
		if v > 255 {
			v = int32(255)
		}
		pCol.szEst = uint8(v)
	}
	return aff
}
func sqlite3AddDefaultValue(pParse *struct_Parse, pExpr *struct_Expr, zStart *int8, zEnd *int8) {
	var p *struct_Table
	var pCol *struct_Column
	var db *struct_sqlite3 = pParse.db
	p = pParse.pNewTable
	if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) {
		var isInit int32 = func() int32 {
			if int32(db.init.busy) != 0 && int32(db.init.iDb) != 1 {
				return 1
			} else {
				return 0
			}
		}()
		pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(int32(p.nCol)-1)*20))
		if !(sqlite3ExprIsConstantOrFunction(pExpr, uint8(isInit)) != 0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[45]int8{'d', 'e', 'f', 'a', 'u', 'l', 't', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'o', 'f', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '[', '%', 's', ']', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'c', 'o', 'n', 's', 't', 'a', 'n', 't', '\x00'})), pCol.zCnName)
		} else if int32(pCol.colFlags)&96 != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[41]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'u', 's', 'e', ' ', 'D', 'E', 'F', 'A', 'U', 'L', 'T', ' ', 'o', 'n', ' ', 'a', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})))
		} else {
			var x struct_Expr
			var pDfltExpr *struct_Expr
			__builtin___memset_chk(unsafe.Pointer(&x), 0, 72, __builtin_object_size(unsafe.Pointer(&x), 0))
			x.op = uint8(181)
			x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd)
			x.pLeft = pExpr
			x.flags = uint32(4096)
			pDfltExpr = sqlite3ExprDup(db, &x, 1)
			sqlite3DbFree(db, unsafe.Pointer(x.u.zToken))
			sqlite3ColumnSetExpr(pParse, p, pCol, pDfltExpr)
		}
	}
	if int32(pParse.eParseMode) >= 2 {
		sqlite3RenameExprUnmap(pParse, pExpr)
	}
	sqlite3ExprDelete(db, pExpr)
}
func sqlite3StringToId(p *struct_Expr) {
	if int32(p.op) == 117 {
		p.op = uint8(59)
	} else if int32(p.op) == 113 && int32(p.pLeft.op) == 117 {
		p.pLeft.op = uint8(59)
	}
}
func makeColumnPartOfPrimaryKey(pParse *struct_Parse, pCol *struct_Column) {
	pCol.colFlags |= uint16(1)
	if int32(pCol.colFlags)&96 != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[52]int8{'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'p', 'a', 'r', 't', ' ', 'o', 'f', ' ', 't', 'h', 'e', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', '\x00'})))
	}
}
func sqlite3AddPrimaryKey(pParse *struct_Parse, pList *struct_ExprList, onError int32, autoInc int32, sortOrder int32) {
	var pTab *struct_Table = pParse.pNewTable
	var pCol *struct_Column = nil
	var iCol int32 = -1
	var i int32
	var nTerm int32
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		goto primary_key_exit
	}
	if pTab.tabFlags&uint32(4) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[41]int8{'t', 'a', 'b', 'l', 'e', ' ', '"', '%', 's', '"', ' ', 'h', 'a', 's', ' ', 'm', 'o', 'r', 'e', ' ', 't', 'h', 'a', 'n', ' ', 'o', 'n', 'e', ' ', 'p', 'r', 'i', 'm', 'a', 'r', 'y', ' ', 'k', 'e', 'y', '\x00'})), pTab.zName)
		goto primary_key_exit
	}
	pTab.tabFlags |= uint32(4)
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		iCol = int32(pTab.nCol) - 1
		pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
		makeColumnPartOfPrimaryKey(pParse, pCol)
		nTerm = int32(1)
	} else {
		nTerm = pList.nExpr
		for i = int32(0); i < nTerm; i++ {
			var pCExpr *struct_Expr = sqlite3ExprSkipCollate((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr)
			func() int {
				_ = 0
				return 0
			}()
			sqlite3StringToId(pCExpr)
			if int32(pCExpr.op) == 59 {
				var zCName *int8
				func() int {
					_ = 0
					return 0
				}()
				zCName = pCExpr.u.zToken
				for iCol = int32(0); iCol < int32(pTab.nCol); iCol++ {
					if sqlite3StrICmp(zCName, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName) == 0 {
						pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
						makeColumnPartOfPrimaryKey(pParse, pCol)
						break
					}
				}
			}
		}
	}
	if nTerm == 1 && pCol != nil && int32(pCol.Xbf_0>>4&15) == 4 && sortOrder != 1 {
		if int32(pParse.eParseMode) >= 2 && pList != nil {
			var pCExpr *struct_Expr = sqlite3ExprSkipCollate((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr)
			sqlite3RenameTokenRemap(pParse, unsafe.Pointer(&pTab.iPKey), unsafe.Pointer(pCExpr))
		}
		pTab.iPKey = int16(iCol)
		pTab.keyConf = uint8(onError)
		func() int {
			_ = 0
			return 0
		}()
		pTab.tabFlags |= uint32(autoInc * 8)
		if pList != nil {
			pParse.iPkSortOrder = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).sortFlags
		}
		func() int {
			_ = sqlite3HasExplicitNulls(pParse, pList)
			return 0
		}()
	} else if autoInc != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[56]int8{'A', 'U', 'T', 'O', 'I', 'N', 'C', 'R', 'E', 'M', 'E', 'N', 'T', ' ', 'i', 's', ' ', 'o', 'n', 'l', 'y', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'a', 'n', ' ', 'I', 'N', 'T', 'E', 'G', 'E', 'R', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', '\x00'})))
	} else {
		sqlite3CreateIndex(pParse, nil, nil, nil, pList, onError, nil, nil, sortOrder, 0, uint8(2))
		pList = (*struct_ExprList)(nil)
	}
primary_key_exit:
	sqlite3ExprListDelete(pParse.db, pList)
	return
}
func sqlite3AddCheckConstraint(pParse *struct_Parse, pCheckExpr *struct_Expr, zStart *int8, zEnd *int8) {
	var pTab *struct_Table = pParse.pNewTable
	var db *struct_sqlite3 = pParse.db
	if pTab != nil && !(int32(pParse.eParseMode) == 1) && !(sqlite3BtreeIsReadonly((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(db.init.iDb)*32))).pBt) != 0) {
		pTab.pCheck = sqlite3ExprListAppend(pParse, pTab.pCheck, pCheckExpr)
		if pParse.constraintName.n != 0 {
			sqlite3ExprListSetName(pParse, pTab.pCheck, &pParse.constraintName, 1)
		} else {
			var t struct_Token
			for *(*uintptr)(unsafe.Pointer(&zStart))++; int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStart)) + uintptr(0))))))))&1 != 0; *(*uintptr)(unsafe.Pointer(&zStart))++ {
			}
			for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zEnd)) - uintptr(- -1))))))))&1 != 0 {
				*(*uintptr)(unsafe.Pointer(&zEnd))--
			}
			t.z = zStart
			t.n = uint32(int32(uintptr(unsafe.Pointer(zEnd)) - uintptr(unsafe.Pointer(t.z))))
			sqlite3ExprListSetName(pParse, pTab.pCheck, &t, 1)
		}
	} else {
		sqlite3ExprDelete(pParse.db, pCheckExpr)
	}
}
func sqlite3AddCollateType(pParse *struct_Parse, pToken *struct_Token) {
	var p *struct_Table
	var i int32
	var zColl *int8
	var db *struct_sqlite3
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
		_cgo_addr := &p
		*_cgo_addr = pParse.pNewTable
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) || int32(pParse.eParseMode) >= 2 {
		return
	}
	i = int32(p.nCol) - 1
	db = pParse.db
	zColl = sqlite3NameFromToken(db, pToken)
	if !(zColl != nil) {
		return
	}
	if sqlite3LocateCollSeq(pParse, zColl) != nil {
		var pIdx *struct_Index
		sqlite3ColumnSetColl(db, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(i)*20)), zColl)
		for pIdx = p.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			func() int {
				_ = 0
				return 0
			}()
			if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(0)*2))) == i {
				*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(0)*8)) = sqlite3ColumnColl(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(i)*20)))
			}
		}
	}
	sqlite3DbFree(db, unsafe.Pointer(zColl))
}
func sqlite3AddGenerated(pParse *struct_Parse, pExpr *struct_Expr, pType *struct_Token) {
	var eType uint8 = uint8(32)
	var pTab *struct_Table = pParse.pNewTable
	var pCol *struct_Column
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		goto generated_done
	}
	pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(int32(pTab.nCol)-1)*20))
	if int32(pParse.eParseMode) == 1 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[43]int8{'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', 's', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'u', 's', 'e', ' ', 'c', 'o', 'm', 'p', 'u', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', '\x00'})))
		goto generated_done
	}
	if int32(pCol.iDflt) > 0 {
		goto generated_error
	}
	if pType != nil {
		if pType.n == uint32(7) && sqlite3_strnicmp((*int8)(unsafe.Pointer(&[8]int8{'v', 'i', 'r', 't', 'u', 'a', 'l', '\x00'})), pType.z, 7) == 0 {
		} else if pType.n == uint32(6) && sqlite3_strnicmp((*int8)(unsafe.Pointer(&[7]int8{'s', 't', 'o', 'r', 'e', 'd', '\x00'})), pType.z, 6) == 0 {
			eType = uint8(64)
		} else {
			goto generated_error
		}
	}
	if int32(eType) == 32 {
		pTab.nNVCol--
	}
	pCol.colFlags |= uint16(int32(eType))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pTab.tabFlags |= uint32(eType)
	if int32(pCol.colFlags)&1 != 0 {
		makeColumnPartOfPrimaryKey(pParse, pCol)
	}
	sqlite3ColumnSetExpr(pParse, pTab, pCol, pExpr)
	pExpr = (*struct_Expr)(nil)
	goto generated_done
generated_error:
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[31]int8{'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '"', '%', 's', '"', '\x00'})), pCol.zCnName)
generated_done:
	sqlite3ExprDelete(pParse.db, pExpr)
}
func sqlite3ChangeCookie(pParse *struct_Parse, iDb int32) {
	var db *struct_sqlite3 = pParse.db
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeAddOp3(v, 99, iDb, 1, int32(uint32(1)+uint32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.schema_cookie)))
}
func identLength(z *int8) int32 {
	var n int32
	for n = int32(0); *z != 0; func() *int8 {
		n++
		return func() (_cgo_ret *int8) {
			_cgo_addr := &z
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr))++
			return
		}()
	}() {
		if int32(*z) == '"' {
			n++
		}
	}
	return n + 2
}
func identPut(z *int8, pIdx *int32, zSignedIdent *int8) {
	var zIdent *uint8 = (*uint8)(unsafe.Pointer(zSignedIdent))
	var i int32
	var j int32
	var needQuote int32
	i = *pIdx
	for j = int32(0); *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j))) != 0; j++ {
		if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j))))))))&6 != 0) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j)))) != '_' {
			break
		}
	}
	needQuote = func() int32 {
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(0))))))))&4 != 0 || sqlite3KeywordCode(zIdent, j) != 59 || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j)))) != 0 || j == 0 {
			return 1
		} else {
			return 0
		}
	}()
	if needQuote != 0 {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('"')
	}
	for j = int32(0); *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j))) != 0; j++ {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j))))
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIdent)) + uintptr(j)))) == '"' {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &i
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = int8('"')
		}
	}
	if needQuote != 0 {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('"')
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))) = int8(0)
	*pIdx = i
}
func createTableStmt(db *struct_sqlite3, p *struct_Table) *int8 {
	var i int32
	var k int32
	var n int32
	var zStmt *int8
	var zSep *int8
	var zSep2 *int8
	var zEnd *int8
	var pCol *struct_Column
	n = int32(0)
	for func() int32 {
		pCol = p.aCol
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); i < int32(p.nCol); func() *struct_Column {
		i++
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
			return
		}()
	}() {
		n += identLength(pCol.zCnName) + 5
	}
	n += identLength(p.zName)
	if n < 50 {
		zSep = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
		zSep2 = (*int8)(unsafe.Pointer(&[2]int8{',', '\x00'}))
		zEnd = (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'}))
	} else {
		zSep = (*int8)(unsafe.Pointer(&[4]int8{'\n', ' ', ' ', '\x00'}))
		zSep2 = (*int8)(unsafe.Pointer(&[5]int8{',', '\n', ' ', ' ', '\x00'}))
		zEnd = (*int8)(unsafe.Pointer(&[3]int8{'\n', ')', '\x00'}))
	}
	n += 35 + 6*int32(p.nCol)
	zStmt = (*int8)(sqlite3DbMallocRaw(nil, uint64(n)))
	if uintptr(unsafe.Pointer(zStmt)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3OomFault(db)
		return (*int8)(nil)
	}
	sqlite3_snprintf(n, zStmt, (*int8)(unsafe.Pointer(&[14]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'A', 'B', 'L', 'E', ' ', '\x00'})))
	k = sqlite3Strlen30(zStmt)
	identPut(zStmt, &k, p.zName)
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStmt)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &k
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()))) = int8('(')
	for func() int32 {
		pCol = p.aCol
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); i < int32(p.nCol); func() *struct_Column {
		i++
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
			return
		}()
	}() {
		var azType [5]*int8 = [5]*int8{(*int8)(unsafe.Pointer(&[1]int8{'\x00'})), (*int8)(unsafe.Pointer(&[6]int8{' ', 'T', 'E', 'X', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{' ', 'N', 'U', 'M', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{' ', 'I', 'N', 'T', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{' ', 'R', 'E', 'A', 'L', '\x00'}))}
		var len int32
		var zType *int8
		sqlite3_snprintf(n-k, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStmt)) + uintptr(k))), zSep)
		k += sqlite3Strlen30(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStmt)) + uintptr(k))))
		zSep = zSep2
		identPut(zStmt, &k, pCol.zCnName)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		zType = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azType)))) + uintptr(int32(pCol.affinity)-65)*8))
		len = sqlite3Strlen30(zType)
		func() int {
			_ = 0
			return 0
		}()
		__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStmt)) + uintptr(k)))), unsafe.Pointer(zType), uint(len), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStmt)) + uintptr(k)))), 0))
		k += len
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3_snprintf(n-k, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStmt)) + uintptr(k))), (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zEnd)
	return zStmt
}
func resizeIndexObject(db *struct_sqlite3, pIdx *struct_Index, N int32) int32 {
	var zExtra *int8
	var nByte int32
	if int32(pIdx.nColumn) >= N {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	nByte = int32((8 + 2 + 2 + uint(1)) * uint(N))
	zExtra = (*int8)(sqlite3DbMallocZero(db, uint64(nByte)))
	if uintptr(unsafe.Pointer(zExtra)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memcpy_chk(unsafe.Pointer(zExtra), unsafe.Pointer(pIdx.azColl), 8*uint(pIdx.nColumn), __builtin_object_size(unsafe.Pointer(zExtra), 0))
	pIdx.azColl = (**int8)(unsafe.Pointer(zExtra))
	*(*uintptr)(unsafe.Pointer(&zExtra)) += uintptr(8 * uint(N))
	__builtin___memcpy_chk(unsafe.Pointer(zExtra), unsafe.Pointer(pIdx.aiRowLogEst), 2*uint(int32(pIdx.nKeyCol)+1), __builtin_object_size(unsafe.Pointer(zExtra), 0))
	pIdx.aiRowLogEst = (*int16)(unsafe.Pointer(zExtra))
	*(*uintptr)(unsafe.Pointer(&zExtra)) += uintptr(2 * uint(N))
	__builtin___memcpy_chk(unsafe.Pointer(zExtra), unsafe.Pointer(pIdx.aiColumn), 2*uint(pIdx.nColumn), __builtin_object_size(unsafe.Pointer(zExtra), 0))
	pIdx.aiColumn = (*int16)(unsafe.Pointer(zExtra))
	*(*uintptr)(unsafe.Pointer(&zExtra)) += uintptr(2 * uint(N))
	__builtin___memcpy_chk(unsafe.Pointer(zExtra), unsafe.Pointer(pIdx.aSortOrder), uint(pIdx.nColumn), __builtin_object_size(unsafe.Pointer(zExtra), 0))
	pIdx.aSortOrder = (*uint8)(unsafe.Pointer(zExtra))
	pIdx.nColumn = uint16(N)
	{
		_autoGo_56 := &pIdx.Xbf_0
		*_autoGo_56 = *_autoGo_56&^16 | uint32(1)&1<<4
	}
	return int32(0)
}
func estimateTableWidth(pTab *struct_Table) {
	var wTable uint32 = uint32(0)
	var pTabCol *struct_Column
	var i int32
	for func() *struct_Column {
		i = int32(pTab.nCol)
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pTabCol
			*_cgo_addr = pTab.aCol
			return *_cgo_addr
		}()
	}(); i > 0; func() *struct_Column {
		i--
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pTabCol
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
			return
		}()
	}() {
		wTable += uint32(pTabCol.szEst)
	}
	if int32(pTab.iPKey) < 0 {
		wTable++
	}
	pTab.szTabRow = sqlite3LogEst(uint64(wTable * uint32(4)))
}
func estimateIndexWidth(pIdx *struct_Index) {
	var wIndex uint32 = uint32(0)
	var i int32
	var aCol *struct_Column = pIdx.pTable.aCol
	for i = int32(0); i < int32(pIdx.nColumn); i++ {
		var x int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))
		func() int {
			_ = 0
			return 0
		}()
		wIndex += uint32(func() int32 {
			if int32(x) < 0 {
				return 1
			} else {
				return int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))*20))).szEst)
			}
		}())
	}
	pIdx.szIdxRow = sqlite3LogEst(uint64(wIndex * uint32(4)))
}
func hasColumn(aiCol *int16, nCol int32, x int32) int32 {
	for func() (_cgo_ret int32) {
		_cgo_addr := &nCol
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() > 0 {
		if x == int32(*func() (_cgo_ret *int16) {
			_cgo_addr := &aiCol
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 2
			return
		}()) {
			return int32(1)
		}
	}
	return int32(0)
}
func isDupColumn(pIdx *struct_Index, nKey int32, pPk *struct_Index, iCol int32) int32 {
	var i int32
	var j int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	j = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(iCol)*2)))
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < nKey; i++ {
		func() int {
			_ = 0
			return 0
		}()
		if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))) == j && sqlite3StrICmp(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(i)*8)), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(iCol)*8))) == 0 {
			return int32(1)
		}
	}
	return int32(0)
}
func recomputeColumnsNotIndexed(pIdx *struct_Index) {
	var m uint64 = uint64(0)
	var j int32
	var pTab *struct_Table = pIdx.pTable
	for j = int32(pIdx.nColumn) - 1; j >= 0; j-- {
		var x int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2)))
		if x >= 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(x)*20))).colFlags)&32 == 0 {
			if x < int32(8*uint(8))-1 {
				m |= uint64(1) << x
			}
		}
	}
	pIdx.colNotIdxed = ^m
	func() int {
		_ = 0
		return 0
	}()
}
func convertToWithoutRowidTable(pParse *struct_Parse, pTab *struct_Table) {
	var pIdx *struct_Index
	var pPk *struct_Index
	var nPk int32
	var nExtra int32
	var i int32
	var j int32
	var db *struct_sqlite3 = pParse.db
	var v *struct_Vdbe = pParse.pVdbe
	if !(db.init.Xbf_0>>1&1 != 0) {
		for i = int32(0); i < int32(pTab.nCol); i++ {
			if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&1 != 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).Xbf_0&15) == 0 {
				{
					_autoGo_57 := &(*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).Xbf_0
					*_autoGo_57 = *_autoGo_57&^15 | uint32(2)&15
				}
			}
		}
		pTab.tabFlags |= uint32(2048)
	}
	func() int {
		_ = 0
		return 0
	}()
	if *(*int32)(unsafe.Pointer(&pParse.u1)) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeChangeP3(v, *(*int32)(unsafe.Pointer(&pParse.u1)), 2)
	}
	if int32(pTab.iPKey) >= 0 {
		var pList *struct_ExprList
		var ipkToken struct_Token
		sqlite3TokenInit(&ipkToken, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(pTab.iPKey)*20))).zCnName)
		pList = sqlite3ExprListAppend(pParse, nil, sqlite3ExprAlloc(db, 59, &ipkToken, 0))
		if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
			pTab.tabFlags &= uint32(4294967167)
			return
		}
		if int32(pParse.eParseMode) >= 2 {
			sqlite3RenameTokenRemap(pParse, unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr), unsafe.Pointer(&pTab.iPKey))
		}
		(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).sortFlags = pParse.iPkSortOrder
		func() int {
			_ = 0
			return 0
		}()
		pTab.iPKey = int16(-1)
		sqlite3CreateIndex(pParse, nil, nil, nil, pList, int32(pTab.keyConf), nil, nil, 0, 0, uint8(2))
		if pParse.nErr != 0 {
			pTab.tabFlags &= uint32(4294967167)
			return
		}
		func() int {
			_ = 0
			return 0
		}()
		pPk = sqlite3PrimaryKeyIndex(pTab)
		func() int {
			_ = 0
			return 0
		}()
	} else {
		pPk = sqlite3PrimaryKeyIndex(pTab)
		func() int {
			_ = 0
			return 0
		}()
		for i = func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = int32(1)
			return *_cgo_addr
		}(); i < int32(pPk.nKeyCol); i++ {
			if isDupColumn(pPk, j, pPk, i) != 0 {
				pPk.nColumn--
			} else {
				*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(j)*8)) = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(i)*8))
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aSortOrder)) + uintptr(j))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aSortOrder)) + uintptr(i)))
				*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &j
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())*2)) = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))
			}
		}
		pPk.nKeyCol = uint16(j)
	}
	func() int {
		_ = 0
		return 0
	}()
	{
		_autoGo_58 := &pPk.Xbf_0
		*_autoGo_58 = *_autoGo_58&^32 | uint32(1)&1<<5
	}
	if !(db.init.Xbf_0>>1&1 != 0) {
		{
			_autoGo_59 := &pPk.Xbf_0
			*_autoGo_59 = *_autoGo_59&^8 | uint32(1)&1<<3
		}
	}
	nPk = int32(func() (_cgo_ret uint16) {
		_cgo_addr := &pPk.nColumn
		*_cgo_addr = pPk.nKeyCol
		return *_cgo_addr
	}())
	if v != nil && pPk.tnum > uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeChangeOpcode(v, int32(pPk.tnum), uint8(11))
	}
	pPk.tnum = pTab.tnum
	for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
		var n int32
		if int32(pIdx.Xbf_0&3) == 2 {
			continue
		}
		for i = func() (_cgo_ret int32) {
			_cgo_addr := &n
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}(); i < nPk; i++ {
			if !(isDupColumn(pIdx, int32(pIdx.nKeyCol), pPk, i) != 0) {
				n++
			}
		}
		if n == 0 {
			pIdx.nColumn = pIdx.nKeyCol
			continue
		}
		if resizeIndexObject(db, pIdx, int32(pIdx.nKeyCol)+n) != 0 {
			return
		}
		for func() int32 {
			i = int32(0)
			return func() (_cgo_ret int32) {
				_cgo_addr := &j
				*_cgo_addr = int32(pIdx.nKeyCol)
				return *_cgo_addr
			}()
		}(); i < nPk; i++ {
			if !(isDupColumn(pIdx, int32(pIdx.nKeyCol), pPk, i) != 0) {
				*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2)) = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))
				*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(j)*8)) = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(i)*8))
				if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aSortOrder)) + uintptr(i))) != 0 {
					{
						_autoGo_60 := &pIdx.Xbf_0
						*_autoGo_60 = *_autoGo_60&^512 | uint32(1)&1<<9
					}
				}
				j++
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	nExtra = int32(0)
	for i = int32(0); i < int32(pTab.nCol); i++ {
		if !(hasColumn(pPk.aiColumn, nPk, i) != 0) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 == 0 {
			nExtra++
		}
	}
	if resizeIndexObject(db, pPk, nPk+nExtra) != 0 {
		return
	}
	for func() int32 {
		i = int32(0)
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = nPk
			return *_cgo_addr
		}()
	}(); i < int32(pTab.nCol); i++ {
		if !(hasColumn(pPk.aiColumn, j, i) != 0) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 == 0 {
			func() int {
				_ = 0
				return 0
			}()
			*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(j)*2)) = int16(i)
			*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(j)*8)) = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
			j++
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	recomputeColumnsNotIndexed(pPk)
}
func sqlite3IsShadowTableOf(db *struct_sqlite3, pTab *struct_Table, zName *int8) int32 {
	var nName int32
	var pMod *struct_Module
	if !(int32(pTab.eTabType) == 1) {
		return int32(0)
	}
	nName = sqlite3Strlen30(pTab.zName)
	if sqlite3_strnicmp(zName, pTab.zName, nName) != 0 {
		return int32(0)
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(nName)))) != '_' {
		return int32(0)
	}
	pMod = (*struct_Module)(sqlite3HashFind(&db.aModule, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg)) + uintptr(0)*8))))
	if uintptr(unsafe.Pointer(pMod)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if pMod.pModule.iVersion < 3 {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pMod.pModule.xShadowName)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	return pMod.pModule.xShadowName((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName))+uintptr(nName))))) + uintptr(1))))
}
func sqlite3MarkAllShadowTablesOf(db *struct_sqlite3, pTab *struct_Table) {
	var nName int32
	var pMod *struct_Module
	var k *struct_HashElem
	func() int {
		_ = 0
		return 0
	}()
	pMod = (*struct_Module)(sqlite3HashFind(&db.aModule, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg)) + uintptr(0)*8))))
	if uintptr(unsafe.Pointer(pMod)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uintptr(unsafe.Pointer(pMod.pModule)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if pMod.pModule.iVersion < 3 {
		return
	}
	if uintptr(unsafe.Pointer(pMod.pModule.xShadowName)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	nName = sqlite3Strlen30(pTab.zName)
	for k = (&pTab.pSchema.tblHash).first; k != nil; k = k.next {
		var pOther *struct_Table = (*struct_Table)(k.data)
		func() int {
			_ = 0
			return 0
		}()
		if !(int32(pOther.eTabType) == 0) {
			continue
		}
		if pOther.tabFlags&uint32(4096) != 0 {
			continue
		}
		if sqlite3_strnicmp(pOther.zName, pTab.zName, nName) == 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOther.zName)) + uintptr(nName)))) == '_' && pMod.pModule.xShadowName((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pOther.zName))+uintptr(nName)))))+uintptr(1)))) != 0 {
			pOther.tabFlags |= uint32(4096)
		}
	}
}
func sqlite3ShadowTableName(db *struct_sqlite3, zName *int8) int32 {
	var zTail *int8
	var pTab *struct_Table
	zTail = strrchr(zName, '_')
	if uintptr(unsafe.Pointer(zTail)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	*zTail = int8(0)
	pTab = sqlite3FindTable(db, zName, nil)
	*zTail = int8('_')
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if !(int32(pTab.eTabType) == 1) {
		return int32(0)
	}
	return sqlite3IsShadowTableOf(db, pTab, zName)
}
func sqlite3EndTable(pParse *struct_Parse, pCons *struct_Token, pEnd *struct_Token, tabOpts uint32, pSelect *struct_Select) {
	var p *struct_Table
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	var pIdx *struct_Index
	if uintptr(unsafe.Pointer(pEnd)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pSelect)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	p = pParse.pNewTable
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if uintptr(unsafe.Pointer(pSelect)) == uintptr(unsafe.Pointer(nil)) && sqlite3ShadowTableName(db, p.zName) != 0 {
		p.tabFlags |= uint32(4096)
	}
	if db.init.busy != 0 {
		if pSelect != nil || !(int32(p.eTabType) == 0) && db.init.newTnum != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})))
			return
		}
		p.tnum = db.init.newTnum
		if p.tnum == uint32(1) {
			p.tabFlags |= uint32(1)
		}
	}
	if tabOpts&uint32(65536) != 0 {
		var ii int32
		p.tabFlags |= uint32(65536)
		for ii = int32(0); ii < int32(p.nCol); ii++ {
			var pCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(ii)*20))
			if int32(pCol.Xbf_0>>4&15) == 0 {
				if int32(pCol.colFlags)&4 != 0 {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[33]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 't', 'y', 'p', 'e', ' ', 'f', 'o', 'r', ' ', '%', 's', '.', '%', 's', ':', ' ', '"', '%', 's', '"', '\x00'})), p.zName, pCol.zCnName, sqlite3ColumnType(pCol, (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))))
				} else {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'m', 'i', 's', 's', 'i', 'n', 'g', ' ', 'd', 'a', 't', 'a', 't', 'y', 'p', 'e', ' ', 'f', 'o', 'r', ' ', '%', 's', '.', '%', 's', '\x00'})), p.zName, pCol.zCnName)
				}
				return
			} else if int32(pCol.Xbf_0>>4&15) == 1 {
				pCol.affinity = int8(65)
			}
			if int32(pCol.colFlags)&1 != 0 && int32(p.iPKey) != ii && int32(pCol.Xbf_0&15) == 0 {
				{
					_autoGo_61 := &pCol.Xbf_0
					*_autoGo_61 = *_autoGo_61&^15 | uint32(2)&15
				}
				p.tabFlags |= uint32(2048)
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if tabOpts&uint32(128) != 0 {
		if p.tabFlags&uint32(8) != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[50]int8{'A', 'U', 'T', 'O', 'I', 'N', 'C', 'R', 'E', 'M', 'E', 'N', 'T', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'W', 'I', 'T', 'H', 'O', 'U', 'T', ' ', 'R', 'O', 'W', 'I', 'D', ' ', 't', 'a', 'b', 'l', 'e', 's', '\x00'})))
			return
		}
		if p.tabFlags&uint32(4) == uint32(0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[32]int8{'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', ' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'o', 'n', ' ', 't', 'a', 'b', 'l', 'e', ' ', '%', 's', '\x00'})), p.zName)
			return
		}
		p.tabFlags |= uint32(128 | 512)
		convertToWithoutRowidTable(pParse, p)
	}
	iDb = sqlite3SchemaToIndex(db, p.pSchema)
	if p.pCheck != nil {
		sqlite3ResolveSelfReference(pParse, p, 4, nil, p.pCheck)
		if pParse.nErr != 0 {
			sqlite3ExprListDelete(db, p.pCheck)
			p.pCheck = (*struct_ExprList)(nil)
		} else {
		}
	}
	if p.tabFlags&uint32(96) != 0 {
		var ii int32
		var nNG int32 = 0
		for ii = int32(0); ii < int32(p.nCol); ii++ {
			var colFlags uint32 = uint32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(ii)*20))).colFlags)
			if colFlags&uint32(96) != uint32(0) {
				var pX *struct_Expr = sqlite3ColumnExpr(p, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(ii)*20)))
				if sqlite3ResolveSelfReference(pParse, p, 8, pX, nil) != 0 {
					sqlite3ColumnSetExpr(pParse, p, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(ii)*20)), sqlite3ExprAlloc(db, 121, nil, 0))
				}
			} else {
				nNG++
			}
		}
		if nNG == 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[44]int8{'m', 'u', 's', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'a', 't', ' ', 'l', 'e', 'a', 's', 't', ' ', 'o', 'n', 'e', ' ', 'n', 'o', 'n', '-', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})))
			return
		}
	}
	estimateTableWidth(p)
	for pIdx = p.pIndex; pIdx != nil; pIdx = pIdx.pNext {
		estimateIndexWidth(pIdx)
	}
	if !(db.init.busy != 0) {
		var n int32
		var v *struct_Vdbe
		var zType *int8
		var zType2 *int8
		var zStmt *int8
		v = sqlite3GetVdbe(pParse)
		if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		sqlite3VdbeAddOp1(v, 121, 0)
		if int32(p.eTabType) == 0 {
			zType = (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'}))
			zType2 = (*int8)(unsafe.Pointer(&[6]int8{'T', 'A', 'B', 'L', 'E', '\x00'}))
		} else {
			zType = (*int8)(unsafe.Pointer(&[5]int8{'v', 'i', 'e', 'w', '\x00'}))
			zType2 = (*int8)(unsafe.Pointer(&[5]int8{'V', 'I', 'E', 'W', '\x00'}))
		}
		if pSelect != nil {
			var dest struct_SelectDest
			var regYield int32
			var addrTop int32
			var regRec int32
			var regRowid int32
			var addrInsLoop int32
			var pSelTab *struct_Table
			if int32(pParse.eParseMode) != 0 {
				pParse.rc = int32(1)
				pParse.nErr++
				return
			}
			regYield = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			regRec = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			regRowid = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3MayAbort(pParse)
			sqlite3VdbeAddOp3(v, 112, 1, pParse.regRoot, iDb)
			sqlite3VdbeChangeP5(v, uint16(16))
			pParse.nTab = int32(2)
			addrTop = sqlite3VdbeCurrentAddr(v) + 1
			sqlite3VdbeAddOp3(v, 13, regYield, 0, addrTop)
			if pParse.nErr != 0 {
				return
			}
			pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, int8(65))
			if uintptr(unsafe.Pointer(pSelTab)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
			func() int {
				_ = 0
				return 0
			}()
			p.nCol = func() (_cgo_ret int16) {
				_cgo_addr := &p.nNVCol
				*_cgo_addr = pSelTab.nCol
				return *_cgo_addr
			}()
			p.aCol = pSelTab.aCol
			pSelTab.nCol = int16(0)
			pSelTab.aCol = (*struct_Column)(nil)
			sqlite3DeleteTable(db, pSelTab)
			sqlite3SelectDestInit(&dest, 13, regYield)
			sqlite3Select(pParse, pSelect, &dest)
			if pParse.nErr != 0 {
				return
			}
			sqlite3VdbeEndCoroutine(v, regYield)
			sqlite3VdbeJumpHere(v, addrTop-1)
			addrInsLoop = sqlite3VdbeAddOp1(v, 14, dest.iSDParm)
			sqlite3VdbeAddOp3(v, 96, dest.iSdst, dest.nSdst, regRec)
			sqlite3TableAffinity(v, p, 0)
			sqlite3VdbeAddOp2(v, 126, 1, regRowid)
			sqlite3VdbeAddOp3(v, 127, 1, regRec, regRowid)
			sqlite3VdbeGoto(v, addrInsLoop)
			sqlite3VdbeJumpHere(v, addrInsLoop)
			sqlite3VdbeAddOp1(v, 121, 1)
		}
		if pSelect != nil {
			zStmt = createTableStmt(db, p)
		} else {
			var pEnd2 *struct_Token = func() *struct_Token {
				if tabOpts != 0 {
					return &pParse.sLastToken
				} else {
					return pEnd
				}
			}()
			n = int32(uintptr(unsafe.Pointer(pEnd2.z)) - uintptr(unsafe.Pointer(pParse.sNameToken.z)))
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pEnd2.z)) + uintptr(0)))) != ';' {
				n += int32(pEnd2.n)
			}
			zStmt = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[15]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', '%', 's', ' ', '%', '.', '*', 's', '\x00'})), zType2, n, pParse.sNameToken.z)
		}
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[98]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 't', 'y', 'p', 'e', '=', '\'', '%', 's', '\'', ',', ' ', 'n', 'a', 'm', 'e', '=', '%', 'Q', ',', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ',', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '=', '#', '%', 'd', ',', ' ', 's', 'q', 'l', '=', '%', 'Q', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'r', 'o', 'w', 'i', 'd', '=', '#', '%', 'd', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, zType, p.zName, p.zName, pParse.regRoot, zStmt, pParse.regRowid)
		sqlite3DbFree(db, unsafe.Pointer(zStmt))
		sqlite3ChangeCookie(pParse, iDb)
		if p.tabFlags&uint32(8) != uint32(0) && !(int32(pParse.eParseMode) != 0) {
			var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pDb.pSchema.pSeqTab)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[42]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'A', 'B', 'L', 'E', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', '(', 'n', 'a', 'm', 'e', ',', 's', 'e', 'q', ')', '\x00'})), pDb.zDbSName)
			}
		}
		sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[34]int8{'t', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '\'', '%', 'q', '\'', ' ', 'A', 'N', 'D', ' ', 't', 'y', 'p', 'e', '!', '=', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', '\x00'})), p.zName), uint16(0))
	}
	if db.init.busy != 0 {
		var pOld *struct_Table
		var pSchema *struct_Schema = p.pSchema
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pOld = (*struct_Table)(sqlite3HashInsert(&pSchema.tblHash, p.zName, unsafe.Pointer(p)))
		if pOld != nil {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3OomFault(db)
			return
		}
		pParse.pNewTable = (*struct_Table)(nil)
		db.mDbFlags |= uint32(1)
		func() int {
			_ = 0
			return 0
		}()
		if strcmp(p.zName, (*int8)(unsafe.Pointer(&[16]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', '\x00'}))) == 0 {
			func() int {
				_ = 0
				return 0
			}()
			p.pSchema.pSeqTab = p
		}
	}
	if !(pSelect != nil) && int32(p.eTabType) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pCons.z)) == uintptr(unsafe.Pointer(nil)) {
			pCons = pEnd
		}
		p.u.tab.addColOffset = 13 + int32(uintptr(unsafe.Pointer(pCons.z))-uintptr(unsafe.Pointer(pParse.sNameToken.z)))
	}
}
func sqlite3CreateView(pParse *struct_Parse, pBegin *struct_Token, pName1 *struct_Token, pName2 *struct_Token, pCNames *struct_ExprList, pSelect *struct_Select, isTemp int32, noErr int32) {
	var p *struct_Table
	var n int32
	var z *int8
	var sEnd struct_Token
	var sFix struct_DbFixer
	var pName *struct_Token = nil
	var iDb int32
	var db *struct_sqlite3 = pParse.db
	if int32(pParse.nVar) > 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[36]int8{'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'i', 'n', ' ', 'v', 'i', 'e', 'w', 's', '\x00'})))
		goto create_view_fail
	}
	sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr)
	p = pParse.pNewTable
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || pParse.nErr != 0 {
		goto create_view_fail
	}
	p.tabFlags |= uint32(512)
	sqlite3TwoPartName(pParse, pName1, pName2, &pName)
	iDb = sqlite3SchemaToIndex(db, p.pSchema)
	sqlite3FixInit(&sFix, pParse, iDb, (*int8)(unsafe.Pointer(&[5]int8{'v', 'i', 'e', 'w', '\x00'})), pName)
	if sqlite3FixSelect(&sFix, pSelect) != 0 {
		goto create_view_fail
	}
	pSelect.selFlags |= uint32(2097152)
	if int32(pParse.eParseMode) >= 2 {
		(*(*_cgoa_12)(unsafe.Pointer(&p.u))).pSelect = pSelect
		pSelect = (*struct_Select)(nil)
	} else {
		(*(*_cgoa_12)(unsafe.Pointer(&p.u))).pSelect = sqlite3SelectDup(db, pSelect, 1)
	}
	p.pCheck = sqlite3ExprListDup(db, pCNames, 1)
	p.eTabType = uint8(2)
	if db.mallocFailed != 0 {
		goto create_view_fail
	}
	sEnd = pParse.sLastToken
	func() int {
		_ = 0
		return 0
	}()
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(sEnd.z)) + uintptr(0)))) != ';' {
		*(*uintptr)(unsafe.Pointer(&sEnd.z)) += uintptr(sEnd.n)
	}
	sEnd.n = uint32(0)
	n = int32(uintptr(unsafe.Pointer(sEnd.z)) - uintptr(unsafe.Pointer(pBegin.z)))
	func() int {
		_ = 0
		return 0
	}()
	z = pBegin.z
	for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n-1))))))))&1 != 0 {
		n--
	}
	sEnd.z = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n-1)))
	sEnd.n = uint32(1)
	sqlite3EndTable(pParse, nil, &sEnd, uint32(0), nil)
create_view_fail:
	sqlite3SelectDelete(db, pSelect)
	if int32(pParse.eParseMode) >= 2 {
		sqlite3RenameExprlistUnmap(pParse, pCNames)
	}
	sqlite3ExprListDelete(db, pCNames)
	return
}
func sqlite3ViewGetColumnNames(pParse *struct_Parse, pTable *struct_Table) int32 {
	var pSelTab *struct_Table
	var pSel *struct_Select
	var nErr int32 = 0
	var n int32
	var db *struct_sqlite3 = pParse.db
	var rc int32
	var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTable.eTabType) == 1 {
		db.nSchemaLock++
		rc = sqlite3VtabCallConnect(pParse, pTable)
		db.nSchemaLock--
		return rc
	}
	if int32(pTable.nCol) > 0 {
		return int32(0)
	}
	if int32(pTable.nCol) < 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'v', 'i', 'e', 'w', ' ', '%', 's', ' ', 'i', 's', ' ', 'c', 'i', 'r', 'c', 'u', 'l', 'a', 'r', 'l', 'y', ' ', 'd', 'e', 'f', 'i', 'n', 'e', 'd', '\x00'})), pTable.zName)
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pSel = sqlite3SelectDup(db, (*(*_cgoa_12)(unsafe.Pointer(&pTable.u))).pSelect, 0)
	if pSel != nil {
		var eParseMode uint8 = pParse.eParseMode
		pParse.eParseMode = uint8(0)
		n = pParse.nTab
		sqlite3SrcListAssignCursors(pParse, pSel.pSrc)
		pTable.nCol = int16(-1)
		db.lookaside.bDisable++
		db.lookaside.sz = uint16(0)
		xAuth = db.xAuth
		db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
		pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, int8(64))
		db.xAuth = xAuth
		pParse.nTab = n
		if uintptr(unsafe.Pointer(pSelTab)) == uintptr(unsafe.Pointer(nil)) {
			pTable.nCol = int16(0)
			nErr++
		} else if pTable.pCheck != nil {
			sqlite3ColumnsFromExprList(pParse, pTable.pCheck, &pTable.nCol, &pTable.aCol)
			if pParse.nErr == 0 && int32(pTable.nCol) == pSel.pEList.nExpr {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel, int8(64))
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			pTable.nCol = pSelTab.nCol
			pTable.aCol = pSelTab.aCol
			pTable.tabFlags |= pSelTab.tabFlags & uint32(98)
			pSelTab.nCol = int16(0)
			pSelTab.aCol = (*struct_Column)(nil)
			func() int {
				_ = 0
				return 0
			}()
		}
		pTable.nNVCol = pTable.nCol
		sqlite3DeleteTable(db, pSelTab)
		sqlite3SelectDelete(db, pSel)
		db.lookaside.bDisable--
		db.lookaside.sz = uint16(func() int32 {
			if db.lookaside.bDisable != 0 {
				return 0
			} else {
				return int32(db.lookaside.szTrue)
			}
		}())
		pParse.eParseMode = eParseMode
	} else {
		nErr++
	}
	pTable.pSchema.schemaFlags |= uint16(2)
	if db.mallocFailed != 0 {
		sqlite3DeleteColumnNames(db, pTable)
	}
	return nErr
}
func sqliteViewResetAll(db *struct_sqlite3, idx int32) {
	var i *struct_HashElem
	func() int {
		_ = 0
		return 0
	}()
	if !(int32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(idx)*32))).pSchema.schemaFlags)&2 == 2) {
		return
	}
	for i = (&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(idx)*32))).pSchema.tblHash).first; i != nil; i = i.next {
		var pTab *struct_Table = (*struct_Table)(i.data)
		if int32(pTab.eTabType) == 2 {
			sqlite3DeleteColumnNames(db, pTab)
		}
	}
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(idx)*32))).pSchema.schemaFlags &= uint16(^2)
}
func sqlite3RootPageMoved(db *struct_sqlite3, iDb int32, iFrom uint32, iTo uint32) {
	var pElem *struct_HashElem
	var pHash *struct_Hash
	var pDb *struct_Db
	func() int {
		_ = 0
		return 0
	}()
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	pHash = &pDb.pSchema.tblHash
	for pElem = pHash.first; pElem != nil; pElem = pElem.next {
		var pTab *struct_Table = (*struct_Table)(pElem.data)
		if pTab.tnum == iFrom {
			pTab.tnum = iTo
		}
	}
	pHash = &pDb.pSchema.idxHash
	for pElem = pHash.first; pElem != nil; pElem = pElem.next {
		var pIdx *struct_Index = (*struct_Index)(pElem.data)
		if pIdx.tnum == iFrom {
			pIdx.tnum = iTo
		}
	}
}
func destroyRootPage(pParse *struct_Parse, iTable int32, iDb int32) {
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var r1 int32 = sqlite3GetTempReg(pParse)
	if iTable < 2 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[15]int8{'c', 'o', 'r', 'r', 'u', 'p', 't', ' ', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})))
	}
	sqlite3VdbeAddOp3(v, 143, iTable, r1, iDb)
	sqlite3MayAbort(pParse)
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[67]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '=', '%', 'd', ' ', 'W', 'H', 'E', 'R', 'E', ' ', '#', '%', 'd', ' ', 'A', 'N', 'D', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '=', '#', '%', 'd', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(iDb)*32))).zDbSName, iTable, r1, r1)
	sqlite3ReleaseTempReg(pParse, r1)
}
func destroyTable(pParse *struct_Parse, pTab *struct_Table) {
	var iTab uint32 = pTab.tnum
	var iDestroyed uint32 = uint32(0)
	for 1 != 0 {
		var pIdx *struct_Index
		var iLargest uint32 = uint32(0)
		if iDestroyed == uint32(0) || iTab < iDestroyed {
			iLargest = iTab
		}
		for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			var iIdx uint32 = pIdx.tnum
			func() int {
				_ = 0
				return 0
			}()
			if (iDestroyed == uint32(0) || iIdx < iDestroyed) && iIdx > iLargest {
				iLargest = iIdx
			}
		}
		if iLargest == uint32(0) {
			return
		} else {
			var iDb int32 = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
			func() int {
				_ = 0
				return 0
			}()
			destroyRootPage(pParse, int32(iLargest), iDb)
			iDestroyed = iLargest
		}
	}
}
func sqlite3ClearStatTables(pParse *struct_Parse, iDb int32, zType *int8, zName *int8) {
	var i int32
	var zDbName *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(iDb)*32))).zDbSName
	for i = int32(1); i <= 4; i++ {
		var zTab [24]int8
		sqlite3_snprintf(int32(24), (*int8)(unsafe.Pointer(&zTab)), (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '%', 'd', '\x00'})), i)
		if sqlite3FindTable(pParse.db, (*int8)(unsafe.Pointer(&zTab)), zDbName) != nil {
			sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[30]int8{'D', 'E', 'L', 'E', 'T', 'E', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', '%', 's', ' ', 'W', 'H', 'E', 'R', 'E', ' ', '%', 's', '=', '%', 'Q', '\x00'})), zDbName, (*int8)(unsafe.Pointer(&zTab)), zType, zName)
		}
	}
}
func sqlite3CodeDropTable(pParse *struct_Parse, pTab *struct_Table, iDb int32, isView int32) {
	var v *struct_Vdbe
	var db *struct_sqlite3 = pParse.db
	var pTrigger *struct_Trigger
	var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	v = sqlite3GetVdbe(pParse)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BeginWriteOperation(pParse, 1, iDb)
	if int32(pTab.eTabType) == 1 {
		sqlite3VdbeAddOp0(v, 169)
	}
	pTrigger = sqlite3TriggerList(pParse, pTab)
	for pTrigger != nil {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3DropTriggerPtr(pParse, pTrigger)
		pTrigger = pTrigger.pNext
	}
	if pTab.tabFlags&uint32(8) != 0 {
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[45]int8{'D', 'E', 'L', 'E', 'T', 'E', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', '=', '%', 'Q', '\x00'})), pDb.zDbSName, pTab.zName)
	}
	sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[67]int8{'D', 'E', 'L', 'E', 'T', 'E', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'a', 'n', 'd', ' ', 't', 'y', 'p', 'e', '!', '=', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', '\x00'})), pDb.zDbSName, pTab.zName)
	if !(isView != 0) && !(int32(pTab.eTabType) == 1) {
		destroyTable(pParse, pTab)
	}
	if int32(pTab.eTabType) == 1 {
		sqlite3VdbeAddOp4(v, 171, iDb, 0, 0, pTab.zName, 0)
		sqlite3MayAbort(pParse)
	}
	sqlite3VdbeAddOp4(v, 150, iDb, 0, 0, pTab.zName, 0)
	sqlite3ChangeCookie(pParse, iDb)
	sqliteViewResetAll(db, iDb)
}
func sqlite3ReadOnlyShadowTables(db *struct_sqlite3) int32 {
	if db.flags&uint64(268435456) != uint64(0) && uintptr(unsafe.Pointer(db.pVtabCtx)) == uintptr(unsafe.Pointer(nil)) && db.nVdbeExec == 0 && !(db.nVTrans > 0 && uintptr(unsafe.Pointer(db.aVTrans)) == uintptr(unsafe.Pointer(nil))) {
		return int32(1)
	}
	return int32(0)
}
func tableMayNotBeDropped(db *struct_sqlite3, pTab *struct_Table) int32 {
	if sqlite3_strnicmp(pTab.zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) == 0 {
		if sqlite3_strnicmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.zName))+uintptr(7))), (*int8)(unsafe.Pointer(&[5]int8{'s', 't', 'a', 't', '\x00'})), 4) == 0 {
			return int32(0)
		}
		if sqlite3_strnicmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.zName))+uintptr(7))), (*int8)(unsafe.Pointer(&[11]int8{'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', 's', '\x00'})), 10) == 0 {
			return int32(0)
		}
		return int32(1)
	}
	if pTab.tabFlags&uint32(4096) != uint32(0) && sqlite3ReadOnlyShadowTables(db) != 0 {
		return int32(1)
	}
	if pTab.tabFlags&uint32(32768) != 0 {
		return int32(1)
	}
	return int32(0)
}
func sqlite3DropTable(pParse *struct_Parse, pName *struct_SrcList, isView int32, noErr int32) {
	var pTab *struct_Table
	var v *struct_Vdbe
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	if db.mallocFailed != 0 {
		goto exit_drop_table
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3ReadSchema(pParse) != 0 {
		goto exit_drop_table
	}
	if noErr != 0 {
		db.suppressErr++
	}
	func() int {
		_ = 0
		return 0
	}()
	pTab = sqlite3LocateTableItem(pParse, uint32(isView), &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112)))
	if noErr != 0 {
		db.suppressErr--
	}
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		if noErr != 0 {
			sqlite3CodeVerifyNamedSchema(pParse, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112))).zDatabase)
			sqlite3ForceNotReadOnly(pParse)
		}
		goto exit_drop_table
	}
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTab.eTabType) == 1 && sqlite3ViewGetColumnNames(pParse, pTab) != 0 {
		goto exit_drop_table
	}
	{
		var code int32
		var zTab *int8 = func() *int8 {
			if true && iDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}()
		var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
		var zArg2 *int8 = nil
		if sqlite3AuthCheck(pParse, 9, zTab, nil, zDb) != 0 {
			goto exit_drop_table
		}
		if isView != 0 {
			if true && iDb == 1 {
				code = int32(15)
			} else {
				code = int32(17)
			}
		} else if int32(pTab.eTabType) == 1 {
			code = int32(30)
			zArg2 = sqlite3GetVTable(db, pTab).pMod.zName
		} else if true && iDb == 1 {
			code = int32(13)
		} else {
			code = int32(11)
		}
		if sqlite3AuthCheck(pParse, code, pTab.zName, zArg2, zDb) != 0 {
			goto exit_drop_table
		}
		if sqlite3AuthCheck(pParse, 9, pTab.zName, nil, zDb) != 0 {
			goto exit_drop_table
		}
	}
	if tableMayNotBeDropped(db, pTab) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\x00'})), pTab.zName)
		goto exit_drop_table
	}
	if isView != 0 && !(int32(pTab.eTabType) == 2) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'u', 's', 'e', ' ', 'D', 'R', 'O', 'P', ' ', 'T', 'A', 'B', 'L', 'E', ' ', 't', 'o', ' ', 'd', 'e', 'l', 'e', 't', 'e', ' ', 't', 'a', 'b', 'l', 'e', ' ', '%', 's', '\x00'})), pTab.zName)
		goto exit_drop_table
	}
	if !(isView != 0) && int32(pTab.eTabType) == 2 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[32]int8{'u', 's', 'e', ' ', 'D', 'R', 'O', 'P', ' ', 'V', 'I', 'E', 'W', ' ', 't', 'o', ' ', 'd', 'e', 'l', 'e', 't', 'e', ' ', 'v', 'i', 'e', 'w', ' ', '%', 's', '\x00'})), pTab.zName)
		goto exit_drop_table
	}
	v = sqlite3GetVdbe(pParse)
	if v != nil {
		sqlite3BeginWriteOperation(pParse, 1, iDb)
		if !(isView != 0) {
			sqlite3ClearStatTables(pParse, iDb, (*int8)(unsafe.Pointer(&[4]int8{'t', 'b', 'l', '\x00'})), pTab.zName)
			sqlite3FkDropTable(pParse, pName, pTab)
		}
		sqlite3CodeDropTable(pParse, pTab, iDb, isView)
	}
exit_drop_table:
	sqlite3SrcListDelete(db, pName)
}
func sqlite3CreateForeignKey(pParse *struct_Parse, pFromCol *struct_ExprList, pTo *struct_Token, pToCol *struct_ExprList, flags int32) {
	var db *struct_sqlite3 = pParse.db
	var pFKey *struct_FKey = nil
	var pNextTo *struct_FKey
	var p *struct_Table = pParse.pNewTable
	var nByte int64
	var i int32
	var nCol int32
	var z *int8
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || int32(pParse.eParseMode) == 1 {
		goto fk_end
	}
	if uintptr(unsafe.Pointer(pFromCol)) == uintptr(unsafe.Pointer(nil)) {
		var iCol int32 = int32(p.nCol) - 1
		if iCol < 0 {
			goto fk_end
		}
		if pToCol != nil && pToCol.nExpr != 1 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[63]int8{'f', 'o', 'r', 'e', 'i', 'g', 'n', ' ', 'k', 'e', 'y', ' ', 'o', 'n', ' ', '%', 's', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'o', 'n', 'l', 'y', ' ', 'o', 'n', 'e', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'o', 'f', ' ', 't', 'a', 'b', 'l', 'e', ' ', '%', 'T', '\x00'})), (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(iCol)*20))).zCnName, pTo)
			goto fk_end
		}
		nCol = int32(1)
	} else if pToCol != nil && pToCol.nExpr != pFromCol.nExpr {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[94]int8{'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'i', 'n', ' ', 'f', 'o', 'r', 'e', 'i', 'g', 'n', ' ', 'k', 'e', 'y', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h', ' ', 't', 'h', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 'd', ' ', 't', 'a', 'b', 'l', 'e', '\x00'})))
		goto fk_end
	} else {
		nCol = pFromCol.nExpr
	}
	nByte = int64(80 + uint(nCol-1)*16 + uint(pTo.n) + uint(1))
	if pToCol != nil {
		for i = int32(0); i < pToCol.nExpr; i++ {
			nByte += int64(sqlite3Strlen30((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pToCol.a)))) + uintptr(i)*28))).zEName) + 1)
		}
	}
	pFKey = (*struct_FKey)(sqlite3DbMallocZero(db, uint64(nByte)))
	if uintptr(unsafe.Pointer(pFKey)) == uintptr(unsafe.Pointer(nil)) {
		goto fk_end
	}
	pFKey.pFrom = p
	func() int {
		_ = 0
		return 0
	}()
	pFKey.pNextFrom = p.u.tab.pFKey
	z = (*int8)(unsafe.Pointer(&*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(nCol)*16))))
	pFKey.zTo = z
	if int32(pParse.eParseMode) >= 2 {
		sqlite3RenameTokenMap(pParse, unsafe.Pointer(z), pTo)
	}
	__builtin___memcpy_chk(unsafe.Pointer(z), unsafe.Pointer(pTo.z), uint(pTo.n), __builtin_object_size(unsafe.Pointer(z), 0))
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(pTo.n))) = int8(0)
	sqlite3Dequote(z)
	*(*uintptr)(unsafe.Pointer(&z)) += uintptr(pTo.n + uint32(1))
	pFKey.nCol = nCol
	if uintptr(unsafe.Pointer(pFromCol)) == uintptr(unsafe.Pointer(nil)) {
		(*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(0)*16))).iFrom = int32(p.nCol) - 1
	} else {
		for i = int32(0); i < nCol; i++ {
			var j int32
			for j = int32(0); j < int32(p.nCol); j++ {
				if sqlite3StrICmp((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aCol)) + uintptr(j)*20))).zCnName, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFromCol.a)))) + uintptr(i)*28))).zEName) == 0 {
					(*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).iFrom = j
					break
				}
			}
			if j >= int32(p.nCol) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[46]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '"', '%', 's', '"', ' ', 'i', 'n', ' ', 'f', 'o', 'r', 'e', 'i', 'g', 'n', ' ', 'k', 'e', 'y', ' ', 'd', 'e', 'f', 'i', 'n', 'i', 't', 'i', 'o', 'n', '\x00'})), (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFromCol.a)))) + uintptr(i)*28))).zEName)
				goto fk_end
			}
			if int32(pParse.eParseMode) >= 2 {
				sqlite3RenameTokenRemap(pParse, unsafe.Pointer(&*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))), unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pFromCol.a)))) + uintptr(i)*28))).zEName))
			}
		}
	}
	if pToCol != nil {
		for i = int32(0); i < nCol; i++ {
			var n int32 = sqlite3Strlen30((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pToCol.a)))) + uintptr(i)*28))).zEName)
			(*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).zCol = z
			if int32(pParse.eParseMode) >= 2 {
				sqlite3RenameTokenRemap(pParse, unsafe.Pointer(z), unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pToCol.a)))) + uintptr(i)*28))).zEName))
			}
			__builtin___memcpy_chk(unsafe.Pointer(z), unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pToCol.a)))) + uintptr(i)*28))).zEName), uint(n), __builtin_object_size(unsafe.Pointer(z), 0))
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n))) = int8(0)
			*(*uintptr)(unsafe.Pointer(&z)) += uintptr(n + 1)
		}
	}
	pFKey.isDeferred = uint8(0)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFKey.aAction)))) + uintptr(0))) = uint8(flags & 255)
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFKey.aAction)))) + uintptr(1))) = uint8(flags >> 8 & 255)
	func() int {
		_ = 0
		return 0
	}()
	pNextTo = (*struct_FKey)(sqlite3HashInsert(&p.pSchema.fkeyHash, pFKey.zTo, unsafe.Pointer(pFKey)))
	if uintptr(unsafe.Pointer(pNextTo)) == uintptr(unsafe.Pointer(pFKey)) {
		sqlite3OomFault(db)
		goto fk_end
	}
	if pNextTo != nil {
		func() int {
			_ = 0
			return 0
		}()
		pFKey.pNextTo = pNextTo
		pNextTo.pPrevTo = pFKey
	}
	func() int {
		_ = 0
		return 0
	}()
	p.u.tab.pFKey = pFKey
	pFKey = (*struct_FKey)(nil)
fk_end:
	sqlite3DbFree(db, unsafe.Pointer(pFKey))
	sqlite3ExprListDelete(db, pFromCol)
	sqlite3ExprListDelete(db, pToCol)
}
func sqlite3DeferForeignKey(pParse *struct_Parse, isDeferred int32) {
	var pTab *struct_Table
	var pFKey *struct_FKey
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
		_cgo_addr := &pTab
		*_cgo_addr = pParse.pNewTable
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if !(int32(pTab.eTabType) == 0) {
		return
	}
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_FKey) {
		_cgo_addr := &pFKey
		*_cgo_addr = pTab.u.tab.pFKey
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	pFKey.isDeferred = uint8(isDeferred)
}
func sqlite3RefillIndex(pParse *struct_Parse, pIndex *struct_Index, memRootPage int32) {
	var pTab *struct_Table = pIndex.pTable
	var iTab int32 = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var iIdx int32 = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	var iSorter int32
	var addr1 int32
	var addr2 int32
	var tnum uint32
	var iPartIdxLabel int32
	var v *struct_Vdbe
	var pKey *struct_KeyInfo
	var regRecord int32
	var db *struct_sqlite3 = pParse.db
	var iDb int32 = sqlite3SchemaToIndex(db, pIndex.pSchema)
	if sqlite3AuthCheck(pParse, 27, pIndex.zName, nil, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName) != 0 {
		return
	}
	sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(1), pTab.zName)
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if memRootPage >= 0 {
		tnum = uint32(memRootPage)
	} else {
		tnum = pIndex.tnum
	}
	pKey = sqlite3KeyInfoOfIndex(pParse, pIndex)
	func() int {
		_ = 0
		return 0
	}()
	iSorter = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	sqlite3VdbeAddOp4(v, 118, iSorter, 0, int32(pIndex.nKeyCol), (*int8)(unsafe.Pointer(sqlite3KeyInfoRef(pKey))), -9)
	sqlite3OpenTable(pParse, iTab, iDb, pTab, 101)
	addr1 = sqlite3VdbeAddOp2(v, 38, iTab, 0)
	regRecord = sqlite3GetTempReg(pParse)
	sqlite3MultiWrite(pParse)
	sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 0, &iPartIdxLabel, nil, 0)
	sqlite3VdbeAddOp2(v, 138, iSorter, regRecord)
	sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel)
	sqlite3VdbeAddOp2(v, 5, iTab, addr1+1)
	sqlite3VdbeJumpHere(v, addr1)
	if memRootPage < 0 {
		sqlite3VdbeAddOp2(v, 144, int32(tnum), iDb)
	}
	sqlite3VdbeAddOp4(v, 112, iIdx, int32(tnum), iDb, (*int8)(unsafe.Pointer(pKey)), -9)
	sqlite3VdbeChangeP5(v, uint16(1|func() int32 {
		if memRootPage >= 0 {
			return 16
		} else {
			return 0
		}
	}()))
	addr1 = sqlite3VdbeAddOp2(v, 36, iSorter, 0)
	if int32(pIndex.onError) != 0 {
		var j2 int32 = sqlite3VdbeGoto(v, 1)
		addr2 = sqlite3VdbeCurrentAddr(v)
		sqlite3VdbeAddOp4Int(v, 131, iSorter, j2, regRecord, int32(pIndex.nKeyCol))
		sqlite3UniqueConstraint(pParse, 2, pIndex)
		sqlite3VdbeJumpHere(v, j2)
	} else {
		sqlite3MayAbort(pParse)
		addr2 = sqlite3VdbeCurrentAddr(v)
	}
	sqlite3VdbeAddOp3(v, 132, iSorter, regRecord, iIdx)
	if !(pIndex.Xbf_0>>9&1 != 0) {
		sqlite3VdbeAddOp1(v, 136, iIdx)
	}
	sqlite3VdbeAddOp2(v, 137, iIdx, regRecord)
	sqlite3VdbeChangeP5(v, uint16(16))
	sqlite3ReleaseTempReg(pParse, regRecord)
	sqlite3VdbeAddOp2(v, 3, iSorter, addr2)
	sqlite3VdbeJumpHere(v, addr1)
	sqlite3VdbeAddOp1(v, 121, iTab)
	sqlite3VdbeAddOp1(v, 121, iIdx)
	sqlite3VdbeAddOp1(v, 121, iSorter)
}
func sqlite3AllocateIndexObject(db *struct_sqlite3, nCol int16, nExtra int32, ppExtra **int8) *struct_Index {
	var p *struct_Index
	var nByte int32
	nByte = int32((112+uint(7))&uint(18446744073709551608) + (8*uint(nCol)+uint(7))&uint(18446744073709551608) + (2*uint(int32(nCol)+1)+2*uint(nCol)+1*uint(nCol)+uint(7))&uint(18446744073709551608))
	p = (*struct_Index)(sqlite3DbMallocZero(db, uint64(nByte+nExtra)))
	if p != nil {
		var pExtra *int8 = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p)))) + uintptr((112+uint(7))&uint(18446744073709551608))))
		p.azColl = (**int8)(unsafe.Pointer(pExtra))
		*(*uintptr)(unsafe.Pointer(&pExtra)) += uintptr((8*uint(nCol) + uint(7)) & uint(18446744073709551608))
		p.aiRowLogEst = (*int16)(unsafe.Pointer(pExtra))
		*(*uintptr)(unsafe.Pointer(&pExtra)) += uintptr(2 * uint(int32(nCol)+1))
		p.aiColumn = (*int16)(unsafe.Pointer(pExtra))
		*(*uintptr)(unsafe.Pointer(&pExtra)) += uintptr(2 * uint(nCol))
		p.aSortOrder = (*uint8)(unsafe.Pointer(pExtra))
		p.nColumn = uint16(nCol)
		p.nKeyCol = uint16(int32(nCol) - 1)
		*ppExtra = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p)))) + uintptr(nByte)))
	}
	return p
}
func sqlite3HasExplicitNulls(pParse *struct_Parse, pList *struct_ExprList) int32 {
	if pList != nil {
		var i int32
		for i = int32(0); i < pList.nExpr; i++ {
			if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).Xbf_0>>5&1 != 0 {
				var sf uint8 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).sortFlags
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'N', 'U', 'L', 'L', 'S', ' ', '%', 's', '\x00'})), func() *int8 {
					if int32(sf) == 0 || int32(sf) == 3 {
						return (*int8)(unsafe.Pointer(&[6]int8{'F', 'I', 'R', 'S', 'T', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[5]int8{'L', 'A', 'S', 'T', '\x00'}))
					}
				}())
				return int32(1)
			}
		}
	}
	return int32(0)
}
func sqlite3CreateIndex(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token, pTblName *struct_SrcList, pList *struct_ExprList, onError int32, pStart *struct_Token, pPIWhere *struct_Expr, sortOrder int32, ifNotExist int32, idxType uint8) {
	var pTab *struct_Table = nil
	var pIndex *struct_Index = nil
	var zName *int8 = nil
	var nName int32
	var i int32
	var j int32
	var sFix struct_DbFixer
	var sortOrderMask int32
	var db *struct_sqlite3 = pParse.db
	var pDb *struct_Db
	var iDb int32
	var pName *struct_Token = nil
	var pListItem *struct_ExprList_item
	var nExtra int32 = 0
	var nExtraCol int32
	var zExtra *int8 = nil
	var pPk *struct_Index = nil
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		goto exit_create_index
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(pParse.eParseMode) == 1 && int32(idxType) != 2 {
		goto exit_create_index
	}
	if 0 != sqlite3ReadSchema(pParse) {
		goto exit_create_index
	}
	if sqlite3HasExplicitNulls(pParse, pList) != 0 {
		goto exit_create_index
	}
	if uintptr(unsafe.Pointer(pTblName)) != uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName)
		if iDb < 0 {
			goto exit_create_index
		}
		func() int {
			_ = 0
			return 0
		}()
		if !(db.init.busy != 0) {
			pTab = sqlite3SrcListLookup(pParse, pTblName)
			if pName2.n == uint32(0) && pTab != nil && uintptr(unsafe.Pointer(pTab.pSchema)) == uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema)) {
				iDb = int32(1)
			}
		}
		sqlite3FixInit(&sFix, pParse, iDb, (*int8)(unsafe.Pointer(&[6]int8{'i', 'n', 'd', 'e', 'x', '\x00'})), pName)
		if sqlite3FixSrcList(&sFix, pTblName) != 0 {
			func() int {
				_ = 0
				return 0
			}()
		}
		pTab = sqlite3LocateTableItem(pParse, uint32(0), &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTblName.a)))) + uintptr(0)*112)))
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
			goto exit_create_index
		}
		if iDb == 1 && uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema)) != uintptr(unsafe.Pointer(pTab.pSchema)) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[50]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'a', ' ', 'T', 'E', 'M', 'P', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'n', ' ', 'n', 'o', 'n', '-', 'T', 'E', 'M', 'P', ' ', 't', 'a', 'b', 'l', 'e', ' ', '"', '%', 's', '"', '\x00'})), pTab.zName)
			goto exit_create_index
		}
		if !(pTab.tabFlags&uint32(128) == uint32(0)) {
			pPk = sqlite3PrimaryKeyIndex(pTab)
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pTab = pParse.pNewTable
		if !(pTab != nil) {
			goto exit_create_index
		}
		iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	}
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3_strnicmp(pTab.zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) == 0 && int32(db.init.busy) == 0 && uintptr(unsafe.Pointer(pTblName)) != uintptr(unsafe.Pointer(nil)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'i', 'n', 'd', 'e', 'x', 'e', 'd', '\x00'})), pTab.zName)
		goto exit_create_index
	}
	if int32(pTab.eTabType) == 2 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[25]int8{'v', 'i', 'e', 'w', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'i', 'n', 'd', 'e', 'x', 'e', 'd', '\x00'})))
		goto exit_create_index
	}
	if int32(pTab.eTabType) == 1 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'i', 'n', 'd', 'e', 'x', 'e', 'd', '\x00'})))
		goto exit_create_index
	}
	if pName != nil {
		zName = sqlite3NameFromToken(db, pName)
		if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
			goto exit_create_index
		}
		func() int {
			_ = 0
			return 0
		}()
		if 0 != sqlite3CheckObjectName(pParse, zName, (*int8)(unsafe.Pointer(&[6]int8{'i', 'n', 'd', 'e', 'x', '\x00'})), pTab.zName) {
			goto exit_create_index
		}
		if !(int32(pParse.eParseMode) >= 2) {
			if !(db.init.busy != 0) {
				if uintptr(unsafe.Pointer(sqlite3FindTable(db, zName, nil))) != uintptr(unsafe.Pointer(nil)) {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'t', 'h', 'e', 'r', 'e', ' ', 'i', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'a', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'n', 'a', 'm', 'e', 'd', ' ', '%', 's', '\x00'})), zName)
					goto exit_create_index
				}
			}
			if uintptr(unsafe.Pointer(sqlite3FindIndex(db, zName, pDb.zDbSName))) != uintptr(unsafe.Pointer(nil)) {
				if !(ifNotExist != 0) {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[24]int8{'i', 'n', 'd', 'e', 'x', ' ', '%', 's', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'e', 'x', 'i', 's', 't', 's', '\x00'})), zName)
				} else {
					func() int {
						_ = 0
						return 0
					}()
					sqlite3CodeVerifySchema(pParse, iDb)
					sqlite3ForceNotReadOnly(pParse)
				}
				goto exit_create_index
			}
		}
	} else {
		var n int32
		var pLoop *struct_Index
		for func() int32 {
			pLoop = pTab.pIndex
			return func() (_cgo_ret int32) {
				_cgo_addr := &n
				*_cgo_addr = int32(1)
				return *_cgo_addr
			}()
		}(); pLoop != nil; func() int32 {
			pLoop = pLoop.pNext
			return func() (_cgo_ret int32) {
				_cgo_addr := &n
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
		}() {
		}
		zName = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[23]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'a', 'u', 't', 'o', 'i', 'n', 'd', 'e', 'x', '_', '%', 's', '_', '%', 'd', '\x00'})), pTab.zName, n)
		if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
			goto exit_create_index
		}
		if int32(pParse.eParseMode) != 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(7)))++
		}
	}
	if !(int32(pParse.eParseMode) >= 2) {
		var zDb *int8 = pDb.zDbSName
		if sqlite3AuthCheck(pParse, 18, func() *int8 {
			if true && iDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}(), nil, zDb) != 0 {
			goto exit_create_index
		}
		i = int32(1)
		if true && iDb == 1 {
			i = int32(3)
		}
		if sqlite3AuthCheck(pParse, i, zName, pTab.zName, zDb) != 0 {
			goto exit_create_index
		}
	}
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		var prevCol struct_Token
		var pCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(int32(pTab.nCol)-1)*20))
		pCol.colFlags |= uint16(8)
		sqlite3TokenInit(&prevCol, pCol.zCnName)
		pList = sqlite3ExprListAppend(pParse, nil, sqlite3ExprAlloc(db, 59, &prevCol, 0))
		if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
			goto exit_create_index
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3ExprListSetSortOrder(pList, sortOrder, -1)
	} else {
		sqlite3ExprListCheckLength(pParse, pList, (*int8)(unsafe.Pointer(&[6]int8{'i', 'n', 'd', 'e', 'x', '\x00'})))
		if pParse.nErr != 0 {
			goto exit_create_index
		}
	}
	for i = int32(0); i < pList.nExpr; i++ {
		var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr
		func() int {
			_ = 0
			return 0
		}()
		if int32(pExpr.op) == 113 {
			func() int {
				_ = 0
				return 0
			}()
			nExtra += 1 + sqlite3Strlen30(pExpr.u.zToken)
		}
	}
	nName = sqlite3Strlen30(zName)
	nExtraCol = func() int32 {
		if pPk != nil {
			return int32(pPk.nKeyCol)
		} else {
			return 1
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	pIndex = sqlite3AllocateIndexObject(db, int16(pList.nExpr+nExtraCol), nName+nExtra+1, &zExtra)
	if db.mallocFailed != 0 {
		goto exit_create_index
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pIndex.zName = zExtra
	*(*uintptr)(unsafe.Pointer(&zExtra)) += uintptr(nName + 1)
	__builtin___memcpy_chk(unsafe.Pointer(pIndex.zName), unsafe.Pointer(zName), uint(nName+1), __builtin_object_size(unsafe.Pointer(pIndex.zName), 0))
	pIndex.pTable = pTab
	pIndex.onError = uint8(onError)
	{
		_autoGo_62 := &pIndex.Xbf_0
		*_autoGo_62 = *_autoGo_62&^8 | func() uint32 {
			if onError != 0 {
				return 1
			} else {
				return 0
			}
		}()&1<<3
	}
	{
		_autoGo_63 := &pIndex.Xbf_0
		*_autoGo_63 = *_autoGo_63&^3 | uint32(idxType)&3
	}
	pIndex.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	pIndex.nKeyCol = uint16(pList.nExpr)
	if pPIWhere != nil {
		sqlite3ResolveSelfReference(pParse, pTab, 2, pPIWhere, nil)
		pIndex.pPartIdxWhere = pPIWhere
		pPIWhere = (*struct_Expr)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(pDb.pSchema.file_format) >= 4 {
		sortOrderMask = int32(-1)
	} else {
		sortOrderMask = int32(0)
	}
	pListItem = (*struct_ExprList_item)(unsafe.Pointer(&pList.a))
	if int32(pParse.eParseMode) >= 2 {
		pIndex.aColExpr = pList
		pList = (*struct_ExprList)(nil)
	}
	for i = int32(0); i < int32(pIndex.nKeyCol); func() *struct_ExprList_item {
		i++
		return func() (_cgo_ret *struct_ExprList_item) {
			_cgo_addr := &pListItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		var pCExpr *struct_Expr
		var requestedSortOrder int32
		var zColl *int8
		sqlite3StringToId(pListItem.pExpr)
		sqlite3ResolveSelfReference(pParse, pTab, 32, pListItem.pExpr, nil)
		if pParse.nErr != 0 {
			goto exit_create_index
		}
		pCExpr = sqlite3ExprSkipCollate(pListItem.pExpr)
		if int32(pCExpr.op) != 167 {
			if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(pParse.pNewTable)) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[61]int8{'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', 's', ' ', 'p', 'r', 'o', 'h', 'i', 'b', 'i', 't', 'e', 'd', ' ', 'i', 'n', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', ' ', 'a', 'n', 'd', ' ', 'U', 'N', 'I', 'Q', 'U', 'E', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', 's', '\x00'})))
				goto exit_create_index
			}
			if uintptr(unsafe.Pointer(pIndex.aColExpr)) == uintptr(unsafe.Pointer(nil)) {
				pIndex.aColExpr = pList
				pList = (*struct_ExprList)(nil)
			}
			j = int32(-2)
			*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(i)*2)) = int16(-2)
			{
				_autoGo_64 := &pIndex.Xbf_0
				*_autoGo_64 = *_autoGo_64&^8 | uint32(0)&1<<3
			}
		} else {
			j = int32(pCExpr.iColumn)
			func() int {
				_ = 0
				return 0
			}()
			if j < 0 {
				j = int32(pTab.iPKey)
			} else {
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).Xbf_0&15) == 0 {
					{
						_autoGo_65 := &pIndex.Xbf_0
						*_autoGo_65 = *_autoGo_65&^8 | uint32(0)&1<<3
					}
				}
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).colFlags)&32 != 0 {
					{
						_autoGo_66 := &pIndex.Xbf_0
						*_autoGo_66 = *_autoGo_66&^1024 | uint32(1)&1<<10
					}
				}
			}
			*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(i)*2)) = int16(j)
		}
		zColl = (*int8)(nil)
		if int32(pListItem.pExpr.op) == 113 {
			var nColl int32
			func() int {
				_ = 0
				return 0
			}()
			zColl = pListItem.pExpr.u.zToken
			nColl = sqlite3Strlen30(zColl) + 1
			func() int {
				_ = 0
				return 0
			}()
			__builtin___memcpy_chk(unsafe.Pointer(zExtra), unsafe.Pointer(zColl), uint(nColl), __builtin_object_size(unsafe.Pointer(zExtra), 0))
			zColl = zExtra
			*(*uintptr)(unsafe.Pointer(&zExtra)) += uintptr(nColl)
			nExtra -= nColl
		} else if j >= 0 {
			zColl = sqlite3ColumnColl(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20)))
		}
		if !(zColl != nil) {
			zColl = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
		}
		if !(db.init.busy != 0) && !(sqlite3LocateCollSeq(pParse, zColl) != nil) {
			goto exit_create_index
		}
		*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.azColl)) + uintptr(i)*8)) = zColl
		requestedSortOrder = int32(pListItem.sortFlags) & sortOrderMask
		*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aSortOrder)) + uintptr(i))) = uint8(requestedSortOrder)
	}
	if pPk != nil {
		for j = int32(0); j < int32(pPk.nKeyCol); j++ {
			var x int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(j)*2)))
			func() int {
				_ = 0
				return 0
			}()
			if isDupColumn(pIndex, int32(pIndex.nKeyCol), pPk, j) != 0 {
				pIndex.nColumn--
			} else {
				*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(i)*2)) = int16(x)
				*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.azColl)) + uintptr(i)*8)) = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(j)*8))
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aSortOrder)) + uintptr(i))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aSortOrder)) + uintptr(j)))
				i++
			}
		}
		func() int {
			_ = 0
			return 0
		}()
	} else {
		*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(i)*2)) = int16(-1)
		*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.azColl)) + uintptr(i)*8)) = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
	}
	sqlite3DefaultRowEst(pIndex)
	if uintptr(unsafe.Pointer(pParse.pNewTable)) == uintptr(unsafe.Pointer(nil)) {
		estimateIndexWidth(pIndex)
	}
	func() int {
		_ = 0
		return 0
	}()
	recomputeColumnsNotIndexed(pIndex)
	if uintptr(unsafe.Pointer(pTblName)) != uintptr(unsafe.Pointer(nil)) && int32(pIndex.nColumn) >= int32(pTab.nCol) {
		{
			_autoGo_67 := &pIndex.Xbf_0
			*_autoGo_67 = *_autoGo_67&^32 | uint32(1)&1<<5
		}
		for j = int32(0); j < int32(pTab.nCol); j++ {
			if j == int32(pTab.iPKey) {
				continue
			}
			if int32(sqlite3TableColumnToIndex(pIndex, int16(j))) >= 0 {
				continue
			}
			{
				_autoGo_68 := &pIndex.Xbf_0
				*_autoGo_68 = *_autoGo_68&^32 | uint32(0)&1<<5
			}
			break
		}
	}
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(pParse.pNewTable)) {
		var pIdx *struct_Index
		for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			var k int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(pIdx.nKeyCol) != int32(pIndex.nKeyCol) {
				continue
			}
			for k = int32(0); k < int32(pIdx.nKeyCol); k++ {
				var z1 *int8
				var z2 *int8
				func() int {
					_ = 0
					return 0
				}()
				if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(k)*2))) != int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(k)*2))) {
					break
				}
				z1 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(k)*8))
				z2 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.azColl)) + uintptr(k)*8))
				if sqlite3StrICmp(z1, z2) != 0 {
					break
				}
			}
			if k == int32(pIdx.nKeyCol) {
				if int32(pIdx.onError) != int32(pIndex.onError) {
					if !(int32(pIdx.onError) == 11 || int32(pIndex.onError) == 11) {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[42]int8{'c', 'o', 'n', 'f', 'l', 'i', 'c', 't', 'i', 'n', 'g', ' ', 'O', 'N', ' ', 'C', 'O', 'N', 'F', 'L', 'I', 'C', 'T', ' ', 'c', 'l', 'a', 'u', 's', 'e', 's', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', '\x00'})), 0)
					}
					if int32(pIdx.onError) == 11 {
						pIdx.onError = pIndex.onError
					}
				}
				if int32(idxType) == 2 {
					{
						_autoGo_69 := &pIdx.Xbf_0
						*_autoGo_69 = *_autoGo_69&^3 | uint32(idxType)&3
					}
				}
				if int32(pParse.eParseMode) >= 2 {
					pIndex.pNext = pParse.pNewIndex
					pParse.pNewIndex = pIndex
					pIndex = (*struct_Index)(nil)
				}
				goto exit_create_index
			}
		}
	}
	if !(int32(pParse.eParseMode) >= 2) {
		func() int {
			_ = 0
			return 0
		}()
		if db.init.busy != 0 {
			var p *struct_Index
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pTblName)) != uintptr(unsafe.Pointer(nil)) {
				pIndex.tnum = db.init.newTnum
				if sqlite3IndexHasDuplicateRootPage(pIndex) != 0 {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '\x00'})))
					pParse.rc = sqlite3CorruptError(118252)
					goto exit_create_index
				}
			}
			p = (*struct_Index)(sqlite3HashInsert(&pIndex.pSchema.idxHash, pIndex.zName, unsafe.Pointer(pIndex)))
			if p != nil {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3OomFault(db)
				goto exit_create_index
			}
			db.mDbFlags |= uint32(1)
		} else if pTab.tabFlags&uint32(128) == uint32(0) || uintptr(unsafe.Pointer(pTblName)) != uintptr(unsafe.Pointer(nil)) {
			var v *struct_Vdbe
			var zStmt *int8
			var iMem int32 = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			v = sqlite3GetVdbe(pParse)
			if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
				goto exit_create_index
			}
			sqlite3BeginWriteOperation(pParse, 1, iDb)
			pIndex.tnum = uint32(sqlite3VdbeAddOp0(v, 182))
			sqlite3VdbeAddOp3(v, 146, iDb, iMem, 2)
			func() int {
				_ = 0
				return 0
			}()
			if pStart != nil {
				var n int32 = int32(uint32(int32(uintptr(unsafe.Pointer(pParse.sLastToken.z))-uintptr(unsafe.Pointer(pName.z)))) + pParse.sLastToken.n)
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pName.z)) + uintptr(n-1)))) == ';' {
					n--
				}
				zStmt = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[20]int8{'C', 'R', 'E', 'A', 'T', 'E', '%', 's', ' ', 'I', 'N', 'D', 'E', 'X', ' ', '%', '.', '*', 's', '\x00'})), func() *int8 {
					if onError == 0 {
						return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[8]int8{' ', 'U', 'N', 'I', 'Q', 'U', 'E', '\x00'}))
					}
				}(), n, pName.z)
			} else {
				zStmt = (*int8)(nil)
			}
			sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[59]int8{'I', 'N', 'S', 'E', 'R', 'T', ' ', 'I', 'N', 'T', 'O', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'V', 'A', 'L', 'U', 'E', 'S', '(', '\'', 'i', 'n', 'd', 'e', 'x', '\'', ',', '%', 'Q', ',', '%', 'Q', ',', '#', '%', 'd', ',', '%', 'Q', ')', ';', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, pIndex.zName, pTab.zName, iMem, zStmt)
			sqlite3DbFree(db, unsafe.Pointer(zStmt))
			if pTblName != nil {
				sqlite3RefillIndex(pParse, pIndex, iMem)
				sqlite3ChangeCookie(pParse, iDb)
				sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[27]int8{'n', 'a', 'm', 'e', '=', '\'', '%', 'q', '\'', ' ', 'A', 'N', 'D', ' ', 't', 'y', 'p', 'e', '=', '\'', 'i', 'n', 'd', 'e', 'x', '\'', '\x00'})), pIndex.zName), uint16(0))
				sqlite3VdbeAddOp2(v, 165, 0, 1)
			}
			sqlite3VdbeJumpHere(v, int32(pIndex.tnum))
		}
	}
	if int32(db.init.busy) != 0 || uintptr(unsafe.Pointer(pTblName)) == uintptr(unsafe.Pointer(nil)) {
		pIndex.pNext = pTab.pIndex
		pTab.pIndex = pIndex
		pIndex = (*struct_Index)(nil)
	} else if int32(pParse.eParseMode) >= 2 {
		func() int {
			_ = 0
			return 0
		}()
		pParse.pNewIndex = pIndex
		pIndex = (*struct_Index)(nil)
	}
exit_create_index:
	if pIndex != nil {
		sqlite3FreeIndex(db, pIndex)
	}
	if pTab != nil {
		var ppFrom **struct_Index
		var pThis *struct_Index
		for ppFrom = &pTab.pIndex; uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pThis
			*_cgo_addr = *ppFrom
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)); ppFrom = &pThis.pNext {
			var pNext *struct_Index
			if int32(pThis.onError) != 5 {
				continue
			}
			for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Index) {
				_cgo_addr := &pNext
				*_cgo_addr = pThis.pNext
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) && int32(pNext.onError) != 5 {
				*ppFrom = pNext
				pThis.pNext = pNext.pNext
				pNext.pNext = pThis
				ppFrom = &pNext.pNext
			}
			break
		}
	}
	sqlite3ExprDelete(db, pPIWhere)
	sqlite3ExprListDelete(db, pList)
	sqlite3SrcListDelete(db, pTblName)
	sqlite3DbFree(db, unsafe.Pointer(zName))
}
func sqlite3DefaultRowEst(pIdx *struct_Index) {
	var aVal [5]int16 = [5]int16{int16(33), int16(32), int16(30), int16(28), int16(26)}
	var a *int16 = pIdx.aiRowLogEst
	var x int16
	var nCopy int32 = func() int32 {
		if int32(10/2) < int32(pIdx.nKeyCol) {
			return int32(10 / 2)
		} else {
			return int32(pIdx.nKeyCol)
		}
	}()
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	x = pIdx.pTable.nRowLogEst
	func() int {
		_ = 0
		return 0
	}()
	if int32(x) < 99 {
		pIdx.pTable.nRowLogEst = func() (_cgo_ret int16) {
			_cgo_addr := &x
			*_cgo_addr = int16(99)
			return *_cgo_addr
		}()
	}
	if uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) != uintptr(unsafe.Pointer(nil)) {
		x -= int16(10)
		func() int {
			_ = 0
			return 0
		}()
	}
	*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(0)*2)) = x
	__builtin___memcpy_chk(unsafe.Pointer(&*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(1)*2))), unsafe.Pointer((*int16)(unsafe.Pointer(&aVal))), uint(nCopy)*2, __builtin_object_size(unsafe.Pointer(&*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(1)*2))), 0))
	for i = nCopy + 1; i <= int32(pIdx.nKeyCol); i++ {
		*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(i)*2)) = int16(23)
		func() int {
			_ = 0
			return 0
		}()
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(pIdx.onError) != 0 {
		*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(pIdx.nKeyCol)*2)) = int16(0)
	}
}
func sqlite3DropIndex(pParse *struct_Parse, pName *struct_SrcList, ifExists int32) {
	var pIndex *struct_Index
	var v *struct_Vdbe
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	if db.mallocFailed != 0 {
		goto exit_drop_index
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if 0 != sqlite3ReadSchema(pParse) {
		goto exit_drop_index
	}
	pIndex = sqlite3FindIndex(db, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112))).zName, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112))).zDatabase)
	if uintptr(unsafe.Pointer(pIndex)) == uintptr(unsafe.Pointer(nil)) {
		if !(ifExists != 0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'i', 'n', 'd', 'e', 'x', ':', ' ', '%', 'S', '\x00'})), (*struct_SrcItem)(unsafe.Pointer(&pName.a)))
		} else {
			sqlite3CodeVerifyNamedSchema(pParse, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112))).zDatabase)
			sqlite3ForceNotReadOnly(pParse)
		}
		pParse.checkSchema = uint8(1)
		goto exit_drop_index
	}
	if int32(pIndex.Xbf_0&3) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[73]int8{'i', 'n', 'd', 'e', 'x', ' ', 'a', 's', 's', 'o', 'c', 'i', 'a', 't', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 'U', 'N', 'I', 'Q', 'U', 'E', ' ', 'o', 'r', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'd', 'r', 'o', 'p', 'p', 'e', 'd', '\x00'})), 0)
		goto exit_drop_index
	}
	iDb = sqlite3SchemaToIndex(db, pIndex.pSchema)
	{
		var code int32 = 10
		var pTab *struct_Table = pIndex.pTable
		var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
		var zTab *int8 = func() *int8 {
			if true && iDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}()
		if sqlite3AuthCheck(pParse, 9, zTab, nil, zDb) != 0 {
			goto exit_drop_index
		}
		if true && iDb == 1 {
			code = int32(12)
		}
		if sqlite3AuthCheck(pParse, code, pIndex.zName, pTab.zName, zDb) != 0 {
			goto exit_drop_index
		}
	}
	v = sqlite3GetVdbe(pParse)
	if v != nil {
		sqlite3BeginWriteOperation(pParse, 1, iDb)
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[60]int8{'D', 'E', 'L', 'E', 'T', 'E', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'A', 'N', 'D', ' ', 't', 'y', 'p', 'e', '=', '\'', 'i', 'n', 'd', 'e', 'x', '\'', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, pIndex.zName)
		sqlite3ClearStatTables(pParse, iDb, (*int8)(unsafe.Pointer(&[4]int8{'i', 'd', 'x', '\x00'})), pIndex.zName)
		sqlite3ChangeCookie(pParse, iDb)
		destroyRootPage(pParse, int32(pIndex.tnum), iDb)
		sqlite3VdbeAddOp4(v, 151, iDb, 0, 0, pIndex.zName, 0)
	}
exit_drop_index:
	sqlite3SrcListDelete(db, pName)
}
func sqlite3ArrayAllocate(db *struct_sqlite3, pArray unsafe.Pointer, szEntry int32, pnEntry *int32, pIdx *int32) unsafe.Pointer {
	var z *int8
	var n int64 = int64(func() (_cgo_ret int32) {
		_cgo_addr := &*pIdx
		*_cgo_addr = *pnEntry
		return *_cgo_addr
	}())
	if n&(n-int64(1)) == int64(0) {
		var sz int64 = func() int64 {
			if n == int64(0) {
				return int64(1)
			} else {
				return int64(2) * n
			}
		}()
		var pNew unsafe.Pointer = sqlite3DbRealloc(db, pArray, uint64(sz*int64(szEntry)))
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			*pIdx = int32(-1)
			return pArray
		}
		pArray = pNew
	}
	z = (*int8)(pArray)
	__builtin___memset_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n*int64(szEntry))))), 0, uint(szEntry), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n*int64(szEntry))))), 0))
	*pnEntry++
	return pArray
}
func sqlite3IdListAppend(pParse *struct_Parse, pList *struct_IdList, pToken *struct_Token) *struct_IdList {
	var db *struct_sqlite3 = pParse.db
	var i int32
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		pList = (*struct_IdList)(sqlite3DbMallocZero(db, uint64(12)))
		if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
			return (*struct_IdList)(nil)
		}
	}
	pList.a = (*struct_IdList_item)(sqlite3ArrayAllocate(db, unsafe.Pointer(pList.a), int32(12), &pList.nId, &i))
	if i < 0 {
		sqlite3IdListDelete(db, pList)
		return (*struct_IdList)(nil)
	}
	(*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.a)) + uintptr(i)*12))).zName = sqlite3NameFromToken(db, pToken)
	if int32(pParse.eParseMode) >= 2 && (*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.a)) + uintptr(i)*12))).zName != nil {
		sqlite3RenameTokenMap(pParse, unsafe.Pointer((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.a)) + uintptr(i)*12))).zName), pToken)
	}
	return pList
}
func sqlite3IdListDelete(db *struct_sqlite3, pList *struct_IdList) {
	var i int32
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	for i = int32(0); i < pList.nId; i++ {
		sqlite3DbFree(db, unsafe.Pointer((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.a)) + uintptr(i)*12))).zName))
	}
	sqlite3DbFree(db, unsafe.Pointer(pList.a))
	sqlite3DbFreeNN(db, unsafe.Pointer(pList))
}
func sqlite3IdListIndex(pList *struct_IdList, zName *int8) int32 {
	var i int32
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return int32(-1)
	}
	for i = int32(0); i < pList.nId; i++ {
		if sqlite3StrICmp((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.a)) + uintptr(i)*12))).zName, zName) == 0 {
			return i
		}
	}
	return int32(-1)
}
func sqlite3SrcListEnlarge(pParse *struct_Parse, pSrc *struct_SrcList, nExtra int32, iStart int32) *struct_SrcList {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uint32(pSrc.nSrc)+uint32(nExtra) > pSrc.nAlloc {
		var pNew *struct_SrcList
		var nAlloc int64 = int64(2)*int64(pSrc.nSrc) + int64(nExtra)
		var db *struct_sqlite3 = pParse.db
		if pSrc.nSrc+nExtra >= 200 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[36]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'F', 'R', 'O', 'M', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 't', 'e', 'r', 'm', 's', ',', ' ', 'm', 'a', 'x', ':', ' ', '%', 'd', '\x00'})), 200)
			return (*struct_SrcList)(nil)
		}
		if nAlloc > int64(200) {
			nAlloc = int64(200)
		}
		pNew = (*struct_SrcList)(sqlite3DbRealloc(db, unsafe.Pointer(pSrc), uint64(120)+uint64(nAlloc-int64(1))*uint64(112)))
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			return (*struct_SrcList)(nil)
		}
		pSrc = pNew
		pSrc.nAlloc = uint32(nAlloc)
	}
	for i = pSrc.nSrc - 1; i >= iStart; i-- {
		*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i+nExtra)*112)) = *(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))
	}
	pSrc.nSrc += nExtra
	__builtin___memset_chk(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(iStart)*112))), 0, 112*uint(nExtra), __builtin_object_size(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(iStart)*112))), 0))
	for i = iStart; i < iStart+nExtra; i++ {
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).iCursor = int32(-1)
	}
	return pSrc
}
func sqlite3SrcListAppend(pParse *struct_Parse, pList *struct_SrcList, pTable *struct_Token, pDatabase *struct_Token) *struct_SrcList {
	var pItem *struct_SrcItem
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		pList = (*struct_SrcList)(sqlite3DbMallocRawNN(pParse.db, uint64(120)))
		if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
			return (*struct_SrcList)(nil)
		}
		pList.nAlloc = uint32(1)
		pList.nSrc = int32(1)
		__builtin___memset_chk(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pList.a)))) + uintptr(0)*112))), 0, 112, __builtin_object_size(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pList.a)))) + uintptr(0)*112))), 0))
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pList.a)))) + uintptr(0)*112))).iCursor = int32(-1)
	} else {
		var pNew *struct_SrcList = sqlite3SrcListEnlarge(pParse, pList, 1, pList.nSrc)
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3SrcListDelete(db, pList)
			return (*struct_SrcList)(nil)
		} else {
			pList = pNew
		}
	}
	pItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pList.a)))) + uintptr(pList.nSrc-1)*112))
	if pDatabase != nil && uintptr(unsafe.Pointer(pDatabase.z)) == uintptr(unsafe.Pointer(nil)) {
		pDatabase = (*struct_Token)(nil)
	}
	if pDatabase != nil {
		pItem.zName = sqlite3NameFromToken(db, pDatabase)
		pItem.zDatabase = sqlite3NameFromToken(db, pTable)
	} else {
		pItem.zName = sqlite3NameFromToken(db, pTable)
		pItem.zDatabase = (*int8)(nil)
	}
	return pList
}
func sqlite3SrcListAssignCursors(pParse *struct_Parse, pList *struct_SrcList) {
	var i int32
	var pItem *struct_SrcItem
	func() int {
		_ = 0
		return 0
	}()
	if pList != nil {
		for func() *struct_SrcItem {
			i = int32(0)
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pList.a))
				return *_cgo_addr
			}()
		}(); i < pList.nSrc; func() *struct_SrcItem {
			i++
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
				return
			}()
		}() {
			if pItem.iCursor >= 0 {
				continue
			}
			pItem.iCursor = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			if pItem.pSelect != nil {
				sqlite3SrcListAssignCursors(pParse, pItem.pSelect.pSrc)
			}
		}
	}
}
func sqlite3SrcListDelete(db *struct_sqlite3, pList *struct_SrcList) {
	var i int32
	var pItem *struct_SrcItem
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	for func() int32 {
		pItem = (*struct_SrcItem)(unsafe.Pointer(&pList.a))
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); i < pList.nSrc; func() *struct_SrcItem {
		i++
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		if pItem.zDatabase != nil {
			sqlite3DbFreeNN(db, unsafe.Pointer(pItem.zDatabase))
		}
		sqlite3DbFree(db, unsafe.Pointer(pItem.zName))
		if pItem.zAlias != nil {
			sqlite3DbFreeNN(db, unsafe.Pointer(pItem.zAlias))
		}
		if pItem.fg.Xbf_0>>1&1 != 0 {
			sqlite3DbFree(db, unsafe.Pointer(pItem.u1.zIndexedBy))
		}
		if pItem.fg.Xbf_0>>2&1 != 0 {
			sqlite3ExprListDelete(db, *(**struct_ExprList)(unsafe.Pointer(&pItem.u1)))
		}
		sqlite3DeleteTable(db, pItem.pTab)
		if pItem.pSelect != nil {
			sqlite3SelectDelete(db, pItem.pSelect)
		}
		if pItem.pOn != nil {
			sqlite3ExprDelete(db, pItem.pOn)
		}
		if pItem.pUsing != nil {
			sqlite3IdListDelete(db, pItem.pUsing)
		}
	}
	sqlite3DbFreeNN(db, unsafe.Pointer(pList))
}
func sqlite3SrcListAppendFromTerm(pParse *struct_Parse, p *struct_SrcList, pTable *struct_Token, pDatabase *struct_Token, pAlias *struct_Token, pSubquery *struct_Select, pOn *struct_Expr, pUsing *struct_IdList) *struct_SrcList {
	var pItem *struct_SrcItem
	var db *struct_sqlite3 = pParse.db
	if !(p != nil) && (pOn != nil || pUsing != nil) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[36]int8{'a', ' ', 'J', 'O', 'I', 'N', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'i', 's', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 'd', ' ', 'b', 'e', 'f', 'o', 'r', 'e', ' ', '%', 's', '\x00'})), func() *int8 {
			if pOn != nil {
				return (*int8)(unsafe.Pointer(&[3]int8{'O', 'N', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[6]int8{'U', 'S', 'I', 'N', 'G', '\x00'}))
			}
		}())
		goto append_from_error
	}
	p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		goto append_from_error
	}
	func() int {
		_ = 0
		return 0
	}()
	pItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(p.nSrc-1)*112))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pParse.eParseMode) >= 2 && pItem.zName != nil {
		var pToken *struct_Token = func() *struct_Token {
			if pDatabase != nil && pDatabase.z != nil {
				return pDatabase
			} else {
				return pTable
			}
		}()
		sqlite3RenameTokenMap(pParse, unsafe.Pointer(pItem.zName), pToken)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pAlias.n != 0 {
		pItem.zAlias = sqlite3NameFromToken(db, pAlias)
	}
	pItem.pSelect = pSubquery
	pItem.pOn = pOn
	pItem.pUsing = pUsing
	return p
append_from_error:
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ExprDelete(db, pOn)
	sqlite3IdListDelete(db, pUsing)
	sqlite3SelectDelete(db, pSubquery)
	return (*struct_SrcList)(nil)
}
func sqlite3SrcListIndexedBy(pParse *struct_Parse, p *struct_SrcList, pIndexedBy *struct_Token) {
	func() int {
		_ = 0
		return 0
	}()
	if p != nil && pIndexedBy.n > uint32(0) {
		var pItem *struct_SrcItem
		func() int {
			_ = 0
			return 0
		}()
		pItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(p.nSrc-1)*112))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pIndexedBy.n == uint32(1) && !(pIndexedBy.z != nil) {
			{
				_autoGo_70 := &pItem.fg.Xbf_0
				*_autoGo_70 = *_autoGo_70&^1 | uint32(1)&1
			}
		} else {
			pItem.u1.zIndexedBy = sqlite3NameFromToken(pParse.db, pIndexedBy)
			{
				_autoGo_71 := &pItem.fg.Xbf_0
				*_autoGo_71 = *_autoGo_71&^2 | uint32(1)&1<<1
			}
			func() int {
				_ = 0
				return 0
			}()
		}
	}
}
func sqlite3SrcListAppendList(pParse *struct_Parse, p1 *struct_SrcList, p2 *struct_SrcList) *struct_SrcList {
	func() int {
		_ = 0
		return 0
	}()
	if p2 != nil {
		var pNew *struct_SrcList = sqlite3SrcListEnlarge(pParse, p1, p2.nSrc, 1)
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3SrcListDelete(pParse.db, p2)
		} else {
			p1 = pNew
			__builtin___memcpy_chk(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p1.a)))) + uintptr(1)*112))), unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p2.a))), uint(p2.nSrc)*112, __builtin_object_size(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p1.a)))) + uintptr(1)*112))), 0))
			sqlite3DbFree(pParse.db, unsafe.Pointer(p2))
		}
	}
	return p1
}
func sqlite3SrcListFuncArgs(pParse *struct_Parse, p *struct_SrcList, pList *struct_ExprList) {
	if p != nil {
		var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(p.nSrc-1)*112))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		*(**struct_ExprList)(unsafe.Pointer(&pItem.u1)) = pList
		{
			_autoGo_72 := &pItem.fg.Xbf_0
			*_autoGo_72 = *_autoGo_72&^4 | uint32(1)&1<<2
		}
	} else {
		sqlite3ExprListDelete(pParse.db, pList)
	}
}
func sqlite3SrcListShiftJoinType(p *struct_SrcList) {
	if p != nil {
		var i int32
		for i = p.nSrc - 1; i > 0; i-- {
			(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(i)*112))).fg.jointype = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(i-1)*112))).fg.jointype
		}
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.a)))) + uintptr(0)*112))).fg.jointype = uint8(0)
	}
}
func sqlite3BeginTransaction(pParse *struct_Parse, type_ int32) {
	var db *struct_sqlite3
	var v *struct_Vdbe
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3AuthCheck(pParse, 22, (*int8)(unsafe.Pointer(&[6]int8{'B', 'E', 'G', 'I', 'N', '\x00'})), nil, nil) != 0 {
		return
	}
	v = sqlite3GetVdbe(pParse)
	if !(v != nil) {
		return
	}
	if type_ != 7 {
		for i = int32(0); i < db.nDb; i++ {
			var eTxnType int32
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if pBt != nil && sqlite3BtreeIsReadonly(pBt) != 0 {
				eTxnType = int32(0)
			} else if type_ == 9 {
				eTxnType = int32(2)
			} else {
				eTxnType = int32(1)
			}
			sqlite3VdbeAddOp2(v, 2, i, eTxnType)
			sqlite3VdbeUsesBtree(v, i)
		}
	}
	sqlite3VdbeAddOp0(v, 1)
}
func sqlite3EndTransaction(pParse *struct_Parse, eType int32) {
	var v *struct_Vdbe
	var isRollback int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	isRollback = func() int32 {
		if eType == 12 {
			return 1
		} else {
			return 0
		}
	}()
	if sqlite3AuthCheck(pParse, 22, func() *int8 {
		if isRollback != 0 {
			return (*int8)(unsafe.Pointer(&[9]int8{'R', 'O', 'L', 'L', 'B', 'A', 'C', 'K', '\x00'}))
		} else {
			return (*int8)(unsafe.Pointer(&[7]int8{'C', 'O', 'M', 'M', 'I', 'T', '\x00'}))
		}
	}(), nil, nil) != 0 {
		return
	}
	v = sqlite3GetVdbe(pParse)
	if v != nil {
		sqlite3VdbeAddOp2(v, 1, 1, isRollback)
	}
}
func sqlite3Savepoint(pParse *struct_Parse, op int32, pName *struct_Token) {
	var zName *int8 = sqlite3NameFromToken(pParse.db, pName)
	if zName != nil {
		var v *struct_Vdbe = sqlite3GetVdbe(pParse)
		var az [3]*int8 = [3]*int8{(*int8)(unsafe.Pointer(&[6]int8{'B', 'E', 'G', 'I', 'N', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'R', 'E', 'L', 'E', 'A', 'S', 'E', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'R', 'O', 'L', 'L', 'B', 'A', 'C', 'K', '\x00'}))}
		func() int {
			_ = 0
			return 0
		}()
		if !(v != nil) || sqlite3AuthCheck(pParse, 32, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&az)))) + uintptr(op)*8)), zName, nil) != 0 {
			sqlite3DbFree(pParse.db, unsafe.Pointer(zName))
			return
		}
		sqlite3VdbeAddOp4(v, 0, op, 0, 0, zName, -7)
	}
}
func sqlite3OpenTempDatabase(pParse *struct_Parse) int32 {
	var db *struct_sqlite3 = pParse.db
	if uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pBt)) == uintptr(unsafe.Pointer(nil)) && !(pParse.explain != 0) {
		var rc int32
		var pBt *struct_Btree
		var flags int32 = 2 | 4 | 16 | 8 | 512
		rc = sqlite3BtreeOpen(db.pVfs, nil, db, &pBt, 0, flags)
		if rc != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[70]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'o', 'p', 'e', 'n', ' ', 'a', ' ', 't', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'f', 'i', 'l', 'e', ' ', 'f', 'o', 'r', ' ', 's', 't', 'o', 'r', 'i', 'n', 'g', ' ', 't', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', ' ', 't', 'a', 'b', 'l', 'e', 's', '\x00'})))
			pParse.rc = rc
			return int32(1)
		}
		(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pBt = pBt
		func() int {
			_ = 0
			return 0
		}()
		if 7 == sqlite3BtreeSetPageSize(pBt, db.nextPagesize, 0, 0) {
			sqlite3OomFault(db)
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3CodeVerifySchemaAtToplevel(pToplevel *struct_Parse, iDb int32) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if func() int32 {
		if pToplevel.cookieMask&(uint32(1)<<iDb) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}() == 0 {
		pToplevel.cookieMask |= uint32(1) << iDb
		if true && iDb == 1 {
			sqlite3OpenTempDatabase(pToplevel)
		}
	}
}
func sqlite3CodeVerifySchema(pParse *struct_Parse, iDb int32) {
	sqlite3CodeVerifySchemaAtToplevel(func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}(), iDb)
}
func sqlite3CodeVerifyNamedSchema(pParse *struct_Parse, zDb *int8) {
	var db *struct_sqlite3 = pParse.db
	var i int32
	for i = int32(0); i < db.nDb; i++ {
		var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))
		if pDb.pBt != nil && (!(zDb != nil) || 0 == sqlite3StrICmp(zDb, pDb.zDbSName)) {
			sqlite3CodeVerifySchema(pParse, i)
		}
	}
}
func sqlite3BeginWriteOperation(pParse *struct_Parse, setStatement int32, iDb int32) {
	var pToplevel *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	sqlite3CodeVerifySchemaAtToplevel(pToplevel, iDb)
	pToplevel.writeMask |= uint32(1) << iDb
	pToplevel.isMultiWrite |= uint8(setStatement)
}
func sqlite3MultiWrite(pParse *struct_Parse) {
	var pToplevel *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	pToplevel.isMultiWrite = uint8(1)
}
func sqlite3MayAbort(pParse *struct_Parse) {
	var pToplevel *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	pToplevel.mayAbort = uint8(1)
}
func sqlite3HaltConstraint(pParse *struct_Parse, errCode int32, onError int32, p4 *int8, p4type int8, p5Errmsg uint8) {
	var v *struct_Vdbe
	func() int {
		_ = 0
		return 0
	}()
	v = sqlite3GetVdbe(pParse)
	func() int {
		_ = 0
		return 0
	}()
	if onError == 2 {
		sqlite3MayAbort(pParse)
	}
	sqlite3VdbeAddOp4(v, 70, errCode, onError, 0, p4, int32(p4type))
	sqlite3VdbeChangeP5(v, uint16(p5Errmsg))
}
func sqlite3UniqueConstraint(pParse *struct_Parse, onError int32, pIdx *struct_Index) {
	var zErr *int8
	var j int32
	var errMsg struct_sqlite3_str
	var pTab *struct_Table = pIdx.pTable
	sqlite3StrAccumInit(&errMsg, pParse.db, nil, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.db.aLimit)))) + uintptr(0)*4)))
	if pIdx.aColExpr != nil {
		sqlite3_str_appendf(&errMsg, (*int8)(unsafe.Pointer(&[11]int8{'i', 'n', 'd', 'e', 'x', ' ', '\'', '%', 'q', '\'', '\x00'})), pIdx.zName)
	} else {
		for j = int32(0); j < int32(pIdx.nKeyCol); j++ {
			var zCol *int8
			func() int {
				_ = 0
				return 0
			}()
			zCol = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2)))*20))).zCnName
			if j != 0 {
				sqlite3_str_append(&errMsg, (*int8)(unsafe.Pointer(&[3]int8{',', ' ', '\x00'})), 2)
			}
			sqlite3_str_appendall(&errMsg, pTab.zName)
			sqlite3_str_append(&errMsg, (*int8)(unsafe.Pointer(&[2]int8{'.', '\x00'})), 1)
			sqlite3_str_appendall(&errMsg, zCol)
		}
	}
	zErr = sqlite3StrAccumFinish(&errMsg)
	sqlite3HaltConstraint(pParse, func() int32 {
		if int32(pIdx.Xbf_0&3) == 2 {
			return 19 | 6<<8
		} else {
			return 19 | 8<<8
		}
	}(), onError, zErr, int8(-7), uint8(2))
}
func sqlite3RowidConstraint(pParse *struct_Parse, onError int32, pTab *struct_Table) {
	var zMsg *int8
	var rc int32
	if int32(pTab.iPKey) >= 0 {
		zMsg = sqlite3MPrintf(pParse.db, (*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 's', '\x00'})), pTab.zName, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(pTab.iPKey)*20))).zCnName)
		rc = int32(19 | 6<<8)
	} else {
		zMsg = sqlite3MPrintf(pParse.db, (*int8)(unsafe.Pointer(&[9]int8{'%', 's', '.', 'r', 'o', 'w', 'i', 'd', '\x00'})), pTab.zName)
		rc = int32(19 | 10<<8)
	}
	sqlite3HaltConstraint(pParse, rc, onError, zMsg, int8(-7), uint8(2))
}
func collationMatch(zColl *int8, pIndex *struct_Index) int32 {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < int32(pIndex.nColumn); i++ {
		var z *int8 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.azColl)) + uintptr(i)*8))
		func() int {
			_ = 0
			return 0
		}()
		if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(i)*2))) >= 0 && 0 == sqlite3StrICmp(z, zColl) {
			return int32(1)
		}
	}
	return int32(0)
}
func reindexTable(pParse *struct_Parse, pTab *struct_Table, zColl *int8) {
	if !(int32(pTab.eTabType) == 1) {
		var pIndex *struct_Index
		for pIndex = pTab.pIndex; pIndex != nil; pIndex = pIndex.pNext {
			if uintptr(unsafe.Pointer(zColl)) == uintptr(unsafe.Pointer(nil)) || collationMatch(zColl, pIndex) != 0 {
				var iDb int32 = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
				sqlite3BeginWriteOperation(pParse, 0, iDb)
				sqlite3RefillIndex(pParse, pIndex, -1)
			}
		}
	}
}
func reindexDatabases(pParse *struct_Parse, zColl *int8) {
	var pDb *struct_Db
	var iDb int32
	var db *struct_sqlite3 = pParse.db
	var k *struct_HashElem
	var pTab *struct_Table
	func() int {
		_ = 0
		return 0
	}()
	for func() *struct_Db {
		iDb = int32(0)
		return func() (_cgo_ret *struct_Db) {
			_cgo_addr := &pDb
			*_cgo_addr = db.aDb
			return *_cgo_addr
		}()
	}(); iDb < db.nDb; func() *struct_Db {
		iDb++
		return func() (_cgo_ret *struct_Db) {
			_cgo_addr := &pDb
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 32
			return
		}()
	}() {
		func() int {
			_ = 0
			return 0
		}()
		for k = (&pDb.pSchema.tblHash).first; k != nil; k = k.next {
			pTab = (*struct_Table)(k.data)
			reindexTable(pParse, pTab, zColl)
		}
	}
}
func sqlite3Reindex(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token) {
	var pColl *struct_CollSeq
	var z *int8
	var zDb *int8
	var pTab *struct_Table
	var pIndex *struct_Index
	var iDb int32
	var db *struct_sqlite3 = pParse.db
	var pObjName *struct_Token
	if 0 != sqlite3ReadSchema(pParse) {
		return
	}
	if uintptr(unsafe.Pointer(pName1)) == uintptr(unsafe.Pointer(nil)) {
		reindexDatabases(pParse, nil)
		return
	} else if uintptr(unsafe.Pointer(pName2)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pName2.z)) == uintptr(unsafe.Pointer(nil)) {
		var zColl *int8
		func() int {
			_ = 0
			return 0
		}()
		zColl = sqlite3NameFromToken(pParse.db, pName1)
		if !(zColl != nil) {
			return
		}
		pColl = sqlite3FindCollSeq(db, db.enc, zColl, 0)
		if pColl != nil {
			reindexDatabases(pParse, zColl)
			sqlite3DbFree(db, unsafe.Pointer(zColl))
			return
		}
		sqlite3DbFree(db, unsafe.Pointer(zColl))
	}
	iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName)
	if iDb < 0 {
		return
	}
	z = sqlite3NameFromToken(db, pObjName)
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	pTab = sqlite3FindTable(db, z, zDb)
	if pTab != nil {
		reindexTable(pParse, pTab, nil)
		sqlite3DbFree(db, unsafe.Pointer(z))
		return
	}
	pIndex = sqlite3FindIndex(db, z, zDb)
	sqlite3DbFree(db, unsafe.Pointer(z))
	if pIndex != nil {
		sqlite3BeginWriteOperation(pParse, 0, iDb)
		sqlite3RefillIndex(pParse, pIndex, -1)
		return
	}
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[46]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'i', 'd', 'e', 'n', 't', 'i', 'f', 'y', ' ', 't', 'h', 'e', ' ', 'o', 'b', 'j', 'e', 'c', 't', ' ', 't', 'o', ' ', 'b', 'e', ' ', 'r', 'e', 'i', 'n', 'd', 'e', 'x', 'e', 'd', '\x00'})))
}
func sqlite3KeyInfoOfIndex(pParse *struct_Parse, pIdx *struct_Index) *struct_KeyInfo {
	var i int32
	var nCol int32 = int32(pIdx.nColumn)
	var nKey int32 = int32(pIdx.nKeyCol)
	var pKey *struct_KeyInfo
	if pParse.nErr != 0 {
		return (*struct_KeyInfo)(nil)
	}
	if pIdx.Xbf_0>>3&1 != 0 {
		pKey = sqlite3KeyInfoAlloc(pParse.db, nKey, nCol-nKey)
	} else {
		pKey = sqlite3KeyInfoAlloc(pParse.db, nCol, 0)
	}
	if pKey != nil {
		func() int {
			_ = 0
			return 0
		}()
		for i = int32(0); i < nCol; i++ {
			var zColl *int8 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(i)*8))
			*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKey.aColl)))) + uintptr(i)*8)) = func() *struct_CollSeq {
				if uintptr(unsafe.Pointer(zColl)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sqlite3StrBINARY)))) {
					return nil
				} else {
					return sqlite3LocateCollSeq(pParse, zColl)
				}
			}()
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKey.aSortFlags)) + uintptr(i))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(i)))
			func() int {
				_ = 0
				return 0
			}()
		}
		if pParse.nErr != 0 {
			func() int {
				_ = 0
				return 0
			}()
			if int32(pIdx.Xbf_0>>8&1) == 0 {
				{
					_autoGo_73 := &pIdx.Xbf_0
					*_autoGo_73 = *_autoGo_73&^256 | uint32(1)&1<<8
				}
				pParse.rc = int32(1 | 2<<8)
			}
			sqlite3KeyInfoUnref(pKey)
			pKey = (*struct_KeyInfo)(nil)
		}
	}
	return pKey
}
func sqlite3CteNew(pParse *struct_Parse, pName *struct_Token, pArglist *struct_ExprList, pQuery *struct_Select, eM10d uint8) *struct_Cte {
	var pNew *struct_Cte
	var db *struct_sqlite3 = pParse.db
	pNew = (*struct_Cte)(sqlite3DbMallocZero(db, uint64(41)))
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		sqlite3ExprListDelete(db, pArglist)
		sqlite3SelectDelete(db, pQuery)
	} else {
		pNew.pSelect = pQuery
		pNew.pCols = pArglist
		pNew.zName = sqlite3NameFromToken(pParse.db, pName)
		pNew.eM10d = eM10d
	}
	return pNew
}
func cteClear(db *struct_sqlite3, pCte *struct_Cte) {
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ExprListDelete(db, pCte.pCols)
	sqlite3SelectDelete(db, pCte.pSelect)
	sqlite3DbFree(db, unsafe.Pointer(pCte.zName))
}
func sqlite3CteDelete(db *struct_sqlite3, pCte *struct_Cte) {
	func() int {
		_ = 0
		return 0
	}()
	cteClear(db, pCte)
	sqlite3DbFree(db, unsafe.Pointer(pCte))
}
func sqlite3WithAdd(pParse *struct_Parse, pWith *struct_With, pCte *struct_Cte) *struct_With {
	var db *struct_sqlite3 = pParse.db
	var pNew *struct_With
	var zName *int8
	if uintptr(unsafe.Pointer(pCte)) == uintptr(unsafe.Pointer(nil)) {
		return pWith
	}
	zName = pCte.zName
	if zName != nil && pWith != nil {
		var i int32
		for i = int32(0); i < pWith.nCte; i++ {
			if sqlite3StrICmp(zName, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pWith.a)))) + uintptr(i)*41))).zName) == 0 {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'d', 'u', 'p', 'l', 'i', 'c', 'a', 't', 'e', ' ', 'W', 'I', 'T', 'H', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'n', 'a', 'm', 'e', ':', ' ', '%', 's', '\x00'})), zName)
			}
		}
	}
	if pWith != nil {
		var nByte int64 = int64(57 + 41*uint(pWith.nCte))
		pNew = (*struct_With)(sqlite3DbRealloc(db, unsafe.Pointer(pWith), uint64(nByte)))
	} else {
		pNew = (*struct_With)(sqlite3DbMallocZero(db, uint64(57)))
	}
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		sqlite3CteDelete(db, pCte)
		pNew = pWith
	} else {
		*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pNew.a)))) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &pNew.nCte
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*41)) = *pCte
		sqlite3DbFree(db, unsafe.Pointer(pCte))
	}
	return pNew
}
func sqlite3WithDelete(db *struct_sqlite3, pWith *struct_With) {
	if pWith != nil {
		var i int32
		for i = int32(0); i < pWith.nCte; i++ {
			cteClear(db, &*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&pWith.a)))) + uintptr(i)*41)))
		}
		sqlite3DbFree(db, unsafe.Pointer(pWith))
	}
}
func callCollNeeded(db *struct_sqlite3, enc int32, zName *int8) {
	func() int {
		_ = 0
		return 0
	}()
	if db.xCollNeeded != nil {
		var zExternal *int8 = sqlite3DbStrDup(db, zName)
		if !(zExternal != nil) {
			return
		}
		db.xCollNeeded(db.pCollNeededArg, db, enc, zExternal)
		sqlite3DbFree(db, unsafe.Pointer(zExternal))
	}
	if db.xCollNeeded16 != nil {
		var zExternal *int8
		var pTmp *struct_sqlite3_value = sqlite3ValueNew(db)
		sqlite3ValueSetStr(pTmp, -1, unsafe.Pointer(zName), uint8(1), (func(unsafe.Pointer))(0))
		zExternal = (*int8)(sqlite3ValueText(pTmp, uint8(2)))
		if zExternal != nil {
			db.xCollNeeded16(db.pCollNeededArg, db, int32(db.enc), unsafe.Pointer(zExternal))
		}
		sqlite3ValueFree(pTmp)
	}
}
func synthCollSeq(db *struct_sqlite3, pColl *struct_CollSeq) int32 {
	var pColl2 *struct_CollSeq
	var z *int8 = pColl.zName
	var i int32
	var aEnc [3]uint8 = [3]uint8{uint8(3), uint8(2), uint8(1)}
	for i = int32(0); i < 3; i++ {
		pColl2 = sqlite3FindCollSeq(db, *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aEnc)))) + uintptr(i))), z, 0)
		if uintptr(unsafe.Pointer(pColl2.xCmp)) != uintptr(unsafe.Pointer(nil)) {
			__builtin___memcpy_chk(unsafe.Pointer(pColl), unsafe.Pointer(pColl2), 40, __builtin_object_size(unsafe.Pointer(pColl), 0))
			pColl.xDel = (func(unsafe.Pointer))(nil)
			return int32(0)
		}
	}
	return int32(1)
}
func sqlite3CheckCollSeq(pParse *struct_Parse, pColl *struct_CollSeq) int32 {
	if pColl != nil && uintptr(unsafe.Pointer(pColl.xCmp)) == uintptr(unsafe.Pointer(nil)) {
		var zName *int8 = pColl.zName
		var db *struct_sqlite3 = pParse.db
		var p *struct_CollSeq = sqlite3GetCollSeq(pParse, db.enc, pColl, zName)
		if !(p != nil) {
			return int32(1)
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	return int32(0)
}
func findCollSeqEntry(db *struct_sqlite3, zName *int8, create int32) *struct_CollSeq {
	var pColl *struct_CollSeq
	pColl = (*struct_CollSeq)(sqlite3HashFind(&db.aCollSeq, zName))
	if nil == pColl && create != 0 {
		var nName int32 = sqlite3Strlen30(zName) + 1
		pColl = (*struct_CollSeq)(sqlite3DbMallocZero(db, uint64(uint(3)*40+uint(nName))))
		if pColl != nil {
			var pDel *struct_CollSeq = nil
			(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(0)*40))).zName = (*int8)(unsafe.Pointer(&*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(3)*40))))
			(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(0)*40))).enc = uint8(1)
			(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(1)*40))).zName = (*int8)(unsafe.Pointer(&*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(3)*40))))
			(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(1)*40))).enc = uint8(2)
			(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(2)*40))).zName = (*int8)(unsafe.Pointer(&*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(3)*40))))
			(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(2)*40))).enc = uint8(3)
			__builtin___memcpy_chk(unsafe.Pointer((*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(0)*40))).zName), unsafe.Pointer(zName), uint(nName), __builtin_object_size(unsafe.Pointer((*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(0)*40))).zName), 0))
			pDel = (*struct_CollSeq)(sqlite3HashInsert(&db.aCollSeq, (*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(0)*40))).zName, unsafe.Pointer(pColl)))
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pDel)) != uintptr(unsafe.Pointer(nil)) {
				sqlite3OomFault(db)
				sqlite3DbFree(db, unsafe.Pointer(pDel))
				pColl = (*struct_CollSeq)(nil)
			}
		}
	}
	return pColl
}
func sqlite3FindCollSeq(db *struct_sqlite3, enc uint8, zName *int8, create int32) *struct_CollSeq {
	var pColl *struct_CollSeq
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if zName != nil {
		pColl = findCollSeqEntry(db, zName, create)
		if pColl != nil {
			*(*uintptr)(unsafe.Pointer(&pColl)) += uintptr(int32(enc)-1) * 40
		}
	} else {
		pColl = db.pDfltColl
	}
	return pColl
}
func sqlite3SetTextEncoding(db *struct_sqlite3, enc uint8) {
	func() int {
		_ = 0
		return 0
	}()
	db.enc = enc
	db.pDfltColl = sqlite3FindCollSeq(db, enc, (*int8)(unsafe.Pointer(&sqlite3StrBINARY)), 0)
}
func sqlite3GetCollSeq(pParse *struct_Parse, enc uint8, pColl *struct_CollSeq, zName *int8) *struct_CollSeq {
	var p *struct_CollSeq
	var db *struct_sqlite3 = pParse.db
	p = pColl
	if !(p != nil) {
		p = sqlite3FindCollSeq(db, enc, zName, 0)
	}
	if !(p != nil) || !(p.xCmp != nil) {
		callCollNeeded(db, int32(enc), zName)
		p = sqlite3FindCollSeq(db, enc, zName, 0)
	}
	if p != nil && !(p.xCmp != nil) && synthCollSeq(db, p) != 0 {
		p = (*struct_CollSeq)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[31]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'c', 'o', 'l', 'l', 'a', 't', 'i', 'o', 'n', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ':', ' ', '%', 's', '\x00'})), zName)
		pParse.rc = int32(1 | 1<<8)
	}
	return p
}
func sqlite3LocateCollSeq(pParse *struct_Parse, zName *int8) *struct_CollSeq {
	var db *struct_sqlite3 = pParse.db
	var enc uint8 = db.enc
	var initbusy uint8 = db.init.busy
	var pColl *struct_CollSeq
	pColl = sqlite3FindCollSeq(db, enc, zName, int32(initbusy))
	if !(initbusy != 0) && (!(pColl != nil) || !(pColl.xCmp != nil)) {
		pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName)
	}
	return pColl
}
func matchQuality(p *struct_FuncDef, nArg int32, enc uint8) int32 {
	var match int32
	func() int {
		_ = 0
		return 0
	}()
	if int32(p.nArg) != nArg {
		if nArg == -2 {
			return func() int32 {
				if uintptr(unsafe.Pointer(p.xSFunc)) == uintptr(unsafe.Pointer(nil)) {
					return 0
				} else {
					return 6
				}
			}()
		}
		if int32(p.nArg) >= 0 {
			return int32(0)
		}
	}
	if int32(p.nArg) == nArg {
		match = int32(4)
	} else {
		match = int32(1)
	}
	if uint32(enc) == p.funcFlags&uint32(3) {
		match += int32(2)
	} else if uint32(enc)&p.funcFlags&uint32(2) != uint32(0) {
		match += int32(1)
	}
	return match
}
func sqlite3FunctionSearch(h int32, zFunc *int8) *struct_FuncDef {
	var p *struct_FuncDef
	for p = *(**struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_FuncDef)(unsafe.Pointer(&sqlite3BuiltinFunctions.a)))) + uintptr(h)*8)); p != nil; p = p.u.pHash {
		func() int {
			_ = 0
			return 0
		}()
		if sqlite3StrICmp(p.zName, zFunc) == 0 {
			return p
		}
	}
	return (*struct_FuncDef)(nil)
}
func sqlite3InsertBuiltinFuncs(aDef *struct_FuncDef, nDef int32) {
	var i int32
	for i = int32(0); i < nDef; i++ {
		var pOther *struct_FuncDef
		var zName *int8 = (*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(aDef)) + uintptr(i)*72))).zName
		var nName int32 = sqlite3Strlen30(zName)
		var h int32 = (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(0)))) + nName) % 23
		func() int {
			_ = 0
			return 0
		}()
		pOther = sqlite3FunctionSearch(h, zName)
		if pOther != nil {
			func() int {
				_ = 0
				return 0
			}()
			(*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(aDef)) + uintptr(i)*72))).pNext = pOther.pNext
			pOther.pNext = &*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(aDef)) + uintptr(i)*72))
		} else {
			(*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(aDef)) + uintptr(i)*72))).pNext = (*struct_FuncDef)(nil)
			(*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(aDef)) + uintptr(i)*72))).u.pHash = *(**struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_FuncDef)(unsafe.Pointer(&sqlite3BuiltinFunctions.a)))) + uintptr(h)*8))
			*(**struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_FuncDef)(unsafe.Pointer(&sqlite3BuiltinFunctions.a)))) + uintptr(h)*8)) = &*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(aDef)) + uintptr(i)*72))
		}
	}
}
func sqlite3FindFunction(db *struct_sqlite3, zName *int8, nArg int32, enc uint8, createFlag uint8) *struct_FuncDef {
	var p *struct_FuncDef
	var pBest *struct_FuncDef = nil
	var bestScore int32 = 0
	var h int32
	var nName int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nName = sqlite3Strlen30(zName)
	p = (*struct_FuncDef)(sqlite3HashFind(&db.aFunc, zName))
	for p != nil {
		var score int32 = matchQuality(p, nArg, enc)
		if score > bestScore {
			pBest = p
			bestScore = score
		}
		p = p.pNext
	}
	if !(createFlag != 0) && (uintptr(unsafe.Pointer(pBest)) == uintptr(unsafe.Pointer(nil)) || db.mDbFlags&uint32(2) != uint32(0)) {
		bestScore = int32(0)
		h = (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(0)))))))) + nName) % 23
		p = sqlite3FunctionSearch(h, zName)
		for p != nil {
			var score int32 = matchQuality(p, nArg, enc)
			if score > bestScore {
				pBest = p
				bestScore = score
			}
			p = p.pNext
		}
	}
	if int32(createFlag) != 0 && bestScore < 6 && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_FuncDef) {
		_cgo_addr := &pBest
		*_cgo_addr = (*struct_FuncDef)(sqlite3DbMallocZero(db, uint64(72+uint(nName)+uint(1))))
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		var pOther *struct_FuncDef
		var z *uint8
		pBest.zName = (*int8)(unsafe.Pointer(&*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(pBest)) + uintptr(1)*72))))
		pBest.nArg = int8(uint16(nArg))
		pBest.funcFlags = uint32(enc)
		__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(pBest)) + uintptr(1)*72))))), unsafe.Pointer(zName), uint(nName+1), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(pBest)) + uintptr(1)*72))))), 0))
		for z = (*uint8)(unsafe.Pointer(pBest.zName)); *z != 0; *(*uintptr)(unsafe.Pointer(&z))++ {
			*z = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(*z)))
		}
		pOther = (*struct_FuncDef)(sqlite3HashInsert(&db.aFunc, pBest.zName, unsafe.Pointer(pBest)))
		if uintptr(unsafe.Pointer(pOther)) == uintptr(unsafe.Pointer(pBest)) {
			sqlite3DbFree(db, unsafe.Pointer(pBest))
			sqlite3OomFault(db)
			return (*struct_FuncDef)(nil)
		} else {
			pBest.pNext = pOther
		}
	}
	if pBest != nil && (pBest.xSFunc != nil || int32(createFlag) != 0) {
		return pBest
	}
	return (*struct_FuncDef)(nil)
}
func sqlite3SchemaClear(p unsafe.Pointer) {
	var temp1 struct_Hash
	var temp2 struct_Hash
	var pElem *struct_HashElem
	var pSchema *struct_Schema = (*struct_Schema)(p)
	temp1 = pSchema.tblHash
	temp2 = pSchema.trigHash
	sqlite3HashInit(&pSchema.trigHash)
	sqlite3HashClear(&pSchema.idxHash)
	for pElem = (&temp2).first; pElem != nil; pElem = pElem.next {
		sqlite3DeleteTrigger(nil, (*struct_Trigger)(pElem.data))
	}
	sqlite3HashClear(&temp2)
	sqlite3HashInit(&pSchema.tblHash)
	for pElem = (&temp1).first; pElem != nil; pElem = pElem.next {
		var pTab *struct_Table = (*struct_Table)(pElem.data)
		sqlite3DeleteTable(nil, pTab)
	}
	sqlite3HashClear(&temp1)
	sqlite3HashClear(&pSchema.fkeyHash)
	pSchema.pSeqTab = (*struct_Table)(nil)
	if int32(pSchema.schemaFlags)&1 != 0 {
		pSchema.iGeneration++
	}
	pSchema.schemaFlags &= uint16(^(1 | 8))
}
func sqlite3SchemaGet(db *struct_sqlite3, pBt *struct_Btree) *struct_Schema {
	var p *struct_Schema
	if pBt != nil {
		p = (*struct_Schema)(sqlite3BtreeSchema(pBt, int32(120), sqlite3SchemaClear))
	} else {
		p = (*struct_Schema)(sqlite3DbMallocZero(nil, uint64(120)))
	}
	if !(p != nil) {
		sqlite3OomFault(db)
	} else if 0 == int32(p.file_format) {
		sqlite3HashInit(&p.tblHash)
		sqlite3HashInit(&p.idxHash)
		sqlite3HashInit(&p.trigHash)
		sqlite3HashInit(&p.fkeyHash)
		p.enc = uint8(1)
	}
	return p
}
func sqlite3SrcListLookup(pParse *struct_Parse, pSrc *struct_SrcList) *struct_Table {
	var pItem *struct_SrcItem = (*struct_SrcItem)(unsafe.Pointer(&pSrc.a))
	var pTab *struct_Table
	func() int {
		_ = 0
		return 0
	}()
	pTab = sqlite3LocateTableItem(pParse, uint32(0), pItem)
	sqlite3DeleteTable(pParse.db, pItem.pTab)
	pItem.pTab = pTab
	if pTab != nil {
		pTab.nTabRef++
		if int32(pItem.fg.Xbf_0>>1&1) != 0 && sqlite3IndexedByLookup(pParse, pItem) != 0 {
			pTab = (*struct_Table)(nil)
		}
	}
	return pTab
}
func sqlite3CodeChangeCount(v *struct_Vdbe, regCounter int32, zColName *int8) {
	sqlite3VdbeAddOp0(v, 82)
	sqlite3VdbeAddOp2(v, 83, regCounter, 1)
	sqlite3VdbeSetNumCols(v, 1)
	sqlite3VdbeSetColName(v, 0, 0, zColName, (func(unsafe.Pointer))(0))
}
func tabIsReadOnly(pParse *struct_Parse, pTab *struct_Table) int32 {
	var db *struct_sqlite3
	if int32(pTab.eTabType) == 1 {
		return func() int32 {
			if uintptr(unsafe.Pointer(sqlite3GetVTable(pParse.db, pTab).pMod.pModule.xUpdate)) == uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}()
	}
	if pTab.tabFlags&uint32(1|4096) == uint32(0) {
		return int32(0)
	}
	db = pParse.db
	if pTab.tabFlags&uint32(1) != uint32(0) {
		return func() int32 {
			if sqlite3WritableSchema(db) == 0 && int32(pParse.nested) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3ReadOnlyShadowTables(db)
}
func sqlite3IsReadOnly(pParse *struct_Parse, pTab *struct_Table, viewOk int32) int32 {
	if tabIsReadOnly(pParse, pTab) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[29]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'm', 'o', 'd', 'i', 'f', 'i', 'e', 'd', '\x00'})), pTab.zName)
		return int32(1)
	}
	if !(viewOk != 0) && int32(pTab.eTabType) == 2 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[38]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'm', 'o', 'd', 'i', 'f', 'y', ' ', '%', 's', ' ', 'b', 'e', 'c', 'a', 'u', 's', 'e', ' ', 'i', 't', ' ', 'i', 's', ' ', 'a', ' ', 'v', 'i', 'e', 'w', '\x00'})), pTab.zName)
		return int32(1)
	}
	return int32(0)
}
func sqlite3MaterializeView(pParse *struct_Parse, pView *struct_Table, pWhere *struct_Expr, pOrderBy *struct_ExprList, pLimit *struct_Expr, iCur int32) {
	var dest struct_SelectDest
	var pSel *struct_Select
	var pFrom *struct_SrcList
	var db *struct_sqlite3 = pParse.db
	var iDb int32 = sqlite3SchemaToIndex(db, pView.pSchema)
	pWhere = sqlite3ExprDup(db, pWhere, 0)
	pFrom = sqlite3SrcListAppend(pParse, nil, nil, nil)
	if pFrom != nil {
		func() int {
			_ = 0
			return 0
		}()
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pFrom.a)))) + uintptr(0)*112))).zName = sqlite3DbStrDup(db, pView.zName)
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pFrom.a)))) + uintptr(0)*112))).zDatabase = sqlite3DbStrDup(db, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
	}
	pSel = sqlite3SelectNew(pParse, nil, pFrom, pWhere, nil, nil, pOrderBy, uint32(131072), pLimit)
	sqlite3SelectDestInit(&dest, 12, iCur)
	sqlite3Select(pParse, pSel, &dest)
	sqlite3SelectDelete(db, pSel)
}
func sqlite3DeleteFrom(pParse *struct_Parse, pTabList *struct_SrcList, pWhere *struct_Expr, pOrderBy *struct_ExprList, pLimit *struct_Expr) {
	var v *struct_Vdbe
	var pTab *struct_Table
	var i int32
	var pWInfo *struct_WhereInfo
	var pIdx *struct_Index
	var iTabCur int32
	var iDataCur int32 = 0
	var iIdxCur int32 = 0
	var nIdx int32
	var db *struct_sqlite3
	var sContext struct_AuthContext
	var sNC struct_NameContext
	var iDb int32
	var memCnt int32 = 0
	var rcauth int32
	var eOnePass int32
	var aiCurOnePass [2]int32
	var aToOpen *uint8 = nil
	var pPk *struct_Index
	var iPk int32 = 0
	var nPk int16 = int16(1)
	var iKey int32
	var nKey int16
	var iEphCur int32 = 0
	var iRowSet int32 = 0
	var addrBypass int32 = 0
	var addrLoop int32 = 0
	var addrEphOpen int32 = 0
	var bComplex int32
	var isView int32
	var pTrigger *struct_Trigger
	__builtin___memset_chk(unsafe.Pointer(&sContext), 0, 16, __builtin_object_size(unsafe.Pointer(&sContext), 0))
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		goto delete_from_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pTab = sqlite3SrcListLookup(pParse, pTabList)
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		goto delete_from_cleanup
	}
	pTrigger = sqlite3TriggersExist(pParse, pTab, 128, nil, nil)
	isView = func() int32 {
		if int32(pTab.eTabType) == 2 {
			return 1
		} else {
			return 0
		}
	}()
	bComplex = func() int32 {
		if pTrigger != nil || sqlite3FkRequired(pParse, pTab, nil, 0) != 0 {
			return 1
		} else {
			return 0
		}
	}()
	if sqlite3ViewGetColumnNames(pParse, pTab) != 0 {
		goto delete_from_cleanup
	}
	if sqlite3IsReadOnly(pParse, pTab, func() int32 {
		if pTrigger != nil {
			return 1
		} else {
			return 0
		}
	}()) != 0 {
		goto delete_from_cleanup
	}
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	rcauth = sqlite3AuthCheck(pParse, 9, pTab.zName, nil, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName)
	func() int {
		_ = 0
		return 0
	}()
	if rcauth == 1 {
		goto delete_from_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iTabCur = func() (_cgo_ret int32) {
		_cgo_addr := &(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).iCursor
		*_cgo_addr = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		return *_cgo_addr
	}()
	for func() *struct_Index {
		nIdx = int32(0)
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pTab.pIndex
			return *_cgo_addr
		}()
	}(); pIdx != nil; func() int32 {
		pIdx = pIdx.pNext
		return func() (_cgo_ret int32) {
			_cgo_addr := &nIdx
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		pParse.nTab++
	}
	if isView != 0 {
		sqlite3AuthContextPush(pParse, &sContext, pTab.zName)
	}
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		goto delete_from_cleanup
	}
	if int32(pParse.nested) == 0 {
		sqlite3VdbeCountChanges(v)
	}
	sqlite3BeginWriteOperation(pParse, bComplex, iDb)
	if isView != 0 {
		sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iTabCur)
		iDataCur = func() (_cgo_ret int32) {
			_cgo_addr := &iIdxCur
			*_cgo_addr = iTabCur
			return *_cgo_addr
		}()
		pOrderBy = (*struct_ExprList)(nil)
		pLimit = (*struct_Expr)(nil)
	}
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	sNC.pParse = pParse
	sNC.pSrcList = pTabList
	if sqlite3ResolveExprNames(&sNC, pWhere) != 0 {
		goto delete_from_cleanup
	}
	if db.flags&(uint64(1)<<32) != uint64(0) && !(pParse.nested != 0) && !(pParse.pTriggerTab != nil) && !(pParse.bReturning != 0) {
		memCnt = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 71, 0, memCnt)
	}
	if rcauth == 0 && uintptr(unsafe.Pointer(pWhere)) == uintptr(unsafe.Pointer(nil)) && !(bComplex != 0) && !(int32(pTab.eTabType) == 1) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(1), pTab.zName)
		if pTab.tabFlags&uint32(128) == uint32(0) {
			sqlite3VdbeAddOp4(v, 144, int32(pTab.tnum), iDb, func() int32 {
				if memCnt != 0 {
					return memCnt
				} else {
					return -1
				}
			}(), pTab.zName, -1)
		}
		for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 144, int32(pIdx.tnum), iDb)
			if int32(pIdx.Xbf_0&3) == 2 && !(pTab.tabFlags&uint32(128) == uint32(0)) {
				sqlite3VdbeChangeP3(v, -1, func() int32 {
					if memCnt != 0 {
						return memCnt
					} else {
						return -1
					}
				}())
			}
		}
	} else {
		var wcf uint16 = uint16(4 | 16)
		if sNC.ncFlags&64 != 0 {
			bComplex = int32(1)
		}
		wcf |= uint16(func() int32 {
			if bComplex != 0 {
				return 0
			} else {
				return 8
			}
		}())
		if pTab.tabFlags&uint32(128) == uint32(0) {
			pPk = (*struct_Index)(nil)
			nPk = int16(1)
			iRowSet = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3VdbeAddOp2(v, 74, 0, iRowSet)
		} else {
			pPk = sqlite3PrimaryKeyIndex(pTab)
			func() int {
				_ = 0
				return 0
			}()
			nPk = int16(pPk.nKeyCol)
			iPk = pParse.nMem + 1
			pParse.nMem += int32(nPk)
			iEphCur = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			addrEphOpen = sqlite3VdbeAddOp2(v, 116, iEphCur, int32(nPk))
			sqlite3VdbeSetP4KeyInfo(pParse, pPk)
		}
		pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, nil, nil, nil, wcf, iTabCur+1)
		if uintptr(unsafe.Pointer(pWInfo)) == uintptr(unsafe.Pointer(nil)) {
			goto delete_from_cleanup
		}
		eOnePass = sqlite3WhereOkOnePass(pWInfo, (*int32)(unsafe.Pointer(&aiCurOnePass)))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if eOnePass != 1 {
			sqlite3MultiWrite(pParse)
		}
		if sqlite3WhereUsesDeferredSeek(pWInfo) != 0 {
			sqlite3VdbeAddOp1(v, 142, iTabCur)
		}
		if memCnt != 0 {
			sqlite3VdbeAddOp2(v, 85, memCnt, 1)
		}
		if pPk != nil {
			for i = int32(0); i < int32(nPk); i++ {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))), iPk+i)
			}
			iKey = iPk
		} else {
			iKey = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey)
		}
		if eOnePass != 0 {
			nKey = nPk
			aToOpen = (*uint8)(sqlite3DbMallocRawNN(db, uint64(nIdx+2)))
			if uintptr(unsafe.Pointer(aToOpen)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3WhereEnd(pWInfo)
				goto delete_from_cleanup
			}
			__builtin___memset_chk(unsafe.Pointer(aToOpen), 1, uint(nIdx+1), __builtin_object_size(unsafe.Pointer(aToOpen), 0))
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(nIdx+1))) = uint8(0)
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(0)*4)) >= 0 {
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(0)*4))-iTabCur))) = uint8(0)
			}
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4)) >= 0 {
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4))-iTabCur))) = uint8(0)
			}
			if addrEphOpen != 0 {
				sqlite3VdbeChangeToNoop(v, addrEphOpen)
			}
			addrBypass = sqlite3VdbeMakeLabel(pParse)
		} else {
			if pPk != nil {
				iKey = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
				nKey = int16(0)
				sqlite3VdbeAddOp4(v, 96, iPk, int32(nPk), iKey, sqlite3IndexAffinityStr(pParse.db, pPk), int32(nPk))
				sqlite3VdbeAddOp4Int(v, 137, iEphCur, iKey, iPk, int32(nPk))
			} else {
				nKey = int16(1)
				sqlite3VdbeAddOp2(v, 155, iRowSet, iKey)
			}
			sqlite3WhereEnd(pWInfo)
		}
		if !(isView != 0) {
			var iAddrOnce int32 = 0
			if eOnePass == 2 {
				iAddrOnce = sqlite3VdbeAddOp0(v, 17)
			}
			sqlite3OpenTableAndIndices(pParse, pTab, 112, uint8(8), iTabCur, aToOpen, &iDataCur, &iIdxCur)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if eOnePass == 2 {
				sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce)
			}
		}
		if eOnePass != 0 {
			func() int {
				_ = 0
				return 0
			}()
			if !(int32(pTab.eTabType) == 1) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(iDataCur-iTabCur)))) != 0 {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp4Int(v, 30, iDataCur, addrBypass, iKey, int32(nKey))
			}
		} else if pPk != nil {
			addrLoop = sqlite3VdbeAddOp1(v, 38, iEphCur)
			if int32(pTab.eTabType) == 1 {
				sqlite3VdbeAddOp3(v, 93, iEphCur, 0, iKey)
			} else {
				sqlite3VdbeAddOp2(v, 133, iEphCur, iKey)
			}
			func() int {
				_ = 0
				return 0
			}()
		} else {
			addrLoop = sqlite3VdbeAddOp3(v, 45, iRowSet, 0, iKey)
			func() int {
				_ = 0
				return 0
			}()
		}
		if int32(pTab.eTabType) == 1 {
			var pVTab *int8 = (*int8)(unsafe.Pointer(sqlite3GetVTable(db, pTab)))
			sqlite3VtabMakeWritable(pParse, pTab)
			func() int {
				_ = 0
				return 0
			}()
			sqlite3MayAbort(pParse)
			if eOnePass == 1 {
				sqlite3VdbeAddOp1(v, 121, iTabCur)
				if uintptr(unsafe.Pointer(pParse.pToplevel)) == uintptr(unsafe.Pointer(nil)) {
					pParse.isMultiWrite = uint8(0)
				}
			}
			sqlite3VdbeAddOp4(v, 10, 0, 1, iKey, pVTab, -12)
			sqlite3VdbeChangeP5(v, uint16(2))
		} else {
			var count int32 = func() int32 {
				if int32(pParse.nested) == 0 {
					return 1
				} else {
					return 0
				}
			}()
			sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, iKey, nKey, uint8(count), uint8(11), uint8(eOnePass), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4)))
		}
		if eOnePass != 0 {
			sqlite3VdbeResolveLabel(v, addrBypass)
			sqlite3WhereEnd(pWInfo)
		} else if pPk != nil {
			sqlite3VdbeAddOp2(v, 5, iEphCur, addrLoop+1)
			sqlite3VdbeJumpHere(v, addrLoop)
		} else {
			sqlite3VdbeGoto(v, addrLoop)
			sqlite3VdbeJumpHere(v, addrLoop)
		}
	}
	if int32(pParse.nested) == 0 && uintptr(unsafe.Pointer(pParse.pTriggerTab)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3AutoincrementEnd(pParse)
	}
	if memCnt != 0 {
		sqlite3CodeChangeCount(v, memCnt, (*int8)(unsafe.Pointer(&[13]int8{'r', 'o', 'w', 's', ' ', 'd', 'e', 'l', 'e', 't', 'e', 'd', '\x00'})))
	}
delete_from_cleanup:
	sqlite3AuthContextPop(&sContext)
	sqlite3SrcListDelete(db, pTabList)
	sqlite3ExprDelete(db, pWhere)
	sqlite3DbFree(db, unsafe.Pointer(aToOpen))
	return
}
func sqlite3GenerateRowDelete(pParse *struct_Parse, pTab *struct_Table, pTrigger *struct_Trigger, iDataCur int32, iIdxCur int32, iPk int32, nPk int16, count uint8, onconf uint8, eMode uint8, iIdxNoSeek int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var iOld int32 = 0
	var iLabel int32
	var opSeek uint8
	func() int {
		_ = 0
		return 0
	}()
	iLabel = sqlite3VdbeMakeLabel(pParse)
	opSeek = uint8(func() int32 {
		if pTab.tabFlags&uint32(128) == uint32(0) {
			return 33
		} else {
			return 30
		}
	}())
	if int32(eMode) == 0 {
		sqlite3VdbeAddOp4Int(v, int32(opSeek), iDataCur, iLabel, iPk, int32(nPk))
	}
	if sqlite3FkRequired(pParse, pTab, nil, 0) != 0 || pTrigger != nil {
		var mask uint32
		var iCol int32
		var addrStart int32
		mask = sqlite3TriggerColmask(pParse, pTrigger, nil, 0, 1|2, pTab, int32(onconf))
		mask |= sqlite3FkOldmask(pParse, pTab)
		iOld = pParse.nMem + 1
		pParse.nMem += 1 + int32(pTab.nCol)
		sqlite3VdbeAddOp2(v, 79, iPk, iOld)
		for iCol = int32(0); iCol < int32(pTab.nCol); iCol++ {
			if mask == 4294967295 || iCol <= 31 && mask&(uint32(1)<<iCol) != uint32(0) {
				var kk int32 = int32(sqlite3TableColumnToStorage(pTab, int16(iCol)))
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1)
			}
		}
		addrStart = sqlite3VdbeCurrentAddr(v)
		sqlite3CodeRowTrigger(pParse, pTrigger, 128, nil, 1, pTab, iOld, int32(onconf), iLabel)
		if addrStart < sqlite3VdbeCurrentAddr(v) {
			sqlite3VdbeAddOp4Int(v, int32(opSeek), iDataCur, iLabel, iPk, int32(nPk))
			iIdxNoSeek = int32(-1)
		}
		sqlite3FkCheck(pParse, pTab, iOld, 0, nil, 0)
	}
	if !(int32(pTab.eTabType) == 2) {
		var p5 uint8 = uint8(0)
		sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, nil, iIdxNoSeek)
		sqlite3VdbeAddOp2(v, 129, iDataCur, func() int32 {
			if int32(count) != 0 {
				return 1
			} else {
				return 0
			}
		}())
		if int32(pParse.nested) == 0 || 0 == sqlite3_stricmp(pTab.zName, (*int8)(unsafe.Pointer(&[13]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 't', 'a', 't', '1', '\x00'}))) {
			sqlite3VdbeAppendP4(v, unsafe.Pointer((*int8)(unsafe.Pointer(pTab))), -6)
		}
		if int32(eMode) != 0 {
			sqlite3VdbeChangeP5(v, uint16(4))
		}
		if iIdxNoSeek >= 0 && iIdxNoSeek != iDataCur {
			sqlite3VdbeAddOp1(v, 129, iIdxNoSeek)
		}
		if int32(eMode) == 2 {
			p5 |= uint8(2)
		}
		sqlite3VdbeChangeP5(v, uint16(p5))
	}
	sqlite3FkActions(pParse, pTab, nil, iOld, nil, 0)
	sqlite3CodeRowTrigger(pParse, pTrigger, 128, nil, 2, pTab, iOld, int32(onconf), iLabel)
	sqlite3VdbeResolveLabel(v, iLabel)
}
func sqlite3GenerateRowIndexDelete(pParse *struct_Parse, pTab *struct_Table, iDataCur int32, iIdxCur int32, aRegIdx *int32, iIdxNoSeek int32) {
	var i int32
	var r1 int32 = -1
	var iPartIdxLabel int32
	var pIdx *struct_Index
	var pPrior *struct_Index = nil
	var v *struct_Vdbe
	var pPk *struct_Index
	v = pParse.pVdbe
	pPk = func() *struct_Index {
		if pTab.tabFlags&uint32(128) == uint32(0) {
			return nil
		} else {
			return sqlite3PrimaryKeyIndex(pTab)
		}
	}()
	for func() *struct_Index {
		i = int32(0)
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pTab.pIndex
			return *_cgo_addr
		}()
	}(); pIdx != nil; func() *struct_Index {
		i++
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pIdx.pNext
			return *_cgo_addr
		}()
	}() {
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(aRegIdx)) != uintptr(unsafe.Pointer(nil)) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)) == 0 {
			continue
		}
		if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(pPk)) {
			continue
		}
		if iIdxCur+i == iIdxNoSeek {
			continue
		}
		r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1, &iPartIdxLabel, pPrior, r1)
		sqlite3VdbeAddOp3(v, 139, iIdxCur+i, r1, func() int32 {
			if int32(pIdx.Xbf_0>>3&1) != 0 {
				return int32(pIdx.nKeyCol)
			} else {
				return int32(pIdx.nColumn)
			}
		}())
		sqlite3VdbeChangeP5(v, uint16(1))
		sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel)
		pPrior = pIdx
	}
}
func sqlite3GenerateIndexKey(pParse *struct_Parse, pIdx *struct_Index, iDataCur int32, regOut int32, prefixOnly int32, piPartIdxLabel *int32, pPrior *struct_Index, regPrior int32) int32 {
	var v *struct_Vdbe = pParse.pVdbe
	var j int32
	var regBase int32
	var nCol int32
	if piPartIdxLabel != nil {
		if pIdx.pPartIdxWhere != nil {
			*piPartIdxLabel = sqlite3VdbeMakeLabel(pParse)
			pParse.iSelfTab = iDataCur + 1
			sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, *piPartIdxLabel, 16)
			pParse.iSelfTab = int32(0)
			pPrior = (*struct_Index)(nil)
		} else {
			*piPartIdxLabel = int32(0)
		}
	}
	nCol = func() int32 {
		if prefixOnly != 0 && int32(pIdx.Xbf_0>>3&1) != 0 {
			return int32(pIdx.nKeyCol)
		} else {
			return int32(pIdx.nColumn)
		}
	}()
	regBase = sqlite3GetTempRange(pParse, nCol)
	if pPrior != nil && (regBase != regPrior || pPrior.pPartIdxWhere != nil) {
		pPrior = (*struct_Index)(nil)
	}
	for j = int32(0); j < nCol; j++ {
		if pPrior != nil && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPrior.aiColumn)) + uintptr(j)*2))) == int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2))) && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPrior.aiColumn)) + uintptr(j)*2))) != -2 {
			continue
		}
		sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j)
		if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2))) >= 0 {
			sqlite3VdbeDeletePriorOpcode(v, uint8(86))
		}
	}
	if regOut != 0 {
		sqlite3VdbeAddOp3(v, 96, regBase, nCol, regOut)
	}
	sqlite3ReleaseTempRange(pParse, regBase, nCol)
	return regBase
}
func sqlite3ResolvePartIdxLabel(pParse *struct_Parse, iLabel int32) {
	if iLabel != 0 {
		sqlite3VdbeResolveLabel(pParse.pVdbe, iLabel)
	}
}
func sqlite3GetFuncCollSeq(context *struct_sqlite3_context) *struct_CollSeq {
	var pOp *struct_VdbeOp
	func() int {
		_ = 0
		return 0
	}()
	pOp = &*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(context.pVdbe.aOp)) + uintptr(context.iOp-1)*24))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return *(**struct_CollSeq)(unsafe.Pointer(&pOp.p4))
}
func sqlite3SkipAccumulatorLoad(context *struct_sqlite3_context) {
	func() int {
		_ = 0
		return 0
	}()
	context.isError = int32(-1)
	context.skipFlag = uint8(1)
}
func minmaxFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var i int32
	var mask int32
	var iBest int32
	var pColl *struct_CollSeq
	func() int {
		_ = 0
		return 0
	}()
	mask = func() int32 {
		if uintptr(unsafe.Pointer(sqlite3_user_data(context))) == uintptr(unsafe.Pointer(nil)) {
			return 0
		} else {
			return -1
		}
	}()
	pColl = sqlite3GetFuncCollSeq(context)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iBest = int32(0)
	if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) == 5 {
		return
	}
	for i = int32(1); i < argc; i++ {
		if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8))) == 5 {
			return
		}
		if sqlite3MemCompare(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(iBest)*8)), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)), pColl)^mask >= 0 {
			iBest = i
		}
	}
	sqlite3_result_value(context, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(iBest)*8)))
}
func typeofFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var azType [5]*int8 = [5]*int8{(*int8)(unsafe.Pointer(&[8]int8{'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'r', 'e', 'a', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'e', 'x', 't', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'b', 'l', 'o', 'b', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'}))}
	var i int32 = sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) - 1
	func() int {
		_ = NotUsed
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_result_text(context, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azType)))) + uintptr(i)*8)), -1, (func(unsafe.Pointer))(0))
}
func subtypeFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	func() int {
		_ = argc
		return 0
	}()
	sqlite3_result_int(context, int32(sqlite3_value_subtype(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
}
func lengthFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	switch sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) {
	case 4:
		fallthrough
	case 1:
		fallthrough
	case 2:
		{
			sqlite3_result_int(context, sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
			break
		}
	case 3:
		{
			var z *uint8 = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			var z0 *uint8
			var c uint8
			if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
			z0 = z
			for int32(func() (_cgo_ret uint8) {
				_cgo_addr := &c
				*_cgo_addr = *z
				return *_cgo_addr
			}()) != 0 {
				*(*uintptr)(unsafe.Pointer(&z))++
				if int32(c) >= 192 {
					for int32(*z)&192 == 128 {
						*(*uintptr)(unsafe.Pointer(&z))++
						*(*uintptr)(unsafe.Pointer(&z0))++
					}
				}
			}
			sqlite3_result_int(context, int32(uintptr(unsafe.Pointer(z))-uintptr(unsafe.Pointer(z0))))
			break
		}
	default:
		{
			sqlite3_result_null(context)
			break
		}
	}
}
func absFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	switch sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) {
	case 1:
		{
			var iVal int64 = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			if iVal < int64(0) {
				if iVal == int64(-1)-(int64(4294967295)|int64(2147483647)<<32) {
					sqlite3_result_error(context, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 't', 'e', 'g', 'e', 'r', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', '\x00'})), -1)
					return
				}
				iVal = -iVal
			}
			sqlite3_result_int64(context, iVal)
			break
		}
	case 5:
		{
			sqlite3_result_null(context)
			break
		}
	default:
		{
			var rVal float64 = sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			if rVal < float64(0) {
				rVal = -rVal
			}
			sqlite3_result_double(context, rVal)
			break
		}
	}
}
func instrFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zHaystack *uint8
	var zNeedle *uint8
	var nHaystack int32
	var nNeedle int32
	var typeHaystack int32
	var typeNeedle int32
	var N int32 = 1
	var isText int32
	var firstChar uint8
	var pC1 *struct_sqlite3_value = nil
	var pC2 *struct_sqlite3_value = nil
	func() int {
		_ = argc
		return 0
	}()
	typeHaystack = sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	typeNeedle = sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	if typeHaystack == 5 || typeNeedle == 5 {
		return
	}
	nHaystack = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	nNeedle = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	if nNeedle > 0 {
		if typeHaystack == 4 && typeNeedle == 4 {
			zHaystack = (*uint8)(sqlite3_value_blob(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
			zNeedle = (*uint8)(sqlite3_value_blob(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))))
			isText = int32(0)
		} else if typeHaystack != 4 && typeNeedle != 4 {
			zHaystack = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			zNeedle = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
			isText = int32(1)
		} else {
			pC1 = sqlite3_value_dup(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			zHaystack = sqlite3_value_text(pC1)
			if uintptr(unsafe.Pointer(zHaystack)) == uintptr(unsafe.Pointer(nil)) {
				goto endInstrOOM
			}
			nHaystack = sqlite3_value_bytes(pC1)
			pC2 = sqlite3_value_dup(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
			zNeedle = sqlite3_value_text(pC2)
			if uintptr(unsafe.Pointer(zNeedle)) == uintptr(unsafe.Pointer(nil)) {
				goto endInstrOOM
			}
			nNeedle = sqlite3_value_bytes(pC2)
			isText = int32(1)
		}
		if uintptr(unsafe.Pointer(zNeedle)) == uintptr(unsafe.Pointer(nil)) || nHaystack != 0 && uintptr(unsafe.Pointer(zHaystack)) == uintptr(unsafe.Pointer(nil)) {
			goto endInstrOOM
		}
		firstChar = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNeedle)) + uintptr(0)))
		for nNeedle <= nHaystack && (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHaystack)) + uintptr(0)))) != int32(firstChar) || memcmp(unsafe.Pointer(zHaystack), unsafe.Pointer(zNeedle), uint(nNeedle)) != 0) {
			N++
			for {
				nHaystack--
				*(*uintptr)(unsafe.Pointer(&zHaystack))++
				if !(isText != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zHaystack)) + uintptr(0))))&192 == 128) {
					break
				}
			}
		}
		if nNeedle > nHaystack {
			N = int32(0)
		}
	}
	sqlite3_result_int(context, N)
endInstr:
	sqlite3_value_free(pC1)
	sqlite3_value_free(pC2)
	return
endInstrOOM:
	sqlite3_result_error_nomem(context)
	goto endInstr
}
func printfFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_PrintfArguments
	var str struct_sqlite3_str
	var zFormat *int8
	var n int32
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	if argc >= 1 && uintptr(unsafe.Pointer(func() (_cgo_ret *int8) {
		_cgo_addr := &zFormat
		*_cgo_addr = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		x.nArg = argc - 1
		x.nUsed = int32(0)
		x.apArg = (**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))
		sqlite3StrAccumInit(&str, db, nil, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)))
		str.printfFlags = uint8(2)
		sqlite3_str_appendf(&str, zFormat, &x)
		n = int32(str.nChar)
		sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n, (func(unsafe.Pointer))(sqlite3OomFault))
	}
}
func substrFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var z *uint8
	var z2 *uint8
	var len int32
	var p0type int32
	var p1 int64
	var p2 int64
	var negP2 int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))) == 5 || argc == 3 && sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8))) == 5 {
		return
	}
	p0type = sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	p1 = int64(sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))))
	if p0type == 4 {
		len = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		z = (*uint8)(sqlite3_value_blob(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
		if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		func() int {
			_ = 0
			return 0
		}()
	} else {
		z = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		len = int32(0)
		if p1 < int64(0) {
			for z2 = z; *z2 != 0; len++ {
				{
					if int32(*func() (_cgo_ret *uint8) {
						_cgo_addr := &z2
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return
					}()) >= 192 {
						for int32(*z2)&192 == 128 {
							*(*uintptr)(unsafe.Pointer(&z2))++
						}
					}
				}
			}
		}
	}
	if argc == 3 {
		p2 = int64(sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8))))
		if p2 < int64(0) {
			p2 = -p2
			negP2 = int32(1)
		}
	} else {
		p2 = int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&sqlite3_context_db_handle(context).aLimit)))) + uintptr(0)*4)))
	}
	if p1 < int64(0) {
		p1 += int64(len)
		if p1 < int64(0) {
			p2 += p1
			if p2 < int64(0) {
				p2 = int64(0)
			}
			p1 = int64(0)
		}
	} else if p1 > int64(0) {
		p1--
	} else if p2 > int64(0) {
		p2--
	}
	if negP2 != 0 {
		p1 -= p2
		if p1 < int64(0) {
			p2 += p1
			p1 = int64(0)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if p0type != 4 {
		for int32(*z) != 0 && p1 != 0 {
			{
				if int32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &z
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) >= 192 {
					for int32(*z)&192 == 128 {
						*(*uintptr)(unsafe.Pointer(&z))++
					}
				}
			}
			p1--
		}
		for z2 = z; int32(*z2) != 0 && p2 != 0; p2-- {
			{
				if int32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &z2
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) >= 192 {
					for int32(*z2)&192 == 128 {
						*(*uintptr)(unsafe.Pointer(&z2))++
					}
				}
			}
		}
		sqlite3_result_text64(context, (*int8)(unsafe.Pointer(z)), uint64(uintptr(unsafe.Pointer(z2))-uintptr(unsafe.Pointer(z))), (func(unsafe.Pointer))(-1), uint8(1))
	} else {
		if p1+p2 > int64(len) {
			p2 = int64(len) - p1
			if p2 < int64(0) {
				p2 = int64(0)
			}
		}
		sqlite3_result_blob64(context, unsafe.Pointer((*int8)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(p1)))))), uint64(p2), (func(unsafe.Pointer))(-1))
	}
}
func roundFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var n int32 = 0
	var r float64
	var zBuf *int8
	func() int {
		_ = 0
		return 0
	}()
	if argc == 2 {
		if 5 == sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))) {
			return
		}
		n = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
		if n > 30 {
			n = int32(30)
		}
		if n < 0 {
			n = int32(0)
		}
	}
	if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) == 5 {
		return
	}
	r = sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if r < -4503599627370496 || r > 4503599627370496 {
	} else if n == 0 {
		r = float64(int64(r + func() float64 {
			if r < float64(0) {
				return -0.5
			} else {
				return 0.5
			}
		}()))
	} else {
		zBuf = sqlite3_mprintf((*int8)(unsafe.Pointer(&[5]int8{'%', '.', '*', 'f', '\x00'})), n, r)
		if uintptr(unsafe.Pointer(zBuf)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3_result_error_nomem(context)
			return
		}
		sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), uint8(1))
		sqlite3_free(unsafe.Pointer(zBuf))
	}
	sqlite3_result_double(context, r)
}
func contextMalloc(context *struct_sqlite3_context, nByte int64) unsafe.Pointer {
	var z *int8
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		_ = 0
		return 0
	}()
	if nByte > int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))) {
		sqlite3_result_error_toobig(context)
		z = (*int8)(nil)
	} else {
		z = (*int8)(sqlite3Malloc(uint64(nByte)))
		if !(z != nil) {
			sqlite3_result_error_nomem(context)
		}
	}
	return unsafe.Pointer(z)
}
func upperFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var z1 *int8
	var z2 *int8
	var i int32
	var n int32
	func() int {
		_ = argc
		return 0
	}()
	z2 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	n = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	func() int {
		_ = 0
		return 0
	}()
	if z2 != nil {
		z1 = (*int8)(contextMalloc(context, int64(n)+int64(1)))
		if z1 != nil {
			for i = int32(0); i < n; i++ {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z1)) + uintptr(i))) = int8(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z2)) + uintptr(i)))) & ^(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z2)) + uintptr(i)))))))) & 32))
			}
			sqlite3_result_text(context, z1, n, sqlite3_free)
		}
	}
}
func lowerFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var z1 *int8
	var z2 *int8
	var i int32
	var n int32
	func() int {
		_ = argc
		return 0
	}()
	z2 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	n = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	func() int {
		_ = 0
		return 0
	}()
	if z2 != nil {
		z1 = (*int8)(contextMalloc(context, int64(n)+int64(1)))
		if z1 != nil {
			for i = int32(0); i < n; i++ {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z1)) + uintptr(i))) = int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z2)) + uintptr(i))))))))
			}
			sqlite3_result_text(context, z1, n, sqlite3_free)
		}
	}
}
func randomFunc(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	var r int64
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	sqlite3_randomness(int32(8), unsafe.Pointer(&r))
	if r < int64(0) {
		r = -(r & (int64(4294967295) | int64(2147483647)<<32))
	}
	sqlite3_result_int64(context, r)
}
func randomBlob(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var n int64
	var p *uint8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	n = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if n < int64(1) {
		n = int64(1)
	}
	p = (*uint8)(contextMalloc(context, n))
	if p != nil {
		sqlite3_randomness(int32(n), unsafe.Pointer(p))
		sqlite3_result_blob(context, unsafe.Pointer((*int8)(unsafe.Pointer(p))), int32(n), sqlite3_free)
	}
}
func last_insert_rowid(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	sqlite3_result_int64(context, sqlite3_last_insert_rowid(db))
}
func changes(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	sqlite3_result_int64(context, sqlite3_changes64(db))
}
func total_changes(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	sqlite3_result_int64(context, sqlite3_total_changes64(db))
}

type struct_compareInfo struct {
	matchAll uint8
	matchOne uint8
	matchSet uint8
	noCase   uint8
}

var globInfo struct_compareInfo = struct_compareInfo{uint8('*'), uint8('?'), uint8('['), uint8(0)}
var likeInfoNorm struct_compareInfo = struct_compareInfo{uint8('%'), uint8('_'), uint8(0), uint8(1)}
var likeInfoAlt struct_compareInfo = struct_compareInfo{uint8('%'), uint8('_'), uint8(0), uint8(0)}

func patternCompare(zPattern *uint8, zString *uint8, pInfo *struct_compareInfo, matchOther uint32) int32 {
	var c uint32
	var c2 uint32
	var matchOne uint32 = uint32(pInfo.matchOne)
	var matchAll uint32 = uint32(pInfo.matchAll)
	var noCase uint8 = pInfo.noCase
	var zEscaped *uint8 = nil
	for func() (_cgo_ret uint32) {
		_cgo_addr := &c
		*_cgo_addr = func() uint32 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) + uintptr(0)))) < 128 {
				return uint32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zPattern
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}())
			} else {
				return sqlite3Utf8Read(&zPattern)
			}
		}()
		return *_cgo_addr
	}() != uint32(0) {
		if c == matchAll {
			for func() (_cgo_ret uint32) {
				_cgo_addr := &c
				*_cgo_addr = func() uint32 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) + uintptr(0)))) < 128 {
						return uint32(*func() (_cgo_ret *uint8) {
							_cgo_addr := &zPattern
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr))++
							return
						}())
					} else {
						return sqlite3Utf8Read(&zPattern)
					}
				}()
				return *_cgo_addr
			}() == matchAll || c == matchOne && matchOne != uint32(0) {
				if c == matchOne && sqlite3Utf8Read(&zString) == uint32(0) {
					return int32(2)
				}
			}
			if c == uint32(0) {
				return int32(0)
			} else if c == matchOther {
				if int32(pInfo.matchSet) == 0 {
					c = sqlite3Utf8Read(&zPattern)
					if c == uint32(0) {
						return int32(2)
					}
				} else {
					func() int {
						_ = 0
						return 0
					}()
					for *zString != 0 {
						var bMatch int32 = patternCompare(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) - uintptr(- -1))), zString, pInfo, matchOther)
						if bMatch != 1 {
							return bMatch
						}
						{
							if int32(*func() (_cgo_ret *uint8) {
								_cgo_addr := &zString
								_cgo_ret = *_cgo_addr
								*(*uintptr)(unsafe.Pointer(_cgo_addr))++
								return
							}()) >= 192 {
								for int32(*zString)&192 == 128 {
									*(*uintptr)(unsafe.Pointer(&zString))++
								}
							}
						}
					}
					return int32(2)
				}
			}
			if c <= uint32(128) {
				var zStop [3]int8
				var bMatch int32
				if noCase != 0 {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zStop)))) + uintptr(0))) = int8(c & uint32(^(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(c))))) & 32)))
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zStop)))) + uintptr(1))) = int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(c)))))
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zStop)))) + uintptr(2))) = int8(0)
				} else {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zStop)))) + uintptr(0))) = int8(c)
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zStop)))) + uintptr(1))) = int8(0)
				}
				for 1 != 0 {
					*(*uintptr)(unsafe.Pointer(&zString)) += uintptr(strcspn((*int8)(unsafe.Pointer(zString)), (*int8)(unsafe.Pointer(&zStop))))
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zString)) + uintptr(0)))) == 0 {
						break
					}
					*(*uintptr)(unsafe.Pointer(&zString))++
					bMatch = patternCompare(zPattern, zString, pInfo, matchOther)
					if bMatch != 1 {
						return bMatch
					}
				}
			} else {
				var bMatch int32
				for func() (_cgo_ret uint32) {
					_cgo_addr := &c2
					*_cgo_addr = func() uint32 {
						if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zString)) + uintptr(0)))) < 128 {
							return uint32(*func() (_cgo_ret *uint8) {
								_cgo_addr := &zString
								_cgo_ret = *_cgo_addr
								*(*uintptr)(unsafe.Pointer(_cgo_addr))++
								return
							}())
						} else {
							return sqlite3Utf8Read(&zString)
						}
					}()
					return *_cgo_addr
				}() != uint32(0) {
					if c2 != c {
						continue
					}
					bMatch = patternCompare(zPattern, zString, pInfo, matchOther)
					if bMatch != 1 {
						return bMatch
					}
				}
			}
			return int32(2)
		}
		if c == matchOther {
			if int32(pInfo.matchSet) == 0 {
				c = sqlite3Utf8Read(&zPattern)
				if c == uint32(0) {
					return int32(1)
				}
				zEscaped = zPattern
			} else {
				var prior_c uint32 = uint32(0)
				var seen int32 = 0
				var invert int32 = 0
				c = sqlite3Utf8Read(&zString)
				if c == uint32(0) {
					return int32(1)
				}
				c2 = sqlite3Utf8Read(&zPattern)
				if c2 == uint32('^') {
					invert = int32(1)
					c2 = sqlite3Utf8Read(&zPattern)
				}
				if c2 == uint32(']') {
					if c == uint32(']') {
						seen = int32(1)
					}
					c2 = sqlite3Utf8Read(&zPattern)
				}
				for c2 != 0 && c2 != uint32(']') {
					if c2 == uint32('-') && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) + uintptr(0)))) != ']' && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) + uintptr(0)))) != 0 && prior_c > uint32(0) {
						c2 = sqlite3Utf8Read(&zPattern)
						if c >= prior_c && c <= c2 {
							seen = int32(1)
						}
						prior_c = uint32(0)
					} else {
						if c == c2 {
							seen = int32(1)
						}
						prior_c = c2
					}
					c2 = sqlite3Utf8Read(&zPattern)
				}
				if c2 == uint32(0) || seen^invert == 0 {
					return int32(1)
				}
				continue
			}
		}
		c2 = func() uint32 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zString)) + uintptr(0)))) < 128 {
				return uint32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &zString
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}())
			} else {
				return sqlite3Utf8Read(&zString)
			}
		}()
		if c == c2 {
			continue
		}
		if int32(noCase) != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(c))))) == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(c2))))) && c < uint32(128) && c2 < uint32(128) {
			continue
		}
		if c == matchOne && uintptr(unsafe.Pointer(zPattern)) != uintptr(unsafe.Pointer(zEscaped)) && c2 != uint32(0) {
			continue
		}
		return int32(1)
	}
	return func() int32 {
		if int32(*zString) == 0 {
			return 0
		} else {
			return 1
		}
	}()
}
func sqlite3_strglob(zGlobPattern *int8, zString *int8) int32 {
	return patternCompare((*uint8)(unsafe.Pointer(zGlobPattern)), (*uint8)(unsafe.Pointer(zString)), &globInfo, uint32('['))
}
func sqlite3_strlike(zPattern *int8, zStr *int8, esc uint32) int32 {
	return patternCompare((*uint8)(unsafe.Pointer(zPattern)), (*uint8)(unsafe.Pointer(zStr)), &likeInfoNorm, esc)
}
func likeFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zA *uint8
	var zB *uint8
	var escape uint32
	var nPat int32
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var pInfo *struct_compareInfo = (*struct_compareInfo)(sqlite3_user_data(context))
	var backupInfo struct_compareInfo
	nPat = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if nPat > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(8)*4)) {
		sqlite3_result_error(context, (*int8)(unsafe.Pointer(&[33]int8{'L', 'I', 'K', 'E', ' ', 'o', 'r', ' ', 'G', 'L', 'O', 'B', ' ', 'p', 'a', 't', 't', 'e', 'r', 'n', ' ', 't', 'o', 'o', ' ', 'c', 'o', 'm', 'p', 'l', 'e', 'x', '\x00'})), -1)
		return
	}
	if argc == 3 {
		var zEsc *uint8 = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)))
		if uintptr(unsafe.Pointer(zEsc)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		if sqlite3Utf8CharLen((*int8)(unsafe.Pointer(zEsc)), -1) != 1 {
			sqlite3_result_error(context, (*int8)(unsafe.Pointer(&[45]int8{'E', 'S', 'C', 'A', 'P', 'E', ' ', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 's', 'i', 'n', 'g', 'l', 'e', ' ', 'c', 'h', 'a', 'r', 'a', 'c', 't', 'e', 'r', '\x00'})), -1)
			return
		}
		escape = sqlite3Utf8Read(&zEsc)
		if escape == uint32(pInfo.matchAll) || escape == uint32(pInfo.matchOne) {
			__builtin___memcpy_chk(unsafe.Pointer(&backupInfo), unsafe.Pointer(pInfo), 4, __builtin_object_size(unsafe.Pointer(&backupInfo), 0))
			pInfo = &backupInfo
			if escape == uint32(pInfo.matchAll) {
				pInfo.matchAll = uint8(0)
			}
			if escape == uint32(pInfo.matchOne) {
				pInfo.matchOne = uint8(0)
			}
		}
	} else {
		escape = uint32(pInfo.matchSet)
	}
	zB = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	zA = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	if zA != nil && zB != nil {
		sqlite3_result_int(context, func() int32 {
			if patternCompare(zB, zA, pInfo, escape) == 0 {
				return 1
			} else {
				return 0
			}
		}())
	}
}
func nullifFunc(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var pColl *struct_CollSeq = sqlite3GetFuncCollSeq(context)
	func() int {
		_ = NotUsed
		return 0
	}()
	if sqlite3MemCompare(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)), *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)), pColl) != 0 {
		sqlite3_result_value(context, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	}
}
func versionFunc(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	sqlite3_result_text(context, sqlite3_libversion(), -1, (func(unsafe.Pointer))(0))
}
func sourceidFunc(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	sqlite3_result_text(context, sqlite3_sourceid(), -1, (func(unsafe.Pointer))(0))
}
func errlogFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	func() int {
		_ = argc
		return 0
	}()
	func() int {
		_ = context
		return 0
	}()
	sqlite3_log(sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))), (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))))
}
func compileoptionusedFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zOptName *int8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	if uintptr(unsafe.Pointer(func() (_cgo_ret *int8) {
		_cgo_addr := &zOptName
		*_cgo_addr = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		sqlite3_result_int(context, sqlite3_compileoption_used(zOptName))
	}
}
func compileoptiongetFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var n int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	n = sqlite3_value_int(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, (func(unsafe.Pointer))(0))
}

var hexdigits [16]int8 = [16]int8{int8('0'), int8('1'), int8('2'), int8('3'), int8('4'), int8('5'), int8('6'), int8('7'), int8('8'), int8('9'), int8('A'), int8('B'), int8('C'), int8('D'), int8('E'), int8('F')}

func sqlite3QuoteValue(pStr *struct_sqlite3_str, pValue *struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	switch sqlite3_value_type(pValue) {
	case 2:
		{
			var r1 float64
			var r2 float64
			var zVal *int8
			r1 = sqlite3_value_double(pValue)
			sqlite3_str_appendf(pStr, (*int8)(unsafe.Pointer(&[7]int8{'%', '!', '.', '1', '5', 'g', '\x00'})), r1)
			zVal = sqlite3_str_value(pStr)
			if zVal != nil {
				sqlite3AtoF(zVal, &r2, int32(pStr.nChar), uint8(1))
				if r1 != r2 {
					sqlite3_str_reset(pStr)
					sqlite3_str_appendf(pStr, (*int8)(unsafe.Pointer(&[7]int8{'%', '!', '.', '2', '0', 'e', '\x00'})), r1)
				}
			}
			break
		}
	case 1:
		{
			sqlite3_str_appendf(pStr, (*int8)(unsafe.Pointer(&[5]int8{'%', 'l', 'l', 'd', '\x00'})), sqlite3_value_int64(pValue))
			break
		}
	case 4:
		{
			var zBlob *int8 = (*int8)(sqlite3_value_blob(pValue))
			var nBlob int32 = sqlite3_value_bytes(pValue)
			func() int {
				_ = 0
				return 0
			}()
			sqlite3StrAccumEnlarge(pStr, nBlob*2+4)
			if int32(pStr.accError) == 0 {
				var zText *int8 = pStr.zText
				var i int32
				for i = int32(0); i < nBlob; i++ {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(i*2+2))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&hexdigits)))) + uintptr(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBlob)) + uintptr(i))))>>4&15)))
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(i*2+3))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&hexdigits)))) + uintptr(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zBlob)) + uintptr(i))))&15)))
				}
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(nBlob*2+2))) = int8('\'')
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(nBlob*2+3))) = int8('\x00')
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(0))) = int8('X')
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zText)) + uintptr(1))) = int8('\'')
				pStr.nChar = uint32(nBlob*2 + 3)
			}
			break
		}
	case 3:
		{
			var zArg *uint8 = sqlite3_value_text(pValue)
			sqlite3_str_appendf(pStr, (*int8)(unsafe.Pointer(&[3]int8{'%', 'Q', '\x00'})), zArg)
			break
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[5]int8{'N', 'U', 'L', 'L', '\x00'})), 4)
			break
		}
	}
}
func quoteFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var str struct_sqlite3_str
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	sqlite3StrAccumInit(&str, db, nil, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)))
	sqlite3QuoteValue(&str, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	sqlite3_result_text(context, sqlite3StrAccumFinish(&str), int32(str.nChar), (func(unsafe.Pointer))(sqlite3OomFault))
	if int32(str.accError) != 0 {
		sqlite3_result_null(context)
		sqlite3_result_error_code(context, int32(str.accError))
	}
}
func unicodeFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var z *uint8 = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	func() int {
		_ = argc
		return 0
	}()
	if z != nil && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) != 0 {
		sqlite3_result_int(context, int32(sqlite3Utf8Read(&z)))
	}
}
func charFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var z *uint8
	var zOut *uint8
	var i int32
	zOut = func() (_cgo_ret *uint8) {
		_cgo_addr := &z
		*_cgo_addr = (*uint8)(sqlite3_malloc64(uint64(argc*4 + 1)))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_result_error_nomem(context)
		return
	}
	for i = int32(0); i < argc; i++ {
		var x int64
		var c uint32
		x = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))
		if x < int64(0) || x > int64(1114111) {
			x = int64(65533)
		}
		c = uint32(x & int64(2097151))
		if c < uint32(128) {
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(c & uint32(255))
		} else if c < uint32(2048) {
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(192 + int32(uint8(c>>6&uint32(31))))
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(128 + int32(uint8(c&uint32(63))))
		} else if c < uint32(65536) {
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(224 + int32(uint8(c>>12&uint32(15))))
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(128 + int32(uint8(c>>6&uint32(63))))
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(128 + int32(uint8(c&uint32(63))))
		} else {
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(240 + int32(uint8(c>>18&uint32(7))))
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(128 + int32(uint8(c>>12&uint32(63))))
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(128 + int32(uint8(c>>6&uint32(63))))
			*func() (_cgo_ret *uint8) {
				_cgo_addr := &zOut
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = uint8(128 + int32(uint8(c&uint32(63))))
		}
	}
	sqlite3_result_text64(context, (*int8)(unsafe.Pointer(z)), uint64(uintptr(unsafe.Pointer(zOut))-uintptr(unsafe.Pointer(z))), sqlite3_free, uint8(1))
}
func hexFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var i int32
	var n int32
	var pBlob *uint8
	var zHex *int8
	var z *int8
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	pBlob = (*uint8)(sqlite3_value_blob(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	n = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	func() int {
		_ = 0
		return 0
	}()
	z = func() (_cgo_ret *int8) {
		_cgo_addr := &zHex
		*_cgo_addr = (*int8)(contextMalloc(context, int64(n)*int64(2)+int64(1)))
		return *_cgo_addr
	}()
	if zHex != nil {
		for i = int32(0); i < n; func() *uint8 {
			i++
			return func() (_cgo_ret *uint8) {
				_cgo_addr := &pBlob
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}()
		}() {
			var c uint8 = *pBlob
			*func() (_cgo_ret *int8) {
				_cgo_addr := &z
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&hexdigits)))) + uintptr(int32(c)>>4&15)))
			*func() (_cgo_ret *int8) {
				_cgo_addr := &z
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr))++
				return
			}() = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&hexdigits)))) + uintptr(int32(c)&15)))
		}
		*z = int8(0)
		sqlite3_result_text(context, zHex, n*2, sqlite3_free)
	}
}
func zeroblobFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var n int64
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	n = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if n < int64(0) {
		n = int64(0)
	}
	rc = sqlite3_result_zeroblob64(context, uint64(n))
	if rc != 0 {
		sqlite3_result_error_code(context, rc)
	}
}
func replaceFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zStr *uint8
	var zPattern *uint8
	var zRep *uint8
	var zOut *uint8
	var nStr int32
	var nPattern int32
	var nRep int32
	var nOut int64
	var loopLimit int32
	var i int32
	var j int32
	var cntExpand uint32
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	zStr = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if uintptr(unsafe.Pointer(zStr)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	nStr = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	func() int {
		_ = 0
		return 0
	}()
	zPattern = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	if uintptr(unsafe.Pointer(zPattern)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		return
	}
	if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) + uintptr(0)))) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_result_value(context, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		return
	}
	nPattern = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	func() int {
		_ = 0
		return 0
	}()
	zRep = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)))
	if uintptr(unsafe.Pointer(zRep)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	nRep = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(2)*8)))
	func() int {
		_ = 0
		return 0
	}()
	nOut = int64(nStr + 1)
	func() int {
		_ = 0
		return 0
	}()
	zOut = (*uint8)(contextMalloc(context, int64(nOut)))
	if uintptr(unsafe.Pointer(zOut)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	loopLimit = nStr - nPattern
	cntExpand = uint32(0)
	for i = func() (_cgo_ret int32) {
		_cgo_addr := &j
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}(); i <= loopLimit; i++ {
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStr)) + uintptr(i)))) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPattern)) + uintptr(0)))) || memcmp(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStr)) + uintptr(i)))), unsafe.Pointer(zPattern), uint(nPattern)) != 0 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStr)) + uintptr(i)))
		} else {
			if nRep > nPattern {
				nOut += int64(nRep - nPattern)
				if nOut-int64(1) > int64(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4))) {
					sqlite3_result_error_toobig(context)
					sqlite3_free(unsafe.Pointer(zOut))
					return
				}
				cntExpand++
				if cntExpand&(cntExpand-uint32(1)) == uint32(0) {
					var zOld *uint8
					zOld = zOut
					zOut = (*uint8)(sqlite3Realloc(unsafe.Pointer(zOut), uint64(int64(int32(nOut))+(nOut-int64(nStr)-int64(1)))))
					if uintptr(unsafe.Pointer(zOut)) == uintptr(unsafe.Pointer(nil)) {
						sqlite3_result_error_nomem(context)
						sqlite3_free(unsafe.Pointer(zOld))
						return
					}
				}
			}
			__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j)))), unsafe.Pointer(zRep), uint(nRep), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j)))), 0))
			j += nRep
			i += nPattern - 1
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memcpy_chk(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j)))), unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStr)) + uintptr(i)))), uint(nStr-i), __builtin_object_size(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j)))), 0))
	j += nStr - i
	func() int {
		_ = 0
		return 0
	}()
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j))) = uint8(0)
	sqlite3_result_text(context, (*int8)(unsafe.Pointer(zOut)), j, sqlite3_free)
}
func trimFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zIn *uint8
	var zCharSet *uint8
	var nIn uint32
	var flags int32
	var i int32
	var aLen *uint32 = nil
	var azChar **uint8 = nil
	var nChar int32
	if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) == 5 {
		return
	}
	zIn = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if uintptr(unsafe.Pointer(zIn)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	nIn = uint32(sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	func() int {
		_ = 0
		return 0
	}()
	if argc == 1 {
		var lenOne [1]uint32 = [1]uint32{uint32(1)}
		var azOne [1]*uint8 = [1]*uint8{(*uint8)(unsafe.Pointer((*int8)(unsafe.Pointer(&[2]int8{' ', '\x00'}))))}
		nChar = int32(1)
		aLen = (*uint32)(unsafe.Pointer((*uint32)(unsafe.Pointer(&lenOne))))
		azChar = (**uint8)(unsafe.Pointer((**uint8)(unsafe.Pointer(&azOne))))
		zCharSet = (*uint8)(nil)
	} else if uintptr(unsafe.Pointer(func() (_cgo_ret *uint8) {
		_cgo_addr := &zCharSet
		*_cgo_addr = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return
	} else {
		var z *uint8
		for func() int32 {
			z = zCharSet
			return func() (_cgo_ret int32) {
				_cgo_addr := &nChar
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
		}(); *z != 0; nChar++ {
			{
				if int32(*func() (_cgo_ret *uint8) {
					_cgo_addr := &z
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) >= 192 {
					for int32(*z)&192 == 128 {
						*(*uintptr)(unsafe.Pointer(&z))++
					}
				}
			}
		}
		if nChar > 0 {
			azChar = (**uint8)(contextMalloc(context, int64(uint64(int64(nChar))*uint64(8+4))))
			if uintptr(unsafe.Pointer(azChar)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
			aLen = (*uint32)(unsafe.Pointer(&*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(azChar)) + uintptr(nChar)*8))))
			for func() int32 {
				z = zCharSet
				return func() (_cgo_ret int32) {
					_cgo_addr := &nChar
					*_cgo_addr = int32(0)
					return *_cgo_addr
				}()
			}(); *z != 0; nChar++ {
				*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(azChar)) + uintptr(nChar)*8)) = (*uint8)(unsafe.Pointer(z))
				{
					if int32(*func() (_cgo_ret *uint8) {
						_cgo_addr := &z
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr))++
						return
					}()) >= 192 {
						for int32(*z)&192 == 128 {
							*(*uintptr)(unsafe.Pointer(&z))++
						}
					}
				}
				*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLen)) + uintptr(nChar)*4)) = uint32(uintptr(unsafe.Pointer(z)) - uintptr(unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(azChar)) + uintptr(nChar)*8)))))
			}
		}
	}
	if nChar > 0 {
		flags = int32(int(sqlite3_user_data(context)))
		if flags&1 != 0 {
			for nIn > uint32(0) {
				var len uint32 = uint32(0)
				for i = int32(0); i < nChar; i++ {
					len = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLen)) + uintptr(i)*4))
					if len <= nIn && memcmp(unsafe.Pointer(zIn), unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(azChar)) + uintptr(i)*8))), uint(len)) == 0 {
						break
					}
				}
				if i >= nChar {
					break
				}
				*(*uintptr)(unsafe.Pointer(&zIn)) += uintptr(len)
				nIn -= len
			}
		}
		if flags&2 != 0 {
			for nIn > uint32(0) {
				var len uint32 = uint32(0)
				for i = int32(0); i < nChar; i++ {
					len = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aLen)) + uintptr(i)*4))
					if len <= nIn && memcmp(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(zIn)) + uintptr(nIn-len)))), unsafe.Pointer(*(**uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(azChar)) + uintptr(i)*8))), uint(len)) == 0 {
						break
					}
				}
				if i >= nChar {
					break
				}
				nIn -= len
			}
		}
		if zCharSet != nil {
			sqlite3_free(unsafe.Pointer(azChar))
		}
	}
	sqlite3_result_text(context, (*int8)(unsafe.Pointer(zIn)), int32(nIn), (func(unsafe.Pointer))(-1))
}
func loadExt(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zFile *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var zProc *int8
	var db *struct_sqlite3 = sqlite3_context_db_handle(context)
	var zErrMsg *int8 = nil
	if db.flags&uint64(131072) == uint64(0) {
		sqlite3_result_error(context, (*int8)(unsafe.Pointer(&[15]int8{'n', 'o', 't', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'e', 'd', '\x00'})), -1)
		return
	}
	if argc == 2 {
		zProc = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
	} else {
		zProc = (*int8)(nil)
	}
	if zFile != nil && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) != 0 {
		sqlite3_result_error(context, zErrMsg, -1)
		sqlite3_free(unsafe.Pointer(zErrMsg))
	}
}

type SumCtx = struct_SumCtx
type struct_SumCtx struct {
	rSum     float64
	iSum     int64
	cnt      int64
	overflow uint8
	approx   uint8
}

func sumStep(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_SumCtx
	var type_ int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	p = (*struct_SumCtx)(sqlite3_aggregate_context(context, int32(26)))
	type_ = sqlite3_value_numeric_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if p != nil && type_ != 5 {
		p.cnt++
		if type_ == 1 {
			var v int64 = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			p.rSum += float64(v)
			if int32(p.approx)|int32(p.overflow) == 0 && sqlite3AddInt64(&p.iSum, v) != 0 {
				p.approx = func() (_cgo_ret uint8) {
					_cgo_addr := &p.overflow
					*_cgo_addr = uint8(1)
					return *_cgo_addr
				}()
			}
		} else {
			p.rSum += sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			p.approx = uint8(1)
		}
	}
}
func sumInverse(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_SumCtx
	var type_ int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	p = (*struct_SumCtx)(sqlite3_aggregate_context(context, int32(26)))
	type_ = sqlite3_value_numeric_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if p != nil && type_ != 5 {
		func() int {
			_ = 0
			return 0
		}()
		p.cnt--
		func() int {
			_ = 0
			return 0
		}()
		if type_ == 1 && int32(p.approx) == 0 {
			var v int64 = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			p.rSum -= float64(v)
			p.iSum -= v
		} else {
			p.rSum -= sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		}
	}
}
func sumFinalize(context *struct_sqlite3_context) {
	var p *struct_SumCtx
	p = (*struct_SumCtx)(sqlite3_aggregate_context(context, 0))
	if p != nil && p.cnt > int64(0) {
		if p.overflow != 0 {
			sqlite3_result_error(context, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 't', 'e', 'g', 'e', 'r', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', '\x00'})), -1)
		} else if p.approx != 0 {
			sqlite3_result_double(context, p.rSum)
		} else {
			sqlite3_result_int64(context, p.iSum)
		}
	}
}
func avgFinalize(context *struct_sqlite3_context) {
	var p *struct_SumCtx
	p = (*struct_SumCtx)(sqlite3_aggregate_context(context, 0))
	if p != nil && p.cnt > int64(0) {
		sqlite3_result_double(context, p.rSum/float64(p.cnt))
	}
}
func totalFinalize(context *struct_sqlite3_context) {
	var p *struct_SumCtx
	p = (*struct_SumCtx)(sqlite3_aggregate_context(context, 0))
	sqlite3_result_double(context, func() float64 {
		if p != nil {
			return p.rSum
		} else {
			return float64(0)
		}
	}())
}

type CountCtx = struct_CountCtx
type struct_CountCtx struct {
	n int64
}

func countStep(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_CountCtx
	p = (*struct_CountCtx)(sqlite3_aggregate_context(context, int32(8)))
	if (argc == 0 || 5 != sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))) && p != nil {
		p.n++
	}
	func() int {
		_ = 0
		return 0
	}()
}
func countFinalize(context *struct_sqlite3_context) {
	var p *struct_CountCtx
	p = (*struct_CountCtx)(sqlite3_aggregate_context(context, 0))
	sqlite3_result_int64(context, func() int64 {
		if p != nil {
			return p.n
		} else {
			return int64(0)
		}
	}())
}
func countInverse(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_CountCtx
	p = (*struct_CountCtx)(sqlite3_aggregate_context(ctx, int32(8)))
	if (argc == 0 || 5 != sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))) && p != nil {
		p.n--
	}
}
func minmaxStep(context *struct_sqlite3_context, NotUsed int32, argv **struct_sqlite3_value) {
	var pArg *struct_sqlite3_value = (*struct_sqlite3_value)(unsafe.Pointer(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	var pBest *struct_sqlite3_value
	func() int {
		_ = NotUsed
		return 0
	}()
	pBest = (*struct_sqlite3_value)(sqlite3_aggregate_context(context, int32(56)))
	if !(pBest != nil) {
		return
	}
	if sqlite3_value_type(pArg) == 5 {
		if pBest.flags != 0 {
			sqlite3SkipAccumulatorLoad(context)
		}
	} else if pBest.flags != 0 {
		var max int32
		var cmp int32
		var pColl *struct_CollSeq = sqlite3GetFuncCollSeq(context)
		max = func() int32 {
			if uintptr(unsafe.Pointer(sqlite3_user_data(context))) != uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}()
		cmp = sqlite3MemCompare(pBest, pArg, pColl)
		if max != 0 && cmp < 0 || !(max != 0) && cmp > 0 {
			sqlite3VdbeMemCopy(pBest, pArg)
		} else {
			sqlite3SkipAccumulatorLoad(context)
		}
	} else {
		pBest.db = sqlite3_context_db_handle(context)
		sqlite3VdbeMemCopy(pBest, pArg)
	}
}
func minMaxValueFinalize(context *struct_sqlite3_context, bValue int32) {
	var pRes *struct_sqlite3_value
	pRes = (*struct_sqlite3_value)(sqlite3_aggregate_context(context, 0))
	if pRes != nil {
		if pRes.flags != 0 {
			sqlite3_result_value(context, pRes)
		}
		if bValue == 0 {
			sqlite3VdbeMemRelease(pRes)
		}
	}
}
func minMaxValue(context *struct_sqlite3_context) {
	minMaxValueFinalize(context, 1)
}
func minMaxFinalize(context *struct_sqlite3_context) {
	minMaxValueFinalize(context, 0)
}

type _cgoa_76 struct {
	str             struct_sqlite3_str
	nAccum          int32
	nFirstSepLength int32
	pnSepLengths    *int32
}

func groupConcatStep(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var zVal *int8
	var pGCC *_cgoa_76
	var zSep *int8
	var nVal int32
	var nSep int32
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) == 5 {
		return
	}
	pGCC = (*_cgoa_76)(sqlite3_aggregate_context(context, int32(48)))
	if pGCC != nil {
		var db *struct_sqlite3 = sqlite3_context_db_handle(context)
		var firstTerm int32 = func() int32 {
			if pGCC.str.mxAlloc == uint32(0) {
				return 1
			} else {
				return 0
			}
		}()
		pGCC.str.mxAlloc = uint32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(0)*4)))
		if argc == 1 {
			if !(firstTerm != 0) {
				sqlite3_str_appendchar(&pGCC.str, 1, int8(','))
			} else {
				pGCC.nFirstSepLength = int32(1)
			}
		} else if !(firstTerm != 0) {
			zSep = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
			nSep = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
			if zSep != nil {
				sqlite3_str_append(&pGCC.str, zSep, nSep)
			} else {
				nSep = int32(0)
			}
			if nSep != pGCC.nFirstSepLength || uintptr(unsafe.Pointer(pGCC.pnSepLengths)) != uintptr(unsafe.Pointer(nil)) {
				var pnsl *int32 = pGCC.pnSepLengths
				if uintptr(unsafe.Pointer(pnsl)) == uintptr(unsafe.Pointer(nil)) {
					pnsl = (*int32)(sqlite3_malloc64(uint64(uint(pGCC.nAccum+1) * 4)))
					if uintptr(unsafe.Pointer(pnsl)) != uintptr(unsafe.Pointer(nil)) {
						var i int32 = 0
						var nA int32 = pGCC.nAccum - 1
						for i < nA {
							*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pnsl)) + uintptr(func() (_cgo_ret int32) {
								_cgo_addr := &i
								_cgo_ret = *_cgo_addr
								*_cgo_addr++
								return
							}())*4)) = pGCC.nFirstSepLength
						}
					}
				} else {
					pnsl = (*int32)(sqlite3_realloc64(unsafe.Pointer(pnsl), uint64(uint(pGCC.nAccum)*4)))
				}
				if uintptr(unsafe.Pointer(pnsl)) != uintptr(unsafe.Pointer(nil)) {
					if pGCC.nAccum > 0 {
						*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pnsl)) + uintptr(pGCC.nAccum-1)*4)) = nSep
					}
					pGCC.pnSepLengths = pnsl
				} else {
					sqlite3StrAccumSetError(&pGCC.str, uint8(7))
				}
			}
		} else {
			pGCC.nFirstSepLength = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
		}
		pGCC.nAccum += int32(1)
		zVal = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
		nVal = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		if zVal != nil {
			sqlite3_str_append(&pGCC.str, zVal, nVal)
		}
	}
}
func groupConcatInverse(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var pGCC *_cgoa_76
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))) == 5 {
		return
	}
	pGCC = (*_cgoa_76)(sqlite3_aggregate_context(context, int32(48)))
	if pGCC != nil {
		var nVS int32
		func() int {
			_ = sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
			return 0
		}()
		nVS = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
		pGCC.nAccum -= int32(1)
		if uintptr(unsafe.Pointer(pGCC.pnSepLengths)) != uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			if pGCC.nAccum > 0 {
				nVS += *pGCC.pnSepLengths
				__builtin___memmove_chk(unsafe.Pointer(pGCC.pnSepLengths), unsafe.Pointer((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(pGCC.pnSepLengths))+uintptr(1)*4))), uint(pGCC.nAccum-1)*4, __builtin_object_size(unsafe.Pointer(pGCC.pnSepLengths), 0))
			}
		} else {
			nVS += pGCC.nFirstSepLength
		}
		if nVS >= int32(pGCC.str.nChar) {
			pGCC.str.nChar = uint32(0)
		} else {
			pGCC.str.nChar -= uint32(nVS)
			__builtin___memmove_chk(unsafe.Pointer(pGCC.str.zText), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pGCC.str.zText)) + uintptr(nVS)))), uint(pGCC.str.nChar), __builtin_object_size(unsafe.Pointer(pGCC.str.zText), 0))
		}
		if pGCC.str.nChar == uint32(0) {
			pGCC.str.mxAlloc = uint32(0)
			sqlite3_free(unsafe.Pointer(pGCC.pnSepLengths))
			pGCC.pnSepLengths = (*int32)(nil)
		}
	}
}
func groupConcatFinalize(context *struct_sqlite3_context) {
	var pGCC *_cgoa_76 = (*_cgoa_76)(sqlite3_aggregate_context(context, 0))
	if pGCC != nil {
		sqlite3ResultStrAccum(context, &pGCC.str)
		sqlite3_free(unsafe.Pointer(pGCC.pnSepLengths))
	}
}
func groupConcatValue(context *struct_sqlite3_context) {
	var pGCC *_cgoa_76 = (*_cgoa_76)(sqlite3_aggregate_context(context, 0))
	if pGCC != nil {
		var pAccum *struct_sqlite3_str = &pGCC.str
		if int32(pAccum.accError) == 18 {
			sqlite3_result_error_toobig(context)
		} else if int32(pAccum.accError) == 7 {
			sqlite3_result_error_nomem(context)
		} else {
			var zText *int8 = sqlite3_str_value(pAccum)
			sqlite3_result_text(context, zText, int32(pAccum.nChar), (func(unsafe.Pointer))(-1))
		}
	}
}
func sqlite3RegisterPerConnectionBuiltinFunctions(db *struct_sqlite3) {
	var rc int32 = sqlite3_overload_function(db, (*int8)(unsafe.Pointer(&[6]int8{'M', 'A', 'T', 'C', 'H', '\x00'})), 2)
	func() int {
		_ = 0
		return 0
	}()
	if rc == 7 {
		sqlite3OomFault(db)
	}
}
func sqlite3RegisterLikeFunctions(db *struct_sqlite3, caseSensitive int32) {
	var pInfo *struct_compareInfo
	var flags int32
	if caseSensitive != 0 {
		pInfo = (*struct_compareInfo)(unsafe.Pointer(&likeInfoAlt))
		flags = int32(4 | 8)
	} else {
		pInfo = (*struct_compareInfo)(unsafe.Pointer(&likeInfoNorm))
		flags = int32(4)
	}
	sqlite3CreateFunc(db, (*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), 2, 1, unsafe.Pointer(pInfo), likeFunc, nil, nil, nil, nil, nil)
	sqlite3CreateFunc(db, (*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), 3, 1, unsafe.Pointer(pInfo), likeFunc, nil, nil, nil, nil, nil)
	sqlite3FindFunction(db, (*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), 2, uint8(1), uint8(0)).funcFlags |= uint32(flags)
	sqlite3FindFunction(db, (*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), 3, uint8(1), uint8(0)).funcFlags |= uint32(flags)
}
func sqlite3IsLikeFunction(db *struct_sqlite3, pExpr *struct_Expr, pIsNocase *int32, aWc *int8) int32 {
	var pDef *struct_FuncDef
	var nExpr int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(pExpr.x.pList != nil) {
		return int32(0)
	}
	nExpr = pExpr.x.pList.nExpr
	func() int {
		_ = 0
		return 0
	}()
	pDef = sqlite3FindFunction(db, pExpr.u.zToken, nExpr, uint8(1), uint8(0))
	if uintptr(unsafe.Pointer(pDef)) == uintptr(unsafe.Pointer(nil)) || pDef.funcFlags&uint32(4) == uint32(0) {
		return int32(0)
	}
	__builtin___memcpy_chk(unsafe.Pointer(aWc), pDef.pUserData, uint(3), __builtin_object_size(unsafe.Pointer(aWc), 0))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nExpr < 3 {
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(aWc)) + uintptr(3))) = int8(0)
	} else {
		var pEscape *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(2)*28))).pExpr
		var zEscape *int8
		if int32(pEscape.op) != 117 {
			return int32(0)
		}
		func() int {
			_ = 0
			return 0
		}()
		zEscape = pEscape.u.zToken
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zEscape)) + uintptr(0)))) == 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zEscape)) + uintptr(1)))) != 0 {
			return int32(0)
		}
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zEscape)) + uintptr(0)))) == int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(aWc)) + uintptr(0)))) {
			return int32(0)
		}
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zEscape)) + uintptr(0)))) == int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(aWc)) + uintptr(1)))) {
			return int32(0)
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(aWc)) + uintptr(3))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zEscape)) + uintptr(0)))
	}
	*pIsNocase = func() int32 {
		if pDef.funcFlags&uint32(8) == uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	return int32(1)
}
func signFunc(context *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var type0 int32
	var x float64
	func() int {
		_ = argc
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	type0 = sqlite3_value_numeric_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	if type0 != 1 && type0 != 2 {
		return
	}
	x = sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	sqlite3_result_int(context, func() int32 {
		if x < 0 {
			return -1
		} else {
			return func() int32 {
				if x > 0 {
					return 1
				} else {
					return 0
				}
			}()
		}
	}())
}
func sqlite3RegisterBuiltinFunctions() {
	var aBuiltinFunc [69]struct_FuncDef = [69]struct_FuncDef{struct_FuncDef{int8(2), uint32(8388608 | 1 | 262144 | 16384 | 4194304 | 2048 | 0), unsafe.Pointer(int(1)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[20]int8{'i', 'm', 'p', 'l', 'i', 'e', 's', '_', 'n', 'o', 'n', 'n', 'u', 'l', 'l', '_', 'r', 'o', 'w', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 262144 | 16384 | 4194304 | 2048 | 0), unsafe.Pointer(int(3)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[13]int8{'e', 'x', 'p', 'r', '_', 'c', 'o', 'm', 'p', 'a', 'r', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 262144 | 16384 | 4194304 | 2048 | 0), unsafe.Pointer(int(2)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[18]int8{'e', 'x', 'p', 'r', '_', 'i', 'm', 'p', 'l', 'i', 'e', 's', '_', 'e', 'x', 'p', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 262144 | 16384 | 4194304 | 2048 | 0), unsafe.Pointer(int(4)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'a', 'f', 'f', 'i', 'n', 'i', 't', 'y', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 524288 | 2097152), unsafe.Pointer(int(0)), nil, loadExt, nil, nil, nil, (*int8)(unsafe.Pointer(&[15]int8{'l', 'o', 'a', 'd', '_', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 524288 | 2097152), unsafe.Pointer(int(0)), nil, loadExt, nil, nil, nil, (*int8)(unsafe.Pointer(&[15]int8{'l', 'o', 'a', 'd', '_', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 8192 | 1), nil, nil, compileoptionusedFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[26]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'o', 'p', 't', 'i', 'o', 'n', '_', 'u', 's', 'e', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 8192 | 1), nil, nil, compileoptiongetFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[25]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'c', 'o', 'm', 'p', 'i', 'l', 'e', 'o', 'p', 't', 'i', 'o', 'n', '_', 'g', 'e', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 4194304 | 2048 | 1024), unsafe.Pointer(int(99)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'u', 'n', 'l', 'i', 'k', 'e', 'l', 'y', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 4194304 | 2048 | 1024), unsafe.Pointer(int(99)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'l', 'i', 'k', 'e', 'l', 'i', 'h', 'o', 'o', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 4194304 | 2048 | 1024), unsafe.Pointer(int(99)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'l', 'i', 'k', 'e', 'l', 'y', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(1)), nil, trimFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'l', 't', 'r', 'i', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(1)), nil, trimFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'l', 't', 'r', 'i', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(2)), nil, trimFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'r', 't', 'r', 'i', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(2)), nil, trimFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'r', 't', 'r', 'i', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(3)), nil, trimFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'i', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(3)), nil, trimFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'i', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 1 | 1*32), unsafe.Pointer(int(0)), nil, minmaxFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'m', 'i', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 2048 | 1 | 1*32), unsafe.Pointer(int(0)), nil, nil, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'m', 'i', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 1*32 | 4096 | 134217728), unsafe.Pointer(int(0)), nil, minmaxStep, minMaxFinalize, minMaxValue, nil, (*int8)(unsafe.Pointer(&[4]int8{'m', 'i', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 1 | 1*32), unsafe.Pointer(int(1)), nil, minmaxFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'m', 'a', 'x', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 2048 | 1 | 1*32), unsafe.Pointer(int(1)), nil, nil, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'m', 'a', 'x', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 1*32 | 4096 | 134217728), unsafe.Pointer(int(1)), nil, minmaxStep, minMaxFinalize, minMaxValue, nil, (*int8)(unsafe.Pointer(&[4]int8{'m', 'a', 'x', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32 | 128), unsafe.Pointer(int(0)), nil, typeofFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'t', 'y', 'p', 'e', 'o', 'f', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32 | 128), unsafe.Pointer(int(0)), nil, subtypeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[8]int8{'s', 'u', 'b', 't', 'y', 'p', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32 | 64), unsafe.Pointer(int(0)), nil, lengthFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'l', 'e', 'n', 'g', 't', 'h', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, instrFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'i', 'n', 's', 't', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, printfFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'p', 'r', 'i', 'n', 't', 'f', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, printfFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'f', 'o', 'r', 'm', 'a', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, unicodeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[8]int8{'u', 'n', 'i', 'c', 'o', 'd', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, charFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'c', 'h', 'a', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, absFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'a', 'b', 's', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, roundFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'u', 'n', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, roundFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'u', 'n', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, upperFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'u', 'p', 'p', 'e', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, lowerFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'l', 'o', 'w', 'e', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, hexFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'h', 'e', 'x', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 4194304 | 2048 | 0), unsafe.Pointer(int(0)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'i', 'f', 'n', 'u', 'l', 'l', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 0*32), unsafe.Pointer(int(0)), nil, randomFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'r', 'a', 'n', 'd', 'o', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32), unsafe.Pointer(int(0)), nil, randomBlob, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'r', 'a', 'n', 'd', 'o', 'm', 'b', 'l', 'o', 'b', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 1*32), unsafe.Pointer(int(0)), nil, nullifFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'n', 'u', 'l', 'l', 'i', 'f', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 8192 | 1), nil, nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[15]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 8192 | 1), nil, nil, sourceidFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[17]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 's', 'o', 'u', 'r', 'c', 'e', '_', 'i', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, errlogFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'l', 'o', 'g', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, quoteFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[6]int8{'q', 'u', 'o', 't', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 0*32), unsafe.Pointer(int(0)), nil, last_insert_rowid, nil, nil, nil, (*int8)(unsafe.Pointer(&[18]int8{'l', 'a', 's', 't', '_', 'i', 'n', 's', 'e', 'r', 't', '_', 'r', 'o', 'w', 'i', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 0*32), unsafe.Pointer(int(0)), nil, changes, nil, nil, nil, (*int8)(unsafe.Pointer(&[8]int8{'c', 'h', 'a', 'n', 'g', 'e', 's', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 0*32), unsafe.Pointer(int(0)), nil, total_changes, nil, nil, nil, (*int8)(unsafe.Pointer(&[14]int8{'t', 'o', 't', 'a', 'l', '_', 'c', 'h', 'a', 'n', 'g', 'e', 's', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, replaceFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[8]int8{'r', 'e', 'p', 'l', 'a', 'c', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, zeroblobFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'z', 'e', 'r', 'o', 'b', 'l', 'o', 'b', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, substrFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'s', 'u', 'b', 's', 't', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, substrFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[7]int8{'s', 'u', 'b', 's', 't', 'r', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, substrFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'s', 'u', 'b', 's', 't', 'r', 'i', 'n', 'g', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, substrFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'s', 'u', 'b', 's', 't', 'r', 'i', 'n', 'g', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32 | 0), unsafe.Pointer(int(0)), nil, sumStep, sumFinalize, sumFinalize, sumInverse, (*int8)(unsafe.Pointer(&[4]int8{'s', 'u', 'm', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32 | 0), unsafe.Pointer(int(0)), nil, sumStep, totalFinalize, totalFinalize, sumInverse, (*int8)(unsafe.Pointer(&[6]int8{'t', 'o', 't', 'a', 'l', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32 | 0), unsafe.Pointer(int(0)), nil, sumStep, avgFinalize, avgFinalize, sumInverse, (*int8)(unsafe.Pointer(&[4]int8{'a', 'v', 'g', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 0*32 | 256 | 134217728), unsafe.Pointer(int(0)), nil, countStep, countFinalize, countFinalize, countInverse, (*int8)(unsafe.Pointer(&[6]int8{'c', 'o', 'u', 'n', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32 | 134217728), unsafe.Pointer(int(0)), nil, countStep, countFinalize, countFinalize, countInverse, (*int8)(unsafe.Pointer(&[6]int8{'c', 'o', 'u', 'n', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32 | 0), unsafe.Pointer(int(0)), nil, groupConcatStep, groupConcatFinalize, groupConcatValue, groupConcatInverse, (*int8)(unsafe.Pointer(&[13]int8{'g', 'r', 'o', 'u', 'p', '_', 'c', 'o', 'n', 'c', 'a', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 0*32 | 0), unsafe.Pointer(int(0)), nil, groupConcatStep, groupConcatFinalize, groupConcatValue, groupConcatInverse, (*int8)(unsafe.Pointer(&[13]int8{'g', 'r', 'o', 'u', 'p', '_', 'c', 'o', 'n', 'c', 'a', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 4 | 8), unsafe.Pointer(&globInfo), nil, likeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'g', 'l', 'o', 'b', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 1 | 4), unsafe.Pointer(&likeInfoNorm), nil, likeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 2048 | 1 | 4), unsafe.Pointer(&likeInfoNorm), nil, likeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, nil, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'c', 'o', 'a', 'l', 'e', 's', 'c', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, nil, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'c', 'o', 'a', 'l', 'e', 's', 'c', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 1 | 0*32), unsafe.Pointer(int(0)), nil, signFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'s', 'i', 'g', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 1 | 4194304 | 2048 | 0), unsafe.Pointer(int(0)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'c', 'o', 'a', 'l', 'e', 's', 'c', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 1 | 4194304 | 2048 | 0), unsafe.Pointer(int(5)), nil, versionFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'i', 'i', 'f', '\x00'})), _cgoa_9{nil}}}
	sqlite3AlterFunctions()
	sqlite3WindowFunctions()
	sqlite3RegisterDateTimeFunctions()
	sqlite3RegisterJsonFunctions()
	sqlite3InsertBuiltinFuncs((*struct_FuncDef)(unsafe.Pointer(&aBuiltinFunc)), int32(4968/72))
}
func sqlite3FkLocateIndex(pParse *struct_Parse, pParent *struct_Table, pFKey *struct_FKey, ppIdx **struct_Index, paiCol **int32) int32 {
	var pIdx *struct_Index = nil
	var aiCol *int32 = nil
	var nCol int32 = pFKey.nCol
	var zKey *int8 = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(0)*16))).zCol
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nCol == 1 {
		if int32(pParent.iPKey) >= 0 {
			if !(zKey != nil) {
				return int32(0)
			}
			if !(sqlite3StrICmp((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCol)) + uintptr(pParent.iPKey)*20))).zCnName, zKey) != 0) {
				return int32(0)
			}
		}
	} else if paiCol != nil {
		func() int {
			_ = 0
			return 0
		}()
		aiCol = (*int32)(sqlite3DbMallocRawNN(pParse.db, uint64(uint(nCol)*4)))
		if !(aiCol != nil) {
			return int32(1)
		}
		*paiCol = aiCol
	}
	for pIdx = pParent.pIndex; pIdx != nil; pIdx = pIdx.pNext {
		if int32(pIdx.nKeyCol) == nCol && int32(pIdx.onError) != 0 && uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) == uintptr(unsafe.Pointer(nil)) {
			if uintptr(unsafe.Pointer(zKey)) == uintptr(unsafe.Pointer(nil)) {
				if int32(pIdx.Xbf_0&3) == 2 {
					if aiCol != nil {
						var i int32
						for i = int32(0); i < nCol; i++ {
							*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4)) = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).iFrom
						}
					}
					break
				}
			} else {
				var i int32
				var j int32
				for i = int32(0); i < nCol; i++ {
					var iCol int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))
					var zDfltColl *int8
					var zIdxCol *int8
					if int32(iCol) < 0 {
						break
					}
					zDfltColl = sqlite3ColumnColl(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCol)) + uintptr(iCol)*20)))
					if !(zDfltColl != nil) {
						zDfltColl = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
					}
					if sqlite3StrICmp(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(i)*8)), zDfltColl) != 0 {
						break
					}
					zIdxCol = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pParent.aCol)) + uintptr(iCol)*20))).zCnName
					for j = int32(0); j < nCol; j++ {
						if sqlite3StrICmp((*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(j)*16))).zCol, zIdxCol) == 0 {
							if aiCol != nil {
								*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4)) = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(j)*16))).iFrom
							}
							break
						}
					}
					if j == nCol {
						break
					}
				}
				if i == nCol {
					break
				}
			}
		}
	}
	if !(pIdx != nil) {
		if !(pParse.disableTriggers != 0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[45]int8{'f', 'o', 'r', 'e', 'i', 'g', 'n', ' ', 'k', 'e', 'y', ' ', 'm', 'i', 's', 'm', 'a', 't', 'c', 'h', ' ', '-', ' ', '"', '%', 'w', '"', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'i', 'n', 'g', ' ', '"', '%', 'w', '"', '\x00'})), pFKey.pFrom.zName, pFKey.zTo)
		}
		sqlite3DbFree(pParse.db, unsafe.Pointer(aiCol))
		return int32(1)
	}
	*ppIdx = pIdx
	return int32(0)
}
func fkLookupParent(pParse *struct_Parse, iDb int32, pTab *struct_Table, pIdx *struct_Index, pFKey *struct_FKey, aiCol *int32, regData int32, nIncr int32, isIgnore int32) {
	var i int32
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var iCur int32 = pParse.nTab - 1
	var iOk int32 = sqlite3VdbeMakeLabel(pParse)
	if nIncr < 0 {
		sqlite3VdbeAddOp2(v, 48, int32(pFKey.isDeferred), iOk)
	}
	for i = int32(0); i < pFKey.nCol; i++ {
		var iReg int32 = int32(sqlite3TableColumnToStorage(pFKey.pFrom, int16(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4))))) + regData + 1
		sqlite3VdbeAddOp2(v, 50, iReg, iOk)
	}
	if isIgnore == 0 {
		if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(nil)) {
			var iMustBeInt int32
			var regTemp int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp2(v, 80, int32(sqlite3TableColumnToStorage(pFKey.pFrom, int16(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(0)*4)))))+1+regData, regTemp)
			iMustBeInt = sqlite3VdbeAddOp2(v, 15, regTemp, 0)
			if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(pFKey.pFrom)) && nIncr == 1 {
				sqlite3VdbeAddOp3(v, 53, regData, iOk, regTemp)
				sqlite3VdbeChangeP5(v, uint16(144))
			}
			sqlite3OpenTable(pParse, iCur, iDb, pTab, 101)
			sqlite3VdbeAddOp3(v, 33, iCur, 0, regTemp)
			sqlite3VdbeGoto(v, iOk)
			sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2)
			sqlite3VdbeJumpHere(v, iMustBeInt)
			sqlite3ReleaseTempReg(pParse, regTemp)
		} else {
			var nCol int32 = pFKey.nCol
			var regTemp int32 = sqlite3GetTempRange(pParse, nCol)
			var regRec int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp3(v, 101, iCur, int32(pIdx.tnum), iDb)
			sqlite3VdbeSetP4KeyInfo(pParse, pIdx)
			for i = int32(0); i < nCol; i++ {
				sqlite3VdbeAddOp2(v, 79, int32(sqlite3TableColumnToStorage(pFKey.pFrom, int16(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4)))))+1+regData, regTemp+i)
			}
			if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(pFKey.pFrom)) && nIncr == 1 {
				var iJump int32 = sqlite3VdbeCurrentAddr(v) + nCol + 1
				for i = int32(0); i < nCol; i++ {
					var iChild int32 = int32(sqlite3TableColumnToStorage(pFKey.pFrom, int16(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4))))) + 1 + regData
					var iParent int32 = 1 + regData
					iParent += int32(sqlite3TableColumnToStorage(pIdx.pTable, *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))))
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))) == int32(pTab.iPKey) {
						iParent = regData
					}
					sqlite3VdbeAddOp3(v, 52, iChild, iJump, iParent)
					sqlite3VdbeChangeP5(v, uint16(16))
				}
				sqlite3VdbeGoto(v, iOk)
			}
			sqlite3VdbeAddOp4(v, 96, regTemp, nCol, regRec, sqlite3IndexAffinityStr(pParse.db, pIdx), nCol)
			sqlite3VdbeAddOp4Int(v, 31, iCur, iOk, regRec, 0)
			sqlite3ReleaseTempReg(pParse, regRec)
			sqlite3ReleaseTempRange(pParse, regTemp, nCol)
		}
	}
	if !(pFKey.isDeferred != 0) && !(pParse.db.flags&uint64(524288) != 0) && !(pParse.pToplevel != nil) && !(pParse.isMultiWrite != 0) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3HaltConstraint(pParse, 19|3<<8, 2, nil, int8(-1), uint8(4))
	} else {
		if nIncr > 0 && int32(pFKey.isDeferred) == 0 {
			sqlite3MayAbort(pParse)
		}
		sqlite3VdbeAddOp2(v, 157, int32(pFKey.isDeferred), nIncr)
	}
	sqlite3VdbeResolveLabel(v, iOk)
	sqlite3VdbeAddOp1(v, 121, iCur)
}
func exprTableRegister(pParse *struct_Parse, pTab *struct_Table, regBase int32, iCol int16) *struct_Expr {
	var pExpr *struct_Expr
	var pCol *struct_Column
	var zColl *int8
	var db *struct_sqlite3 = pParse.db
	pExpr = sqlite3Expr(db, 176, nil)
	if pExpr != nil {
		if int32(iCol) >= 0 && int32(iCol) != int32(pTab.iPKey) {
			pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
			pExpr.iTable = regBase + int32(sqlite3TableColumnToStorage(pTab, iCol)) + 1
			pExpr.affExpr = pCol.affinity
			zColl = sqlite3ColumnColl(pCol)
			if uintptr(unsafe.Pointer(zColl)) == uintptr(unsafe.Pointer(nil)) {
				zColl = db.pDfltColl.zName
			}
			pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl)
		} else {
			pExpr.iTable = regBase
			pExpr.affExpr = int8(68)
		}
	}
	return pExpr
}
func exprTableColumn(db *struct_sqlite3, pTab *struct_Table, iCursor int32, iCol int16) *struct_Expr {
	var pExpr *struct_Expr = sqlite3Expr(db, 167, nil)
	if pExpr != nil {
		func() int {
			_ = 0
			return 0
		}()
		pExpr.y.pTab = pTab
		pExpr.iTable = iCursor
		pExpr.iColumn = iCol
	}
	return pExpr
}
func fkScanChildren(pParse *struct_Parse, pSrc *struct_SrcList, pTab *struct_Table, pIdx *struct_Index, pFKey *struct_FKey, aiCol *int32, regData int32, nIncr int32) {
	var db *struct_sqlite3 = pParse.db
	var i int32
	var pWhere *struct_Expr = nil
	var sNameContext struct_NameContext
	var pWInfo *struct_WhereInfo
	var iFkIfZero int32 = 0
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nIncr < 0 {
		iFkIfZero = sqlite3VdbeAddOp2(v, 48, int32(pFKey.isDeferred), 0)
	}
	for i = int32(0); i < pFKey.nCol; i++ {
		var pLeft *struct_Expr
		var pRight *struct_Expr
		var pEq *struct_Expr
		var iCol int16
		var zCol *int8
		iCol = int16(func() int32 {
			if pIdx != nil {
				return int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
			} else {
				return -1
			}
		}())
		pLeft = exprTableRegister(pParse, pTab, regData, iCol)
		iCol = int16(func() int32 {
			if aiCol != nil {
				return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4))
			} else {
				return (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(0)*16))).iFrom
			}
		}())
		func() int {
			_ = 0
			return 0
		}()
		zCol = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pFKey.pFrom.aCol)) + uintptr(iCol)*20))).zCnName
		pRight = sqlite3Expr(db, 59, zCol)
		pEq = sqlite3PExpr(pParse, 53, pLeft, pRight)
		pWhere = sqlite3ExprAnd(pParse, pWhere, pEq)
	}
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(pFKey.pFrom)) && nIncr > 0 {
		var pNe *struct_Expr
		var pLeft *struct_Expr
		var pRight *struct_Expr
		if pTab.tabFlags&uint32(128) == uint32(0) {
			pLeft = exprTableRegister(pParse, pTab, regData, int16(-1))
			pRight = exprTableColumn(db, pTab, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).iCursor, int16(-1))
			pNe = sqlite3PExpr(pParse, 52, pLeft, pRight)
		} else {
			var pEq *struct_Expr
			var pAll *struct_Expr = nil
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < int32(pIdx.nKeyCol); i++ {
				var iCol int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))
				func() int {
					_ = 0
					return 0
				}()
				pLeft = exprTableRegister(pParse, pTab, regData, iCol)
				pRight = sqlite3Expr(db, 59, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName)
				pEq = sqlite3PExpr(pParse, 45, pLeft, pRight)
				pAll = sqlite3ExprAnd(pParse, pAll, pEq)
			}
			pNe = sqlite3PExpr(pParse, 19, pAll, nil)
		}
		pWhere = sqlite3ExprAnd(pParse, pWhere, pNe)
	}
	__builtin___memset_chk(unsafe.Pointer(&sNameContext), 0, 56, __builtin_object_size(unsafe.Pointer(&sNameContext), 0))
	sNameContext.pSrcList = pSrc
	sNameContext.pParse = pParse
	sqlite3ResolveExprNames(&sNameContext, pWhere)
	if pParse.nErr == 0 {
		pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, nil, nil, nil, uint16(0), 0)
		sqlite3VdbeAddOp2(v, 157, int32(pFKey.isDeferred), nIncr)
		if pWInfo != nil {
			sqlite3WhereEnd(pWInfo)
		}
	}
	sqlite3ExprDelete(db, pWhere)
	if iFkIfZero != 0 {
		sqlite3VdbeJumpHereOrPopInst(v, iFkIfZero)
	}
}
func sqlite3FkReferences(pTab *struct_Table) *struct_FKey {
	return (*struct_FKey)(sqlite3HashFind(&pTab.pSchema.fkeyHash, pTab.zName))
}
func fkTriggerDelete(dbMem *struct_sqlite3, p *struct_Trigger) {
	if p != nil {
		var pStep *struct_TriggerStep = p.step_list
		sqlite3ExprDelete(dbMem, pStep.pWhere)
		sqlite3ExprListDelete(dbMem, pStep.pExprList)
		sqlite3SelectDelete(dbMem, pStep.pSelect)
		sqlite3ExprDelete(dbMem, p.pWhen)
		sqlite3DbFree(dbMem, unsafe.Pointer(p))
	}
}
func sqlite3FkClearTriggerCache(db *struct_sqlite3, iDb int32) {
	var k *struct_HashElem
	var pHash *struct_Hash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.tblHash
	for k = pHash.first; k != nil; k = k.next {
		var pTab *struct_Table = (*struct_Table)(k.data)
		var pFKey *struct_FKey
		if !(int32(pTab.eTabType) == 0) {
			continue
		}
		for pFKey = pTab.u.tab.pFKey; pFKey != nil; pFKey = pFKey.pNextFrom {
			fkTriggerDelete(db, *(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(0)*8)))
			*(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(0)*8)) = (*struct_Trigger)(nil)
			fkTriggerDelete(db, *(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(1)*8)))
			*(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(1)*8)) = (*struct_Trigger)(nil)
		}
	}
}
func sqlite3FkDropTable(pParse *struct_Parse, pName *struct_SrcList, pTab *struct_Table) {
	var db *struct_sqlite3 = pParse.db
	if db.flags&uint64(16384) != 0 && int32(pTab.eTabType) == 0 {
		var iSkip int32 = 0
		var v *struct_Vdbe = sqlite3GetVdbe(pParse)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(sqlite3FkReferences(pTab))) == uintptr(unsafe.Pointer(nil)) {
			var p *struct_FKey
			for p = pTab.u.tab.pFKey; p != nil; p = p.pNextFrom {
				if int32(p.isDeferred) != 0 || db.flags&uint64(524288) != 0 {
					break
				}
			}
			if !(p != nil) {
				return
			}
			iSkip = sqlite3VdbeMakeLabel(pParse)
			sqlite3VdbeAddOp2(v, 48, 1, iSkip)
		}
		pParse.disableTriggers = uint8(1)
		sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), nil, nil, nil)
		pParse.disableTriggers = uint8(0)
		if db.flags&uint64(524288) == uint64(0) {
			sqlite3VdbeAddOp2(v, 48, 0, sqlite3VdbeCurrentAddr(v)+2)
			sqlite3HaltConstraint(pParse, 19|3<<8, 2, nil, int8(-1), uint8(4))
		}
		if iSkip != 0 {
			sqlite3VdbeResolveLabel(v, iSkip)
		}
	}
}
func fkChildIsModified(pTab *struct_Table, p *struct_FKey, aChange *int32, bChngRowid int32) int32 {
	var i int32
	for i = int32(0); i < p.nCol; i++ {
		var iChildKey int32 = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&p.aCol)))) + uintptr(i)*16))).iFrom
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aChange)) + uintptr(iChildKey)*4)) >= 0 {
			return int32(1)
		}
		if iChildKey == int32(pTab.iPKey) && bChngRowid != 0 {
			return int32(1)
		}
	}
	return int32(0)
}
func fkParentIsModified(pTab *struct_Table, p *struct_FKey, aChange *int32, bChngRowid int32) int32 {
	var i int32
	for i = int32(0); i < p.nCol; i++ {
		var zKey *int8 = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&p.aCol)))) + uintptr(i)*16))).zCol
		var iKey int32
		for iKey = int32(0); iKey < int32(pTab.nCol); iKey++ {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aChange)) + uintptr(iKey)*4)) >= 0 || iKey == int32(pTab.iPKey) && bChngRowid != 0 {
				var pCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iKey)*20))
				if zKey != nil {
					if 0 == sqlite3StrICmp(pCol.zCnName, zKey) {
						return int32(1)
					}
				} else if int32(pCol.colFlags)&1 != 0 {
					return int32(1)
				}
			}
		}
	}
	return int32(0)
}
func isSetNullAction(pParse *struct_Parse, pFKey *struct_FKey) int32 {
	var pTop *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	if pTop.pTriggerPrg != nil {
		var p *struct_Trigger = pTop.pTriggerPrg.pTrigger
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(*(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(0)*8)))) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFKey.aAction)))) + uintptr(0)))) == 8 || uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(*(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(1)*8)))) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFKey.aAction)))) + uintptr(1)))) == 8 {
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3FkCheck(pParse *struct_Parse, pTab *struct_Table, regOld int32, regNew int32, aChange *int32, bChngRowid int32) {
	var db *struct_sqlite3 = pParse.db
	var pFKey *struct_FKey
	var iDb int32
	var zDb *int8
	var isIgnoreErrors int32 = int32(pParse.disableTriggers)
	func() int {
		_ = 0
		return 0
	}()
	if db.flags&uint64(16384) == uint64(0) {
		return
	}
	if !(int32(pTab.eTabType) == 0) {
		return
	}
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	for pFKey = pTab.u.tab.pFKey; pFKey != nil; pFKey = pFKey.pNextFrom {
		var pTo *struct_Table
		var pIdx *struct_Index = nil
		var aiFree *int32 = nil
		var aiCol *int32
		var iCol int32
		var i int32
		var bIgnore int32 = 0
		if aChange != nil && sqlite3_stricmp(pTab.zName, pFKey.zTo) != 0 && fkChildIsModified(pTab, pFKey, aChange, bChngRowid) == 0 {
			continue
		}
		if pParse.disableTriggers != 0 {
			pTo = sqlite3FindTable(db, pFKey.zTo, zDb)
		} else {
			pTo = sqlite3LocateTable(pParse, uint32(0), pFKey.zTo, zDb)
		}
		if !(pTo != nil) || sqlite3FkLocateIndex(pParse, pTo, pFKey, &pIdx, &aiFree) != 0 {
			func() int {
				_ = 0
				return 0
			}()
			if !(isIgnoreErrors != 0) || int32(db.mallocFailed) != 0 {
				return
			}
			if uintptr(unsafe.Pointer(pTo)) == uintptr(unsafe.Pointer(nil)) {
				var v *struct_Vdbe = sqlite3GetVdbe(pParse)
				var iJump int32 = sqlite3VdbeCurrentAddr(v) + pFKey.nCol + 1
				for i = int32(0); i < pFKey.nCol; i++ {
					var iFromCol int32
					var iReg int32
					iFromCol = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(i)*16))).iFrom
					iReg = int32(sqlite3TableColumnToStorage(pFKey.pFrom, int16(iFromCol))) + regOld + 1
					sqlite3VdbeAddOp2(v, 50, iReg, iJump)
				}
				sqlite3VdbeAddOp2(v, 157, int32(pFKey.isDeferred), -1)
			}
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		if aiFree != nil {
			aiCol = aiFree
		} else {
			iCol = (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(0)*16))).iFrom
			aiCol = &iCol
		}
		for i = int32(0); i < pFKey.nCol; i++ {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4)) == int32(pTab.iPKey) {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4)) = int32(-1)
			}
			func() int {
				_ = 0
				return 0
			}()
			if db.xAuth != nil {
				var rcauth int32
				var zCol *int8 = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTo.aCol)) + uintptr(func() int32 {
					if pIdx != nil {
						return int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
					} else {
						return int32(pTo.iPKey)
					}
				}())*20))).zCnName
				rcauth = sqlite3AuthReadCol(pParse, pTo.zName, zCol, iDb)
				bIgnore = func() int32 {
					if rcauth == 2 {
						return 1
					} else {
						return 0
					}
				}()
			}
		}
		sqlite3TableLock(pParse, iDb, pTo.tnum, uint8(0), pTo.zName)
		pParse.nTab++
		if regOld != 0 {
			fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore)
		}
		if regNew != 0 && !(isSetNullAction(pParse, pFKey) != 0) {
			fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, 1, bIgnore)
		}
		sqlite3DbFree(db, unsafe.Pointer(aiFree))
	}
	for pFKey = sqlite3FkReferences(pTab); pFKey != nil; pFKey = pFKey.pNextTo {
		var pIdx *struct_Index = nil
		var pSrc *struct_SrcList
		var aiCol *int32 = nil
		if aChange != nil && fkParentIsModified(pTab, pFKey, aChange, bChngRowid) == 0 {
			continue
		}
		if !(pFKey.isDeferred != 0) && !(db.flags&uint64(524288) != 0) && !(pParse.pToplevel != nil) && !(pParse.isMultiWrite != 0) {
			func() int {
				_ = 0
				return 0
			}()
			continue
		}
		if sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) != 0 {
			if !(isIgnoreErrors != 0) || int32(db.mallocFailed) != 0 {
				return
			}
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		pSrc = sqlite3SrcListAppend(pParse, nil, nil, nil)
		if pSrc != nil {
			var pItem *struct_SrcItem = (*struct_SrcItem)(unsafe.Pointer(&pSrc.a))
			pItem.pTab = pFKey.pFrom
			pItem.zName = pFKey.pFrom.zName
			pItem.pTab.nTabRef++
			pItem.iCursor = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			if regNew != 0 {
				fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1)
			}
			if regOld != 0 {
				var eAction int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFKey.aAction)))) + func() uintptr {
					if uintptr(unsafe.Pointer(aChange)) != uintptr(unsafe.Pointer(nil)) {
						return 1
					} else {
						return 0
					}
				}())))
				fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1)
				if !(pFKey.isDeferred != 0) && eAction != 10 && eAction != 8 {
					sqlite3MayAbort(pParse)
				}
			}
			pItem.zName = (*int8)(nil)
			sqlite3SrcListDelete(db, pSrc)
		}
		sqlite3DbFree(db, unsafe.Pointer(aiCol))
	}
}
func sqlite3FkOldmask(pParse *struct_Parse, pTab *struct_Table) uint32 {
	var mask uint32 = uint32(0)
	if pParse.db.flags&uint64(16384) != 0 && int32(pTab.eTabType) == 0 {
		var p *struct_FKey
		var i int32
		for p = pTab.u.tab.pFKey; p != nil; p = p.pNextFrom {
			for i = int32(0); i < p.nCol; i++ {
				mask |= func() uint32 {
					if (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&p.aCol)))) + uintptr(i)*16))).iFrom > 31 {
						return 4294967295
					} else {
						return uint32(1) << (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&p.aCol)))) + uintptr(i)*16))).iFrom
					}
				}()
			}
		}
		for p = sqlite3FkReferences(pTab); p != nil; p = p.pNextTo {
			var pIdx *struct_Index = nil
			sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, nil)
			if pIdx != nil {
				for i = int32(0); i < int32(pIdx.nKeyCol); i++ {
					func() int {
						_ = 0
						return 0
					}()
					mask |= func() uint32 {
						if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))) > 31 {
							return 4294967295
						} else {
							return uint32(1) << int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
						}
					}()
				}
			}
		}
	}
	return mask
}
func sqlite3FkRequired(pParse *struct_Parse, pTab *struct_Table, aChange *int32, chngRowid int32) int32 {
	var eRet int32 = 1
	var bHaveFK int32 = 0
	if pParse.db.flags&uint64(16384) != 0 && int32(pTab.eTabType) == 0 {
		if !(aChange != nil) {
			bHaveFK = func() int32 {
				if sqlite3FkReferences(pTab) != nil || pTab.u.tab.pFKey != nil {
					return 1
				} else {
					return 0
				}
			}()
		} else {
			var p *struct_FKey
			for p = pTab.u.tab.pFKey; p != nil; p = p.pNextFrom {
				if fkChildIsModified(pTab, p, aChange, chngRowid) != 0 {
					if 0 == sqlite3_stricmp(pTab.zName, p.zTo) {
						eRet = int32(2)
					}
					bHaveFK = int32(1)
				}
			}
			for p = sqlite3FkReferences(pTab); p != nil; p = p.pNextTo {
				if fkParentIsModified(pTab, p, aChange, chngRowid) != 0 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&p.aAction)))) + uintptr(1)))) != 0 {
						return int32(2)
					}
					bHaveFK = int32(1)
				}
			}
		}
	}
	return func() int32 {
		if bHaveFK != 0 {
			return eRet
		} else {
			return 0
		}
	}()
}
func fkActionTrigger(pParse *struct_Parse, pTab *struct_Table, pFKey *struct_FKey, pChanges *struct_ExprList) *struct_Trigger {
	var db *struct_sqlite3 = pParse.db
	var action int32
	var pTrigger *struct_Trigger
	var iAction int32 = func() int32 {
		if uintptr(unsafe.Pointer(pChanges)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	action = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFKey.aAction)))) + uintptr(iAction))))
	if action == 7 && db.flags&uint64(524288) != 0 {
		return (*struct_Trigger)(nil)
	}
	pTrigger = *(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(iAction)*8))
	if action != 0 && !(pTrigger != nil) {
		var zFrom *int8
		var nFrom int32
		var pIdx *struct_Index = nil
		var aiCol *int32 = nil
		var pStep *struct_TriggerStep = nil
		var pWhere *struct_Expr = nil
		var pList *struct_ExprList = nil
		var pSelect *struct_Select = nil
		var i int32
		var pWhen *struct_Expr = nil
		if sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) != 0 {
			return (*struct_Trigger)(nil)
		}
		func() int {
			_ = 0
			return 0
		}()
		for i = int32(0); i < pFKey.nCol; i++ {
			var tOld struct_Token = struct_Token{(*int8)(unsafe.Pointer(&[4]int8{'o', 'l', 'd', '\x00'})), uint32(3)}
			var tNew struct_Token = struct_Token{(*int8)(unsafe.Pointer(&[4]int8{'n', 'e', 'w', '\x00'})), uint32(3)}
			var tFromCol struct_Token
			var tToCol struct_Token
			var iFromCol int32
			var pEq *struct_Expr
			iFromCol = func() int32 {
				if aiCol != nil {
					return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCol)) + uintptr(i)*4))
				} else {
					return (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFKey.aCol)))) + uintptr(0)*16))).iFrom
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3TokenInit(&tToCol, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(func() int32 {
				if pIdx != nil {
					return int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
				} else {
					return int32(pTab.iPKey)
				}
			}())*20))).zCnName)
			sqlite3TokenInit(&tFromCol, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pFKey.pFrom.aCol)) + uintptr(iFromCol)*20))).zCnName)
			pEq = sqlite3PExpr(pParse, 53, sqlite3PExpr(pParse, 141, sqlite3ExprAlloc(db, 59, &tOld, 0), sqlite3ExprAlloc(db, 59, &tToCol, 0)), sqlite3ExprAlloc(db, 59, &tFromCol, 0))
			pWhere = sqlite3ExprAnd(pParse, pWhere, pEq)
			if pChanges != nil {
				pEq = sqlite3PExpr(pParse, 45, sqlite3PExpr(pParse, 141, sqlite3ExprAlloc(db, 59, &tOld, 0), sqlite3ExprAlloc(db, 59, &tToCol, 0)), sqlite3PExpr(pParse, 141, sqlite3ExprAlloc(db, 59, &tNew, 0), sqlite3ExprAlloc(db, 59, &tToCol, 0)))
				pWhen = sqlite3ExprAnd(pParse, pWhen, pEq)
			}
			if action != 7 && (action != 10 || pChanges != nil) {
				var pNew *struct_Expr
				if action == 10 {
					pNew = sqlite3PExpr(pParse, 141, sqlite3ExprAlloc(db, 59, &tNew, 0), sqlite3ExprAlloc(db, 59, &tToCol, 0))
				} else if action == 9 {
					var pCol *struct_Column = (*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pFKey.pFrom.aCol)) + uintptr(iFromCol)*20))
					var pDflt *struct_Expr
					if int32(pCol.colFlags)&96 != 0 {
						pDflt = (*struct_Expr)(nil)
					} else {
						pDflt = sqlite3ColumnExpr(pFKey.pFrom, pCol)
					}
					if pDflt != nil {
						pNew = sqlite3ExprDup(db, pDflt, 0)
					} else {
						pNew = sqlite3ExprAlloc(db, 121, nil, 0)
					}
				} else {
					pNew = sqlite3ExprAlloc(db, 121, nil, 0)
				}
				pList = sqlite3ExprListAppend(pParse, pList, pNew)
				sqlite3ExprListSetName(pParse, pList, &tFromCol, 0)
			}
		}
		sqlite3DbFree(db, unsafe.Pointer(aiCol))
		zFrom = pFKey.pFrom.zName
		nFrom = sqlite3Strlen30(zFrom)
		if action == 7 {
			var tFrom struct_Token
			var pRaise *struct_Expr
			tFrom.z = zFrom
			tFrom.n = uint32(nFrom)
			pRaise = sqlite3Expr(db, 71, (*int8)(unsafe.Pointer(&[30]int8{'F', 'O', 'R', 'E', 'I', 'G', 'N', ' ', 'K', 'E', 'Y', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', '\x00'})))
			if pRaise != nil {
				pRaise.affExpr = int8(2)
			}
			pSelect = sqlite3SelectNew(pParse, sqlite3ExprListAppend(pParse, nil, pRaise), sqlite3SrcListAppend(pParse, nil, &tFrom, nil), pWhere, nil, nil, nil, uint32(0), nil)
			pWhere = (*struct_Expr)(nil)
		}
		db.lookaside.bDisable++
		db.lookaside.sz = uint16(0)
		pTrigger = (*struct_Trigger)(sqlite3DbMallocZero(db, uint64(72+96+uint(nFrom)+uint(1))))
		if pTrigger != nil {
			pStep = func() (_cgo_ret *struct_TriggerStep) {
				_cgo_addr := &pTrigger.step_list
				*_cgo_addr = (*struct_TriggerStep)(unsafe.Pointer(&*(*struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer(pTrigger)) + uintptr(1)*72))))
				return *_cgo_addr
			}()
			pStep.zTarget = (*int8)(unsafe.Pointer(&*(*struct_TriggerStep)(unsafe.Pointer(uintptr(unsafe.Pointer(pStep)) + uintptr(1)*96))))
			__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(pStep.zTarget))), unsafe.Pointer(zFrom), uint(nFrom), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(pStep.zTarget))), 0))
			pStep.pWhere = sqlite3ExprDup(db, pWhere, 1)
			pStep.pExprList = sqlite3ExprListDup(db, pList, 1)
			pStep.pSelect = sqlite3SelectDup(db, pSelect, 1)
			if pWhen != nil {
				pWhen = sqlite3PExpr(pParse, 19, pWhen, nil)
				pTrigger.pWhen = sqlite3ExprDup(db, pWhen, 1)
			}
		}
		db.lookaside.bDisable--
		db.lookaside.sz = uint16(func() int32 {
			if db.lookaside.bDisable != 0 {
				return 0
			} else {
				return int32(db.lookaside.szTrue)
			}
		}())
		sqlite3ExprDelete(db, pWhere)
		sqlite3ExprDelete(db, pWhen)
		sqlite3ExprListDelete(db, pList)
		sqlite3SelectDelete(db, pSelect)
		if int32(db.mallocFailed) == 1 {
			fkTriggerDelete(db, pTrigger)
			return (*struct_Trigger)(nil)
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		switch action {
		case 7:
			pStep.op = uint8(138)
			break
		case 10:
			if !(pChanges != nil) {
				pStep.op = uint8(128)
				break
			}
		default:
			pStep.op = uint8(129)
		}
		pStep.pTrig = pTrigger
		pTrigger.pSchema = pTab.pSchema
		pTrigger.pTabSchema = pTab.pSchema
		*(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(iAction)*8)) = pTrigger
		pTrigger.op = uint8(func() int32 {
			if pChanges != nil {
				return 129
			} else {
				return 128
			}
		}())
	}
	return pTrigger
}
func sqlite3FkActions(pParse *struct_Parse, pTab *struct_Table, pChanges *struct_ExprList, regOld int32, aChange *int32, bChngRowid int32) {
	if pParse.db.flags&uint64(16384) != 0 {
		var pFKey *struct_FKey
		for pFKey = sqlite3FkReferences(pTab); pFKey != nil; pFKey = pFKey.pNextTo {
			if uintptr(unsafe.Pointer(aChange)) == uintptr(unsafe.Pointer(nil)) || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) != 0 {
				var pAct *struct_Trigger = fkActionTrigger(pParse, pTab, pFKey, pChanges)
				if pAct != nil {
					sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, 2, 0)
				}
			}
		}
	}
}
func sqlite3FkDelete(db *struct_sqlite3, pTab *struct_Table) {
	var pFKey *struct_FKey
	var pNext *struct_FKey
	func() int {
		_ = 0
		return 0
	}()
	for pFKey = pTab.u.tab.pFKey; pFKey != nil; pFKey = pNext {
		func() int {
			_ = 0
			return 0
		}()
		if !(db != nil) || uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil)) {
			if pFKey.pPrevTo != nil {
				pFKey.pPrevTo.pNextTo = pFKey.pNextTo
			} else {
				var p unsafe.Pointer = unsafe.Pointer(pFKey.pNextTo)
				var z *int8 = func() *int8 {
					if p != nil {
						return pFKey.pNextTo.zTo
					} else {
						return pFKey.zTo
					}
				}()
				sqlite3HashInsert(&pTab.pSchema.fkeyHash, z, p)
			}
			if pFKey.pNextTo != nil {
				pFKey.pNextTo.pPrevTo = pFKey.pPrevTo
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		fkTriggerDelete(db, *(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(0)*8)))
		fkTriggerDelete(db, *(**struct_Trigger)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Trigger)(unsafe.Pointer(&pFKey.apTrigger)))) + uintptr(1)*8)))
		pNext = pFKey.pNextFrom
		sqlite3DbFree(db, unsafe.Pointer(pFKey))
	}
}
func sqlite3OpenTable(pParse *struct_Parse, iCur int32, iDb int32, pTab *struct_Table, opcode int32) {
	var v *struct_Vdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(func() int32 {
		if opcode == 112 {
			return 1
		} else {
			return 0
		}
	}()), pTab.zName)
	if pTab.tabFlags&uint32(128) == uint32(0) {
		sqlite3VdbeAddOp4Int(v, opcode, iCur, int32(pTab.tnum), iDb, int32(pTab.nNVCol))
	} else {
		var pPk *struct_Index = sqlite3PrimaryKeyIndex(pTab)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp3(v, opcode, iCur, int32(pPk.tnum), iDb)
		sqlite3VdbeSetP4KeyInfo(pParse, pPk)
	}
}
func sqlite3IndexAffinityStr(db *struct_sqlite3, pIdx *struct_Index) *int8 {
	if !(pIdx.zColAff != nil) {
		var n int32
		var pTab *struct_Table = pIdx.pTable
		pIdx.zColAff = (*int8)(sqlite3DbMallocRaw(nil, uint64(int32(pIdx.nColumn)+1)))
		if !(pIdx.zColAff != nil) {
			sqlite3OomFault(db)
			return (*int8)(nil)
		}
		for n = int32(0); n < int32(pIdx.nColumn); n++ {
			var x int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(n)*2))
			var aff int8
			if int32(x) >= 0 {
				aff = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(x)*20))).affinity
			} else if int32(x) == -1 {
				aff = int8(68)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				aff = sqlite3ExprAffinity((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(n)*28))).pExpr)
			}
			if int32(aff) < 65 {
				aff = int8(65)
			}
			if int32(aff) > 67 {
				aff = int8(67)
			}
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.zColAff)) + uintptr(n))) = aff
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.zColAff)) + uintptr(n))) = int8(0)
	}
	return pIdx.zColAff
}
func sqlite3TableAffinity(v *struct_Vdbe, pTab *struct_Table, iReg int32) {
	var i int32
	var j int32
	var zColAff *int8
	if pTab.tabFlags&uint32(65536) != 0 {
		if iReg == 0 {
			var pPrev *struct_VdbeOp
			sqlite3VdbeAppendP4(v, unsafe.Pointer(pTab), -6)
			pPrev = sqlite3VdbeGetOp(v, -1)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pPrev.opcode = uint8(94)
			sqlite3VdbeAddOp3(v, 96, pPrev.p1, pPrev.p2, pPrev.p3)
		} else {
			sqlite3VdbeAddOp2(v, 94, iReg, int32(pTab.nNVCol))
			sqlite3VdbeAppendP4(v, unsafe.Pointer(pTab), -6)
		}
		return
	}
	zColAff = pTab.zColAff
	if uintptr(unsafe.Pointer(zColAff)) == uintptr(unsafe.Pointer(nil)) {
		var db *struct_sqlite3 = sqlite3VdbeDb(v)
		zColAff = (*int8)(sqlite3DbMallocRaw(nil, uint64(int32(pTab.nCol)+1)))
		if !(zColAff != nil) {
			sqlite3OomFault(db)
			return
		}
		for i = func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}(); i < int32(pTab.nCol); i++ {
			func() int {
				_ = 0
				return 0
			}()
			if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 == 0 {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zColAff)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &j
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()))) = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).affinity
			}
		}
		for {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zColAff)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr--
				return
			}()))) = int8(0)
			if !(j >= 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zColAff)) + uintptr(j)))) <= 65) {
				break
			}
		}
		pTab.zColAff = zColAff
	}
	func() int {
		_ = 0
		return 0
	}()
	i = int32(strlen(zColAff) & uint(1073741823))
	if i != 0 {
		if iReg != 0 {
			sqlite3VdbeAddOp4(v, 95, iReg, i, 0, zColAff, i)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeChangeP4(v, -1, zColAff, i)
		}
	}
}
func readsTable(p *struct_Parse, iDb int32, pTab *struct_Table) int32 {
	var v *struct_Vdbe = sqlite3GetVdbe(p)
	var i int32
	var iEnd int32 = sqlite3VdbeCurrentAddr(v)
	var pVTab *struct_VTable = func() *struct_VTable {
		if int32(pTab.eTabType) == 1 {
			return sqlite3GetVTable(p.db, pTab)
		} else {
			return nil
		}
	}()
	for i = int32(1); i < iEnd; i++ {
		var pOp *struct_VdbeOp = sqlite3VdbeGetOp(v, i)
		func() int {
			_ = 0
			return 0
		}()
		if int32(pOp.opcode) == 101 && pOp.p3 == iDb {
			var pIndex *struct_Index
			var tnum uint32 = uint32(pOp.p2)
			if tnum == pTab.tnum {
				return int32(1)
			}
			for pIndex = pTab.pIndex; pIndex != nil; pIndex = pIndex.pNext {
				if tnum == pIndex.tnum {
					return int32(1)
				}
			}
		}
		if int32(pOp.opcode) == 172 && uintptr(unsafe.Pointer(*(**struct_VTable)(unsafe.Pointer(&pOp.p4)))) == uintptr(unsafe.Pointer(pVTab)) {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			return int32(1)
		}
	}
	return int32(0)
}
func exprColumnFlagUnion(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 167 && int32(pExpr.iColumn) >= 0 {
		func() int {
			_ = 0
			return 0
		}()
		pWalker.eCode |= uint16(int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_Table)(unsafe.Pointer(&pWalker.u))).aCol)) + uintptr(pExpr.iColumn)*20))).colFlags))
	}
	return int32(0)
}
func sqlite3ComputeGeneratedColumns(pParse *struct_Parse, iRegStore int32, pTab *struct_Table) {
	var i int32
	var w struct_Walker
	var pRedo *struct_Column
	var eProgress int32
	var pOp *struct_VdbeOp
	func() int {
		_ = 0
		return 0
	}()
	sqlite3TableAffinity(pParse.pVdbe, pTab, iRegStore)
	if pTab.tabFlags&uint32(64) != uint32(0) {
		pOp = sqlite3VdbeGetOp(pParse.pVdbe, -1)
		if int32(pOp.opcode) == 95 {
			var ii int32
			var jj int32
			var zP4 *int8 = *(**int8)(unsafe.Pointer(&pOp.p4))
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			for ii = func() (_cgo_ret int32) {
				_cgo_addr := &jj
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}(); *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zP4)) + uintptr(jj))) != 0; ii++ {
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(ii)*20))).colFlags)&32 != 0 {
					continue
				}
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(ii)*20))).colFlags)&64 != 0 {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zP4)) + uintptr(jj))) = int8(64)
				}
				jj++
			}
		} else if int32(pOp.opcode) == 94 {
			pOp.p3 = int32(1)
		}
	}
	for i = int32(0); i < int32(pTab.nCol); i++ {
		if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&96 != 0 {
			(*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags |= uint16(128)
		}
	}
	*(**struct_Table)(unsafe.Pointer(&w.u)) = pTab
	w.xExprCallback = exprColumnFlagUnion
	w.xSelectCallback = (func(*struct_Walker, *struct_Select) int32)(nil)
	w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
	pParse.iSelfTab = -iRegStore
	for {
		eProgress = int32(0)
		pRedo = (*struct_Column)(nil)
		for i = int32(0); i < int32(pTab.nCol); i++ {
			var pCol *struct_Column = (*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))
			if int32(pCol.colFlags)&128 != 0 {
				var x int32
				pCol.colFlags |= uint16(256)
				w.eCode = uint16(0)
				sqlite3WalkExpr(&w, sqlite3ColumnExpr(pTab, pCol))
				pCol.colFlags &= uint16(^256)
				if int32(w.eCode)&128 != 0 {
					pRedo = pCol
					continue
				}
				eProgress = int32(1)
				func() int {
					_ = 0
					return 0
				}()
				x = int32(sqlite3TableColumnToStorage(pTab, int16(i))) + iRegStore
				sqlite3ExprCodeGeneratedColumn(pParse, pTab, pCol, x)
				pCol.colFlags &= uint16(^128)
			}
		}
		if !(pRedo != nil && eProgress != 0) {
			break
		}
	}
	if pRedo != nil {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'l', 'o', 'o', 'p', ' ', 'o', 'n', ' ', '"', '%', 's', '"', '\x00'})), pRedo.zCnName)
	}
	pParse.iSelfTab = int32(0)
}
func autoIncBegin(pParse *struct_Parse, iDb int32, pTab *struct_Table) int32 {
	var memId int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	if pTab.tabFlags&uint32(8) != uint32(0) && pParse.db.mDbFlags&uint32(4) == uint32(0) {
		var pToplevel *struct_Parse = func() *struct_Parse {
			if pParse.pToplevel != nil {
				return pParse.pToplevel
			} else {
				return pParse
			}
		}()
		var pInfo *struct_AutoincInfo
		var pSeqTab *struct_Table = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(iDb)*32))).pSchema.pSeqTab
		if uintptr(unsafe.Pointer(pSeqTab)) == uintptr(unsafe.Pointer(nil)) || !(pSeqTab.tabFlags&uint32(128) == uint32(0)) || int32(pSeqTab.eTabType) == 1 || int32(pSeqTab.nCol) != 2 {
			pParse.nErr++
			pParse.rc = int32(11 | 2<<8)
			return int32(0)
		}
		pInfo = pToplevel.pAinc
		for pInfo != nil && uintptr(unsafe.Pointer(pInfo.pTab)) != uintptr(unsafe.Pointer(pTab)) {
			pInfo = pInfo.pNext
		}
		if uintptr(unsafe.Pointer(pInfo)) == uintptr(unsafe.Pointer(nil)) {
			pInfo = (*struct_AutoincInfo)(sqlite3DbMallocRawNN(pParse.db, uint64(24)))
			sqlite3ParserAddCleanup(pToplevel, sqlite3DbFree, unsafe.Pointer(pInfo))
			if pParse.db.mallocFailed != 0 {
				return int32(0)
			}
			pInfo.pNext = pToplevel.pAinc
			pToplevel.pAinc = pInfo
			pInfo.pTab = pTab
			pInfo.iDb = iDb
			pToplevel.nMem++
			pInfo.regCtr = func() (_cgo_ret int32) {
				_cgo_addr := &pToplevel.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			pToplevel.nMem += int32(2)
		}
		memId = pInfo.regCtr
	}
	return memId
}
func sqlite3AutoincrementBegin(pParse *struct_Parse) {
	var p *struct_AutoincInfo
	var db *struct_sqlite3 = pParse.db
	var pDb *struct_Db
	var memId int32
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for p = pParse.pAinc; p != nil; p = p.pNext {
		const iLn int32 = 0
		var autoInc [12]struct_VdbeOpList = [12]struct_VdbeOpList{struct_VdbeOpList{uint8(74), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(38), int8(0), int8(10), int8(0)}, struct_VdbeOpList{uint8(93), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(52), int8(0), int8(9), int8(0)}, struct_VdbeOpList{uint8(134), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(93), int8(0), int8(1), int8(0)}, struct_VdbeOpList{uint8(85), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(79), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(11), int8(0), int8(11), int8(0)}, struct_VdbeOpList{uint8(5), int8(0), int8(2), int8(0)}, struct_VdbeOpList{uint8(71), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(121), int8(0), int8(0), int8(0)}}
		var aOp *struct_VdbeOp
		pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(p.iDb)*32))
		memId = p.regCtr
		func() int {
			_ = 0
			return 0
		}()
		sqlite3OpenTable(pParse, 0, p.iDb, pDb.pSchema.pSeqTab, 101)
		sqlite3VdbeLoadString(v, memId-1, p.pTab.zName)
		aOp = sqlite3VdbeAddOpList(v, int32(48/4), (*struct_VdbeOpList)(unsafe.Pointer(&autoInc)), iLn)
		if uintptr(unsafe.Pointer(aOp)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p2 = memId
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p3 = memId + 2
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(2)*24))).p3 = memId
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p1 = memId - 1
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p3 = memId
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p5 = uint16(16)
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(4)*24))).p2 = memId + 1
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(5)*24))).p3 = memId
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(6)*24))).p1 = memId
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(7)*24))).p2 = memId + 2
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(7)*24))).p1 = memId
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(10)*24))).p2 = memId
		if pParse.nTab == 0 {
			pParse.nTab = int32(1)
		}
	}
}
func autoIncStep(pParse *struct_Parse, memId int32, regRowid int32) {
	if memId > 0 {
		sqlite3VdbeAddOp2(pParse.pVdbe, 158, memId, regRowid)
	}
}
func autoIncrementEnd(pParse *struct_Parse) {
	var p *struct_AutoincInfo
	var v *struct_Vdbe = pParse.pVdbe
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	for p = pParse.pAinc; p != nil; p = p.pNext {
		const iLn int32 = 0
		var autoIncEnd [5]struct_VdbeOpList = [5]struct_VdbeOpList{struct_VdbeOpList{uint8(51), int8(0), int8(2), int8(0)}, struct_VdbeOpList{uint8(126), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(96), int8(0), int8(2), int8(0)}, struct_VdbeOpList{uint8(127), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(121), int8(0), int8(0), int8(0)}}
		var aOp *struct_VdbeOp
		var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(p.iDb)*32))
		var iRec int32
		var memId int32 = p.regCtr
		iRec = sqlite3GetTempReg(pParse)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp3(v, 55, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId)
		sqlite3OpenTable(pParse, 0, p.iDb, pDb.pSchema.pSeqTab, 112)
		aOp = sqlite3VdbeAddOpList(v, int32(20/4), (*struct_VdbeOpList)(unsafe.Pointer(&autoIncEnd)), iLn)
		if uintptr(unsafe.Pointer(aOp)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p1 = memId + 1
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p2 = memId + 1
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(2)*24))).p1 = memId - 1
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(2)*24))).p3 = iRec
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p2 = iRec
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p3 = memId + 1
		(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(3)*24))).p5 = uint16(8)
		sqlite3ReleaseTempReg(pParse, iRec)
	}
}
func sqlite3AutoincrementEnd(pParse *struct_Parse) {
	if pParse.pAinc != nil {
		autoIncrementEnd(pParse)
	}
}
func sqlite3Insert(pParse *struct_Parse, pTabList *struct_SrcList, pSelect *struct_Select, pColumn *struct_IdList, onError int32, pUpsert *struct_Upsert) {
	var db *struct_sqlite3
	var pTab *struct_Table
	var i int32
	var j int32
	var v *struct_Vdbe
	var pIdx *struct_Index
	var nColumn int32
	var nHidden int32 = 0
	var iDataCur int32 = 0
	var iIdxCur int32 = 0
	var ipkColumn int32 = -1
	var endOfLoop int32
	var srcTab int32 = 0
	var addrInsTop int32 = 0
	var addrCont int32 = 0
	var dest struct_SelectDest
	var iDb int32
	var useTempTable uint8 = uint8(0)
	var appendFlag uint8 = uint8(0)
	var withoutRowid uint8
	var bIdListInOrder uint8
	var pList *struct_ExprList = nil
	var iRegStore int32
	var regFromSelect int32 = 0
	var regAutoinc int32 = 0
	var regRowCount int32 = 0
	var regIns int32
	var regRowid int32
	var regData int32
	var aRegIdx *int32 = nil
	var isView int32
	var pTrigger *struct_Trigger
	var tmask int32
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		goto insert_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	dest.iSDParm = int32(0)
	if pSelect != nil && pSelect.selFlags&uint32(512) != uint32(0) && uintptr(unsafe.Pointer(pSelect.pPrior)) == uintptr(unsafe.Pointer(nil)) {
		pList = pSelect.pEList
		pSelect.pEList = (*struct_ExprList)(nil)
		sqlite3SelectDelete(db, pSelect)
		pSelect = (*struct_Select)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	pTab = sqlite3SrcListLookup(pParse, pTabList)
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		goto insert_cleanup
	}
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3AuthCheck(pParse, 18, pTab.zName, nil, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName) != 0 {
		goto insert_cleanup
	}
	withoutRowid = func() uint8 {
		if !(pTab.tabFlags&uint32(128) == uint32(0)) {
			return 1
		} else {
			return 0
		}
	}()
	pTrigger = sqlite3TriggersExist(pParse, pTab, 127, nil, &tmask)
	isView = func() int32 {
		if int32(pTab.eTabType) == 2 {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3ViewGetColumnNames(pParse, pTab) != 0 {
		goto insert_cleanup
	}
	if sqlite3IsReadOnly(pParse, pTab, tmask) != 0 {
		goto insert_cleanup
	}
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		goto insert_cleanup
	}
	if int32(pParse.nested) == 0 {
		sqlite3VdbeCountChanges(v)
	}
	sqlite3BeginWriteOperation(pParse, func() int32 {
		if pSelect != nil || pTrigger != nil {
			return 1
		} else {
			return 0
		}
	}(), iDb)
	if uintptr(unsafe.Pointer(pColumn)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pSelect)) != uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pTrigger)) == uintptr(unsafe.Pointer(nil)) && xferOptimization(pParse, pTab, pSelect, onError, iDb) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		goto insert_end
	}
	regAutoinc = autoIncBegin(pParse, iDb, pTab)
	regRowid = func() (_cgo_ret int32) {
		_cgo_addr := &regIns
		*_cgo_addr = pParse.nMem + 1
		return *_cgo_addr
	}()
	pParse.nMem += int32(pTab.nCol) + 1
	if int32(pTab.eTabType) == 1 {
		regRowid++
		pParse.nMem++
	}
	regData = regRowid + 1
	bIdListInOrder = func() uint8 {
		if pTab.tabFlags&uint32(1024|64) == uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	if pColumn != nil {
		for i = int32(0); i < pColumn.nId; i++ {
			(*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumn.a)) + uintptr(i)*12))).idx = int32(-1)
		}
		for i = int32(0); i < pColumn.nId; i++ {
			for j = int32(0); j < int32(pTab.nCol); j++ {
				if sqlite3StrICmp((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumn.a)) + uintptr(i)*12))).zName, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName) == 0 {
					(*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumn.a)) + uintptr(i)*12))).idx = j
					if i != j {
						bIdListInOrder = uint8(0)
					}
					if j == int32(pTab.iPKey) {
						ipkColumn = i
						func() int {
							_ = 0
							return 0
						}()
					}
					if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).colFlags)&(64|32) != 0 {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[41]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'I', 'N', 'S', 'E', 'R', 'T', ' ', 'i', 'n', 't', 'o', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '"', '%', 's', '"', '\x00'})), (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName)
						goto insert_cleanup
					}
					break
				}
			}
			if j >= int32(pTab.nCol) {
				if sqlite3IsRowid((*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumn.a)) + uintptr(i)*12))).zName) != 0 && !(withoutRowid != 0) {
					ipkColumn = i
					bIdListInOrder = uint8(0)
				} else {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[32]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 'S', ' ', 'h', 'a', 's', ' ', 'n', 'o', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'n', 'a', 'm', 'e', 'd', ' ', '%', 's', '\x00'})), (*struct_SrcItem)(unsafe.Pointer(&pTabList.a)), (*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumn.a)) + uintptr(i)*12))).zName)
					pParse.checkSchema = uint8(1)
					goto insert_cleanup
				}
			}
		}
	}
	if pSelect != nil {
		var regYield int32
		var addrTop int32
		var rc int32
		regYield = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		addrTop = sqlite3VdbeCurrentAddr(v) + 1
		sqlite3VdbeAddOp3(v, 13, regYield, 0, addrTop)
		sqlite3SelectDestInit(&dest, 13, regYield)
		dest.iSdst = func() int32 {
			if int32(bIdListInOrder) != 0 {
				return regData
			} else {
				return 0
			}
		}()
		dest.nSdst = int32(pTab.nCol)
		rc = sqlite3Select(pParse, pSelect, &dest)
		regFromSelect = dest.iSdst
		func() int {
			_ = 0
			return 0
		}()
		if rc != 0 || pParse.nErr != 0 {
			goto insert_cleanup
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeEndCoroutine(v, regYield)
		sqlite3VdbeJumpHere(v, addrTop-1)
		func() int {
			_ = 0
			return 0
		}()
		nColumn = pSelect.pEList.nExpr
		if pTrigger != nil || readsTable(pParse, iDb, pTab) != 0 {
			useTempTable = uint8(1)
		}
		if useTempTable != 0 {
			var regRec int32
			var regTempRowid int32
			var addrL int32
			srcTab = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			regRec = sqlite3GetTempReg(pParse)
			regTempRowid = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp2(v, 116, srcTab, nColumn)
			addrL = sqlite3VdbeAddOp1(v, 14, dest.iSDParm)
			sqlite3VdbeAddOp3(v, 96, regFromSelect, nColumn, regRec)
			sqlite3VdbeAddOp2(v, 126, srcTab, regTempRowid)
			sqlite3VdbeAddOp3(v, 127, srcTab, regRec, regTempRowid)
			sqlite3VdbeGoto(v, addrL)
			sqlite3VdbeJumpHere(v, addrL)
			sqlite3ReleaseTempReg(pParse, regRec)
			sqlite3ReleaseTempReg(pParse, regTempRowid)
		}
	} else {
		var sNC struct_NameContext
		__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
		sNC.pParse = pParse
		srcTab = int32(-1)
		func() int {
			_ = 0
			return 0
		}()
		if pList != nil {
			nColumn = pList.nExpr
			if sqlite3ResolveExprListNames(&sNC, pList) != 0 {
				goto insert_cleanup
			}
		} else {
			nColumn = int32(0)
		}
	}
	if uintptr(unsafe.Pointer(pColumn)) == uintptr(unsafe.Pointer(nil)) && nColumn > 0 {
		ipkColumn = int32(pTab.iPKey)
		if ipkColumn >= 0 && pTab.tabFlags&uint32(96) != uint32(0) {
			for i = ipkColumn - 1; i >= 0; i-- {
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&96 != 0 {
					ipkColumn--
				}
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if pTab.tabFlags&uint32(96|2) != uint32(0) {
			for i = int32(0); i < int32(pTab.nCol); i++ {
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&98 != 0 {
					nHidden++
				}
			}
		}
		if nColumn != int32(pTab.nCol)-nHidden {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[52]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 'S', ' ', 'h', 'a', 's', ' ', '%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'b', 'u', 't', ' ', '%', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 's', ' ', 'w', 'e', 'r', 'e', ' ', 's', 'u', 'p', 'p', 'l', 'i', 'e', 'd', '\x00'})), (*struct_SrcItem)(unsafe.Pointer(&pTabList.a)), int32(pTab.nCol)-nHidden, nColumn)
			goto insert_cleanup
		}
	}
	if uintptr(unsafe.Pointer(pColumn)) != uintptr(unsafe.Pointer(nil)) && nColumn != pColumn.nId {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[25]int8{'%', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o', 'r', ' ', '%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', '\x00'})), nColumn, pColumn.nId)
		goto insert_cleanup
	}
	if db.flags&(uint64(1)<<32) != uint64(0) && !(pParse.nested != 0) && !(pParse.pTriggerTab != nil) && !(pParse.bReturning != 0) {
		regRowCount = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 71, 0, regRowCount)
	}
	if !(isView != 0) {
		var nIdx int32
		nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 112, uint8(0), -1, nil, &iDataCur, &iIdxCur)
		aRegIdx = (*int32)(sqlite3DbMallocRawNN(db, uint64(4*uint(nIdx+2))))
		if uintptr(unsafe.Pointer(aRegIdx)) == uintptr(unsafe.Pointer(nil)) {
			goto insert_cleanup
		}
		for func() *struct_Index {
			i = int32(0)
			return func() (_cgo_ret *struct_Index) {
				_cgo_addr := &pIdx
				*_cgo_addr = pTab.pIndex
				return *_cgo_addr
			}()
		}(); i < nIdx; func() int32 {
			pIdx = pIdx.pNext
			return func() (_cgo_ret int32) {
				_cgo_addr := &i
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
		}() {
			func() int {
				_ = 0
				return 0
			}()
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)) = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			pParse.nMem += int32(pIdx.nColumn)
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)) = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
	}
	if pUpsert != nil {
		var pNx *struct_Upsert
		if int32(pTab.eTabType) == 1 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[46]int8{'U', 'P', 'S', 'E', 'R', 'T', ' ', 'n', 'o', 't', ' ', 'i', 'm', 'p', 'l', 'e', 'm', 'e', 'n', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', ' ', '"', '%', 's', '"', '\x00'})), pTab.zName)
			goto insert_cleanup
		}
		if int32(pTab.eTabType) == 2 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[21]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'U', 'P', 'S', 'E', 'R', 'T', ' ', 'a', ' ', 'v', 'i', 'e', 'w', '\x00'})))
			goto insert_cleanup
		}
		if sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget) != 0 {
			goto insert_cleanup
		}
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).iCursor = iDataCur
		pNx = pUpsert
		for {
			pNx.pUpsertSrc = pTabList
			pNx.regData = regData
			pNx.iDataCur = iDataCur
			pNx.iIdxCur = iIdxCur
			if pNx.pUpsertTarget != nil {
				if sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx) != 0 {
					goto insert_cleanup
				}
			}
			pNx = pNx.pNextUpsert
			if !(uintptr(unsafe.Pointer(pNx)) != uintptr(unsafe.Pointer(nil))) {
				break
			}
		}
	}
	if useTempTable != 0 {
		addrInsTop = sqlite3VdbeAddOp1(v, 38, srcTab)
		addrCont = sqlite3VdbeCurrentAddr(v)
	} else if pSelect != nil {
		addrInsTop = func() (_cgo_ret int32) {
			_cgo_addr := &addrCont
			*_cgo_addr = sqlite3VdbeAddOp1(v, 14, dest.iSDParm)
			return *_cgo_addr
		}()
		if ipkColumn >= 0 {
			sqlite3VdbeAddOp2(v, 79, regFromSelect+ipkColumn, regRowid)
		}
	}
	nHidden = int32(0)
	iRegStore = regData
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < int32(pTab.nCol); func() int32 {
		i++
		return func() (_cgo_ret int32) {
			_cgo_addr := &iRegStore
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		var k int32
		var colFlags uint32
		func() int {
			_ = 0
			return 0
		}()
		if i == int32(pTab.iPKey) {
			sqlite3VdbeAddOp1(v, 75, iRegStore)
			continue
		}
		if func() (_cgo_ret uint32) {
			_cgo_addr := &colFlags
			*_cgo_addr = uint32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)
			return *_cgo_addr
		}()&uint32(98) != uint32(0) {
			nHidden++
			if colFlags&uint32(32) != uint32(0) {
				iRegStore--
				continue
			} else if colFlags&uint32(64) != uint32(0) {
				if tmask&1 != 0 {
					sqlite3VdbeAddOp1(v, 75, iRegStore)
				}
				continue
			} else if uintptr(unsafe.Pointer(pColumn)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))), iRegStore)
				continue
			}
		}
		if pColumn != nil {
			for j = int32(0); j < pColumn.nId && (*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pColumn.a)) + uintptr(j)*12))).idx != i; j++ {
			}
			if j >= pColumn.nId {
				sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))), iRegStore)
				continue
			}
			k = j
		} else if nColumn == 0 {
			sqlite3ExprCodeFactorable(pParse, sqlite3ColumnExpr(pTab, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))), iRegStore)
			continue
		} else {
			k = i - nHidden
		}
		if useTempTable != 0 {
			sqlite3VdbeAddOp3(v, 93, srcTab, k, iRegStore)
		} else if pSelect != nil {
			if regFromSelect != regData {
				sqlite3VdbeAddOp2(v, 80, regFromSelect+k, iRegStore)
			}
		} else {
			sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(k)*28))).pExpr, iRegStore)
		}
	}
	endOfLoop = sqlite3VdbeMakeLabel(pParse)
	if tmask&1 != 0 {
		var regCols int32 = sqlite3GetTempRange(pParse, int32(pTab.nCol)+1)
		if ipkColumn < 0 {
			sqlite3VdbeAddOp2(v, 71, -1, regCols)
		} else {
			var addr1 int32
			func() int {
				_ = 0
				return 0
			}()
			if useTempTable != 0 {
				sqlite3VdbeAddOp3(v, 93, srcTab, ipkColumn, regCols)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(ipkColumn)*28))).pExpr, regCols)
			}
			addr1 = sqlite3VdbeAddOp1(v, 51, regCols)
			sqlite3VdbeAddOp2(v, 71, -1, regCols)
			sqlite3VdbeJumpHere(v, addr1)
			sqlite3VdbeAddOp1(v, 15, regCols)
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp3(v, 79, regRowid+1, regCols+1, int32(pTab.nNVCol)-1)
		if pTab.tabFlags&uint32(96) != 0 {
			sqlite3ComputeGeneratedColumns(pParse, regCols+1, pTab)
		}
		if !(isView != 0) {
			sqlite3TableAffinity(v, pTab, regCols+1)
		}
		sqlite3CodeRowTrigger(pParse, pTrigger, 127, nil, 1, pTab, regCols-int32(pTab.nCol)-1, onError, endOfLoop)
		sqlite3ReleaseTempRange(pParse, regCols, int32(pTab.nCol)+1)
	}
	if !(isView != 0) {
		if int32(pTab.eTabType) == 1 {
			sqlite3VdbeAddOp2(v, 74, 0, regIns)
		}
		if ipkColumn >= 0 {
			if useTempTable != 0 {
				sqlite3VdbeAddOp3(v, 93, srcTab, ipkColumn, regRowid)
			} else if pSelect != nil {
			} else {
				var pIpk *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(ipkColumn)*28))).pExpr
				if int32(pIpk.op) == 121 && !(int32(pTab.eTabType) == 1) {
					sqlite3VdbeAddOp3(v, 126, iDataCur, regRowid, regAutoinc)
					appendFlag = uint8(1)
				} else {
					sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(ipkColumn)*28))).pExpr, regRowid)
				}
			}
			if !(appendFlag != 0) {
				var addr1 int32
				if !(int32(pTab.eTabType) == 1) {
					addr1 = sqlite3VdbeAddOp1(v, 51, regRowid)
					sqlite3VdbeAddOp3(v, 126, iDataCur, regRowid, regAutoinc)
					sqlite3VdbeJumpHere(v, addr1)
				} else {
					addr1 = sqlite3VdbeCurrentAddr(v)
					sqlite3VdbeAddOp2(v, 50, regRowid, addr1+2)
				}
				sqlite3VdbeAddOp1(v, 15, regRowid)
			}
		} else if int32(pTab.eTabType) == 1 || int32(withoutRowid) != 0 {
			sqlite3VdbeAddOp2(v, 74, 0, regRowid)
		} else {
			sqlite3VdbeAddOp3(v, 126, iDataCur, regRowid, regAutoinc)
			appendFlag = uint8(1)
		}
		autoIncStep(pParse, regAutoinc, regRowid)
		if pTab.tabFlags&uint32(96) != 0 {
			sqlite3ComputeGeneratedColumns(pParse, regRowid+1, pTab)
		}
		if int32(pTab.eTabType) == 1 {
			var pVTab *int8 = (*int8)(unsafe.Pointer(sqlite3GetVTable(db, pTab)))
			sqlite3VtabMakeWritable(pParse, pTab)
			sqlite3VdbeAddOp4(v, 10, 1, int32(pTab.nCol)+2, regIns, pVTab, -12)
			sqlite3VdbeChangeP5(v, uint16(func() int32 {
				if onError == 11 {
					return 2
				} else {
					return onError
				}
			}()))
			sqlite3MayAbort(pParse)
		} else {
			var isReplace int32 = 0
			var bUseSeek int32
			sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regIns, 0, func() uint8 {
				if ipkColumn >= 0 {
					return 1
				} else {
					return 0
				}
			}(), uint8(onError), endOfLoop, &isReplace, nil, pUpsert)
			sqlite3FkCheck(pParse, pTab, 0, regIns, nil, 0)
			bUseSeek = func() int32 {
				if isReplace == 0 || !(sqlite3VdbeHasSubProgram(v) != 0) {
					return 1
				} else {
					return 0
				}
			}()
			sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regIns, aRegIdx, 0, int32(appendFlag), bUseSeek)
		}
	}
	if regRowCount != 0 {
		sqlite3VdbeAddOp2(v, 85, regRowCount, 1)
	}
	if pTrigger != nil {
		sqlite3CodeRowTrigger(pParse, pTrigger, 127, nil, 2, pTab, regData-2-int32(pTab.nCol), onError, endOfLoop)
	}
	sqlite3VdbeResolveLabel(v, endOfLoop)
	if useTempTable != 0 {
		sqlite3VdbeAddOp2(v, 5, srcTab, addrCont)
		sqlite3VdbeJumpHere(v, addrInsTop)
		sqlite3VdbeAddOp1(v, 121, srcTab)
	} else if pSelect != nil {
		sqlite3VdbeGoto(v, addrCont)
		sqlite3VdbeJumpHere(v, addrInsTop)
	}
insert_end:
	if int32(pParse.nested) == 0 && uintptr(unsafe.Pointer(pParse.pTriggerTab)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3AutoincrementEnd(pParse)
	}
	if regRowCount != 0 {
		sqlite3CodeChangeCount(v, regRowCount, (*int8)(unsafe.Pointer(&[14]int8{'r', 'o', 'w', 's', ' ', 'i', 'n', 's', 'e', 'r', 't', 'e', 'd', '\x00'})))
	}
insert_cleanup:
	sqlite3SrcListDelete(db, pTabList)
	sqlite3ExprListDelete(db, pList)
	sqlite3UpsertDelete(db, pUpsert)
	sqlite3SelectDelete(db, pSelect)
	sqlite3IdListDelete(db, pColumn)
	sqlite3DbFree(db, unsafe.Pointer(aRegIdx))
}
func checkConstraintExprNode(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 167 {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pExpr.iColumn) >= 0 {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**int32)(unsafe.Pointer(&pWalker.u)))) + uintptr(pExpr.iColumn)*4)) >= 0 {
				pWalker.eCode |= uint16(1)
			}
		} else {
			pWalker.eCode |= uint16(2)
		}
	}
	return int32(0)
}
func sqlite3ExprReferencesUpdatedColumn(pExpr *struct_Expr, aiChng *int32, chngRowid int32) int32 {
	var w struct_Walker
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	w.eCode = uint16(0)
	w.xExprCallback = checkConstraintExprNode
	*(**int32)(unsafe.Pointer(&w.u)) = aiChng
	sqlite3WalkExpr(&w, pExpr)
	if !(chngRowid != 0) {
		w.eCode &= uint16(^2)
	}
	return func() int32 {
		if int32(w.eCode) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}

type IndexListTerm = struct_IndexListTerm
type IndexIterator = struct_IndexIterator
type _cgoa_78 struct {
	pIdx *struct_Index
}
type _cgoa_79 struct {
	nIdx int32
	aIdx *struct_IndexListTerm
}
type _cgoa_77 struct {
	ax _cgoa_79
}
type struct_IndexIterator struct {
	eType int32
	i     int32
	u     _cgoa_77
}
type struct_IndexListTerm struct {
	p  *struct_Index
	ix int32
}

func indexIteratorFirst(pIter *struct_IndexIterator, pIx *int32) *struct_Index {
	func() int {
		_ = 0
		return 0
	}()
	if pIter.eType != 0 {
		*pIx = (*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter.u.ax.aIdx)) + uintptr(0)*12))).ix
		return (*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter.u.ax.aIdx)) + uintptr(0)*12))).p
	} else {
		*pIx = int32(0)
		return (*(*_cgoa_78)(unsafe.Pointer(&pIter.u))).pIdx
	}
}
func indexIteratorNext(pIter *struct_IndexIterator, pIx *int32) *struct_Index {
	if pIter.eType != 0 {
		var i int32 = func() (_cgo_ret int32) {
			_cgo_addr := &pIter.i
			*_cgo_addr++
			return *_cgo_addr
		}()
		if i >= pIter.u.ax.nIdx {
			*pIx = i
			return (*struct_Index)(nil)
		}
		*pIx = (*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter.u.ax.aIdx)) + uintptr(i)*12))).ix
		return (*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pIter.u.ax.aIdx)) + uintptr(i)*12))).p
	} else {
		*pIx++
		(*(*_cgoa_78)(unsafe.Pointer(&pIter.u))).pIdx = (*(*_cgoa_78)(unsafe.Pointer(&pIter.u))).pIdx.pNext
		return (*(*_cgoa_78)(unsafe.Pointer(&pIter.u))).pIdx
	}
}
func sqlite3GenerateConstraintChecks(pParse *struct_Parse, pTab *struct_Table, aRegIdx *int32, iDataCur int32, iIdxCur int32, regNewData int32, regOldData int32, pkChng uint8, overrideError uint8, ignoreDest int32, pbMayReplace *int32, aiChng *int32, pUpsert *struct_Upsert) {
	var v *struct_Vdbe
	var pIdx *struct_Index
	var pPk *struct_Index = nil
	var db *struct_sqlite3
	var i int32
	var ix int32
	var nCol int32
	var onError int32
	var seenReplace int32 = 0
	var nPkField int32
	var pUpsertClause *struct_Upsert = nil
	var isUpdate uint8
	var bAffinityDone uint8 = uint8(0)
	var upsertIpkReturn int32 = 0
	var upsertIpkDelay int32 = 0
	var ipkTop int32 = 0
	var ipkBottom int32 = 0
	var regTrigCnt int32
	var addrRecheck int32 = 0
	var lblRecheckOk int32 = 0
	var pTrigger *struct_Trigger
	var nReplaceTrig int32 = 0
	var sIdxIter struct_IndexIterator
	isUpdate = func() uint8 {
		if regOldData != 0 {
			return 1
		} else {
			return 0
		}
	}()
	db = pParse.db
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nCol = int32(pTab.nCol)
	if pTab.tabFlags&uint32(128) == uint32(0) {
		pPk = (*struct_Index)(nil)
		nPkField = int32(1)
	} else {
		pPk = sqlite3PrimaryKeyIndex(pTab)
		nPkField = int32(pPk.nKeyCol)
	}
	if pTab.tabFlags&uint32(2048) != 0 {
		var b2ndPass int32 = 0
		var nSeenReplace int32 = 0
		var nGenerated int32 = 0
		for 1 != 0 {
			for i = int32(0); i < nCol; i++ {
				var iReg int32
				var pCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))
				var isGenerated int32
				onError = int32(pCol.Xbf_0 & 15)
				if onError == 0 {
					continue
				}
				if i == int32(pTab.iPKey) {
					continue
				}
				isGenerated = int32(pCol.colFlags) & 96
				if isGenerated != 0 && !(b2ndPass != 0) {
					nGenerated++
					continue
				}
				if aiChng != nil && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiChng)) + uintptr(i)*4)) < 0 && !(isGenerated != 0) {
					continue
				}
				if int32(overrideError) != 11 {
					onError = int32(overrideError)
				} else if onError == 11 {
					onError = int32(2)
				}
				if onError == 5 {
					if b2ndPass != 0 || int32(pCol.iDflt) == 0 {
						onError = int32(2)
					} else {
						func() int {
							_ = 0
							return 0
						}()
					}
				} else if b2ndPass != 0 && !(isGenerated != 0) {
					continue
				}
				func() int {
					_ = 0
					return 0
				}()
				iReg = int32(sqlite3TableColumnToStorage(pTab, int16(i))) + regNewData + 1
				switch onError {
				case 5:
					{
						var addr1 int32 = sqlite3VdbeAddOp1(v, 51, iReg)
						func() int {
							_ = 0
							return 0
						}()
						nSeenReplace++
						sqlite3ExprCodeCopy(pParse, sqlite3ColumnExpr(pTab, pCol), iReg)
						sqlite3VdbeJumpHere(v, addr1)
						break
					}
				case 2:
					sqlite3MayAbort(pParse)
				case 1:
					fallthrough
				case 3:
					{
						var zMsg *int8 = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 's', '\x00'})), pTab.zName, pCol.zCnName)
						sqlite3VdbeAddOp3(v, 69, 19|5<<8, onError, iReg)
						sqlite3VdbeAppendP4(v, unsafe.Pointer(zMsg), -7)
						sqlite3VdbeChangeP5(v, uint16(1))
						break
					}
				default:
					{
						func() int {
							_ = 0
							return 0
						}()
						sqlite3VdbeAddOp2(v, 50, iReg, ignoreDest)
						break
					}
				}
			}
			if nGenerated == 0 && nSeenReplace == 0 {
				break
			}
			if b2ndPass != 0 {
				break
			}
			b2ndPass = int32(1)
			if nSeenReplace > 0 && pTab.tabFlags&uint32(96) != uint32(0) {
				sqlite3ComputeGeneratedColumns(pParse, regNewData+1, pTab)
			}
		}
	}
	if pTab.pCheck != nil && db.flags&uint64(512) == uint64(0) {
		var pCheck *struct_ExprList = pTab.pCheck
		pParse.iSelfTab = -(regNewData + 1)
		onError = func() int32 {
			if int32(overrideError) != 11 {
				return int32(overrideError)
			} else {
				return 2
			}
		}()
		for i = int32(0); i < pCheck.nExpr; i++ {
			var allOk int32
			var pCopy *struct_Expr
			var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pCheck.a)))) + uintptr(i)*28))).pExpr
			if aiChng != nil && !(sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, int32(pkChng)) != 0) {
				continue
			}
			if int32(bAffinityDone) == 0 {
				sqlite3TableAffinity(v, pTab, regNewData+1)
				bAffinityDone = uint8(1)
			}
			allOk = sqlite3VdbeMakeLabel(pParse)
			pCopy = sqlite3ExprDup(db, pExpr, 0)
			if !(db.mallocFailed != 0) {
				sqlite3ExprIfTrue(pParse, pCopy, allOk, 16)
			}
			sqlite3ExprDelete(db, pCopy)
			if onError == 4 {
				sqlite3VdbeGoto(v, ignoreDest)
			} else {
				var zName *int8 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pCheck.a)))) + uintptr(i)*28))).zEName
				func() int {
					_ = 0
					return 0
				}()
				if onError == 5 {
					onError = int32(2)
				}
				sqlite3HaltConstraint(pParse, 19|1<<8, onError, zName, int8(0), uint8(3))
			}
			sqlite3VdbeResolveLabel(v, allOk)
		}
		pParse.iSelfTab = int32(0)
	}
	sIdxIter.eType = int32(0)
	sIdxIter.i = int32(0)
	sIdxIter.u.ax.aIdx = (*struct_IndexListTerm)(nil)
	(*(*_cgoa_78)(unsafe.Pointer(&sIdxIter.u))).pIdx = pTab.pIndex
	if pUpsert != nil {
		if uintptr(unsafe.Pointer(pUpsert.pUpsertTarget)) == uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			if int32(pUpsert.isDoUpdate) == 0 {
				overrideError = uint8(4)
				pUpsert = (*struct_Upsert)(nil)
			} else {
				overrideError = uint8(6)
			}
		} else if uintptr(unsafe.Pointer(pTab.pIndex)) != uintptr(unsafe.Pointer(nil)) {
			var nIdx int32
			var jj int32
			var nByte uint64
			var pTerm *struct_Upsert
			var bUsed *uint8
			for func() *struct_Index {
				nIdx = int32(0)
				return func() (_cgo_ret *struct_Index) {
					_cgo_addr := &pIdx
					*_cgo_addr = pTab.pIndex
					return *_cgo_addr
				}()
			}(); pIdx != nil; func() int32 {
				pIdx = pIdx.pNext
				return func() (_cgo_ret int32) {
					_cgo_addr := &nIdx
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
			}() {
				func() int {
					_ = 0
					return 0
				}()
			}
			sIdxIter.eType = int32(1)
			sIdxIter.u.ax.nIdx = nIdx
			nByte = uint64((12+uint(1))*uint(nIdx) + uint(nIdx))
			sIdxIter.u.ax.aIdx = (*struct_IndexListTerm)(sqlite3DbMallocZero(db, nByte))
			if uintptr(unsafe.Pointer(sIdxIter.u.ax.aIdx)) == uintptr(unsafe.Pointer(nil)) {
				return
			}
			bUsed = (*uint8)(unsafe.Pointer(&*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(sIdxIter.u.ax.aIdx)) + uintptr(nIdx)*12))))
			pUpsert.pToFree = unsafe.Pointer(sIdxIter.u.ax.aIdx)
			for func() *struct_Upsert {
				i = int32(0)
				return func() (_cgo_ret *struct_Upsert) {
					_cgo_addr := &pTerm
					*_cgo_addr = pUpsert
					return *_cgo_addr
				}()
			}(); pTerm != nil; pTerm = pTerm.pNextUpsert {
				if uintptr(unsafe.Pointer(pTerm.pUpsertTarget)) == uintptr(unsafe.Pointer(nil)) {
					break
				}
				if uintptr(unsafe.Pointer(pTerm.pUpsertIdx)) == uintptr(unsafe.Pointer(nil)) {
					continue
				}
				jj = int32(0)
				pIdx = pTab.pIndex
				for uintptr(unsafe.Pointer(pIdx)) != uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pIdx)) != uintptr(unsafe.Pointer(pTerm.pUpsertIdx)) {
					pIdx = pIdx.pNext
					jj++
				}
				if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(bUsed)) + uintptr(jj))) != 0 {
					continue
				}
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(bUsed)) + uintptr(jj))) = uint8(1)
				(*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(sIdxIter.u.ax.aIdx)) + uintptr(i)*12))).p = pIdx
				(*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(sIdxIter.u.ax.aIdx)) + uintptr(i)*12))).ix = jj
				i++
			}
			for func() *struct_Index {
				jj = int32(0)
				return func() (_cgo_ret *struct_Index) {
					_cgo_addr := &pIdx
					*_cgo_addr = pTab.pIndex
					return *_cgo_addr
				}()
			}(); pIdx != nil; func() int32 {
				pIdx = pIdx.pNext
				return func() (_cgo_ret int32) {
					_cgo_addr := &jj
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
			}() {
				if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(bUsed)) + uintptr(jj))) != 0 {
					continue
				}
				(*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(sIdxIter.u.ax.aIdx)) + uintptr(i)*12))).p = pIdx
				(*(*struct_IndexListTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(sIdxIter.u.ax.aIdx)) + uintptr(i)*12))).ix = jj
				i++
			}
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	if db.flags&uint64(8192|16384) == uint64(0) {
		pTrigger = (*struct_Trigger)(nil)
		regTrigCnt = int32(0)
	} else {
		if db.flags&uint64(8192) != 0 {
			pTrigger = sqlite3TriggersExist(pParse, pTab, 128, nil, nil)
			regTrigCnt = func() int32 {
				if uintptr(unsafe.Pointer(pTrigger)) != uintptr(unsafe.Pointer(nil)) || sqlite3FkRequired(pParse, pTab, nil, 0) != 0 {
					return 1
				} else {
					return 0
				}
			}()
		} else {
			pTrigger = (*struct_Trigger)(nil)
			regTrigCnt = sqlite3FkRequired(pParse, pTab, nil, 0)
		}
		if regTrigCnt != 0 {
			regTrigCnt = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3VdbeAddOp2(v, 71, 0, regTrigCnt)
			lblRecheckOk = sqlite3VdbeMakeLabel(pParse)
			addrRecheck = lblRecheckOk
		}
	}
	if int32(pkChng) != 0 && uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(nil)) {
		var addrRowidOk int32 = sqlite3VdbeMakeLabel(pParse)
		onError = int32(pTab.keyConf)
		if int32(overrideError) != 11 {
			onError = int32(overrideError)
		} else if onError == 11 {
			onError = int32(2)
		}
		if pUpsert != nil {
			pUpsertClause = sqlite3UpsertOfIndex(pUpsert, nil)
			if uintptr(unsafe.Pointer(pUpsertClause)) != uintptr(unsafe.Pointer(nil)) {
				if int32(pUpsertClause.isDoUpdate) == 0 {
					onError = int32(4)
				} else {
					onError = int32(6)
				}
			}
			if uintptr(unsafe.Pointer(pUpsertClause)) != uintptr(unsafe.Pointer(pUpsert)) {
				upsertIpkDelay = sqlite3VdbeAddOp0(v, 11)
			}
		}
		if onError == 5 && onError != int32(overrideError) && pTab.pIndex != nil && !(upsertIpkDelay != 0) {
			ipkTop = sqlite3VdbeAddOp0(v, 11) + 1
		}
		if isUpdate != 0 {
			sqlite3VdbeAddOp3(v, 53, regNewData, addrRowidOk, regOldData)
			sqlite3VdbeChangeP5(v, uint16(144))
		}
		sqlite3VdbeAddOp3(v, 33, iDataCur, addrRowidOk, regNewData)
		switch onError {
		default:
			{
				onError = int32(2)
			}
		case 1:
			fallthrough
		case 2:
			fallthrough
		case 3:
			{
				sqlite3RowidConstraint(pParse, onError, pTab)
				break
			}
		case 5:
			{
				if regTrigCnt != 0 {
					sqlite3MultiWrite(pParse)
					sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regNewData, int16(1), uint8(0), uint8(5), uint8(1), -1)
					sqlite3VdbeAddOp2(v, 85, regTrigCnt, 1)
					nReplaceTrig++
				} else if pTab.pIndex != nil {
					sqlite3MultiWrite(pParse)
					sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, nil, -1)
				}
				seenReplace = int32(1)
				break
			}
		case 6:
			{
				sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, nil, iDataCur)
			}
		case 4:
			{
				sqlite3VdbeGoto(v, ignoreDest)
				break
			}
		}
		sqlite3VdbeResolveLabel(v, addrRowidOk)
		if pUpsert != nil && uintptr(unsafe.Pointer(pUpsertClause)) != uintptr(unsafe.Pointer(pUpsert)) {
			upsertIpkReturn = sqlite3VdbeAddOp0(v, 11)
		} else if ipkTop != 0 {
			ipkBottom = sqlite3VdbeAddOp0(v, 11)
			sqlite3VdbeJumpHere(v, ipkTop-1)
		}
	}
	for pIdx = indexIteratorFirst(&sIdxIter, &ix); pIdx != nil; pIdx = indexIteratorNext(&sIdxIter, &ix) {
		var regIdx int32
		var regR int32
		var iThisCur int32
		var addrUniqueOk int32
		var addrConflictCk int32
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(ix)*4)) == 0 {
			continue
		}
		if pUpsert != nil {
			pUpsertClause = sqlite3UpsertOfIndex(pUpsert, pIdx)
			if upsertIpkDelay != 0 && uintptr(unsafe.Pointer(pUpsertClause)) == uintptr(unsafe.Pointer(pUpsert)) {
				sqlite3VdbeJumpHere(v, upsertIpkDelay)
			}
		}
		addrUniqueOk = sqlite3VdbeMakeLabel(pParse)
		if int32(bAffinityDone) == 0 {
			sqlite3TableAffinity(v, pTab, regNewData+1)
			bAffinityDone = uint8(1)
		}
		iThisCur = iIdxCur + ix
		if pIdx.pPartIdxWhere != nil {
			sqlite3VdbeAddOp2(v, 74, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(ix)*4)))
			pParse.iSelfTab = -(regNewData + 1)
			sqlite3ExprIfFalseDup(pParse, pIdx.pPartIdxWhere, addrUniqueOk, 16)
			pParse.iSelfTab = int32(0)
		}
		regIdx = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(ix)*4)) + 1
		for i = int32(0); i < int32(pIdx.nColumn); i++ {
			var iField int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
			var x int32
			if iField == -2 {
				pParse.iSelfTab = -(regNewData + 1)
				sqlite3ExprCodeCopy(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(i)*28))).pExpr, regIdx+i)
				pParse.iSelfTab = int32(0)
			} else if iField == -1 || iField == int32(pTab.iPKey) {
				x = regNewData
				sqlite3VdbeAddOp2(v, 81, x, regIdx+i)
			} else {
				x = int32(sqlite3TableColumnToStorage(pTab, int16(iField))) + regNewData + 1
				sqlite3VdbeAddOp2(v, 80, x, regIdx+i)
			}
		}
		sqlite3VdbeAddOp3(v, 96, regIdx, int32(pIdx.nColumn), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(ix)*4)))
		if int32(isUpdate) != 0 && uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(pIdx)) && int32(pkChng) == 0 {
			sqlite3VdbeResolveLabel(v, addrUniqueOk)
			continue
		}
		onError = int32(pIdx.onError)
		if onError == 0 {
			sqlite3VdbeResolveLabel(v, addrUniqueOk)
			continue
		}
		if int32(overrideError) != 11 {
			onError = int32(overrideError)
		} else if onError == 11 {
			onError = int32(2)
		}
		if pUpsertClause != nil {
			if int32(pUpsertClause.isDoUpdate) == 0 {
				onError = int32(4)
			} else {
				onError = int32(6)
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		if ix == 0 && uintptr(unsafe.Pointer(pIdx.pNext)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(pIdx)) && onError == 5 && (uint64(0) == db.flags&uint64(8192) || nil == sqlite3TriggersExist(pParse, pTab, 128, nil, nil)) && (uint64(0) == db.flags&uint64(16384) || nil == pTab.u.tab.pFKey && nil == sqlite3FkReferences(pTab)) {
			sqlite3VdbeResolveLabel(v, addrUniqueOk)
			continue
		}
		addrConflictCk = sqlite3VdbeAddOp4Int(v, 29, iThisCur, addrUniqueOk, regIdx, int32(pIdx.nKeyCol))
		regR = func() int32 {
			if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(pPk)) {
				return regIdx
			} else {
				return sqlite3GetTempRange(pParse, nPkField)
			}
		}()
		if int32(isUpdate) != 0 || onError == 5 {
			if pTab.tabFlags&uint32(128) == uint32(0) {
				sqlite3VdbeAddOp2(v, 141, iThisCur, regR)
				if isUpdate != 0 {
					sqlite3VdbeAddOp3(v, 53, regR, addrUniqueOk, regOldData)
					sqlite3VdbeChangeP5(v, uint16(144))
				}
			} else {
				var x int32
				if uintptr(unsafe.Pointer(pIdx)) != uintptr(unsafe.Pointer(pPk)) {
					for i = int32(0); i < int32(pPk.nKeyCol); i++ {
						func() int {
							_ = 0
							return 0
						}()
						x = int32(sqlite3TableColumnToIndex(pIdx, *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))))
						sqlite3VdbeAddOp3(v, 93, iThisCur, x, regR+i)
					}
				}
				if isUpdate != 0 {
					var addrJump int32 = sqlite3VdbeCurrentAddr(v) + int32(pPk.nKeyCol)
					var op int32 = 52
					var regCmp int32 = func() int32 {
						if int32(pIdx.Xbf_0&3) == 2 {
							return regIdx
						} else {
							return regR
						}
					}()
					for i = int32(0); i < int32(pPk.nKeyCol); i++ {
						var p4 *int8 = (*int8)(unsafe.Pointer(sqlite3LocateCollSeq(pParse, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.azColl)) + uintptr(i)*8)))))
						x = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2)))
						func() int {
							_ = 0
							return 0
						}()
						if i == int32(pPk.nKeyCol)-1 {
							addrJump = addrUniqueOk
							op = int32(53)
						}
						x = int32(sqlite3TableColumnToStorage(pTab, int16(x)))
						sqlite3VdbeAddOp4(v, op, regOldData+1+x, addrJump, regCmp+i, p4, -2)
						sqlite3VdbeChangeP5(v, uint16(144))
					}
				}
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		switch onError {
		case 1:
			fallthrough
		case 2:
			fallthrough
		case 3:
			{
				sqlite3UniqueConstraint(pParse, onError, pIdx)
				break
			}
		case 6:
			{
				sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix)
			}
		case 4:
			{
				sqlite3VdbeGoto(v, ignoreDest)
				break
			}
		default:
			{
				var nConflictCk int32
				func() int {
					_ = 0
					return 0
				}()
				nConflictCk = sqlite3VdbeCurrentAddr(v) - addrConflictCk
				func() int {
					_ = 0
					return 0
				}()
				if regTrigCnt != 0 {
					sqlite3MultiWrite(pParse)
					nReplaceTrig++
				}
				if pTrigger != nil && int32(isUpdate) != 0 {
					sqlite3VdbeAddOp1(v, 166, iDataCur)
				}
				sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur, regR, int16(nPkField), uint8(0), uint8(5), uint8(func() int32 {
					if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(pPk)) {
						return 1
					} else {
						return 0
					}
				}()), iThisCur)
				if pTrigger != nil && int32(isUpdate) != 0 {
					sqlite3VdbeAddOp1(v, 167, iDataCur)
				}
				if regTrigCnt != 0 {
					var addrBypass int32
					sqlite3VdbeAddOp2(v, 85, regTrigCnt, 1)
					addrBypass = sqlite3VdbeAddOp0(v, 11)
					sqlite3VdbeResolveLabel(v, lblRecheckOk)
					lblRecheckOk = sqlite3VdbeMakeLabel(pParse)
					if pIdx.pPartIdxWhere != nil {
						sqlite3VdbeAddOp2(v, 50, regIdx-1, lblRecheckOk)
					}
					for nConflictCk > 0 {
						var x struct_VdbeOp
						x = *sqlite3VdbeGetOp(v, addrConflictCk)
						if int32(x.opcode) != 141 {
							var p2 int32
							var zP4 *int8
							if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3OpcodeProperty)))) + uintptr(x.opcode))))&1 != 0 {
								p2 = lblRecheckOk
							} else {
								p2 = x.p2
							}
							zP4 = (*int8)(func() unsafe.Pointer {
								if int32(x.p4type) == -3 {
									return unsafe.Pointer(int(*(*int32)(unsafe.Pointer(&x.p4))))
								} else {
									return unsafe.Pointer(*(**int8)(unsafe.Pointer(&x.p4)))
								}
							}())
							sqlite3VdbeAddOp4(v, int32(x.opcode), x.p1, p2, x.p3, zP4, int32(x.p4type))
							sqlite3VdbeChangeP5(v, x.p5)
						}
						nConflictCk--
						addrConflictCk++
					}
					sqlite3UniqueConstraint(pParse, 2, pIdx)
					sqlite3VdbeJumpHere(v, addrBypass)
				}
				seenReplace = int32(1)
				break
			}
		}
		sqlite3VdbeResolveLabel(v, addrUniqueOk)
		if regR != regIdx {
			sqlite3ReleaseTempRange(pParse, regR, nPkField)
		}
		if pUpsertClause != nil && upsertIpkReturn != 0 && sqlite3UpsertNextIsIPK(pUpsertClause) != 0 {
			sqlite3VdbeGoto(v, upsertIpkDelay+1)
			sqlite3VdbeJumpHere(v, upsertIpkReturn)
			upsertIpkReturn = int32(0)
		}
	}
	if ipkTop != 0 {
		sqlite3VdbeGoto(v, ipkTop)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeJumpHere(v, ipkBottom)
	}
	func() int {
		_ = 0
		return 0
	}()
	if nReplaceTrig != 0 {
		sqlite3VdbeAddOp2(v, 20, regTrigCnt, lblRecheckOk)
		if !(pPk != nil) {
			if isUpdate != 0 {
				sqlite3VdbeAddOp3(v, 53, regNewData, addrRecheck, regOldData)
				sqlite3VdbeChangeP5(v, uint16(144))
			}
			sqlite3VdbeAddOp3(v, 33, iDataCur, addrRecheck, regNewData)
			sqlite3RowidConstraint(pParse, 2, pTab)
		} else {
			sqlite3VdbeGoto(v, addrRecheck)
		}
		sqlite3VdbeResolveLabel(v, lblRecheckOk)
	}
	if pTab.tabFlags&uint32(128) == uint32(0) {
		var regRec int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(ix)*4))
		sqlite3VdbeAddOp3(v, 96, regNewData+1, int32(pTab.nNVCol), regRec)
		if !(bAffinityDone != 0) {
			sqlite3TableAffinity(v, pTab, 0)
		}
	}
	*pbMayReplace = seenReplace
}
func sqlite3CompleteInsertion(pParse *struct_Parse, pTab *struct_Table, iDataCur int32, iIdxCur int32, regNewData int32, aRegIdx *int32, update_flags int32, appendBias int32, useSeekResult int32) {
	var v *struct_Vdbe
	var pIdx *struct_Index
	var pik_flags uint8
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for func() *struct_Index {
		i = int32(0)
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pTab.pIndex
			return *_cgo_addr
		}()
	}(); pIdx != nil; func() int32 {
		pIdx = pIdx.pNext
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		func() int {
			_ = 0
			return 0
		}()
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)) == 0 {
			continue
		}
		if pIdx.pPartIdxWhere != nil {
			sqlite3VdbeAddOp2(v, 50, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)), sqlite3VdbeCurrentAddr(v)+2)
		}
		pik_flags = uint8(func() int32 {
			if useSeekResult != 0 {
				return 16
			} else {
				return 0
			}
		}())
		if int32(pIdx.Xbf_0&3) == 2 && !(pTab.tabFlags&uint32(128) == uint32(0)) {
			pik_flags |= uint8(1)
			pik_flags |= uint8(update_flags & 2)
			if update_flags == 0 {
			}
		}
		sqlite3VdbeAddOp4Int(v, 137, iIdxCur+i, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)), *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4))+1, func() int32 {
			if int32(pIdx.Xbf_0>>3&1) != 0 {
				return int32(pIdx.nKeyCol)
			} else {
				return int32(pIdx.nColumn)
			}
		}())
		sqlite3VdbeChangeP5(v, uint16(pik_flags))
	}
	if !(pTab.tabFlags&uint32(128) == uint32(0)) {
		return
	}
	if pParse.nested != 0 {
		pik_flags = uint8(0)
	} else {
		pik_flags = uint8(1)
		pik_flags |= uint8(func() int32 {
			if update_flags != 0 {
				return update_flags
			} else {
				return 32
			}
		}())
	}
	if appendBias != 0 {
		pik_flags |= uint8(8)
	}
	if useSeekResult != 0 {
		pik_flags |= uint8(16)
	}
	sqlite3VdbeAddOp3(v, 127, iDataCur, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(i)*4)), regNewData)
	if !(pParse.nested != 0) {
		sqlite3VdbeAppendP4(v, unsafe.Pointer(pTab), -6)
	}
	sqlite3VdbeChangeP5(v, uint16(pik_flags))
}
func sqlite3OpenTableAndIndices(pParse *struct_Parse, pTab *struct_Table, op int32, p5 uint8, iBase int32, aToOpen *uint8, piDataCur *int32, piIdxCur *int32) int32 {
	var i int32
	var iDb int32
	var iDataCur int32
	var pIdx *struct_Index
	var v *struct_Vdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTab.eTabType) == 1 {
		*piDataCur = func() (_cgo_ret int32) {
			_cgo_addr := &*piIdxCur
			*_cgo_addr = int32(-999)
			return *_cgo_addr
		}()
		return int32(0)
	}
	iDb = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	if iBase < 0 {
		iBase = pParse.nTab
	}
	iDataCur = func() (_cgo_ret int32) {
		_cgo_addr := &iBase
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	if piDataCur != nil {
		*piDataCur = iDataCur
	}
	if pTab.tabFlags&uint32(128) == uint32(0) && (uintptr(unsafe.Pointer(aToOpen)) == uintptr(unsafe.Pointer(nil)) || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(0)))) != 0) {
		sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op)
	} else {
		sqlite3TableLock(pParse, iDb, pTab.tnum, func() uint8 {
			if op == 112 {
				return 1
			} else {
				return 0
			}
		}(), pTab.zName)
	}
	if piIdxCur != nil {
		*piIdxCur = iBase
	}
	for func() *struct_Index {
		i = int32(0)
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pTab.pIndex
			return *_cgo_addr
		}()
	}(); pIdx != nil; func() int32 {
		pIdx = pIdx.pNext
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		var iIdxCur int32 = func() (_cgo_ret int32) {
			_cgo_addr := &iBase
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		func() int {
			_ = 0
			return 0
		}()
		if int32(pIdx.Xbf_0&3) == 2 && !(pTab.tabFlags&uint32(128) == uint32(0)) {
			if piDataCur != nil {
				*piDataCur = iIdxCur
			}
			p5 = uint8(0)
		}
		if uintptr(unsafe.Pointer(aToOpen)) == uintptr(unsafe.Pointer(nil)) || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(i+1)))) != 0 {
			sqlite3VdbeAddOp3(v, op, iIdxCur, int32(pIdx.tnum), iDb)
			sqlite3VdbeSetP4KeyInfo(pParse, pIdx)
			sqlite3VdbeChangeP5(v, uint16(p5))
		}
	}
	if iBase > pParse.nTab {
		pParse.nTab = iBase
	}
	return i
}
func xferCompatibleIndex(pDest *struct_Index, pSrc *struct_Index) int32 {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pDest.nKeyCol) != int32(pSrc.nKeyCol) || int32(pDest.nColumn) != int32(pSrc.nColumn) {
		return int32(0)
	}
	if int32(pDest.onError) != int32(pSrc.onError) {
		return int32(0)
	}
	for i = int32(0); i < int32(pSrc.nKeyCol); i++ {
		if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.aiColumn)) + uintptr(i)*2))) != int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest.aiColumn)) + uintptr(i)*2))) {
			return int32(0)
		}
		if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.aiColumn)) + uintptr(i)*2))) == -2 {
			func() int {
				_ = 0
				return 0
			}()
			if sqlite3ExprCompare(nil, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSrc.aColExpr.a)))) + uintptr(i)*28))).pExpr, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pDest.aColExpr.a)))) + uintptr(i)*28))).pExpr, -1) != 0 {
				return int32(0)
			}
		}
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.aSortOrder)) + uintptr(i)))) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest.aSortOrder)) + uintptr(i)))) {
			return int32(0)
		}
		if sqlite3_stricmp(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.azColl)) + uintptr(i)*8)), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest.azColl)) + uintptr(i)*8))) != 0 {
			return int32(0)
		}
	}
	if sqlite3ExprCompare(nil, pSrc.pPartIdxWhere, pDest.pPartIdxWhere, -1) != 0 {
		return int32(0)
	}
	return int32(1)
}
func xferOptimization(pParse *struct_Parse, pDest *struct_Table, pSelect *struct_Select, onError int32, iDbDest int32) int32 {
	var db *struct_sqlite3 = pParse.db
	var pEList *struct_ExprList
	var pSrc *struct_Table
	var pSrcIdx *struct_Index
	var pDestIdx *struct_Index
	var pItem *struct_SrcItem
	var i int32
	var iDbSrc int32
	var iSrc int32
	var iDest int32
	var addr1 int32
	var addr2 int32
	var emptyDestTest int32 = 0
	var emptySrcTest int32 = 0
	var v *struct_Vdbe
	var regAutoinc int32
	var destHasUniqueIdx int32 = 0
	var regData int32
	var regRowid int32
	func() int {
		_ = 0
		return 0
	}()
	if pParse.pWith != nil || pSelect.pWith != nil {
		return int32(0)
	}
	if int32(pDest.eTabType) == 1 {
		return int32(0)
	}
	if onError == 11 {
		if int32(pDest.iPKey) >= 0 {
			onError = int32(pDest.keyConf)
		}
		if onError == 11 {
			onError = int32(2)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if pSelect.pSrc.nSrc != 1 {
		return int32(0)
	}
	if (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSelect.pSrc.a)))) + uintptr(0)*112))).pSelect != nil {
		return int32(0)
	}
	if pSelect.pWhere != nil {
		return int32(0)
	}
	if pSelect.pOrderBy != nil {
		return int32(0)
	}
	if pSelect.pGroupBy != nil {
		return int32(0)
	}
	if pSelect.pLimit != nil {
		return int32(0)
	}
	if pSelect.pPrior != nil {
		return int32(0)
	}
	if pSelect.selFlags&uint32(1) != 0 {
		return int32(0)
	}
	pEList = pSelect.pEList
	func() int {
		_ = 0
		return 0
	}()
	if pEList.nExpr != 1 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(0)*28))).pExpr.op) != 180 {
		return int32(0)
	}
	pItem = (*struct_SrcItem)(unsafe.Pointer(&pSelect.pSrc.a))
	pSrc = sqlite3LocateTableItem(pParse, uint32(0), pItem)
	if uintptr(unsafe.Pointer(pSrc)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if pSrc.tnum == pDest.tnum && uintptr(unsafe.Pointer(pSrc.pSchema)) == uintptr(unsafe.Pointer(pDest.pSchema)) {
		return int32(0)
	}
	if func() int32 {
		if pDest.tabFlags&uint32(128) == uint32(0) {
			return 1
		} else {
			return 0
		}
	}() != func() int32 {
		if pSrc.tabFlags&uint32(128) == uint32(0) {
			return 1
		} else {
			return 0
		}
	}() {
		return int32(0)
	}
	if !(int32(pSrc.eTabType) == 0) {
		return int32(0)
	}
	if int32(pDest.nCol) != int32(pSrc.nCol) {
		return int32(0)
	}
	if int32(pDest.iPKey) != int32(pSrc.iPKey) {
		return int32(0)
	}
	if pDest.tabFlags&uint32(65536) != uint32(0) && pSrc.tabFlags&uint32(65536) == uint32(0) {
		return int32(0)
	}
	for i = int32(0); i < int32(pDest.nCol); i++ {
		var pDestCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pDest.aCol)) + uintptr(i)*20))
		var pSrcCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.aCol)) + uintptr(i)*20))
		if int32(pDestCol.colFlags)&96 != int32(pSrcCol.colFlags)&96 {
			return int32(0)
		}
		if int32(pDestCol.colFlags)&96 != 0 {
			if sqlite3ExprCompare(nil, sqlite3ColumnExpr(pSrc, pSrcCol), sqlite3ColumnExpr(pDest, pDestCol), -1) != 0 {
				return int32(0)
			}
		}
		if int32(pDestCol.affinity) != int32(pSrcCol.affinity) {
			return int32(0)
		}
		if sqlite3_stricmp(sqlite3ColumnColl(pDestCol), sqlite3ColumnColl(pSrcCol)) != 0 {
			return int32(0)
		}
		if int32(pDestCol.Xbf_0&15) != 0 && !(pSrcCol.Xbf_0&15 != 0) {
			return int32(0)
		}
		if int32(pDestCol.colFlags)&96 == 0 && i > 0 {
			var pDestExpr *struct_Expr = sqlite3ColumnExpr(pDest, pDestCol)
			var pSrcExpr *struct_Expr = sqlite3ColumnExpr(pSrc, pSrcCol)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if func() int32 {
				if uintptr(unsafe.Pointer(pDestExpr)) == uintptr(unsafe.Pointer(nil)) {
					return 1
				} else {
					return 0
				}
			}() != func() int32 {
				if uintptr(unsafe.Pointer(pSrcExpr)) == uintptr(unsafe.Pointer(nil)) {
					return 1
				} else {
					return 0
				}
			}() || uintptr(unsafe.Pointer(pDestExpr)) != uintptr(unsafe.Pointer(nil)) && strcmp(pDestExpr.u.zToken, pSrcExpr.u.zToken) != 0 {
				return int32(0)
			}
		}
	}
	for pDestIdx = pDest.pIndex; pDestIdx != nil; pDestIdx = pDestIdx.pNext {
		if int32(pDestIdx.onError) != 0 {
			destHasUniqueIdx = int32(1)
		}
		for pSrcIdx = pSrc.pIndex; pSrcIdx != nil; pSrcIdx = pSrcIdx.pNext {
			if xferCompatibleIndex(pDestIdx, pSrcIdx) != 0 {
				break
			}
		}
		if uintptr(unsafe.Pointer(pSrcIdx)) == uintptr(unsafe.Pointer(nil)) {
			return int32(0)
		}
		if pSrcIdx.tnum == pDestIdx.tnum && uintptr(unsafe.Pointer(pSrc.pSchema)) == uintptr(unsafe.Pointer(pDest.pSchema)) && sqlite3FaultSim(411) == 0 {
			return int32(0)
		}
	}
	if pDest.pCheck != nil && sqlite3ExprListCompare(pSrc.pCheck, pDest.pCheck, -1) != 0 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	if db.flags&uint64(16384) != uint64(0) && uintptr(unsafe.Pointer(pDest.u.tab.pFKey)) != uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if db.flags&(uint64(1)<<32) != uint64(0) {
		return int32(0)
	}
	iDbSrc = sqlite3SchemaToIndex(db, pSrc.pSchema)
	v = sqlite3GetVdbe(pParse)
	sqlite3CodeVerifySchema(pParse, iDbSrc)
	iSrc = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	iDest = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	regAutoinc = autoIncBegin(pParse, iDbDest, pDest)
	regData = sqlite3GetTempReg(pParse)
	sqlite3VdbeAddOp2(v, 74, 0, regData)
	regRowid = sqlite3GetTempReg(pParse)
	sqlite3OpenTable(pParse, iDest, iDbDest, pDest, 112)
	func() int {
		_ = 0
		return 0
	}()
	if db.mDbFlags&uint32(4) == uint32(0) && (int32(pDest.iPKey) < 0 && uintptr(unsafe.Pointer(pDest.pIndex)) != uintptr(unsafe.Pointer(nil)) || destHasUniqueIdx != 0 || onError != 2 && onError != 1) {
		addr1 = sqlite3VdbeAddOp2(v, 38, iDest, 0)
		emptyDestTest = sqlite3VdbeAddOp0(v, 11)
		sqlite3VdbeJumpHere(v, addr1)
	}
	if pSrc.tabFlags&uint32(128) == uint32(0) {
		var insFlags uint8
		sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, 101)
		emptySrcTest = sqlite3VdbeAddOp2(v, 38, iSrc, 0)
		if int32(pDest.iPKey) >= 0 {
			addr1 = sqlite3VdbeAddOp2(v, 134, iSrc, regRowid)
			if db.mDbFlags&uint32(4) == uint32(0) {
				addr2 = sqlite3VdbeAddOp3(v, 33, iDest, 0, regRowid)
				sqlite3RowidConstraint(pParse, onError, pDest)
				sqlite3VdbeJumpHere(v, addr2)
			}
			autoIncStep(pParse, regAutoinc, regRowid)
		} else if uintptr(unsafe.Pointer(pDest.pIndex)) == uintptr(unsafe.Pointer(nil)) && !(db.mDbFlags&uint32(8) != 0) {
			addr1 = sqlite3VdbeAddOp2(v, 126, iDest, regRowid)
		} else {
			addr1 = sqlite3VdbeAddOp2(v, 134, iSrc, regRowid)
			func() int {
				_ = 0
				return 0
			}()
		}
		if db.mDbFlags&uint32(4) != 0 {
			sqlite3VdbeAddOp1(v, 136, iDest)
			insFlags = uint8(8 | 16 | 128)
		} else {
			insFlags = uint8(1 | 32 | 8 | 128)
		}
		{
			sqlite3VdbeAddOp3(v, 128, iDest, iSrc, regRowid)
		}
		sqlite3VdbeAddOp3(v, 127, iDest, regData, regRowid)
		if db.mDbFlags&uint32(4) == uint32(0) {
			sqlite3VdbeChangeP4(v, -1, (*int8)(unsafe.Pointer(pDest)), -6)
		}
		sqlite3VdbeChangeP5(v, uint16(insFlags))
		sqlite3VdbeAddOp2(v, 5, iSrc, addr1)
		sqlite3VdbeAddOp2(v, 121, iSrc, 0)
		sqlite3VdbeAddOp2(v, 121, iDest, 0)
	} else {
		sqlite3TableLock(pParse, iDbDest, pDest.tnum, uint8(1), pDest.zName)
		sqlite3TableLock(pParse, iDbSrc, pSrc.tnum, uint8(0), pSrc.zName)
	}
	for pDestIdx = pDest.pIndex; pDestIdx != nil; pDestIdx = pDestIdx.pNext {
		var idxInsFlags uint8 = uint8(0)
		for pSrcIdx = pSrc.pIndex; pSrcIdx != nil; pSrcIdx = pSrcIdx.pNext {
			if xferCompatibleIndex(pDestIdx, pSrcIdx) != 0 {
				break
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp3(v, 101, iSrc, int32(pSrcIdx.tnum), iDbSrc)
		sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx)
		sqlite3VdbeAddOp3(v, 112, iDest, int32(pDestIdx.tnum), iDbDest)
		sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx)
		sqlite3VdbeChangeP5(v, uint16(1))
		addr1 = sqlite3VdbeAddOp2(v, 38, iSrc, 0)
		if db.mDbFlags&uint32(4) != 0 {
			for i = int32(0); i < int32(pSrcIdx.nColumn); i++ {
				var zColl *int8 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrcIdx.azColl)) + uintptr(i)*8))
				if sqlite3_stricmp((*int8)(unsafe.Pointer(&sqlite3StrBINARY)), zColl) != 0 {
					break
				}
			}
			if i == int32(pSrcIdx.nColumn) {
				idxInsFlags = uint8(16 | 128)
				sqlite3VdbeAddOp1(v, 136, iDest)
				sqlite3VdbeAddOp2(v, 128, iDest, iSrc)
			}
		} else if !(pSrc.tabFlags&uint32(128) == uint32(0)) && int32(pDestIdx.Xbf_0&3) == 2 {
			idxInsFlags |= uint8(1)
		}
		if int32(idxInsFlags) != 16|128 {
			sqlite3VdbeAddOp3(v, 133, iSrc, regData, 1)
			if db.mDbFlags&uint32(4) == uint32(0) && !(pDest.tabFlags&uint32(128) == uint32(0)) && int32(pDestIdx.Xbf_0&3) == 2 {
			}
		}
		sqlite3VdbeAddOp2(v, 137, iDest, regData)
		sqlite3VdbeChangeP5(v, uint16(int32(idxInsFlags)|8))
		sqlite3VdbeAddOp2(v, 5, iSrc, addr1+1)
		sqlite3VdbeJumpHere(v, addr1)
		sqlite3VdbeAddOp2(v, 121, iSrc, 0)
		sqlite3VdbeAddOp2(v, 121, iDest, 0)
	}
	if emptySrcTest != 0 {
		sqlite3VdbeJumpHere(v, emptySrcTest)
	}
	sqlite3ReleaseTempReg(pParse, regRowid)
	sqlite3ReleaseTempReg(pParse, regData)
	if emptyDestTest != 0 {
		sqlite3AutoincrementEnd(pParse)
		sqlite3VdbeAddOp2(v, 70, 0, 0)
		sqlite3VdbeJumpHere(v, emptyDestTest)
		sqlite3VdbeAddOp2(v, 121, iDest, 0)
		return int32(0)
	} else {
		return int32(1)
	}
}
func sqlite3_exec(db *struct_sqlite3, zSql *int8, xCallback func(unsafe.Pointer, int32, **int8, **int8) int32, pArg unsafe.Pointer, pzErrMsg **int8) int32 {
	var rc int32 = 0
	var zLeftover *int8
	var pStmt *struct_sqlite3_stmt = nil
	var azCols **int8 = nil
	var callbackIsInit int32
	if !(sqlite3SafetyCheckOk(db) != 0) {
		return sqlite3MisuseError(128104)
	}
	if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		zSql = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	}
	sqlite3_mutex_enter(db.mutex)
	sqlite3Error(db, 0)
	for rc == 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0)))) != 0 {
		var nCol int32 = 0
		var azVals **int8 = nil
		pStmt = (*struct_sqlite3_stmt)(nil)
		rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover)
		func() int {
			_ = 0
			return 0
		}()
		if rc != 0 {
			continue
		}
		if !(pStmt != nil) {
			zSql = zLeftover
			continue
		}
		callbackIsInit = int32(0)
		for 1 != 0 {
			var i int32
			rc = sqlite3_step(pStmt)
			if xCallback != nil && (100 == rc || 101 == rc && !(callbackIsInit != 0) && db.flags&uint64(256) != 0) {
				if !(callbackIsInit != 0) {
					nCol = sqlite3_column_count(pStmt)
					azCols = (**int8)(sqlite3DbMallocRaw(db, uint64(uint(2*nCol+1)*8)))
					if uintptr(unsafe.Pointer(azCols)) == uintptr(unsafe.Pointer(nil)) {
						goto exec_out
					}
					for i = int32(0); i < nCol; i++ {
						*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azCols)) + uintptr(i)*8)) = (*int8)(unsafe.Pointer(sqlite3_column_name(pStmt, i)))
						func() int {
							_ = 0
							return 0
						}()
					}
					callbackIsInit = int32(1)
				}
				if rc == 100 {
					azVals = &*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azCols)) + uintptr(nCol)*8))
					for i = int32(0); i < nCol; i++ {
						*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azVals)) + uintptr(i)*8)) = (*int8)(unsafe.Pointer(sqlite3_column_text(pStmt, i)))
						if !(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azVals)) + uintptr(i)*8)) != nil) && sqlite3_column_type(pStmt, i) != 5 {
							sqlite3OomFault(db)
							goto exec_out
						}
					}
					*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azVals)) + uintptr(i)*8)) = (*int8)(nil)
				}
				if xCallback(pArg, nCol, azVals, azCols) != 0 {
					rc = int32(4)
					sqlite3VdbeFinalize((*struct_Vdbe)(unsafe.Pointer(pStmt)))
					pStmt = (*struct_sqlite3_stmt)(nil)
					sqlite3Error(db, 4)
					goto exec_out
				}
			}
			if rc != 100 {
				rc = sqlite3VdbeFinalize((*struct_Vdbe)(unsafe.Pointer(pStmt)))
				pStmt = (*struct_sqlite3_stmt)(nil)
				zSql = zLeftover
				for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0))))))))&1 != 0 {
					*(*uintptr)(unsafe.Pointer(&zSql))++
				}
				break
			}
		}
		sqlite3DbFree(db, unsafe.Pointer(azCols))
		azCols = (**int8)(nil)
	}
exec_out:
	if pStmt != nil {
		sqlite3VdbeFinalize((*struct_Vdbe)(unsafe.Pointer(pStmt)))
	}
	sqlite3DbFree(db, unsafe.Pointer(azCols))
	rc = sqlite3ApiExit(db, rc)
	if rc != 0 && pzErrMsg != nil {
		*pzErrMsg = sqlite3DbStrDup(nil, sqlite3_errmsg(db))
		if uintptr(unsafe.Pointer(*pzErrMsg)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
			sqlite3Error(db, 7)
		}
	} else if pzErrMsg != nil {
		*pzErrMsg = (*int8)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3_mutex_leave(db.mutex)
	return rc
}

type struct_sqlite3_api_routines struct {
	aggregate_context      func(*struct_sqlite3_context, int32) unsafe.Pointer
	aggregate_count        func(*struct_sqlite3_context) int32
	bind_blob              func(*struct_sqlite3_stmt, int32, unsafe.Pointer, int32, func(unsafe.Pointer)) int32
	bind_double            func(*struct_sqlite3_stmt, int32, float64) int32
	bind_int               func(*struct_sqlite3_stmt, int32, int32) int32
	bind_int64             func(*struct_sqlite3_stmt, int32, int64) int32
	bind_null              func(*struct_sqlite3_stmt, int32) int32
	bind_parameter_count   func(*struct_sqlite3_stmt) int32
	bind_parameter_index   func(*struct_sqlite3_stmt, *int8) int32
	bind_parameter_name    func(*struct_sqlite3_stmt, int32) *int8
	bind_text              func(*struct_sqlite3_stmt, int32, *int8, int32, func(unsafe.Pointer)) int32
	bind_text16            func(*struct_sqlite3_stmt, int32, unsafe.Pointer, int32, func(unsafe.Pointer)) int32
	bind_value             func(*struct_sqlite3_stmt, int32, *struct_sqlite3_value) int32
	busy_handler           func(*struct_sqlite3, func(unsafe.Pointer, int32) int32, unsafe.Pointer) int32
	busy_timeout           func(*struct_sqlite3, int32) int32
	changes                func(*struct_sqlite3) int32
	close                  func(*struct_sqlite3) int32
	collation_needed       func(*struct_sqlite3, unsafe.Pointer, func(unsafe.Pointer, *struct_sqlite3, int32, *int8)) int32
	collation_needed16     func(*struct_sqlite3, unsafe.Pointer, func(unsafe.Pointer, *struct_sqlite3, int32, unsafe.Pointer)) int32
	column_blob            func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_bytes           func(*struct_sqlite3_stmt, int32) int32
	column_bytes16         func(*struct_sqlite3_stmt, int32) int32
	column_count           func(*struct_sqlite3_stmt) int32
	column_database_name   func(*struct_sqlite3_stmt, int32) *int8
	column_database_name16 func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_decltype        func(*struct_sqlite3_stmt, int32) *int8
	column_decltype16      func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_double          func(*struct_sqlite3_stmt, int32) float64
	column_int             func(*struct_sqlite3_stmt, int32) int32
	column_int64           func(*struct_sqlite3_stmt, int32) int64
	column_name            func(*struct_sqlite3_stmt, int32) *int8
	column_name16          func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_origin_name     func(*struct_sqlite3_stmt, int32) *int8
	column_origin_name16   func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_table_name      func(*struct_sqlite3_stmt, int32) *int8
	column_table_name16    func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_text            func(*struct_sqlite3_stmt, int32) *uint8
	column_text16          func(*struct_sqlite3_stmt, int32) unsafe.Pointer
	column_type            func(*struct_sqlite3_stmt, int32) int32
	column_value           func(*struct_sqlite3_stmt, int32) *struct_sqlite3_value
	commit_hook            func(*struct_sqlite3, func(unsafe.Pointer) int32, unsafe.Pointer) unsafe.Pointer
	complete               func(*int8) int32
	complete16             func(unsafe.Pointer) int32
	create_collation       func(*struct_sqlite3, *int8, int32, unsafe.Pointer, func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32) int32
	create_collation16     func(*struct_sqlite3, unsafe.Pointer, int32, unsafe.Pointer, func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32) int32
	create_function        func(*struct_sqlite3, *int8, int32, int32, unsafe.Pointer, func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context)) int32
	create_function16      func(*struct_sqlite3, unsafe.Pointer, int32, int32, unsafe.Pointer, func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context)) int32
	create_module          func(*struct_sqlite3, *int8, *struct_sqlite3_module, unsafe.Pointer) int32
	data_count             func(*struct_sqlite3_stmt) int32
	db_handle              func(*struct_sqlite3_stmt) *struct_sqlite3
	declare_vtab           func(*struct_sqlite3, *int8) int32
	enable_shared_cache    func(int32) int32
	errcode                func(*struct_sqlite3) int32
	errmsg                 func(*struct_sqlite3) *int8
	errmsg16               func(*struct_sqlite3) unsafe.Pointer
	exec                   func(*struct_sqlite3, *int8, func(unsafe.Pointer, int32, **int8, **int8) int32, unsafe.Pointer, **int8) int32
	expired                func(*struct_sqlite3_stmt) int32
	finalize               func(*struct_sqlite3_stmt) int32
	free                   func(unsafe.Pointer)
	free_table             func(**int8)
	get_autocommit         func(*struct_sqlite3) int32
	get_auxdata            func(*struct_sqlite3_context, int32) unsafe.Pointer
	get_table              func(*struct_sqlite3, *int8, ***int8, *int32, *int32, **int8) int32
	global_recover         func() int32
	interruptx             func(*struct_sqlite3)
	last_insert_rowid      func(*struct_sqlite3) int64
	libversion             func() *int8
	libversion_number      func() int32
	malloc                 func(int32) unsafe.Pointer
	mprintf                func(*int8, ...interface {
	}) *int8
	open             func(*int8, **struct_sqlite3) int32
	open16           func(unsafe.Pointer, **struct_sqlite3) int32
	prepare          func(*struct_sqlite3, *int8, int32, **struct_sqlite3_stmt, **int8) int32
	prepare16        func(*struct_sqlite3, unsafe.Pointer, int32, **struct_sqlite3_stmt, *unsafe.Pointer) int32
	profile          func(*struct_sqlite3, func(unsafe.Pointer, *int8, uint64), unsafe.Pointer) unsafe.Pointer
	progress_handler func(*struct_sqlite3, int32, func(unsafe.Pointer) int32, unsafe.Pointer)
	realloc          func(unsafe.Pointer, int32) unsafe.Pointer
	reset            func(*struct_sqlite3_stmt) int32
	result_blob      func(*struct_sqlite3_context, unsafe.Pointer, int32, func(unsafe.Pointer))
	result_double    func(*struct_sqlite3_context, float64)
	result_error     func(*struct_sqlite3_context, *int8, int32)
	result_error16   func(*struct_sqlite3_context, unsafe.Pointer, int32)
	result_int       func(*struct_sqlite3_context, int32)
	result_int64     func(*struct_sqlite3_context, int64)
	result_null      func(*struct_sqlite3_context)
	result_text      func(*struct_sqlite3_context, *int8, int32, func(unsafe.Pointer))
	result_text16    func(*struct_sqlite3_context, unsafe.Pointer, int32, func(unsafe.Pointer))
	result_text16be  func(*struct_sqlite3_context, unsafe.Pointer, int32, func(unsafe.Pointer))
	result_text16le  func(*struct_sqlite3_context, unsafe.Pointer, int32, func(unsafe.Pointer))
	result_value     func(*struct_sqlite3_context, *struct_sqlite3_value)
	rollback_hook    func(*struct_sqlite3, func(unsafe.Pointer), unsafe.Pointer) unsafe.Pointer
	set_authorizer   func(*struct_sqlite3, func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32, unsafe.Pointer) int32
	set_auxdata      func(*struct_sqlite3_context, int32, unsafe.Pointer, func(unsafe.Pointer))
	xsnprintf        func(int32, *int8, *int8, ...interface {
	}) *int8
	step                  func(*struct_sqlite3_stmt) int32
	table_column_metadata func(*struct_sqlite3, *int8, *int8, *int8, **int8, **int8, *int32, *int32, *int32) int32
	thread_cleanup        func()
	total_changes         func(*struct_sqlite3) int32
	trace                 func(*struct_sqlite3, func(unsafe.Pointer, *int8), unsafe.Pointer) unsafe.Pointer
	transfer_bindings     func(*struct_sqlite3_stmt, *struct_sqlite3_stmt) int32
	update_hook           func(*struct_sqlite3, func(unsafe.Pointer, int32, *int8, *int8, int64), unsafe.Pointer) unsafe.Pointer
	user_data             func(*struct_sqlite3_context) unsafe.Pointer
	value_blob            func(*struct_sqlite3_value) unsafe.Pointer
	value_bytes           func(*struct_sqlite3_value) int32
	value_bytes16         func(*struct_sqlite3_value) int32
	value_double          func(*struct_sqlite3_value) float64
	value_int             func(*struct_sqlite3_value) int32
	value_int64           func(*struct_sqlite3_value) int64
	value_numeric_type    func(*struct_sqlite3_value) int32
	value_text            func(*struct_sqlite3_value) *uint8
	value_text16          func(*struct_sqlite3_value) unsafe.Pointer
	value_text16be        func(*struct_sqlite3_value) unsafe.Pointer
	value_text16le        func(*struct_sqlite3_value) unsafe.Pointer
	value_type            func(*struct_sqlite3_value) int32
	vmprintf              func(*int8, ...interface {
	}) *int8
	overload_function   func(*struct_sqlite3, *int8, int32) int32
	prepare_v2          func(*struct_sqlite3, *int8, int32, **struct_sqlite3_stmt, **int8) int32
	prepare16_v2        func(*struct_sqlite3, unsafe.Pointer, int32, **struct_sqlite3_stmt, *unsafe.Pointer) int32
	clear_bindings      func(*struct_sqlite3_stmt) int32
	create_module_v2    func(*struct_sqlite3, *int8, *struct_sqlite3_module, unsafe.Pointer, func(unsafe.Pointer)) int32
	bind_zeroblob       func(*struct_sqlite3_stmt, int32, int32) int32
	blob_bytes          func(*struct_sqlite3_blob) int32
	blob_close          func(*struct_sqlite3_blob) int32
	blob_open           func(*struct_sqlite3, *int8, *int8, *int8, int64, int32, **struct_sqlite3_blob) int32
	blob_read           func(*struct_sqlite3_blob, unsafe.Pointer, int32, int32) int32
	blob_write          func(*struct_sqlite3_blob, unsafe.Pointer, int32, int32) int32
	create_collation_v2 func(*struct_sqlite3, *int8, int32, unsafe.Pointer, func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32, func(unsafe.Pointer)) int32
	file_control        func(*struct_sqlite3, *int8, int32, unsafe.Pointer) int32
	memory_highwater    func(int32) int64
	memory_used         func() int64
	mutex_alloc         func(int32) *struct_sqlite3_mutex
	mutex_enter         func(*struct_sqlite3_mutex)
	mutex_free          func(*struct_sqlite3_mutex)
	mutex_leave         func(*struct_sqlite3_mutex)
	mutex_try           func(*struct_sqlite3_mutex) int32
	open_v2             func(*int8, **struct_sqlite3, int32, *int8) int32
	release_memory      func(int32) int32
	result_error_nomem  func(*struct_sqlite3_context)
	result_error_toobig func(*struct_sqlite3_context)
	sleep               func(int32) int32
	soft_heap_limit     func(int32)
	vfs_find            func(*int8) *struct_sqlite3_vfs
	vfs_register        func(*struct_sqlite3_vfs, int32) int32
	vfs_unregister      func(*struct_sqlite3_vfs) int32
	xthreadsafe         func() int32
	result_zeroblob     func(*struct_sqlite3_context, int32)
	result_error_code   func(*struct_sqlite3_context, int32)
	test_control        func(int32, ...interface {
	}) int32
	randomness            func(int32, unsafe.Pointer)
	context_db_handle     func(*struct_sqlite3_context) *struct_sqlite3
	extended_result_codes func(*struct_sqlite3, int32) int32
	limit                 func(*struct_sqlite3, int32, int32) int32
	next_stmt             func(*struct_sqlite3, *struct_sqlite3_stmt) *struct_sqlite3_stmt
	sql                   func(*struct_sqlite3_stmt) *int8
	status                func(int32, *int32, *int32, int32) int32
	backup_finish         func(*struct_sqlite3_backup) int32
	backup_init           func(*struct_sqlite3, *int8, *struct_sqlite3, *int8) *struct_sqlite3_backup
	backup_pagecount      func(*struct_sqlite3_backup) int32
	backup_remaining      func(*struct_sqlite3_backup) int32
	backup_step           func(*struct_sqlite3_backup, int32) int32
	compileoption_get     func(int32) *int8
	compileoption_used    func(*int8) int32
	create_function_v2    func(*struct_sqlite3, *int8, int32, int32, unsafe.Pointer, func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context), func(unsafe.Pointer)) int32
	db_config             func(*struct_sqlite3, int32, ...interface {
	}) int32
	db_mutex         func(*struct_sqlite3) *struct_sqlite3_mutex
	db_status        func(*struct_sqlite3, int32, *int32, *int32, int32) int32
	extended_errcode func(*struct_sqlite3) int32
	log              func(int32, *int8, ...interface {
	})
	soft_heap_limit64  func(int64) int64
	sourceid           func() *int8
	stmt_status        func(*struct_sqlite3_stmt, int32, int32) int32
	strnicmp           func(*int8, *int8, int32) int32
	unlock_notify      func(*struct_sqlite3, func(*unsafe.Pointer, int32), unsafe.Pointer) int32
	wal_autocheckpoint func(*struct_sqlite3, int32) int32
	wal_checkpoint     func(*struct_sqlite3, *int8) int32
	wal_hook           func(*struct_sqlite3, func(unsafe.Pointer, *struct_sqlite3, *int8, int32) int32, unsafe.Pointer) unsafe.Pointer
	blob_reopen        func(*struct_sqlite3_blob, int64) int32
	vtab_config        func(*struct_sqlite3, int32, ...interface {
	}) int32
	vtab_on_conflict  func(*struct_sqlite3) int32
	close_v2          func(*struct_sqlite3) int32
	db_filename       func(*struct_sqlite3, *int8) *int8
	db_readonly       func(*struct_sqlite3, *int8) int32
	db_release_memory func(*struct_sqlite3) int32
	errstr            func(int32) *int8
	stmt_busy         func(*struct_sqlite3_stmt) int32
	stmt_readonly     func(*struct_sqlite3_stmt) int32
	stricmp           func(*int8, *int8) int32
	uri_boolean       func(*int8, *int8, int32) int32
	uri_int64         func(*int8, *int8, int64) int64
	uri_parameter     func(*int8, *int8) *int8
	xvsnprintf        func(int32, *int8, *int8, ...interface {
	}) *int8
	wal_checkpoint_v2     func(*struct_sqlite3, *int8, int32, *int32, *int32) int32
	auto_extension        func(func()) int32
	bind_blob64           func(*struct_sqlite3_stmt, int32, unsafe.Pointer, uint64, func(unsafe.Pointer)) int32
	bind_text64           func(*struct_sqlite3_stmt, int32, *int8, uint64, func(unsafe.Pointer), uint8) int32
	cancel_auto_extension func(func()) int32
	load_extension        func(*struct_sqlite3, *int8, *int8, **int8) int32
	malloc64              func(uint64) unsafe.Pointer
	msize                 func(unsafe.Pointer) uint64
	realloc64             func(unsafe.Pointer, uint64) unsafe.Pointer
	reset_auto_extension  func()
	result_blob64         func(*struct_sqlite3_context, unsafe.Pointer, uint64, func(unsafe.Pointer))
	result_text64         func(*struct_sqlite3_context, *int8, uint64, func(unsafe.Pointer), uint8)
	strglob               func(*int8, *int8) int32
	value_dup             func(*struct_sqlite3_value) *struct_sqlite3_value
	value_free            func(*struct_sqlite3_value)
	result_zeroblob64     func(*struct_sqlite3_context, uint64) int32
	bind_zeroblob64       func(*struct_sqlite3_stmt, int32, uint64) int32
	value_subtype         func(*struct_sqlite3_value) uint32
	result_subtype        func(*struct_sqlite3_context, uint32)
	status64              func(int32, *int64, *int64, int32) int32
	strlike               func(*int8, *int8, uint32) int32
	db_cacheflush         func(*struct_sqlite3) int32
	system_errno          func(*struct_sqlite3) int32
	trace_v2              func(*struct_sqlite3, uint32, func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32, unsafe.Pointer) int32
	expanded_sql          func(*struct_sqlite3_stmt) *int8
	set_last_insert_rowid func(*struct_sqlite3, int64)
	prepare_v3            func(*struct_sqlite3, *int8, int32, uint32, **struct_sqlite3_stmt, **int8) int32
	prepare16_v3          func(*struct_sqlite3, unsafe.Pointer, int32, uint32, **struct_sqlite3_stmt, *unsafe.Pointer) int32
	bind_pointer          func(*struct_sqlite3_stmt, int32, unsafe.Pointer, *int8, func(unsafe.Pointer)) int32
	result_pointer        func(*struct_sqlite3_context, unsafe.Pointer, *int8, func(unsafe.Pointer))
	value_pointer         func(*struct_sqlite3_value, *int8) unsafe.Pointer
	vtab_nochange         func(*struct_sqlite3_context) int32
	value_nochange        func(*struct_sqlite3_value) int32
	vtab_collation        func(*struct_sqlite3_index_info, int32) *int8
	keyword_count         func() int32
	keyword_name          func(int32, **int8, *int32) int32
	keyword_check         func(*int8, int32) int32
	str_new               func(*struct_sqlite3) *struct_sqlite3_str
	str_finish            func(*struct_sqlite3_str) *int8
	str_appendf           func(*struct_sqlite3_str, *int8, ...interface {
	})
	str_vappendf func(*struct_sqlite3_str, *int8, ...interface {
	})
	str_append             func(*struct_sqlite3_str, *int8, int32)
	str_appendall          func(*struct_sqlite3_str, *int8)
	str_appendchar         func(*struct_sqlite3_str, int32, int8)
	str_reset              func(*struct_sqlite3_str)
	str_errcode            func(*struct_sqlite3_str) int32
	str_length             func(*struct_sqlite3_str) int32
	str_value              func(*struct_sqlite3_str) *int8
	create_window_function func(*struct_sqlite3, *int8, int32, int32, unsafe.Pointer, func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(*struct_sqlite3_context), func(*struct_sqlite3_context), func(*struct_sqlite3_context, int32, **struct_sqlite3_value), func(unsafe.Pointer)) int32
	normalized_sql         func(*struct_sqlite3_stmt) *int8
	stmt_isexplain         func(*struct_sqlite3_stmt) int32
	value_frombind         func(*struct_sqlite3_value) int32
	drop_modules           func(*struct_sqlite3, **int8) int32
	hard_heap_limit64      func(int64) int64
	uri_key                func(*int8, int32) *int8
	filename_database      func(*int8) *int8
	filename_journal       func(*int8) *int8
	filename_wal           func(*int8) *int8
	create_filename        func(*int8, *int8, *int8, int32, **int8) *int8
	free_filename          func(*int8)
	database_file_object   func(*int8) *struct_sqlite3_file
	txn_state              func(*struct_sqlite3, *int8) int32
	changes64              func(*struct_sqlite3) int64
	total_changes64        func(*struct_sqlite3) int64
	autovacuum_pages       func(*struct_sqlite3, func(unsafe.Pointer, *int8, uint32, uint32, uint32) uint32, unsafe.Pointer, func(unsafe.Pointer)) int32
	error_offset           func(*struct_sqlite3) int32
	vtab_rhs_value         func(*struct_sqlite3_index_info, int32, **struct_sqlite3_value) int32
	vtab_distinct          func(*struct_sqlite3_index_info) int32
	vtab_in                func(*struct_sqlite3_index_info, int32, int32) int32
	vtab_in_first          func(*struct_sqlite3_value, **struct_sqlite3_value) int32
	vtab_in_next           func(*struct_sqlite3_value, **struct_sqlite3_value) int32
}
type sqlite3_loadext_entry = func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32

var sqlite3Apis struct_sqlite3_api_routines = struct_sqlite3_api_routines{sqlite3_aggregate_context, sqlite3_aggregate_count, sqlite3_bind_blob, sqlite3_bind_double, sqlite3_bind_int, sqlite3_bind_int64, sqlite3_bind_null, sqlite3_bind_parameter_count, sqlite3_bind_parameter_index, sqlite3_bind_parameter_name, sqlite3_bind_text, sqlite3_bind_text16, sqlite3_bind_value, sqlite3_busy_handler, sqlite3_busy_timeout, sqlite3_changes, sqlite3_close, sqlite3_collation_needed, sqlite3_collation_needed16, sqlite3_column_blob, sqlite3_column_bytes, sqlite3_column_bytes16, sqlite3_column_count, nil, nil, sqlite3_column_decltype, sqlite3_column_decltype16, sqlite3_column_double, sqlite3_column_int, sqlite3_column_int64, sqlite3_column_name, sqlite3_column_name16, nil, nil, nil, nil, sqlite3_column_text, sqlite3_column_text16, sqlite3_column_type, sqlite3_column_value, sqlite3_commit_hook, sqlite3_complete, sqlite3_complete16, sqlite3_create_collation, sqlite3_create_collation16, sqlite3_create_function, sqlite3_create_function16, sqlite3_create_module, sqlite3_data_count, sqlite3_db_handle, sqlite3_declare_vtab, sqlite3_enable_shared_cache, sqlite3_errcode, sqlite3_errmsg, sqlite3_errmsg16, sqlite3_exec, sqlite3_expired, sqlite3_finalize, sqlite3_free, sqlite3_free_table, sqlite3_get_autocommit, sqlite3_get_auxdata, sqlite3_get_table, nil, sqlite3_interrupt, sqlite3_last_insert_rowid, sqlite3_libversion, sqlite3_libversion_number, sqlite3_malloc, sqlite3_mprintf, sqlite3_open, sqlite3_open16, sqlite3_prepare, sqlite3_prepare16, sqlite3_profile, sqlite3_progress_handler, sqlite3_realloc, sqlite3_reset, sqlite3_result_blob, sqlite3_result_double, sqlite3_result_error, sqlite3_result_error16, sqlite3_result_int, sqlite3_result_int64, sqlite3_result_null, sqlite3_result_text, sqlite3_result_text16, sqlite3_result_text16be, sqlite3_result_text16le, sqlite3_result_value, sqlite3_rollback_hook, sqlite3_set_authorizer, sqlite3_set_auxdata, sqlite3_snprintf, sqlite3_step, sqlite3_table_column_metadata, sqlite3_thread_cleanup, sqlite3_total_changes, sqlite3_trace, sqlite3_transfer_bindings, sqlite3_update_hook, sqlite3_user_data, sqlite3_value_blob, sqlite3_value_bytes, sqlite3_value_bytes16, sqlite3_value_double, sqlite3_value_int, sqlite3_value_int64, sqlite3_value_numeric_type, sqlite3_value_text, sqlite3_value_text16, sqlite3_value_text16be, sqlite3_value_text16le, sqlite3_value_type, sqlite3_vmprintf, sqlite3_overload_function, sqlite3_prepare_v2, sqlite3_prepare16_v2, sqlite3_clear_bindings, sqlite3_create_module_v2, sqlite3_bind_zeroblob, sqlite3_blob_bytes, sqlite3_blob_close, sqlite3_blob_open, sqlite3_blob_read, sqlite3_blob_write, sqlite3_create_collation_v2, sqlite3_file_control, sqlite3_memory_highwater, sqlite3_memory_used, sqlite3_mutex_alloc, sqlite3_mutex_enter, sqlite3_mutex_free, sqlite3_mutex_leave, sqlite3_mutex_try, sqlite3_open_v2, sqlite3_release_memory, sqlite3_result_error_nomem, sqlite3_result_error_toobig, sqlite3_sleep, sqlite3_soft_heap_limit, sqlite3_vfs_find, sqlite3_vfs_register, sqlite3_vfs_unregister, sqlite3_threadsafe, sqlite3_result_zeroblob, sqlite3_result_error_code, sqlite3_test_control, sqlite3_randomness, sqlite3_context_db_handle, sqlite3_extended_result_codes, sqlite3_limit, sqlite3_next_stmt, sqlite3_sql, sqlite3_status, sqlite3_backup_finish, sqlite3_backup_init, sqlite3_backup_pagecount, sqlite3_backup_remaining, sqlite3_backup_step, sqlite3_compileoption_get, sqlite3_compileoption_used, sqlite3_create_function_v2, sqlite3_db_config, sqlite3_db_mutex, sqlite3_db_status, sqlite3_extended_errcode, sqlite3_log, sqlite3_soft_heap_limit64, sqlite3_sourceid, sqlite3_stmt_status, sqlite3_strnicmp, nil, sqlite3_wal_autocheckpoint, sqlite3_wal_checkpoint, sqlite3_wal_hook, sqlite3_blob_reopen, sqlite3_vtab_config, sqlite3_vtab_on_conflict, sqlite3_close_v2, sqlite3_db_filename, sqlite3_db_readonly, sqlite3_db_release_memory, sqlite3_errstr, sqlite3_stmt_busy, sqlite3_stmt_readonly, sqlite3_stricmp, sqlite3_uri_boolean, sqlite3_uri_int64, sqlite3_uri_parameter, sqlite3_vsnprintf, sqlite3_wal_checkpoint_v2, sqlite3_auto_extension, sqlite3_bind_blob64, sqlite3_bind_text64, sqlite3_cancel_auto_extension, sqlite3_load_extension, sqlite3_malloc64, sqlite3_msize, sqlite3_realloc64, sqlite3_reset_auto_extension, sqlite3_result_blob64, sqlite3_result_text64, sqlite3_strglob, (func(*struct_sqlite3_value) *struct_sqlite3_value)(sqlite3_value_dup), sqlite3_value_free, sqlite3_result_zeroblob64, sqlite3_bind_zeroblob64, sqlite3_value_subtype, sqlite3_result_subtype, sqlite3_status64, sqlite3_strlike, sqlite3_db_cacheflush, sqlite3_system_errno, sqlite3_trace_v2, sqlite3_expanded_sql, sqlite3_set_last_insert_rowid, sqlite3_prepare_v3, sqlite3_prepare16_v3, sqlite3_bind_pointer, sqlite3_result_pointer, sqlite3_value_pointer, sqlite3_vtab_nochange, sqlite3_value_nochange, sqlite3_vtab_collation, sqlite3_keyword_count, sqlite3_keyword_name, sqlite3_keyword_check, sqlite3_str_new, sqlite3_str_finish, sqlite3_str_appendf, sqlite3_str_vappendf, sqlite3_str_append, sqlite3_str_appendall, sqlite3_str_appendchar, sqlite3_str_reset, sqlite3_str_errcode, sqlite3_str_length, sqlite3_str_value, sqlite3_create_window_function, nil, sqlite3_stmt_isexplain, sqlite3_value_frombind, sqlite3_drop_modules, sqlite3_hard_heap_limit64, sqlite3_uri_key, sqlite3_filename_database, sqlite3_filename_journal, sqlite3_filename_wal, sqlite3_create_filename, sqlite3_free_filename, sqlite3_database_file_object, sqlite3_txn_state, sqlite3_changes64, sqlite3_total_changes64, sqlite3_autovacuum_pages, sqlite3_error_offset, sqlite3_vtab_rhs_value, sqlite3_vtab_distinct, sqlite3_vtab_in, sqlite3_vtab_in_first, sqlite3_vtab_in_next}

func sqlite3LoadExtension(db *struct_sqlite3, zFile *int8, zProc *int8, pzErrMsg **int8) int32 {
	var pVfs *struct_sqlite3_vfs = db.pVfs
	var handle unsafe.Pointer
	var xInit func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32
	var zErrmsg *int8 = nil
	var zEntry *int8
	var zAltEntry *int8 = nil
	var aHandle *unsafe.Pointer
	var nMsg uint64 = uint64(strlen(zFile))
	var ii int32
	var rc int32
	var azEndings [1]*int8 = [1]*int8{(*int8)(unsafe.Pointer(&[6]int8{'d', 'y', 'l', 'i', 'b', '\x00'}))}
	if pzErrMsg != nil {
		*pzErrMsg = (*int8)(nil)
	}
	if db.flags&uint64(65536) == uint64(0) {
		if pzErrMsg != nil {
			*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[15]int8{'n', 'o', 't', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'e', 'd', '\x00'})))
		}
		return int32(1)
	}
	zEntry = func() *int8 {
		if zProc != nil {
			return zProc
		} else {
			return (*int8)(unsafe.Pointer((*int8)(unsafe.Pointer(&[23]int8{'s', 'q', 'l', 'i', 't', 'e', '3', '_', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', '_', 'i', 'n', 'i', 't', '\x00'}))))
		}
	}()
	if nMsg > uint64(1024) {
		goto extension_not_found
	}
	handle = sqlite3OsDlOpen(pVfs, zFile)
	for ii = int32(0); ii < int32(8/8) && uintptr(unsafe.Pointer(handle)) == uintptr(unsafe.Pointer(nil)); ii++ {
		var zAltFile *int8 = sqlite3_mprintf((*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 's', '\x00'})), zFile, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azEndings)))) + uintptr(ii)*8)))
		if uintptr(unsafe.Pointer(zAltFile)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		handle = sqlite3OsDlOpen(pVfs, zAltFile)
		sqlite3_free(unsafe.Pointer(zAltFile))
	}
	if uintptr(unsafe.Pointer(handle)) == uintptr(unsafe.Pointer(nil)) {
		goto extension_not_found
	}
	xInit = (func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32)(sqlite3OsDlSym(pVfs, handle, zEntry))
	if uintptr(unsafe.Pointer(xInit)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(zProc)) == uintptr(unsafe.Pointer(nil)) {
		var iFile int32
		var iEntry int32
		var c int32
		var ncFile int32 = sqlite3Strlen30(zFile)
		zAltEntry = (*int8)(sqlite3_malloc64(uint64(ncFile + 30)))
		if uintptr(unsafe.Pointer(zAltEntry)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3OsDlClose(pVfs, handle)
			return int32(7)
		}
		__builtin___memcpy_chk(unsafe.Pointer(zAltEntry), unsafe.Pointer((*int8)(unsafe.Pointer(&[9]int8{'s', 'q', 'l', 'i', 't', 'e', '3', '_', '\x00'}))), uint(8), __builtin_object_size(unsafe.Pointer(zAltEntry), 0))
		for iFile = ncFile - 1; iFile >= 0 && !(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(iFile)))) == '/'); iFile-- {
		}
		iFile++
		if sqlite3_strnicmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile))+uintptr(iFile))), (*int8)(unsafe.Pointer(&[4]int8{'l', 'i', 'b', '\x00'})), 3) == 0 {
			iFile += int32(3)
		}
		for iEntry = int32(8); func() (_cgo_ret int32) {
			_cgo_addr := &c
			*_cgo_addr = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(iFile))))
			return *_cgo_addr
		}() != 0 && c != '.'; iFile++ {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(c)))))&2 != 0 {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAltEntry)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &iEntry
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()))) = int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint32(c)))))
			}
		}
		__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAltEntry))+uintptr(iEntry)))), unsafe.Pointer((*int8)(unsafe.Pointer(&[6]int8{'_', 'i', 'n', 'i', 't', '\x00'}))), uint(6), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAltEntry))+uintptr(iEntry)))), 0))
		zEntry = zAltEntry
		xInit = (func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32)(sqlite3OsDlSym(pVfs, handle, zEntry))
	}
	if uintptr(unsafe.Pointer(xInit)) == uintptr(unsafe.Pointer(nil)) {
		if pzErrMsg != nil {
			nMsg += uint64(strlen(zEntry) + uint(300))
			*pzErrMsg = func() (_cgo_ret *int8) {
				_cgo_addr := &zErrmsg
				*_cgo_addr = (*int8)(sqlite3_malloc64(nMsg))
				return *_cgo_addr
			}()
			if zErrmsg != nil {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3_snprintf(int32(nMsg), zErrmsg, (*int8)(unsafe.Pointer(&[43]int8{'n', 'o', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'p', 'o', 'i', 'n', 't', ' ', '[', '%', 's', ']', ' ', 'i', 'n', ' ', 's', 'h', 'a', 'r', 'e', 'd', ' ', 'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ', '[', '%', 's', ']', '\x00'})), zEntry, zFile)
				sqlite3OsDlError(pVfs, int32(nMsg-uint64(1)), zErrmsg)
			}
		}
		sqlite3OsDlClose(pVfs, handle)
		sqlite3_free(unsafe.Pointer(zAltEntry))
		return int32(1)
	}
	sqlite3_free(unsafe.Pointer(zAltEntry))
	rc = xInit(db, &zErrmsg, &sqlite3Apis)
	if rc != 0 {
		if rc == 0|1<<8 {
			return int32(0)
		}
		if pzErrMsg != nil {
			*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[32]int8{'e', 'r', 'r', 'o', 'r', ' ', 'd', 'u', 'r', 'i', 'n', 'g', ' ', 'i', 'n', 'i', 't', 'i', 'a', 'l', 'i', 'z', 'a', 't', 'i', 'o', 'n', ':', ' ', '%', 's', '\x00'})), zErrmsg)
		}
		sqlite3_free(unsafe.Pointer(zErrmsg))
		sqlite3OsDlClose(pVfs, handle)
		return int32(1)
	}
	aHandle = (*unsafe.Pointer)(sqlite3DbMallocZero(db, uint64(8*uint(db.nExtension+1))))
	if uintptr(unsafe.Pointer(aHandle)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	if db.nExtension > 0 {
		__builtin___memcpy_chk(unsafe.Pointer(aHandle), unsafe.Pointer(db.aExtension), 8*uint(db.nExtension), __builtin_object_size(unsafe.Pointer(aHandle), 0))
	}
	sqlite3DbFree(db, unsafe.Pointer(db.aExtension))
	db.aExtension = aHandle
	*(*unsafe.Pointer)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aExtension)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &db.nExtension
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*8)) = handle
	return int32(0)
extension_not_found:
	if pzErrMsg != nil {
		nMsg += uint64(300)
		*pzErrMsg = func() (_cgo_ret *int8) {
			_cgo_addr := &zErrmsg
			*_cgo_addr = (*int8)(sqlite3_malloc64(nMsg))
			return *_cgo_addr
		}()
		if zErrmsg != nil {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_snprintf(int32(nMsg), zErrmsg, (*int8)(unsafe.Pointer(&[37]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'o', 'p', 'e', 'n', ' ', 's', 'h', 'a', 'r', 'e', 'd', ' ', 'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ', '[', '%', '.', '*', 's', ']', '\x00'})), 1024, zFile)
			sqlite3OsDlError(pVfs, int32(nMsg-uint64(1)), zErrmsg)
		}
	}
	return int32(1)
}
func sqlite3_load_extension(db *struct_sqlite3, zFile *int8, zProc *int8, pzErrMsg **int8) int32 {
	var rc int32
	sqlite3_mutex_enter(db.mutex)
	rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg)
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3CloseExtensions(db *struct_sqlite3) {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nExtension; i++ {
		sqlite3OsDlClose(db.pVfs, *(*unsafe.Pointer)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aExtension)) + uintptr(i)*8)))
	}
	sqlite3DbFree(db, unsafe.Pointer(db.aExtension))
}
func sqlite3_enable_load_extension(db *struct_sqlite3, onoff int32) int32 {
	sqlite3_mutex_enter(db.mutex)
	if onoff != 0 {
		db.flags |= uint64(65536 | 131072)
	} else {
		db.flags &= ^uint64(65536 | 131072)
	}
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}

type sqlite3AutoExtList = struct_sqlite3AutoExtList
type struct_sqlite3AutoExtList struct {
	nExt uint32
	aExt *func()
}

var sqlite3Autoext struct_sqlite3AutoExtList = struct_sqlite3AutoExtList{uint32(0), nil}

func sqlite3_auto_extension(xInit func()) int32 {
	var rc int32 = 0
	rc = sqlite3_initialize()
	if rc != 0 {
		return rc
	} else {
		var i uint32
		var mutex *struct_sqlite3_mutex = sqlite3MutexAlloc(2)
		sqlite3_mutex_enter(mutex)
		for i = uint32(0); i < sqlite3Autoext.nExt; i++ {
			if uintptr(unsafe.Pointer(*(*func())(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3Autoext.aExt)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(xInit)) {
				break
			}
		}
		if i == sqlite3Autoext.nExt {
			var nByte uint64 = uint64(uint(sqlite3Autoext.nExt+uint32(1)) * 8)
			var aNew *func()
			aNew = (*func())(sqlite3_realloc64(unsafe.Pointer(sqlite3Autoext.aExt), nByte))
			if uintptr(unsafe.Pointer(aNew)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(7)
			} else {
				sqlite3Autoext.aExt = aNew
				*(*func())(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3Autoext.aExt)) + uintptr(sqlite3Autoext.nExt)*8)) = xInit
				sqlite3Autoext.nExt++
			}
		}
		sqlite3_mutex_leave(mutex)
		func() int {
			_ = 0
			return 0
		}()
		return rc
	}
}
func sqlite3_cancel_auto_extension(xInit func()) int32 {
	var mutex *struct_sqlite3_mutex = sqlite3MutexAlloc(2)
	var i int32
	var n int32 = 0
	sqlite3_mutex_enter(mutex)
	for i = int32(sqlite3Autoext.nExt) - 1; i >= 0; i-- {
		if uintptr(unsafe.Pointer(*(*func())(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3Autoext.aExt)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(xInit)) {
			sqlite3Autoext.nExt--
			*(*func())(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3Autoext.aExt)) + uintptr(i)*8)) = *(*func())(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3Autoext.aExt)) + uintptr(sqlite3Autoext.nExt)*8))
			n++
			break
		}
	}
	sqlite3_mutex_leave(mutex)
	return n
}
func sqlite3_reset_auto_extension() {
	if sqlite3_initialize() == 0 {
		var mutex *struct_sqlite3_mutex = sqlite3MutexAlloc(2)
		sqlite3_mutex_enter(mutex)
		sqlite3_free(unsafe.Pointer(sqlite3Autoext.aExt))
		sqlite3Autoext.aExt = (*func())(nil)
		sqlite3Autoext.nExt = uint32(0)
		sqlite3_mutex_leave(mutex)
	}
}
func sqlite3AutoLoadExtensions(db *struct_sqlite3) {
	var i uint32
	var go_ int32 = 1
	var rc int32
	var xInit func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32
	if sqlite3Autoext.nExt == uint32(0) {
		return
	}
	for i = uint32(0); go_ != 0; i++ {
		var zErrmsg *int8
		var mutex *struct_sqlite3_mutex = sqlite3MutexAlloc(2)
		var pThunk *struct_sqlite3_api_routines = &sqlite3Apis
		sqlite3_mutex_enter(mutex)
		if i >= sqlite3Autoext.nExt {
			xInit = (func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32)(nil)
			go_ = int32(0)
		} else {
			xInit = (func(*struct_sqlite3, **int8, *struct_sqlite3_api_routines) int32)(*(*func())(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3Autoext.aExt)) + uintptr(i)*8)))
		}
		sqlite3_mutex_leave(mutex)
		zErrmsg = (*int8)(nil)
		if xInit != nil && func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = xInit(db, &zErrmsg, pThunk)
			return *_cgo_addr
		}() != 0 {
			sqlite3ErrorWithMsg(db, rc, (*int8)(unsafe.Pointer(&[39]int8{'a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', ' ', 'e', 'x', 't', 'e', 'n', 's', 'i', 'o', 'n', ' ', 'l', 'o', 'a', 'd', 'i', 'n', 'g', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ':', ' ', '%', 's', '\x00'})), zErrmsg)
			go_ = int32(0)
		}
		sqlite3_free(unsafe.Pointer(zErrmsg))
	}
}

var pragCName [57]*int8 = [57]*int8{(*int8)(unsafe.Pointer(&[3]int8{'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'s', 'e', 'q', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'f', 'r', 'o', 'm', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'t', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'o', 'n', '_', 'u', 'p', 'd', 'a', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[10]int8{'o', 'n', '_', 'd', 'e', 'l', 'e', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'m', 'a', 't', 'c', 'h', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'c', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'y', 'p', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'n', 'o', 't', 'n', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'d', 'f', 'l', 't', '_', 'v', 'a', 'l', 'u', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', 'k', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'h', 'i', 'd', 'd', 'e', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'s', 'c', 'h', 'e', 'm', 'a', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'y', 'p', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'c', 'o', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'w', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'s', 't', 'r', 'i', 'c', 't', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'s', 'e', 'q', 'n', 'o', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'c', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'d', 'e', 's', 'c', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'c', 'o', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'k', 'e', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'b', 'u', 'i', 'l', 't', 'i', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'y', 'p', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'e', 'n', 'c', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'r', 'g', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'f', 'l', 'a', 'g', 's', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'t', 'b', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'i', 'd', 'x', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'w', 'd', 't', 'h', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'h', 'g', 'h', 't', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'f', 'l', 'g', 's', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'s', 'e', 'q', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'u', 'n', 'i', 'q', 'u', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'o', 'r', 'i', 'g', 'i', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'p', 'a', 'r', 't', 'i', 'a', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'w', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'p', 'a', 'r', 'e', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'f', 'k', 'i', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'s', 'e', 'q', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'f', 'i', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'b', 'u', 's', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'l', 'o', 'g', '\x00'})), (*int8)(unsafe.Pointer(&[13]int8{'c', 'h', 'e', 'c', 'k', 'p', 'o', 'i', 'n', 't', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'s', 't', 'a', 't', 'u', 's', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'c', 'a', 'c', 'h', 'e', '_', 's', 'i', 'z', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'t', 'i', 'm', 'e', 'o', 'u', 't', '\x00'}))}

type struct_PragmaName struct {
	zName      *int8
	ePragTyp   uint8
	mPragFlg   uint8
	iPragCName uint8
	nPragCName uint8
	iArg       uint64
}
type PragmaName = struct_PragmaName

var aPragmaName [67]struct_PragmaName = [67]struct_PragmaName{struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'a', 'n', 'a', 'l', 'y', 's', 'i', 's', '_', 'l', 'i', 'm', 'i', 't', '\x00'})), uint8(1), uint8(16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'a', 'p', 'p', 'l', 'i', 'c', 'a', 't', 'i', 'o', 'n', '_', 'i', 'd', '\x00'})), uint8(2), uint8(4 | 16), uint8(0), uint8(0), uint64(8)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'a', 'u', 't', 'o', '_', 'v', 'a', 'c', 'u', 'u', 'm', '\x00'})), uint8(3), uint8(1 | 16 | 128 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', '_', 'i', 'n', 'd', 'e', 'x', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(32768)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[13]int8{'b', 'u', 's', 'y', '_', 't', 'i', 'm', 'e', 'o', 'u', 't', '\x00'})), uint8(5), uint8(16), uint8(56), uint8(1), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'c', 'a', 'c', 'h', 'e', '_', 's', 'i', 'z', 'e', '\x00'})), uint8(6), uint8(1 | 16 | 128 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'c', 'a', 'c', 'h', 'e', '_', 's', 'p', 'i', 'l', 'l', '\x00'})), uint8(7), uint8(16 | 128 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[20]int8{'c', 'a', 's', 'e', '_', 's', 'e', 'n', 's', 'i', 't', 'i', 'v', 'e', '_', 'l', 'i', 'k', 'e', '\x00'})), uint8(8), uint8(2), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'c', 'e', 'l', 'l', '_', 's', 'i', 'z', 'e', '_', 'c', 'h', 'e', 'c', 'k', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(2097152)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[21]int8{'c', 'h', 'e', 'c', 'k', 'p', 'o', 'i', 'n', 't', '_', 'f', 'u', 'l', 'l', 'f', 's', 'y', 'n', 'c', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(16)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'c', 'o', 'l', 'l', 'a', 't', 'i', 'o', 'n', '_', 'l', 'i', 's', 't', '\x00'})), uint8(9), uint8(16), uint8(38), uint8(2), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'c', 'o', 'm', 'p', 'i', 'l', 'e', '_', 'o', 'p', 't', 'i', 'o', 'n', 's', '\x00'})), uint8(10), uint8(16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[14]int8{'c', 'o', 'u', 'n', 't', '_', 'c', 'h', 'a', 'n', 'g', 'e', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(1) << 32}, struct_PragmaName{(*int8)(unsafe.Pointer(&[13]int8{'d', 'a', 't', 'a', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '\x00'})), uint8(2), uint8(8 | 16), uint8(0), uint8(0), uint64(15)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[14]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', '_', 'l', 'i', 's', 't', '\x00'})), uint8(12), uint8(1 | 16), uint8(47), uint8(3), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'d', 'e', 'f', 'a', 'u', 'l', 't', '_', 'c', 'a', 'c', 'h', 'e', '_', 's', 'i', 'z', 'e', '\x00'})), uint8(13), uint8(1 | 16 | 128 | 4), uint8(55), uint8(1), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'d', 'e', 'f', 'e', 'r', '_', 'f', 'o', 'r', 'e', 'i', 'g', 'n', '_', 'k', 'e', 'y', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(524288)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[23]int8{'e', 'm', 'p', 't', 'y', '_', 'r', 'e', 's', 'u', 'l', 't', '_', 'c', 'a', 'l', 'l', 'b', 'a', 'c', 'k', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(256)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[9]int8{'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', '\x00'})), uint8(14), uint8(16 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[18]int8{'f', 'o', 'r', 'e', 'i', 'g', 'n', '_', 'k', 'e', 'y', '_', 'c', 'h', 'e', 'c', 'k', '\x00'})), uint8(15), uint8(1 | 16 | 32 | 64), uint8(43), uint8(4), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[17]int8{'f', 'o', 'r', 'e', 'i', 'g', 'n', '_', 'k', 'e', 'y', '_', 'l', 'i', 's', 't', '\x00'})), uint8(16), uint8(1 | 32 | 64), uint8(0), uint8(8), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[13]int8{'f', 'o', 'r', 'e', 'i', 'g', 'n', '_', 'k', 'e', 'y', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(16384)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'f', 'r', 'e', 'e', 'l', 'i', 's', 't', '_', 'c', 'o', 'u', 'n', 't', '\x00'})), uint8(2), uint8(8 | 16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[18]int8{'f', 'u', 'l', 'l', '_', 'c', 'o', 'l', 'u', 'm', 'n', '_', 'n', 'a', 'm', 'e', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(4)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[10]int8{'f', 'u', 'l', 'l', 'f', 's', 'y', 'n', 'c', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(8)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[14]int8{'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', '_', 'l', 'i', 's', 't', '\x00'})), uint8(17), uint8(16), uint8(27), uint8(6), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'h', 'a', 'r', 'd', '_', 'h', 'e', 'a', 'p', '_', 'l', 'i', 'm', 'i', 't', '\x00'})), uint8(18), uint8(16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[25]int8{'i', 'g', 'n', 'o', 'r', 'e', '_', 'c', 'h', 'e', 'c', 'k', '_', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(512)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'i', 'n', 'c', 'r', 'e', 'm', 'e', 'n', 't', 'a', 'l', '_', 'v', 'a', 'c', 'u', 'u', 'm', '\x00'})), uint8(19), uint8(1 | 2), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'i', 'n', 'd', 'e', 'x', '_', 'i', 'n', 'f', 'o', '\x00'})), uint8(20), uint8(1 | 32 | 64), uint8(21), uint8(3), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'i', 'n', 'd', 'e', 'x', '_', 'l', 'i', 's', 't', '\x00'})), uint8(21), uint8(1 | 32 | 64), uint8(38), uint8(5), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'i', 'n', 'd', 'e', 'x', '_', 'x', 'i', 'n', 'f', 'o', '\x00'})), uint8(20), uint8(1 | 32 | 64), uint8(21), uint8(6), uint64(1)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'i', 'n', 't', 'e', 'g', 'r', 'i', 't', 'y', '_', 'c', 'h', 'e', 'c', 'k', '\x00'})), uint8(22), uint8(1 | 16 | 32 | 64), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[13]int8{'j', 'o', 'u', 'r', 'n', 'a', 'l', '_', 'm', 'o', 'd', 'e', '\x00'})), uint8(23), uint8(1 | 16 | 128), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'j', 'o', 'u', 'r', 'n', 'a', 'l', '_', 's', 'i', 'z', 'e', '_', 'l', 'i', 'm', 'i', 't', '\x00'})), uint8(24), uint8(16 | 128), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'l', 'e', 'g', 'a', 'c', 'y', '_', 'a', 'l', 't', 'e', 'r', '_', 't', 'a', 'b', 'l', 'e', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(67108864)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'l', 'o', 'c', 'k', '_', 'p', 'r', 'o', 'x', 'y', '_', 'f', 'i', 'l', 'e', '\x00'})), uint8(25), uint8(4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[13]int8{'l', 'o', 'c', 'k', 'i', 'n', 'g', '_', 'm', 'o', 'd', 'e', '\x00'})), uint8(26), uint8(16 | 128), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'m', 'a', 'x', '_', 'p', 'a', 'g', 'e', '_', 'c', 'o', 'u', 'n', 't', '\x00'})), uint8(27), uint8(1 | 16 | 128), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[10]int8{'m', 'm', 'a', 'p', '_', 's', 'i', 'z', 'e', '\x00'})), uint8(28), uint8(0), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'m', 'o', 'd', 'u', 'l', 'e', '_', 'l', 'i', 's', 't', '\x00'})), uint8(29), uint8(16), uint8(9), uint8(1), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[9]int8{'o', 'p', 't', 'i', 'm', 'i', 'z', 'e', '\x00'})), uint8(30), uint8(32 | 1), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'p', 'a', 'g', 'e', '_', 'c', 'o', 'u', 'n', 't', '\x00'})), uint8(27), uint8(1 | 16 | 128), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[10]int8{'p', 'a', 'g', 'e', '_', 's', 'i', 'z', 'e', '\x00'})), uint8(31), uint8(16 | 128 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'p', 'r', 'a', 'g', 'm', 'a', '_', 'l', 'i', 's', 't', '\x00'})), uint8(32), uint8(16), uint8(9), uint8(1), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'q', 'u', 'e', 'r', 'y', '_', 'o', 'n', 'l', 'y', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(1048576)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'q', 'u', 'i', 'c', 'k', '_', 'c', 'h', 'e', 'c', 'k', '\x00'})), uint8(22), uint8(1 | 16 | 32 | 64), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[17]int8{'r', 'e', 'a', 'd', '_', 'u', 'n', 'c', 'o', 'm', 'm', 'i', 't', 't', 'e', 'd', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(1024)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', '_', 't', 'r', 'i', 'g', 'g', 'e', 'r', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(8192)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[26]int8{'r', 'e', 'v', 'e', 'r', 's', 'e', '_', 'u', 'n', 'o', 'r', 'd', 'e', 'r', 'e', 'd', '_', 's', 'e', 'l', 'e', 'c', 't', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(4096)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'s', 'c', 'h', 'e', 'm', 'a', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '\x00'})), uint8(2), uint8(4 | 16), uint8(0), uint8(0), uint64(1)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[14]int8{'s', 'e', 'c', 'u', 'r', 'e', '_', 'd', 'e', 'l', 'e', 't', 'e', '\x00'})), uint8(33), uint8(16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'s', 'h', 'o', 'r', 't', '_', 'c', 'o', 'l', 'u', 'm', 'n', '_', 'n', 'a', 'm', 'e', 's', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(64)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[14]int8{'s', 'h', 'r', 'i', 'n', 'k', '_', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})), uint8(34), uint8(2), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'s', 'o', 'f', 't', '_', 'h', 'e', 'a', 'p', '_', 'l', 'i', 'm', 'i', 't', '\x00'})), uint8(35), uint8(16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'s', 'y', 'n', 'c', 'h', 'r', 'o', 'n', 'o', 'u', 's', '\x00'})), uint8(36), uint8(1 | 16 | 128 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'t', 'a', 'b', 'l', 'e', '_', 'i', 'n', 'f', 'o', '\x00'})), uint8(37), uint8(1 | 32 | 64), uint8(8), uint8(6), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'t', 'a', 'b', 'l', 'e', '_', 'l', 'i', 's', 't', '\x00'})), uint8(38), uint8(1 | 32), uint8(15), uint8(6), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[12]int8{'t', 'a', 'b', 'l', 'e', '_', 'x', 'i', 'n', 'f', 'o', '\x00'})), uint8(37), uint8(1 | 32 | 64), uint8(8), uint8(7), uint64(1)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[11]int8{'t', 'e', 'm', 'p', '_', 's', 't', 'o', 'r', 'e', '\x00'})), uint8(39), uint8(16 | 4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[21]int8{'t', 'e', 'm', 'p', '_', 's', 't', 'o', 'r', 'e', '_', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '\x00'})), uint8(40), uint8(4), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[8]int8{'t', 'h', 'r', 'e', 'a', 'd', 's', '\x00'})), uint8(41), uint8(16), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'t', 'r', 'u', 's', 't', 'e', 'd', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(128)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[13]int8{'u', 's', 'e', 'r', '_', 'v', 'e', 'r', 's', 'i', 'o', 'n', '\x00'})), uint8(2), uint8(4 | 16), uint8(0), uint8(0), uint64(6)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[19]int8{'w', 'a', 'l', '_', 'a', 'u', 't', 'o', 'c', 'h', 'e', 'c', 'k', 'p', 'o', 'i', 'n', 't', '\x00'})), uint8(42), uint8(0), uint8(0), uint8(0), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[15]int8{'w', 'a', 'l', '_', 'c', 'h', 'e', 'c', 'k', 'p', 'o', 'i', 'n', 't', '\x00'})), uint8(43), uint8(1), uint8(50), uint8(3), uint64(0)}, struct_PragmaName{(*int8)(unsafe.Pointer(&[16]int8{'w', 'r', 'i', 't', 'a', 'b', 'l', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', '\x00'})), uint8(4), uint8(16 | 4), uint8(0), uint8(0), uint64(1 | 134217728)}}

func getSafetyLevel(z *int8, omitFull int32, dflt uint8) uint8 {
	var zText [25]int8 = [25]int8{'o', 'n', 'o', 'f', 'f', 'a', 'l', 's', 'e', 'y', 'e', 's', 't', 'r', 'u', 'e', 'x', 't', 'r', 'a', 'f', 'u', 'l', 'l', '\x00'}
	var iOffset [8]uint8 = [8]uint8{uint8(0), uint8(1), uint8(2), uint8(4), uint8(9), uint8(12), uint8(15), uint8(20)}
	var iLength [8]uint8 = [8]uint8{uint8(2), uint8(2), uint8(3), uint8(5), uint8(3), uint8(4), uint8(5), uint8(4)}
	var iValue [8]uint8 = [8]uint8{uint8(1), uint8(0), uint8(0), uint8(0), uint8(1), uint8(1), uint8(3), uint8(2)}
	var i int32
	var n int32
	if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*z)))))&4 != 0 {
		return uint8(sqlite3Atoi(z))
	}
	n = sqlite3Strlen30(z)
	for i = int32(0); i < int32(8/1); i++ {
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&iLength)))) + uintptr(i)))) == n && sqlite3_strnicmp(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zText)))) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&iOffset)))) + uintptr(i)))))), z, n) == 0 && (!(omitFull != 0) || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&iValue)))) + uintptr(i)))) <= 1) {
			return *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&iValue)))) + uintptr(i)))
		}
	}
	return dflt
}
func sqlite3GetBoolean(z *int8, dflt uint8) uint8 {
	return func() uint8 {
		if int32(getSafetyLevel(z, 1, dflt)) != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func getLockingMode(z *int8) int32 {
	if z != nil {
		if 0 == sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[10]int8{'e', 'x', 'c', 'l', 'u', 's', 'i', 'v', 'e', '\x00'}))) {
			return int32(1)
		}
		if 0 == sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[7]int8{'n', 'o', 'r', 'm', 'a', 'l', '\x00'}))) {
			return int32(0)
		}
	}
	return int32(-1)
}
func getAutoVacuum(z *int8) int32 {
	var i int32
	if 0 == sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[5]int8{'n', 'o', 'n', 'e', '\x00'}))) {
		return int32(0)
	}
	if 0 == sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[5]int8{'f', 'u', 'l', 'l', '\x00'}))) {
		return int32(1)
	}
	if 0 == sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[12]int8{'i', 'n', 'c', 'r', 'e', 'm', 'e', 'n', 't', 'a', 'l', '\x00'}))) {
		return int32(2)
	}
	i = sqlite3Atoi(z)
	return int32(uint8(func() int32 {
		if i >= 0 && i <= 2 {
			return i
		} else {
			return 0
		}
	}()))
}
func getTempStore(z *int8) int32 {
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) >= '0' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) <= '2' {
		return int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) - '0'
	} else if sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[5]int8{'f', 'i', 'l', 'e', '\x00'}))) == 0 {
		return int32(1)
	} else if sqlite3StrICmp(z, (*int8)(unsafe.Pointer(&[7]int8{'m', 'e', 'm', 'o', 'r', 'y', '\x00'}))) == 0 {
		return int32(2)
	} else {
		return int32(0)
	}
}
func invalidateTempStorage(pParse *struct_Parse) int32 {
	var db *struct_sqlite3 = pParse.db
	if uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pBt)) != uintptr(unsafe.Pointer(nil)) {
		if !(db.autoCommit != 0) || sqlite3BtreeTxnState((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pBt) != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[62]int8{'t', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', ' ', 's', 't', 'o', 'r', 'a', 'g', 'e', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', ' ', 'f', 'r', 'o', 'm', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'a', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '\x00'})))
			return int32(1)
		}
		sqlite3BtreeClose((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pBt)
		(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pBt = (*struct_Btree)(nil)
		sqlite3ResetAllSchemasOfConnection(db)
	}
	return int32(0)
}
func changeTempStorage(pParse *struct_Parse, zStorageType *int8) int32 {
	var ts int32 = getTempStore(zStorageType)
	var db *struct_sqlite3 = pParse.db
	if int32(db.temp_store) == ts {
		return int32(0)
	}
	if invalidateTempStorage(pParse) != 0 {
		return int32(1)
	}
	db.temp_store = uint8(ts)
	return int32(0)
}
func setPragmaResultColumnNames(v *struct_Vdbe, pPragma *struct_PragmaName) {
	var n uint8 = pPragma.nPragCName
	sqlite3VdbeSetNumCols(v, func() int32 {
		if int32(n) == 0 {
			return 1
		} else {
			return int32(n)
		}
	}())
	if int32(n) == 0 {
		sqlite3VdbeSetColName(v, 0, 0, pPragma.zName, (func(unsafe.Pointer))(0))
	} else {
		var i int32
		var j int32
		for func() int32 {
			i = int32(0)
			return func() (_cgo_ret int32) {
				_cgo_addr := &j
				*_cgo_addr = int32(pPragma.iPragCName)
				return *_cgo_addr
			}()
		}(); i < int32(n); func() int32 {
			i++
			return func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
		}() {
			sqlite3VdbeSetColName(v, i, 0, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pragCName)))) + uintptr(j)*8)), (func(unsafe.Pointer))(0))
		}
	}
}
func returnSingleInt(v *struct_Vdbe, value int64) {
	sqlite3VdbeAddOp4Dup8(v, 72, 0, 1, 0, (*uint8)(unsafe.Pointer(&value)), -14)
	sqlite3VdbeAddOp2(v, 83, 1, 1)
}
func returnSingleText(v *struct_Vdbe, zValue *int8) {
	if zValue != nil {
		sqlite3VdbeLoadString(v, 1, (*int8)(unsafe.Pointer(zValue)))
		sqlite3VdbeAddOp2(v, 83, 1, 1)
	}
}
func setAllPagerFlags(db *struct_sqlite3) {
	if db.autoCommit != 0 {
		var pDb *struct_Db = db.aDb
		var n int32 = db.nDb
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		for func() (_cgo_ret int32) {
			_cgo_addr := &n
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}() > 0 {
			if pDb.pBt != nil {
				sqlite3BtreeSetPagerFlags(pDb.pBt, uint32(uint64(pDb.safety_level)|db.flags&uint64(56)))
			}
			*(*uintptr)(unsafe.Pointer(&pDb)) += 32
		}
	}
}
func actionName(action uint8) *int8 {
	var zName *int8
	switch int32(action) {
	case 8:
		zName = (*int8)(unsafe.Pointer(&[9]int8{'S', 'E', 'T', ' ', 'N', 'U', 'L', 'L', '\x00'}))
		break
	case 9:
		zName = (*int8)(unsafe.Pointer(&[12]int8{'S', 'E', 'T', ' ', 'D', 'E', 'F', 'A', 'U', 'L', 'T', '\x00'}))
		break
	case 10:
		zName = (*int8)(unsafe.Pointer(&[8]int8{'C', 'A', 'S', 'C', 'A', 'D', 'E', '\x00'}))
		break
	case 7:
		zName = (*int8)(unsafe.Pointer(&[9]int8{'R', 'E', 'S', 'T', 'R', 'I', 'C', 'T', '\x00'}))
		break
	default:
		zName = (*int8)(unsafe.Pointer(&[10]int8{'N', 'O', ' ', 'A', 'C', 'T', 'I', 'O', 'N', '\x00'}))
		func() int {
			_ = 0
			return 0
		}()
		break
	}
	return zName
}
func sqlite3JournalModename(eMode int32) *int8 {
	var azModeName [6]*int8 = [6]*int8{(*int8)(unsafe.Pointer(&[7]int8{'d', 'e', 'l', 'e', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'p', 'e', 'r', 's', 'i', 's', 't', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'o', 'f', 'f', '\x00'})), (*int8)(unsafe.Pointer(&[9]int8{'t', 'r', 'u', 'n', 'c', 'a', 't', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'m', 'e', 'm', 'o', 'r', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[4]int8{'w', 'a', 'l', '\x00'}))}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if eMode == int32(48/8) {
		return (*int8)(nil)
	}
	return *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azModeName)))) + uintptr(eMode)*8))
}
func pragmaLocate(zName *int8) *struct_PragmaName {
	var upr int32
	var lwr int32
	var mid int32 = 0
	var rc int32
	lwr = int32(0)
	upr = int32(1608/24) - 1
	for lwr <= upr {
		mid = (lwr + upr) / 2
		rc = sqlite3_stricmp(zName, (*(*struct_PragmaName)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_PragmaName)(unsafe.Pointer(&aPragmaName)))) + uintptr(mid)*24))).zName)
		if rc == 0 {
			break
		}
		if rc < 0 {
			upr = mid - 1
		} else {
			lwr = mid + 1
		}
	}
	return func() *struct_PragmaName {
		if lwr > upr {
			return nil
		} else {
			return &*(*struct_PragmaName)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_PragmaName)(unsafe.Pointer(&aPragmaName)))) + uintptr(mid)*24))
		}
	}()
}
func pragmaFunclistLine(v *struct_Vdbe, p *struct_FuncDef, isBuiltin int32, showInternFuncs int32) {
	for ; p != nil; p = p.pNext {
		var zType *int8
		var mask uint32 = uint32(2048 | 524288 | 1048576 | 2097152 | 262144)
		var azEnc [4]*int8 = [4]*int8{nil, (*int8)(unsafe.Pointer(&[5]int8{'u', 't', 'f', '8', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'u', 't', 'f', '1', '6', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'u', 't', 'f', '1', '6', 'b', 'e', '\x00'}))}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(p.xSFunc)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if p.funcFlags&uint32(262144) != uint32(0) && showInternFuncs == 0 {
			continue
		}
		if uintptr(unsafe.Pointer(p.xValue)) != uintptr(unsafe.Pointer(nil)) {
			zType = (*int8)(unsafe.Pointer(&[2]int8{'w', '\x00'}))
		} else if uintptr(unsafe.Pointer(p.xFinalize)) != uintptr(unsafe.Pointer(nil)) {
			zType = (*int8)(unsafe.Pointer(&[2]int8{'a', '\x00'}))
		} else {
			zType = (*int8)(unsafe.Pointer(&[2]int8{'s', '\x00'}))
		}
		sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[7]int8{'s', 'i', 's', 's', 'i', 'i', '\x00'})), p.zName, isBuiltin, zType, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azEnc)))) + uintptr(p.funcFlags&uint32(3))*8)), int32(p.nArg), p.funcFlags&mask^uint32(2097152))
	}
}
func integrityCheckResultRow(v *struct_Vdbe) int32 {
	var addr int32
	sqlite3VdbeAddOp2(v, 83, 3, 1)
	addr = sqlite3VdbeAddOp3(v, 49, 1, sqlite3VdbeCurrentAddr(v)+2, 1)
	sqlite3VdbeAddOp0(v, 70)
	return addr
}
func sqlite3Pragma(pParse *struct_Parse, pId1 *struct_Token, pId2 *struct_Token, pValue *struct_Token, minusFlag int32) {
	var zLeft *int8 = nil
	var zRight *int8 = nil
	var zDb *int8 = nil
	var pId *struct_Token
	var aFcntl [4]*int8
	var iDb int32
	var rc int32
	var db *struct_sqlite3 = pParse.db
	var pDb *struct_Db
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var pPragma *struct_PragmaName
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	sqlite3VdbeRunOnlyOnce(v)
	pParse.nMem = int32(2)
	iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId)
	if iDb < 0 {
		return
	}
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	if iDb == 1 && sqlite3OpenTempDatabase(pParse) != 0 {
		return
	}
	zLeft = sqlite3NameFromToken(db, pId)
	if !(zLeft != nil) {
		return
	}
	if minusFlag != 0 {
		zRight = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[4]int8{'-', '%', 'T', '\x00'})), pValue)
	} else {
		zRight = sqlite3NameFromToken(db, pValue)
	}
	func() int {
		_ = 0
		return 0
	}()
	zDb = func() *int8 {
		if pId2.n > uint32(0) {
			return pDb.zDbSName
		} else {
			return nil
		}
	}()
	if sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb) != 0 {
		goto pragma_out
	}
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8)) = (*int8)(nil)
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(1)*8)) = zLeft
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(2)*8)) = zRight
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(3)*8)) = (*int8)(nil)
	db.busyHandler.nBusy = int32(0)
	rc = sqlite3_file_control(db, zDb, 14, unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl))))
	if rc == 0 {
		sqlite3VdbeSetNumCols(v, 1)
		sqlite3VdbeSetColName(v, 0, 0, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8)), (func(unsafe.Pointer))(-1))
		returnSingleText(v, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8)))
		sqlite3_free(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8))))
		goto pragma_out
	}
	if rc != 12 {
		if *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8)) != nil {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8)))
			sqlite3_free(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aFcntl)))) + uintptr(0)*8))))
		}
		pParse.nErr++
		pParse.rc = rc
		goto pragma_out
	}
	pPragma = pragmaLocate(zLeft)
	if uintptr(unsafe.Pointer(pPragma)) == uintptr(unsafe.Pointer(nil)) {
		goto pragma_out
	}
	if int32(pPragma.mPragFlg)&1 != 0 {
		if sqlite3ReadSchema(pParse) != 0 {
			goto pragma_out
		}
	}
	if int32(pPragma.mPragFlg)&2 == 0 && (int32(pPragma.mPragFlg)&4 == 0 || uintptr(unsafe.Pointer(zRight)) == uintptr(unsafe.Pointer(nil))) {
		setPragmaResultColumnNames(v, pPragma)
	}
	switch int32(pPragma.ePragTyp) {
	case 13:
		{
			const iLn int32 = 0
			var getCacheSize [9]struct_VdbeOpList = [9]struct_VdbeOpList{struct_VdbeOpList{uint8(2), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(98), int8(0), int8(1), int8(3)}, struct_VdbeOpList{uint8(49), int8(1), int8(8), int8(0)}, struct_VdbeOpList{uint8(71), int8(0), int8(2), int8(0)}, struct_VdbeOpList{uint8(107), int8(1), int8(2), int8(1)}, struct_VdbeOpList{uint8(49), int8(1), int8(8), int8(0)}, struct_VdbeOpList{uint8(71), int8(0), int8(1), int8(0)}, struct_VdbeOpList{uint8(182), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(83), int8(1), int8(1), int8(0)}}
			var aOp *struct_VdbeOp
			sqlite3VdbeUsesBtree(v, iDb)
			if !(zRight != nil) {
				pParse.nMem += int32(2)
				aOp = sqlite3VdbeAddOpList(v, int32(36/4), (*struct_VdbeOpList)(unsafe.Pointer(&getCacheSize)), iLn)
				if 0 != 0 {
					break
				}
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(6)*24))).p1 = int32(-2000)
			} else {
				var size int32 = sqlite3AbsInt32(sqlite3Atoi(zRight))
				sqlite3BeginWriteOperation(pParse, 0, iDb)
				sqlite3VdbeAddOp3(v, 99, iDb, 3, size)
				func() int {
					_ = 0
					return 0
				}()
				pDb.pSchema.cache_size = size
				sqlite3BtreeSetCacheSize(pDb.pBt, pDb.pSchema.cache_size)
			}
			break
		}
	case 31:
		{
			var pBt *struct_Btree = pDb.pBt
			func() int {
				_ = 0
				return 0
			}()
			if !(zRight != nil) {
				var size int32 = func() int32 {
					if pBt != nil {
						return sqlite3BtreeGetPageSize(pBt)
					} else {
						return 0
					}
				}()
				returnSingleInt(v, int64(size))
			} else {
				db.nextPagesize = sqlite3Atoi(zRight)
				if 7 == sqlite3BtreeSetPageSize(pBt, db.nextPagesize, 0, 0) {
					sqlite3OomFault(db)
				}
			}
			break
		}
	case 33:
		{
			var pBt *struct_Btree = pDb.pBt
			var b int32 = -1
			func() int {
				_ = 0
				return 0
			}()
			if zRight != nil {
				if sqlite3_stricmp(zRight, (*int8)(unsafe.Pointer(&[5]int8{'f', 'a', 's', 't', '\x00'}))) == 0 {
					b = int32(2)
				} else {
					b = int32(sqlite3GetBoolean(zRight, uint8(0)))
				}
			}
			if pId2.n == uint32(0) && b >= 0 {
				var ii int32
				for ii = int32(0); ii < db.nDb; ii++ {
					sqlite3BtreeSecureDelete((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt, b)
				}
			}
			b = sqlite3BtreeSecureDelete(pBt, b)
			returnSingleInt(v, int64(b))
			break
		}
	case 27:
		{
			var iReg int32
			var x int64 = int64(0)
			sqlite3CodeVerifySchema(pParse, iDb)
			iReg = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zLeft)) + uintptr(0)))))))) == 'p' {
				sqlite3VdbeAddOp2(v, 176, iDb, iReg)
			} else {
				if zRight != nil && sqlite3DecOrHexToI64(zRight, &x) == 0 {
					if x < int64(0) {
						x = int64(0)
					} else if x > int64(4294967294) {
						x = int64(4294967294)
					}
				} else {
					x = int64(0)
				}
				sqlite3VdbeAddOp3(v, 177, iDb, iReg, int32(x))
			}
			sqlite3VdbeAddOp2(v, 83, iReg, 1)
			break
		}
	case 26:
		{
			var zRet *int8 = (*int8)(unsafe.Pointer(&[7]int8{'n', 'o', 'r', 'm', 'a', 'l', '\x00'}))
			var eMode int32 = getLockingMode(zRight)
			if pId2.n == uint32(0) && eMode == -1 {
				eMode = int32(db.dfltLockMode)
			} else {
				var pPager *struct_Pager
				if pId2.n == uint32(0) {
					var ii int32
					func() int {
						_ = 0
						return 0
					}()
					for ii = int32(2); ii < db.nDb; ii++ {
						pPager = sqlite3BtreePager((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt)
						sqlite3PagerLockingMode(pPager, eMode)
					}
					db.dfltLockMode = uint8(eMode)
				}
				pPager = sqlite3BtreePager(pDb.pBt)
				eMode = sqlite3PagerLockingMode(pPager, eMode)
			}
			func() int {
				_ = 0
				return 0
			}()
			if eMode == 1 {
				zRet = (*int8)(unsafe.Pointer(&[10]int8{'e', 'x', 'c', 'l', 'u', 's', 'i', 'v', 'e', '\x00'}))
			}
			returnSingleText(v, zRet)
			break
		}
	case 23:
		{
			var eMode int32
			var ii int32
			if uintptr(unsafe.Pointer(zRight)) == uintptr(unsafe.Pointer(nil)) {
				eMode = int32(-1)
			} else {
				var zMode *int8
				var n int32 = sqlite3Strlen30(zRight)
				for eMode = int32(0); uintptr(unsafe.Pointer(func() (_cgo_ret *int8) {
					_cgo_addr := &zMode
					*_cgo_addr = sqlite3JournalModename(eMode)
					return *_cgo_addr
				}())) != uintptr(unsafe.Pointer(nil)); eMode++ {
					if sqlite3_strnicmp(zRight, zMode, n) == 0 {
						break
					}
				}
				if !(zMode != nil) {
					eMode = int32(-1)
				}
				if eMode == 2 && db.flags&uint64(268435456) != uint64(0) {
					eMode = int32(-1)
				}
			}
			if eMode == -1 && pId2.n == uint32(0) {
				iDb = int32(0)
				pId2.n = uint32(1)
			}
			for ii = db.nDb - 1; ii >= 0; ii-- {
				if (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt != nil && (ii == iDb || pId2.n == uint32(0)) {
					sqlite3VdbeUsesBtree(v, ii)
					sqlite3VdbeAddOp3(v, 7, ii, 1, eMode)
				}
			}
			sqlite3VdbeAddOp2(v, 83, 1, 1)
			break
		}
	case 24:
		{
			var pPager *struct_Pager = sqlite3BtreePager(pDb.pBt)
			var iLimit int64 = int64(-2)
			if zRight != nil {
				sqlite3DecOrHexToI64(zRight, &iLimit)
				if iLimit < int64(-1) {
					iLimit = int64(-1)
				}
			}
			iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit)
			returnSingleInt(v, iLimit)
			break
		}
	case 3:
		{
			var pBt *struct_Btree = pDb.pBt
			func() int {
				_ = 0
				return 0
			}()
			if !(zRight != nil) {
				returnSingleInt(v, int64(sqlite3BtreeGetAutoVacuum(pBt)))
			} else {
				var eAuto int32 = getAutoVacuum(zRight)
				func() int {
					_ = 0
					return 0
				}()
				db.nextAutovac = int8(uint8(eAuto))
				rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto)
				if rc == 0 && (eAuto == 1 || eAuto == 2) {
					const iLn int32 = 0
					var setMeta6 [5]struct_VdbeOpList = [5]struct_VdbeOpList{struct_VdbeOpList{uint8(2), int8(0), int8(1), int8(0)}, struct_VdbeOpList{uint8(98), int8(0), int8(1), int8(4)}, struct_VdbeOpList{uint8(18), int8(1), int8(0), int8(0)}, struct_VdbeOpList{uint8(70), int8(0), int8(2), int8(0)}, struct_VdbeOpList{uint8(99), int8(0), int8(7), int8(0)}}
					var aOp *struct_VdbeOp
					var iAddr int32 = sqlite3VdbeCurrentAddr(v)
					aOp = sqlite3VdbeAddOpList(v, int32(20/4), (*struct_VdbeOpList)(unsafe.Pointer(&setMeta6)), iLn)
					if 0 != 0 {
						break
					}
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p1 = iDb
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p1 = iDb
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(2)*24))).p2 = iAddr + 4
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(4)*24))).p1 = iDb
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(4)*24))).p3 = eAuto - 1
					sqlite3VdbeUsesBtree(v, iDb)
				}
			}
			break
		}
	case 19:
		{
			var iLimit int32
			var addr int32
			if uintptr(unsafe.Pointer(zRight)) == uintptr(unsafe.Pointer(nil)) || !(sqlite3GetInt32(zRight, &iLimit) != 0) || iLimit <= 0 {
				iLimit = int32(2147483647)
			}
			sqlite3BeginWriteOperation(pParse, 0, iDb)
			sqlite3VdbeAddOp2(v, 71, iLimit, 1)
			addr = sqlite3VdbeAddOp1(v, 61, iDb)
			sqlite3VdbeAddOp1(v, 83, 1)
			sqlite3VdbeAddOp2(v, 85, 1, -1)
			sqlite3VdbeAddOp2(v, 49, 1, addr)
			sqlite3VdbeJumpHere(v, addr)
			break
		}
	case 6:
		{
			func() int {
				_ = 0
				return 0
			}()
			if !(zRight != nil) {
				returnSingleInt(v, int64(pDb.pSchema.cache_size))
			} else {
				var size int32 = sqlite3Atoi(zRight)
				pDb.pSchema.cache_size = size
				sqlite3BtreeSetCacheSize(pDb.pBt, pDb.pSchema.cache_size)
			}
			break
		}
	case 7:
		{
			func() int {
				_ = 0
				return 0
			}()
			if !(zRight != nil) {
				returnSingleInt(v, int64(func() int32 {
					if db.flags&uint64(32) == uint64(0) {
						return 0
					} else {
						return sqlite3BtreeSetSpillSize(pDb.pBt, 0)
					}
				}()))
			} else {
				var size int32 = 1
				if sqlite3GetInt32(zRight, &size) != 0 {
					sqlite3BtreeSetSpillSize(pDb.pBt, size)
				}
				if sqlite3GetBoolean(zRight, func() uint8 {
					if size != 0 {
						return 1
					} else {
						return 0
					}
				}()) != 0 {
					db.flags |= uint64(32)
				} else {
					db.flags &= ^uint64(32)
				}
				setAllPagerFlags(db)
			}
			break
		}
	case 28:
		{
			var sz int64
			func() int {
				_ = 0
				return 0
			}()
			if zRight != nil {
				var ii int32
				sqlite3DecOrHexToI64(zRight, &sz)
				if sz < int64(0) {
					sz = sqlite3Config.szMmap
				}
				if pId2.n == uint32(0) {
					db.szMmap = sz
				}
				for ii = db.nDb - 1; ii >= 0; ii-- {
					if (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt != nil && (ii == iDb || pId2.n == uint32(0)) {
						sqlite3BtreeSetMmapLimit((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pBt, sz)
					}
				}
			}
			sz = int64(-1)
			rc = sqlite3_file_control(db, zDb, 18, unsafe.Pointer(&sz))
			if rc == 0 {
				returnSingleInt(v, sz)
			} else if rc != 12 {
				pParse.nErr++
				pParse.rc = rc
			}
			break
		}
	case 39:
		{
			if !(zRight != nil) {
				returnSingleInt(v, int64(db.temp_store))
			} else {
				changeTempStorage(pParse, zRight)
			}
			break
		}
	case 40:
		{
			if !(zRight != nil) {
				returnSingleText(v, sqlite3_temp_directory)
			} else {
				if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRight)) + uintptr(0))) != 0 {
					var res int32
					rc = sqlite3OsAccess(db.pVfs, zRight, 1, &res)
					if rc != 0 || res == 0 {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[25]int8{'n', 'o', 't', ' ', 'a', ' ', 'w', 'r', 'i', 't', 'a', 'b', 'l', 'e', ' ', 'd', 'i', 'r', 'e', 'c', 't', 'o', 'r', 'y', '\x00'})))
						goto pragma_out
					}
				}
				if 1 == 0 || 1 == 1 && int32(db.temp_store) <= 1 || 1 == 2 && int32(db.temp_store) == 1 {
					invalidateTempStorage(pParse)
				}
				sqlite3_free(unsafe.Pointer(sqlite3_temp_directory))
				if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRight)) + uintptr(0))) != 0 {
					sqlite3_temp_directory = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zRight)
				} else {
					sqlite3_temp_directory = (*int8)(nil)
				}
			}
			break
		}
	case 25:
		{
			if !(zRight != nil) {
				var pPager *struct_Pager = sqlite3BtreePager(pDb.pBt)
				var proxy_file_path *int8 = nil
				var pFile *struct_sqlite3_file = sqlite3PagerFile(pPager)
				sqlite3OsFileControlHint(pFile, 2, unsafe.Pointer(&proxy_file_path))
				returnSingleText(v, proxy_file_path)
			} else {
				var pPager *struct_Pager = sqlite3BtreePager(pDb.pBt)
				var pFile *struct_sqlite3_file = sqlite3PagerFile(pPager)
				var res int32
				if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRight)) + uintptr(0))) != 0 {
					res = sqlite3OsFileControl(pFile, 3, unsafe.Pointer(zRight))
				} else {
					res = sqlite3OsFileControl(pFile, 3, unsafe.Pointer(0))
				}
				if res != 0 {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[30]int8{'f', 'a', 'i', 'l', 'e', 'd', ' ', 't', 'o', ' ', 's', 'e', 't', ' ', 'l', 'o', 'c', 'k', ' ', 'p', 'r', 'o', 'x', 'y', ' ', 'f', 'i', 'l', 'e', '\x00'})))
					goto pragma_out
				}
			}
			break
		}
	case 36:
		{
			if !(zRight != nil) {
				returnSingleInt(v, int64(int32(pDb.safety_level)-1))
			} else if !(db.autoCommit != 0) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[53]int8{'S', 'a', 'f', 'e', 't', 'y', ' ', 'l', 'e', 'v', 'e', 'l', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'b', 'e', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', ' ', 'i', 'n', 's', 'i', 'd', 'e', ' ', 'a', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '\x00'})))
			} else if iDb != 1 {
				var iLevel int32 = (int32(getSafetyLevel(zRight, 0, uint8(1))) + 1) & 7
				if iLevel == 0 {
					iLevel = int32(1)
				}
				pDb.safety_level = uint8(iLevel)
				pDb.bSyncSet = uint8(1)
				setAllPagerFlags(db)
			}
			break
		}
	case 4:
		{
			if uintptr(unsafe.Pointer(zRight)) == uintptr(unsafe.Pointer(nil)) {
				setPragmaResultColumnNames(v, pPragma)
				returnSingleInt(v, func() int64 {
					if db.flags&pPragma.iArg != uint64(0) {
						return 1
					} else {
						return 0
					}
				}())
			} else {
				var mask uint64 = pPragma.iArg
				if int32(db.autoCommit) == 0 {
					mask &= uint64(18446744073709535231)
				}
				if sqlite3GetBoolean(zRight, uint8(0)) != 0 {
					db.flags |= mask
				} else {
					db.flags &= ^mask
					if mask == uint64(524288) {
						db.nDeferredImmCons = int64(0)
					}
					if mask&uint64(1) != uint64(0) && sqlite3_stricmp(zRight, (*int8)(unsafe.Pointer(&[6]int8{'r', 'e', 's', 'e', 't', '\x00'}))) == 0 {
						sqlite3ResetAllSchemasOfConnection(db)
					}
				}
				sqlite3VdbeAddOp0(v, 165)
				setAllPagerFlags(db)
			}
			break
		}
	case 37:
		if zRight != nil {
			var pTab *struct_Table
			sqlite3CodeVerifyNamedSchema(pParse, zDb)
			pTab = sqlite3LocateTable(pParse, uint32(2), zRight, zDb)
			if pTab != nil {
				var i int32
				var k int32
				var nHidden int32 = 0
				var pCol *struct_Column
				var pPk *struct_Index = sqlite3PrimaryKeyIndex(pTab)
				pParse.nMem = int32(7)
				sqlite3ViewGetColumnNames(pParse, pTab)
				for func() *struct_Column {
					i = int32(0)
					return func() (_cgo_ret *struct_Column) {
						_cgo_addr := &pCol
						*_cgo_addr = pTab.aCol
						return *_cgo_addr
					}()
				}(); i < int32(pTab.nCol); func() *struct_Column {
					i++
					return func() (_cgo_ret *struct_Column) {
						_cgo_addr := &pCol
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
						return
					}()
				}() {
					var isHidden int32 = 0
					var pColExpr *struct_Expr
					if int32(pCol.colFlags)&98 != 0 {
						if pPragma.iArg == uint64(0) {
							nHidden++
							continue
						}
						if int32(pCol.colFlags)&32 != 0 {
							isHidden = int32(2)
						} else if int32(pCol.colFlags)&64 != 0 {
							isHidden = int32(3)
						} else {
							func() int {
								_ = 0
								return 0
							}()
							isHidden = int32(1)
						}
					}
					if int32(pCol.colFlags)&1 == 0 {
						k = int32(0)
					} else if uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(nil)) {
						k = int32(1)
					} else {
						for k = int32(1); k <= int32(pTab.nCol) && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(k-1)*2))) != i; k++ {
						}
					}
					pColExpr = sqlite3ColumnExpr(pTab, pCol)
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					sqlite3VdbeMultiLoad(v, 1, func() *int8 {
						if pPragma.iArg != 0 {
							return (*int8)(unsafe.Pointer(&[8]int8{'i', 's', 's', 'i', 's', 'i', 'i', '\x00'}))
						} else {
							return (*int8)(unsafe.Pointer(&[7]int8{'i', 's', 's', 'i', 's', 'i', '\x00'}))
						}
					}(), i-nHidden, pCol.zCnName, sqlite3ColumnType(pCol, (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))), func() int32 {
						if int32(pCol.Xbf_0&15) != 0 {
							return 1
						} else {
							return 0
						}
					}(), func() *int8 {
						if isHidden >= 2 || uintptr(unsafe.Pointer(pColExpr)) == uintptr(unsafe.Pointer(nil)) {
							return nil
						} else {
							return pColExpr.u.zToken
						}
					}(), k, isHidden)
				}
			}
		}
		break
	case 38:
		{
			var ii int32
			pParse.nMem = int32(6)
			sqlite3CodeVerifyNamedSchema(pParse, zDb)
			for ii = int32(0); ii < db.nDb; ii++ {
				var k *struct_HashElem
				var pHash *struct_Hash
				var initNCol int32
				if zDb != nil && sqlite3_stricmp(zDb, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).zDbSName) != 0 {
					continue
				}
				pHash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pSchema.tblHash
				initNCol = int32(pHash.count)
				for func() (_cgo_ret int32) {
					_cgo_addr := &initNCol
					_cgo_ret = *_cgo_addr
					*_cgo_addr--
					return
				}() != 0 {
					for k = pHash.first; 1 != 0; k = k.next {
						var pTab *struct_Table
						if uintptr(unsafe.Pointer(k)) == uintptr(unsafe.Pointer(nil)) {
							initNCol = int32(0)
							break
						}
						pTab = (*struct_Table)(k.data)
						if int32(pTab.nCol) == 0 {
							var zSql *int8 = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[16]int8{'S', 'E', 'L', 'E', 'C', 'T', '*', 'F', 'R', 'O', 'M', '"', '%', 'w', '"', '\x00'})), pTab.zName)
							if zSql != nil {
								var pDummy *struct_sqlite3_stmt = nil
								func() int {
									_ = sqlite3_prepare(db, zSql, -1, &pDummy, nil)
									return 0
								}()
								func() int {
									_ = sqlite3_finalize(pDummy)
									return 0
								}()
								sqlite3DbFree(db, unsafe.Pointer(zSql))
							}
							if db.mallocFailed != 0 {
								sqlite3ErrorMsg(db.pParse, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
								db.pParse.rc = int32(7)
							}
							pHash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).pSchema.tblHash
							break
						}
					}
				}
				for k = pHash.first; k != nil; k = k.next {
					var pTab *struct_Table = (*struct_Table)(k.data)
					var zType *int8
					if zRight != nil && sqlite3_stricmp(zRight, pTab.zName) != 0 {
						continue
					}
					if int32(pTab.eTabType) == 2 {
						zType = (*int8)(unsafe.Pointer(&[5]int8{'v', 'i', 'e', 'w', '\x00'}))
					} else if int32(pTab.eTabType) == 1 {
						zType = (*int8)(unsafe.Pointer(&[8]int8{'v', 'i', 'r', 't', 'u', 'a', 'l', '\x00'}))
					} else if pTab.tabFlags&uint32(4096) != 0 {
						zType = (*int8)(unsafe.Pointer(&[7]int8{'s', 'h', 'a', 'd', 'o', 'w', '\x00'}))
					} else {
						zType = (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'}))
					}
					sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[7]int8{'s', 's', 's', 'i', 'i', 'i', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(ii)*32))).zDbSName, sqlite3PreferredTableName(pTab.zName), zType, int32(pTab.nCol), pTab.tabFlags&uint32(128) != uint32(0), pTab.tabFlags&uint32(65536) != uint32(0))
				}
			}
		}
		break
	case 20:
		if zRight != nil {
			var pIdx *struct_Index
			var pTab *struct_Table
			pIdx = sqlite3FindIndex(db, zRight, zDb)
			if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(nil)) {
				pTab = sqlite3LocateTable(pParse, uint32(2), zRight, zDb)
				if pTab != nil && !(pTab.tabFlags&uint32(128) == uint32(0)) {
					pIdx = sqlite3PrimaryKeyIndex(pTab)
				}
			}
			if pIdx != nil {
				var iIdxDb int32 = sqlite3SchemaToIndex(db, pIdx.pSchema)
				var i int32
				var mx int32
				if pPragma.iArg != 0 {
					mx = int32(pIdx.nColumn)
					pParse.nMem = int32(6)
				} else {
					mx = int32(pIdx.nKeyCol)
					pParse.nMem = int32(3)
				}
				pTab = pIdx.pTable
				sqlite3CodeVerifySchema(pParse, iIdxDb)
				func() int {
					_ = 0
					return 0
				}()
				for i = int32(0); i < mx; i++ {
					var cnum int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))
					sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[5]int8{'i', 'i', 's', 'X', '\x00'})), i, int32(cnum), func() *int8 {
						if int32(cnum) < 0 {
							return nil
						} else {
							return (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(cnum)*20))).zCnName
						}
					}())
					if pPragma.iArg != 0 {
						sqlite3VdbeMultiLoad(v, 4, (*int8)(unsafe.Pointer(&[5]int8{'i', 's', 'i', 'X', '\x00'})), int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(i)))), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(i)*8)), i < int32(pIdx.nKeyCol))
					}
					sqlite3VdbeAddOp2(v, 83, 1, pParse.nMem)
				}
			}
		}
		break
	case 21:
		if zRight != nil {
			var pIdx *struct_Index
			var pTab *struct_Table
			var i int32
			pTab = sqlite3FindTable(db, zRight, zDb)
			if pTab != nil {
				var iTabDb int32 = sqlite3SchemaToIndex(db, pTab.pSchema)
				pParse.nMem = int32(5)
				sqlite3CodeVerifySchema(pParse, iTabDb)
				for func() int32 {
					pIdx = pTab.pIndex
					return func() (_cgo_ret int32) {
						_cgo_addr := &i
						*_cgo_addr = int32(0)
						return *_cgo_addr
					}()
				}(); pIdx != nil; func() int32 {
					pIdx = pIdx.pNext
					return func() (_cgo_ret int32) {
						_cgo_addr := &i
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
				}() {
					var azOrigin [3]*int8 = [3]*int8{(*int8)(unsafe.Pointer(&[2]int8{'c', '\x00'})), (*int8)(unsafe.Pointer(&[2]int8{'u', '\x00'})), (*int8)(unsafe.Pointer(&[3]int8{'p', 'k', '\x00'}))}
					sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[6]int8{'i', 's', 'i', 's', 'i', '\x00'})), i, pIdx.zName, int32(pIdx.onError) != 0, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azOrigin)))) + uintptr(pIdx.Xbf_0&3)*8)), uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) != uintptr(unsafe.Pointer(nil)))
				}
			}
		}
		break
	case 12:
		{
			var i int32
			pParse.nMem = int32(3)
			for i = int32(0); i < db.nDb; i++ {
				if uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt)) == uintptr(unsafe.Pointer(nil)) {
					continue
				}
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[4]int8{'i', 's', 's', '\x00'})), i, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).zDbSName, sqlite3BtreeGetFilename((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt))
			}
		}
		break
	case 9:
		{
			var i int32 = 0
			var p *struct_HashElem
			pParse.nMem = int32(2)
			for p = (&db.aCollSeq).first; p != nil; p = p.next {
				var pColl *struct_CollSeq = (*struct_CollSeq)(p.data)
				sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[3]int8{'i', 's', '\x00'})), func() (_cgo_ret int32) {
					_cgo_addr := &i
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}(), pColl.zName)
			}
		}
		break
	case 17:
		{
			var i int32
			var j *struct_HashElem
			var p *struct_FuncDef
			var showInternFunc int32 = func() int32 {
				if db.mDbFlags&uint32(32) != uint32(0) {
					return 1
				} else {
					return 0
				}
			}()
			pParse.nMem = int32(6)
			for i = int32(0); i < 23; i++ {
				for p = *(**struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_FuncDef)(unsafe.Pointer(&sqlite3BuiltinFunctions.a)))) + uintptr(i)*8)); p != nil; p = p.u.pHash {
					func() int {
						_ = 0
						return 0
					}()
					pragmaFunclistLine(v, p, 1, showInternFunc)
				}
			}
			for j = (&db.aFunc).first; j != nil; j = j.next {
				p = (*struct_FuncDef)(j.data)
				func() int {
					_ = 0
					return 0
				}()
				pragmaFunclistLine(v, p, 0, showInternFunc)
			}
		}
		break
	case 29:
		{
			var j *struct_HashElem
			pParse.nMem = int32(1)
			for j = (&db.aModule).first; j != nil; j = j.next {
				var pMod *struct_Module = (*struct_Module)(j.data)
				sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[2]int8{'s', '\x00'})), pMod.zName)
			}
		}
		break
	case 32:
		{
			var i int32
			for i = int32(0); i < int32(1608/24); i++ {
				sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[2]int8{'s', '\x00'})), (*(*struct_PragmaName)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_PragmaName)(unsafe.Pointer(&aPragmaName)))) + uintptr(i)*24))).zName)
			}
		}
		break
	case 16:
		if zRight != nil {
			var pFK *struct_FKey
			var pTab *struct_Table
			pTab = sqlite3FindTable(db, zRight, zDb)
			if pTab != nil && int32(pTab.eTabType) == 0 {
				pFK = pTab.u.tab.pFKey
				if pFK != nil {
					var iTabDb int32 = sqlite3SchemaToIndex(db, pTab.pSchema)
					var i int32 = 0
					pParse.nMem = int32(8)
					sqlite3CodeVerifySchema(pParse, iTabDb)
					for pFK != nil {
						var j int32
						for j = int32(0); j < pFK.nCol; j++ {
							sqlite3VdbeMultiLoad(v, 1, (*int8)(unsafe.Pointer(&[9]int8{'i', 'i', 's', 's', 's', 's', 's', 's', '\x00'})), i, j, pFK.zTo, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr((*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFK.aCol)))) + uintptr(j)*16))).iFrom)*20))).zCnName, (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFK.aCol)))) + uintptr(j)*16))).zCol, actionName(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFK.aAction)))) + uintptr(1)))), actionName(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&pFK.aAction)))) + uintptr(0)))), (*int8)(unsafe.Pointer(&[5]int8{'N', 'O', 'N', 'E', '\x00'})))
						}
						i++
						pFK = pFK.pNextFrom
					}
				}
			}
		}
		break
	case 15:
		{
			var pFK *struct_FKey
			var pTab *struct_Table
			var pParent *struct_Table
			var pIdx *struct_Index
			var i int32
			var j int32
			var k *struct_HashElem
			var x int32
			var regResult int32
			var regKey int32
			var regRow int32
			var addrTop int32
			var addrOk int32
			var aiCols *int32
			regResult = pParse.nMem + 1
			pParse.nMem += int32(4)
			regKey = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			regRow = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			k = (&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.tblHash).first
			for k != nil {
				if zRight != nil {
					pTab = sqlite3LocateTable(pParse, uint32(0), zRight, zDb)
					k = (*struct_HashElem)(nil)
				} else {
					pTab = (*struct_Table)(k.data)
					k = k.next
				}
				if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) || !(int32(pTab.eTabType) == 0) || uintptr(unsafe.Pointer(pTab.u.tab.pFKey)) == uintptr(unsafe.Pointer(nil)) {
					continue
				}
				iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
				zDb = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
				sqlite3CodeVerifySchema(pParse, iDb)
				sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(0), pTab.zName)
				if int32(pTab.nCol)+regRow > pParse.nMem {
					pParse.nMem = int32(pTab.nCol) + regRow
				}
				sqlite3OpenTable(pParse, 0, iDb, pTab, 101)
				sqlite3VdbeLoadString(v, regResult, pTab.zName)
				func() int {
					_ = 0
					return 0
				}()
				for func() *struct_FKey {
					i = int32(1)
					return func() (_cgo_ret *struct_FKey) {
						_cgo_addr := &pFK
						*_cgo_addr = pTab.u.tab.pFKey
						return *_cgo_addr
					}()
				}(); pFK != nil; func() *struct_FKey {
					i++
					return func() (_cgo_ret *struct_FKey) {
						_cgo_addr := &pFK
						*_cgo_addr = pFK.pNextFrom
						return *_cgo_addr
					}()
				}() {
					pParent = sqlite3FindTable(db, pFK.zTo, zDb)
					if uintptr(unsafe.Pointer(pParent)) == uintptr(unsafe.Pointer(nil)) {
						continue
					}
					pIdx = (*struct_Index)(nil)
					sqlite3TableLock(pParse, iDb, pParent.tnum, uint8(0), pParent.zName)
					x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, nil)
					if x == 0 {
						if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(nil)) {
							sqlite3OpenTable(pParse, i, iDb, pParent, 101)
						} else {
							sqlite3VdbeAddOp3(v, 101, i, int32(pIdx.tnum), iDb)
							sqlite3VdbeSetP4KeyInfo(pParse, pIdx)
						}
					} else {
						k = (*struct_HashElem)(nil)
						break
					}
				}
				func() int {
					_ = 0
					return 0
				}()
				if pFK != nil {
					break
				}
				if pParse.nTab < i {
					pParse.nTab = i
				}
				addrTop = sqlite3VdbeAddOp1(v, 38, 0)
				func() int {
					_ = 0
					return 0
				}()
				for func() *struct_FKey {
					i = int32(1)
					return func() (_cgo_ret *struct_FKey) {
						_cgo_addr := &pFK
						*_cgo_addr = pTab.u.tab.pFKey
						return *_cgo_addr
					}()
				}(); pFK != nil; func() *struct_FKey {
					i++
					return func() (_cgo_ret *struct_FKey) {
						_cgo_addr := &pFK
						*_cgo_addr = pFK.pNextFrom
						return *_cgo_addr
					}()
				}() {
					pParent = sqlite3FindTable(db, pFK.zTo, zDb)
					pIdx = (*struct_Index)(nil)
					aiCols = (*int32)(nil)
					if pParent != nil {
						x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols)
						func() int {
							_ = 0
							return 0
						}()
					}
					addrOk = sqlite3VdbeMakeLabel(pParse)
					if regRow+pFK.nCol > pParse.nMem {
						pParse.nMem = regRow + pFK.nCol
					}
					for j = int32(0); j < pFK.nCol; j++ {
						var iCol int32 = func() int32 {
							if aiCols != nil {
								return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCols)) + uintptr(j)*4))
							} else {
								return (*(*struct_sColMap)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_sColMap)(unsafe.Pointer(&pFK.aCol)))) + uintptr(j)*16))).iFrom
							}
						}()
						sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j)
						sqlite3VdbeAddOp2(v, 50, regRow+j, addrOk)
					}
					if pIdx != nil {
						sqlite3VdbeAddOp4(v, 96, regRow, pFK.nCol, regKey, sqlite3IndexAffinityStr(db, pIdx), pFK.nCol)
						sqlite3VdbeAddOp4Int(v, 31, i, addrOk, regKey, 0)
					} else if pParent != nil {
						var jmp int32 = sqlite3VdbeCurrentAddr(v) + 2
						sqlite3VdbeAddOp3(v, 32, i, jmp, regRow)
						sqlite3VdbeGoto(v, addrOk)
						func() int {
							_ = 0
							return 0
						}()
					}
					if pTab.tabFlags&uint32(128) == uint32(0) {
						sqlite3VdbeAddOp2(v, 134, 0, regResult+1)
					} else {
						sqlite3VdbeAddOp2(v, 74, 0, regResult+1)
					}
					sqlite3VdbeMultiLoad(v, regResult+2, (*int8)(unsafe.Pointer(&[4]int8{'s', 'i', 'X', '\x00'})), pFK.zTo, i-1)
					sqlite3VdbeAddOp2(v, 83, regResult, 4)
					sqlite3VdbeResolveLabel(v, addrOk)
					sqlite3DbFree(db, unsafe.Pointer(aiCols))
				}
				sqlite3VdbeAddOp2(v, 5, 0, addrTop+1)
				sqlite3VdbeJumpHere(v, addrTop)
			}
		}
		break
	case 8:
		{
			if zRight != nil {
				sqlite3RegisterLikeFunctions(db, int32(sqlite3GetBoolean(zRight, uint8(0))))
			}
		}
		break
	case 22:
		{
			var i int32
			var j int32
			var addr int32
			var mxErr int32
			var pObjTab *struct_Table = nil
			var isQuick int32 = func() int32 {
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zLeft)) + uintptr(0)))))))) == 'q' {
					return 1
				} else {
					return 0
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pId2.z)) == uintptr(unsafe.Pointer(nil)) {
				iDb = int32(-1)
			}
			pParse.nMem = int32(6)
			mxErr = int32(100)
			if zRight != nil {
				if sqlite3GetInt32(zRight, &mxErr) != 0 {
					if mxErr <= 0 {
						mxErr = int32(100)
					}
				} else {
					pObjTab = sqlite3LocateTable(pParse, uint32(0), zRight, func() *int8 {
						if iDb >= 0 {
							return (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
						} else {
							return nil
						}
					}())
				}
			}
			sqlite3VdbeAddOp2(v, 71, mxErr-1, 1)
			for i = int32(0); i < db.nDb; i++ {
				var x *struct_HashElem
				var pTbls *struct_Hash
				var aRoot *int32
				var cnt int32 = 0
				var mxIdx int32 = 0
				if 0 != 0 && i == 1 {
					continue
				}
				if iDb >= 0 && i != iDb {
					continue
				}
				sqlite3CodeVerifySchema(pParse, i)
				func() int {
					_ = 0
					return 0
				}()
				pTbls = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.tblHash
				for func() *struct_HashElem {
					cnt = int32(0)
					return func() (_cgo_ret *struct_HashElem) {
						_cgo_addr := &x
						*_cgo_addr = pTbls.first
						return *_cgo_addr
					}()
				}(); x != nil; x = x.next {
					var pTab *struct_Table = (*struct_Table)(x.data)
					var pIdx *struct_Index
					var nIdx int32
					if pObjTab != nil && uintptr(unsafe.Pointer(pObjTab)) != uintptr(unsafe.Pointer(pTab)) {
						continue
					}
					if pTab.tabFlags&uint32(128) == uint32(0) {
						cnt++
					}
					for func() *struct_Index {
						nIdx = int32(0)
						return func() (_cgo_ret *struct_Index) {
							_cgo_addr := &pIdx
							*_cgo_addr = pTab.pIndex
							return *_cgo_addr
						}()
					}(); pIdx != nil; func() int32 {
						pIdx = pIdx.pNext
						return func() (_cgo_ret int32) {
							_cgo_addr := &nIdx
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}()
					}() {
						cnt++
					}
					if nIdx > mxIdx {
						mxIdx = nIdx
					}
				}
				if cnt == 0 {
					continue
				}
				if pObjTab != nil {
					cnt++
				}
				aRoot = (*int32)(sqlite3DbMallocRawNN(db, uint64(4*uint(cnt+1))))
				if uintptr(unsafe.Pointer(aRoot)) == uintptr(unsafe.Pointer(nil)) {
					break
				}
				cnt = int32(0)
				if pObjTab != nil {
					*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &cnt
						*_cgo_addr++
						return *_cgo_addr
					}())*4)) = int32(0)
				}
				for x = pTbls.first; x != nil; x = x.next {
					var pTab *struct_Table = (*struct_Table)(x.data)
					var pIdx *struct_Index
					if pObjTab != nil && uintptr(unsafe.Pointer(pObjTab)) != uintptr(unsafe.Pointer(pTab)) {
						continue
					}
					if pTab.tabFlags&uint32(128) == uint32(0) {
						*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(func() (_cgo_ret int32) {
							_cgo_addr := &cnt
							*_cgo_addr++
							return *_cgo_addr
						}())*4)) = int32(pTab.tnum)
					}
					for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
						*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(func() (_cgo_ret int32) {
							_cgo_addr := &cnt
							*_cgo_addr++
							return *_cgo_addr
						}())*4)) = int32(pIdx.tnum)
					}
				}
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRoot)) + uintptr(0)*4)) = cnt
				pParse.nMem = func() int32 {
					if pParse.nMem > 8+mxIdx {
						return pParse.nMem
					} else {
						return 8 + mxIdx
					}
				}()
				sqlite3ClearTempRegCache(pParse)
				sqlite3VdbeAddOp4(v, 154, 2, cnt, 1, (*int8)(unsafe.Pointer(aRoot)), -15)
				sqlite3VdbeChangeP5(v, uint16(uint8(i)))
				addr = sqlite3VdbeAddOp1(v, 50, 2)
				sqlite3VdbeAddOp4(v, 117, 0, 3, 0, sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[24]int8{'*', '*', '*', ' ', 'i', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', '%', 's', ' ', '*', '*', '*', '\n', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).zDbSName), -7)
				sqlite3VdbeAddOp3(v, 111, 2, 3, 3)
				integrityCheckResultRow(v)
				sqlite3VdbeJumpHere(v, addr)
				for x = pTbls.first; x != nil; x = x.next {
					var pTab *struct_Table = (*struct_Table)(x.data)
					var pIdx *struct_Index
					var pPk *struct_Index
					var pPrior *struct_Index = nil
					var loopTop int32
					var iDataCur int32
					var iIdxCur int32
					var r1 int32 = -1
					var bStrict int32
					if !(int32(pTab.eTabType) == 0) {
						continue
					}
					if pObjTab != nil && uintptr(unsafe.Pointer(pObjTab)) != uintptr(unsafe.Pointer(pTab)) {
						continue
					}
					pPk = func() *struct_Index {
						if pTab.tabFlags&uint32(128) == uint32(0) {
							return nil
						} else {
							return sqlite3PrimaryKeyIndex(pTab)
						}
					}()
					sqlite3OpenTableAndIndices(pParse, pTab, 101, uint8(0), 1, nil, &iDataCur, &iIdxCur)
					sqlite3VdbeAddOp2(v, 71, 0, 7)
					for func() *struct_Index {
						j = int32(0)
						return func() (_cgo_ret *struct_Index) {
							_cgo_addr := &pIdx
							*_cgo_addr = pTab.pIndex
							return *_cgo_addr
						}()
					}(); pIdx != nil; func() int32 {
						pIdx = pIdx.pNext
						return func() (_cgo_ret int32) {
							_cgo_addr := &j
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}()
					}() {
						sqlite3VdbeAddOp2(v, 71, 0, 8+j)
					}
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					sqlite3VdbeAddOp2(v, 38, iDataCur, 0)
					loopTop = sqlite3VdbeAddOp2(v, 85, 7, 1)
					if !(isQuick != 0) {
						sqlite3VdbeAddOp3(v, 93, iDataCur, int32(pTab.nNVCol)-1, 3)
						sqlite3VdbeChangeP5(v, uint16(128))
					}
					bStrict = func() int32 {
						if pTab.tabFlags&uint32(65536) != uint32(0) {
							return 1
						} else {
							return 0
						}
					}()
					for j = int32(0); j < int32(pTab.nCol); j++ {
						var zErr *int8
						var pCol *struct_Column = (*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))
						var doError int32
						var jmp2 int32
						if j == int32(pTab.iPKey) {
							continue
						}
						if int32(pCol.Xbf_0&15) == 0 && !(bStrict != 0) {
							continue
						}
						doError = func() int32 {
							if bStrict != 0 {
								return sqlite3VdbeMakeLabel(pParse)
							} else {
								return 0
							}
						}()
						sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3)
						if int32(sqlite3VdbeGetOp(v, -1).opcode) == 93 {
							sqlite3VdbeChangeP5(v, uint16(128))
						}
						if pCol.Xbf_0&15 != 0 {
							jmp2 = sqlite3VdbeAddOp1(v, 51, 3)
							zErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[20]int8{'N', 'U', 'L', 'L', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'i', 'n', ' ', '%', 's', '.', '%', 's', '\x00'})), pTab.zName, pCol.zCnName)
							sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, -7)
							if bStrict != 0 && int32(pCol.Xbf_0>>4&15) != 1 {
								sqlite3VdbeGoto(v, doError)
							} else {
								integrityCheckResultRow(v)
							}
							sqlite3VdbeJumpHere(v, jmp2)
						}
						if pTab.tabFlags&uint32(65536) != uint32(0) && int32(pCol.Xbf_0>>4&15) != 1 {
							jmp2 = sqlite3VdbeAddOp3(v, 21, 3, 0, int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sqlite3StdTypeMap)))) + uintptr(int32(pCol.Xbf_0>>4&15)-1)))))
							zErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[22]int8{'n', 'o', 'n', '-', '%', 's', ' ', 'v', 'a', 'l', 'u', 'e', ' ', 'i', 'n', ' ', '%', 's', '.', '%', 's', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&sqlite3StdType)))) + uintptr(int32(pCol.Xbf_0>>4&15)-1)*8)), pTab.zName, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName)
							sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, -7)
							sqlite3VdbeResolveLabel(v, doError)
							integrityCheckResultRow(v)
							sqlite3VdbeJumpHere(v, jmp2)
						}
					}
					if pTab.pCheck != nil && db.flags&uint64(512) == uint64(0) {
						var pCheck *struct_ExprList = sqlite3ExprListDup(db, pTab.pCheck, 0)
						if int32(db.mallocFailed) == 0 {
							var addrCkFault int32 = sqlite3VdbeMakeLabel(pParse)
							var addrCkOk int32 = sqlite3VdbeMakeLabel(pParse)
							var zErr *int8
							var k int32
							pParse.iSelfTab = iDataCur + 1
							for k = pCheck.nExpr - 1; k > 0; k-- {
								sqlite3ExprIfFalse(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pCheck.a)))) + uintptr(k)*28))).pExpr, addrCkFault, 0)
							}
							sqlite3ExprIfTrue(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pCheck.a)))) + uintptr(0)*28))).pExpr, addrCkOk, 16)
							sqlite3VdbeResolveLabel(v, addrCkFault)
							pParse.iSelfTab = int32(0)
							zErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[30]int8{'C', 'H', 'E', 'C', 'K', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ' ', 'i', 'n', ' ', '%', 's', '\x00'})), pTab.zName)
							sqlite3VdbeAddOp4(v, 117, 0, 3, 0, zErr, -7)
							integrityCheckResultRow(v)
							sqlite3VdbeResolveLabel(v, addrCkOk)
						}
						sqlite3ExprListDelete(db, pCheck)
					}
					if !(isQuick != 0) {
						for func() *struct_Index {
							j = int32(0)
							return func() (_cgo_ret *struct_Index) {
								_cgo_addr := &pIdx
								*_cgo_addr = pTab.pIndex
								return *_cgo_addr
							}()
						}(); pIdx != nil; func() int32 {
							pIdx = pIdx.pNext
							return func() (_cgo_ret int32) {
								_cgo_addr := &j
								_cgo_ret = *_cgo_addr
								*_cgo_addr++
								return
							}()
						}() {
							var jmp2 int32
							var jmp3 int32
							var jmp4 int32
							var jmp5 int32
							var ckUniq int32 = sqlite3VdbeMakeLabel(pParse)
							if uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(pIdx)) {
								continue
							}
							r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3, pPrior, r1)
							pPrior = pIdx
							sqlite3VdbeAddOp2(v, 85, 8+j, 1)
							jmp2 = sqlite3VdbeAddOp4Int(v, 31, iIdxCur+j, ckUniq, r1, int32(pIdx.nColumn))
							sqlite3VdbeLoadString(v, 3, (*int8)(unsafe.Pointer(&[5]int8{'r', 'o', 'w', ' ', '\x00'})))
							sqlite3VdbeAddOp3(v, 111, 7, 3, 3)
							sqlite3VdbeLoadString(v, 4, (*int8)(unsafe.Pointer(&[21]int8{' ', 'm', 'i', 's', 's', 'i', 'n', 'g', ' ', 'f', 'r', 'o', 'm', ' ', 'i', 'n', 'd', 'e', 'x', ' ', '\x00'})))
							sqlite3VdbeAddOp3(v, 111, 4, 3, 3)
							jmp5 = sqlite3VdbeLoadString(v, 4, pIdx.zName)
							sqlite3VdbeAddOp3(v, 111, 4, 3, 3)
							jmp4 = integrityCheckResultRow(v)
							sqlite3VdbeJumpHere(v, jmp2)
							if int32(pIdx.onError) != 0 {
								var uniqOk int32 = sqlite3VdbeMakeLabel(pParse)
								var jmp6 int32
								var kk int32
								for kk = int32(0); kk < int32(pIdx.nKeyCol); kk++ {
									var iCol int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(kk)*2)))
									func() int {
										_ = 0
										return 0
									}()
									if iCol >= 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).Xbf_0&15) != 0 {
										continue
									}
									sqlite3VdbeAddOp2(v, 50, r1+kk, uniqOk)
								}
								jmp6 = sqlite3VdbeAddOp1(v, 5, iIdxCur+j)
								sqlite3VdbeGoto(v, uniqOk)
								sqlite3VdbeJumpHere(v, jmp6)
								sqlite3VdbeAddOp4Int(v, 40, iIdxCur+j, uniqOk, r1, int32(pIdx.nKeyCol))
								sqlite3VdbeLoadString(v, 3, (*int8)(unsafe.Pointer(&[27]int8{'n', 'o', 'n', '-', 'u', 'n', 'i', 'q', 'u', 'e', ' ', 'e', 'n', 't', 'r', 'y', ' ', 'i', 'n', ' ', 'i', 'n', 'd', 'e', 'x', ' ', '\x00'})))
								sqlite3VdbeGoto(v, jmp5)
								sqlite3VdbeResolveLabel(v, uniqOk)
							}
							sqlite3VdbeJumpHere(v, jmp4)
							sqlite3ResolvePartIdxLabel(pParse, jmp3)
						}
					}
					sqlite3VdbeAddOp2(v, 5, iDataCur, loopTop)
					sqlite3VdbeJumpHere(v, loopTop-1)
					if !(isQuick != 0) {
						sqlite3VdbeLoadString(v, 2, (*int8)(unsafe.Pointer(&[29]int8{'w', 'r', 'o', 'n', 'g', ' ', '#', ' ', 'o', 'f', ' ', 'e', 'n', 't', 'r', 'i', 'e', 's', ' ', 'i', 'n', ' ', 'i', 'n', 'd', 'e', 'x', ' ', '\x00'})))
						for func() *struct_Index {
							j = int32(0)
							return func() (_cgo_ret *struct_Index) {
								_cgo_addr := &pIdx
								*_cgo_addr = pTab.pIndex
								return *_cgo_addr
							}()
						}(); pIdx != nil; func() int32 {
							pIdx = pIdx.pNext
							return func() (_cgo_ret int32) {
								_cgo_addr := &j
								_cgo_ret = *_cgo_addr
								*_cgo_addr++
								return
							}()
						}() {
							if uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(pIdx)) {
								continue
							}
							sqlite3VdbeAddOp2(v, 97, iIdxCur+j, 3)
							addr = sqlite3VdbeAddOp3(v, 53, 8+j, 0, 3)
							sqlite3VdbeChangeP5(v, uint16(144))
							sqlite3VdbeLoadString(v, 4, pIdx.zName)
							sqlite3VdbeAddOp3(v, 111, 4, 2, 3)
							integrityCheckResultRow(v)
							sqlite3VdbeJumpHere(v, addr)
						}
					}
				}
			}
			{
				const iLn int32 = 0
				var endCode [7]struct_VdbeOpList = [7]struct_VdbeOpList{struct_VdbeOpList{uint8(85), int8(1), int8(0), int8(0)}, struct_VdbeOpList{uint8(59), int8(1), int8(4), int8(0)}, struct_VdbeOpList{uint8(117), int8(0), int8(3), int8(0)}, struct_VdbeOpList{uint8(83), int8(3), int8(1), int8(0)}, struct_VdbeOpList{uint8(70), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(117), int8(0), int8(3), int8(0)}, struct_VdbeOpList{uint8(11), int8(0), int8(3), int8(0)}}
				var aOp *struct_VdbeOp
				aOp = sqlite3VdbeAddOpList(v, int32(28/4), (*struct_VdbeOpList)(unsafe.Pointer(&endCode)), iLn)
				if aOp != nil {
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p2 = 1 - mxErr
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(2)*24))).p4type = int8(-1)
					*(**int8)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(2)*24))).p4)) = (*int8)(unsafe.Pointer(&[3]int8{'o', 'k', '\x00'}))
					(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(5)*24))).p4type = int8(-1)
					*(**int8)(unsafe.Pointer(&(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(5)*24))).p4)) = (*int8)(unsafe.Pointer(sqlite3ErrStr(11)))
				}
				sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2)
			}
		}
		break
	case 14:
		{
			type struct_EncName struct {
				zName *int8
				enc   uint8
			}
			var encnames [9]struct_EncName = [9]struct_EncName{struct_EncName{(*int8)(unsafe.Pointer(&[5]int8{'U', 'T', 'F', '8', '\x00'})), uint8(1)}, struct_EncName{(*int8)(unsafe.Pointer(&[6]int8{'U', 'T', 'F', '-', '8', '\x00'})), uint8(1)}, struct_EncName{(*int8)(unsafe.Pointer(&[9]int8{'U', 'T', 'F', '-', '1', '6', 'l', 'e', '\x00'})), uint8(2)}, struct_EncName{(*int8)(unsafe.Pointer(&[9]int8{'U', 'T', 'F', '-', '1', '6', 'b', 'e', '\x00'})), uint8(3)}, struct_EncName{(*int8)(unsafe.Pointer(&[8]int8{'U', 'T', 'F', '1', '6', 'l', 'e', '\x00'})), uint8(2)}, struct_EncName{(*int8)(unsafe.Pointer(&[8]int8{'U', 'T', 'F', '1', '6', 'b', 'e', '\x00'})), uint8(3)}, struct_EncName{(*int8)(unsafe.Pointer(&[7]int8{'U', 'T', 'F', '-', '1', '6', '\x00'})), uint8(0)}, struct_EncName{(*int8)(unsafe.Pointer(&[6]int8{'U', 'T', 'F', '1', '6', '\x00'})), uint8(0)}, struct_EncName{nil, uint8(0)}}
			var pEnc *struct_EncName
			if !(zRight != nil) {
				if sqlite3ReadSchema(pParse) != 0 {
					goto pragma_out
				}
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				returnSingleText(v, (*(*struct_EncName)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_EncName)(unsafe.Pointer(&encnames)))) + uintptr(pParse.db.enc)*9))).zName)
			} else if db.mDbFlags&uint32(64) == uint32(0) {
				for pEnc = &*(*struct_EncName)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_EncName)(unsafe.Pointer(&encnames)))) + uintptr(0)*9)); pEnc.zName != nil; *(*uintptr)(unsafe.Pointer(&pEnc)) += 9 {
					if 0 == sqlite3StrICmp(zRight, pEnc.zName) {
						var enc uint8 = uint8(func() int32 {
							if int32(pEnc.enc) != 0 {
								return int32(pEnc.enc)
							} else {
								return 2
							}
						}())
						(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.enc = enc
						sqlite3SetTextEncoding(db, enc)
						break
					}
				}
				if !(pEnc.zName != nil) {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[25]int8{'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ':', ' ', '%', 's', '\x00'})), zRight)
				}
			}
		}
		break
	case 2:
		{
			var iCookie int32 = int32(pPragma.iArg)
			sqlite3VdbeUsesBtree(v, iDb)
			if zRight != nil && int32(pPragma.mPragFlg)&8 == 0 {
				var setCookie [2]struct_VdbeOpList = [2]struct_VdbeOpList{struct_VdbeOpList{uint8(2), int8(0), int8(1), int8(0)}, struct_VdbeOpList{uint8(99), int8(0), int8(0), int8(0)}}
				var aOp *struct_VdbeOp
				aOp = sqlite3VdbeAddOpList(v, int32(8/4), (*struct_VdbeOpList)(unsafe.Pointer(&setCookie)), 0)
				if 0 != 0 {
					break
				}
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p2 = iCookie
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p3 = sqlite3Atoi(zRight)
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p5 = uint16(1)
			} else {
				var readCookie [3]struct_VdbeOpList = [3]struct_VdbeOpList{struct_VdbeOpList{uint8(2), int8(0), int8(0), int8(0)}, struct_VdbeOpList{uint8(98), int8(0), int8(1), int8(0)}, struct_VdbeOpList{uint8(83), int8(1), int8(1), int8(0)}}
				var aOp *struct_VdbeOp
				aOp = sqlite3VdbeAddOpList(v, int32(12/4), (*struct_VdbeOpList)(unsafe.Pointer(&readCookie)), 0)
				if 0 != 0 {
					break
				}
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(0)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p1 = iDb
				(*(*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(aOp)) + uintptr(1)*24))).p3 = iCookie
				sqlite3VdbeReusable(v)
			}
		}
		break
	case 10:
		{
			var i int32 = 0
			var zOpt *int8
			pParse.nMem = int32(1)
			for uintptr(unsafe.Pointer(func() (_cgo_ret *int8) {
				_cgo_addr := &zOpt
				*_cgo_addr = sqlite3_compileoption_get(func() (_cgo_ret int32) {
					_cgo_addr := &i
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) {
				sqlite3VdbeLoadString(v, 1, zOpt)
				sqlite3VdbeAddOp2(v, 83, 1, 1)
			}
			sqlite3VdbeReusable(v)
		}
		break
	case 43:
		{
			var iBt int32 = func() int32 {
				if pId2.z != nil {
					return iDb
				} else {
					return 10 + 2
				}
			}()
			var eMode int32 = 0
			if zRight != nil {
				if sqlite3StrICmp(zRight, (*int8)(unsafe.Pointer(&[5]int8{'f', 'u', 'l', 'l', '\x00'}))) == 0 {
					eMode = int32(1)
				} else if sqlite3StrICmp(zRight, (*int8)(unsafe.Pointer(&[8]int8{'r', 'e', 's', 't', 'a', 'r', 't', '\x00'}))) == 0 {
					eMode = int32(2)
				} else if sqlite3StrICmp(zRight, (*int8)(unsafe.Pointer(&[9]int8{'t', 'r', 'u', 'n', 'c', 'a', 't', 'e', '\x00'}))) == 0 {
					eMode = int32(3)
				}
			}
			pParse.nMem = int32(3)
			sqlite3VdbeAddOp3(v, 6, iBt, eMode, 1)
			sqlite3VdbeAddOp2(v, 83, 1, 3)
		}
		break
	case 42:
		{
			if zRight != nil {
				sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight))
			}
			returnSingleInt(v, int64(func() int32 {
				if uintptr(unsafe.Pointer(db.xWalCallback)) == uintptr(unsafe.Pointer(sqlite3WalDefaultHook)) {
					return int32(int(db.pWalArg))
				} else {
					return 0
				}
			}()))
		}
		break
	case 34:
		{
			sqlite3_db_release_memory(db)
			break
		}
	case 30:
		{
			var iDbLast int32
			var iTabCur int32
			var k *struct_HashElem
			var pSchema *struct_Schema
			var pTab *struct_Table
			var pIdx *struct_Index
			var szThreshold int16
			var zSubSql *int8
			var opMask uint32
			if zRight != nil {
				opMask = uint32(sqlite3Atoi(zRight))
				if opMask&uint32(2) == uint32(0) {
					break
				}
			} else {
				opMask = uint32(65534)
			}
			iTabCur = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			for iDbLast = func() int32 {
				if zDb != nil {
					return iDb
				} else {
					return db.nDb - 1
				}
			}(); iDb <= iDbLast; iDb++ {
				if iDb == 1 {
					continue
				}
				sqlite3CodeVerifySchema(pParse, iDb)
				pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
				for k = (&pSchema.tblHash).first; k != nil; k = k.next {
					pTab = (*struct_Table)(k.data)
					if pTab.tabFlags&uint32(256) == uint32(0) {
						continue
					}
					szThreshold = int16(int32(pTab.nRowLogEst) + 46)
					func() int {
						_ = 0
						return 0
					}()
					for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
						if !(pIdx.Xbf_0>>7&1 != 0) {
							szThreshold = int16(0)
							break
						}
					}
					if szThreshold != 0 {
						sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 101)
						sqlite3VdbeAddOp3(v, 35, iTabCur, int32(uint32(sqlite3VdbeCurrentAddr(v)+2)+opMask&uint32(1)), int32(szThreshold))
					}
					zSubSql = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[18]int8{'A', 'N', 'A', 'L', 'Y', 'Z', 'E', ' ', '"', '%', 'w', '"', '.', '"', '%', 'w', '"', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, pTab.zName)
					if opMask&uint32(1) != 0 {
						var r1 int32 = sqlite3GetTempReg(pParse)
						sqlite3VdbeAddOp4(v, 117, 0, r1, 0, zSubSql, -7)
						sqlite3VdbeAddOp2(v, 83, r1, 1)
					} else {
						sqlite3VdbeAddOp4(v, 147, 0, 0, 0, zSubSql, -7)
					}
				}
			}
			sqlite3VdbeAddOp0(v, 165)
			break
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			if zRight != nil {
				sqlite3_busy_timeout(db, sqlite3Atoi(zRight))
			}
			returnSingleInt(v, int64(db.busyTimeout))
			break
		}
	case 35:
		{
			var N int64
			if zRight != nil && sqlite3DecOrHexToI64(zRight, &N) == 0 {
				sqlite3_soft_heap_limit64(N)
			}
			returnSingleInt(v, sqlite3_soft_heap_limit64(int64(-1)))
			break
		}
	case 18:
		{
			var N int64
			if zRight != nil && sqlite3DecOrHexToI64(zRight, &N) == 0 {
				var iPrior int64 = sqlite3_hard_heap_limit64(int64(-1))
				if N > int64(0) && (iPrior == int64(0) || iPrior > N) {
					sqlite3_hard_heap_limit64(N)
				}
			}
			returnSingleInt(v, sqlite3_hard_heap_limit64(int64(-1)))
			break
		}
	case 41:
		{
			var N int64
			if zRight != nil && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= int64(0) {
				sqlite3_limit(db, 11, int32(N&int64(2147483647)))
			}
			returnSingleInt(v, int64(sqlite3_limit(db, 11, -1)))
			break
		}
	case 1:
		{
			var N int64
			if zRight != nil && sqlite3DecOrHexToI64(zRight, &N) == 0 && N >= int64(0) {
				db.nAnalysisLimit = int32(N & int64(2147483647))
			}
			returnSingleInt(v, int64(db.nAnalysisLimit))
			break
		}
	}
	if int32(pPragma.mPragFlg)&4 != 0 && zRight != nil {
	}
pragma_out:
	sqlite3DbFree(db, unsafe.Pointer(zLeft))
	sqlite3DbFree(db, unsafe.Pointer(zRight))
}

type PragmaVtab = struct_PragmaVtab
type PragmaVtabCursor = struct_PragmaVtabCursor
type struct_PragmaVtab struct {
	base    struct_sqlite3_vtab
	db      *struct_sqlite3
	pName   *struct_PragmaName
	nHidden uint8
	iHidden uint8
}
type struct_PragmaVtabCursor struct {
	base    struct_sqlite3_vtab_cursor
	pPragma *struct_sqlite3_stmt
	iRowid  int64
	azArg   [2]*int8
}

func pragmaVtabConnect(db *struct_sqlite3, pAux unsafe.Pointer, argc int32, argv **int8, ppVtab **struct_sqlite3_vtab, pzErr **int8) int32 {
	var pPragma *struct_PragmaName = (*struct_PragmaName)(pAux)
	var pTab *struct_PragmaVtab = nil
	var rc int32
	var i int32
	var j int32
	var cSep int8 = int8('(')
	var acc struct_sqlite3_str
	var zBuf [200]int8
	func() int {
		_ = argc
		return 0
	}()
	func() int {
		_ = argv
		return 0
	}()
	sqlite3StrAccumInit(&acc, nil, (*int8)(unsafe.Pointer(&zBuf)), int32(200), 0)
	sqlite3_str_appendall(&acc, (*int8)(unsafe.Pointer(&[15]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'A', 'B', 'L', 'E', ' ', 'x', '\x00'})))
	for func() int32 {
		i = int32(0)
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = int32(pPragma.iPragCName)
			return *_cgo_addr
		}()
	}(); i < int32(pPragma.nPragCName); func() int32 {
		i++
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		sqlite3_str_appendf(&acc, (*int8)(unsafe.Pointer(&[7]int8{'%', 'c', '"', '%', 's', '"', '\x00'})), int32(cSep), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pragCName)))) + uintptr(j)*8)))
		cSep = int8(',')
	}
	if i == 0 {
		sqlite3_str_appendf(&acc, (*int8)(unsafe.Pointer(&[6]int8{'(', '"', '%', 's', '"', '\x00'})), pPragma.zName)
		i++
	}
	j = int32(0)
	if int32(pPragma.mPragFlg)&32 != 0 {
		sqlite3_str_appendall(&acc, (*int8)(unsafe.Pointer(&[12]int8{',', 'a', 'r', 'g', ' ', 'H', 'I', 'D', 'D', 'E', 'N', '\x00'})))
		j++
	}
	if int32(pPragma.mPragFlg)&(64|128) != 0 {
		sqlite3_str_appendall(&acc, (*int8)(unsafe.Pointer(&[15]int8{',', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'H', 'I', 'D', 'D', 'E', 'N', '\x00'})))
		j++
	}
	sqlite3_str_append(&acc, (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'})), 1)
	sqlite3StrAccumFinish(&acc)
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3_declare_vtab(db, (*int8)(unsafe.Pointer(&zBuf)))
	if rc == 0 {
		pTab = (*struct_PragmaVtab)(sqlite3_malloc(int32(42)))
		if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
			rc = int32(7)
		} else {
			__builtin___memset_chk(unsafe.Pointer(pTab), 0, 42, __builtin_object_size(unsafe.Pointer(pTab), 0))
			pTab.pName = pPragma
			pTab.db = db
			pTab.iHidden = uint8(i)
			pTab.nHidden = uint8(j)
		}
	} else {
		*pzErr = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_errmsg(db))
	}
	*ppVtab = (*struct_sqlite3_vtab)(unsafe.Pointer(pTab))
	return rc
}
func pragmaVtabDisconnect(pVtab *struct_sqlite3_vtab) int32 {
	var pTab *struct_PragmaVtab = (*struct_PragmaVtab)(unsafe.Pointer(pVtab))
	sqlite3_free(unsafe.Pointer(pTab))
	return int32(0)
}
func pragmaVtabBestIndex(tab *struct_sqlite3_vtab, pIdxInfo *struct_sqlite3_index_info) int32 {
	var pTab *struct_PragmaVtab = (*struct_PragmaVtab)(unsafe.Pointer(tab))
	var pConstraint *struct_sqlite3_index_constraint
	var i int32
	var j int32
	var seen [2]int32
	pIdxInfo.estimatedCost = float64(1)
	if int32(pTab.nHidden) == 0 {
		return int32(0)
	}
	pConstraint = pIdxInfo.aConstraint
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(0)*4)) = int32(0)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(1)*4)) = int32(0)
	for i = int32(0); i < pIdxInfo.nConstraint; func() *struct_sqlite3_index_constraint {
		i++
		return func() (_cgo_ret *struct_sqlite3_index_constraint) {
			_cgo_addr := &pConstraint
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 12
			return
		}()
	}() {
		if int32(pConstraint.usable) == 0 {
			continue
		}
		if int32(pConstraint.op) != 2 {
			continue
		}
		if pConstraint.iColumn < int32(pTab.iHidden) {
			continue
		}
		j = pConstraint.iColumn - int32(pTab.iHidden)
		func() int {
			_ = 0
			return 0
		}()
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(j)*4)) = i + 1
	}
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(0)*4)) == 0 {
		pIdxInfo.estimatedCost = float64(2147483647)
		pIdxInfo.estimatedRows = int64(2147483647)
		return int32(0)
	}
	j = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(0)*4)) - 1
	(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(j)*5))).argvIndex = int32(1)
	(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(j)*5))).omit = uint8(1)
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(1)*4)) == 0 {
		return int32(0)
	}
	pIdxInfo.estimatedCost = float64(20)
	pIdxInfo.estimatedRows = int64(20)
	j = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&seen)))) + uintptr(1)*4)) - 1
	(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(j)*5))).argvIndex = int32(2)
	(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(j)*5))).omit = uint8(1)
	return int32(0)
}
func pragmaVtabOpen(pVtab *struct_sqlite3_vtab, ppCursor **struct_sqlite3_vtab_cursor) int32 {
	var pCsr *struct_PragmaVtabCursor
	pCsr = (*struct_PragmaVtabCursor)(sqlite3_malloc(int32(40)))
	if uintptr(unsafe.Pointer(pCsr)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(pCsr), 0, 40, __builtin_object_size(unsafe.Pointer(pCsr), 0))
	pCsr.base.pVtab = pVtab
	*ppCursor = &pCsr.base
	return int32(0)
}
func pragmaVtabCursorClear(pCsr *struct_PragmaVtabCursor) {
	var i int32
	sqlite3_finalize(pCsr.pPragma)
	pCsr.pPragma = (*struct_sqlite3_stmt)(nil)
	for i = int32(0); i < int32(16/8); i++ {
		sqlite3_free(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(i)*8))))
		*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(i)*8)) = (*int8)(nil)
	}
}
func pragmaVtabClose(cur *struct_sqlite3_vtab_cursor) int32 {
	var pCsr *struct_PragmaVtabCursor = (*struct_PragmaVtabCursor)(unsafe.Pointer(cur))
	pragmaVtabCursorClear(pCsr)
	sqlite3_free(unsafe.Pointer(pCsr))
	return int32(0)
}
func pragmaVtabNext(pVtabCursor *struct_sqlite3_vtab_cursor) int32 {
	var pCsr *struct_PragmaVtabCursor = (*struct_PragmaVtabCursor)(unsafe.Pointer(pVtabCursor))
	var rc int32 = 0
	pCsr.iRowid++
	func() int {
		_ = 0
		return 0
	}()
	if 100 != sqlite3_step(pCsr.pPragma) {
		rc = sqlite3_finalize(pCsr.pPragma)
		pCsr.pPragma = (*struct_sqlite3_stmt)(nil)
		pragmaVtabCursorClear(pCsr)
	}
	return rc
}
func pragmaVtabFilter(pVtabCursor *struct_sqlite3_vtab_cursor, idxNum int32, idxStr *int8, argc int32, argv **struct_sqlite3_value) int32 {
	var pCsr *struct_PragmaVtabCursor = (*struct_PragmaVtabCursor)(unsafe.Pointer(pVtabCursor))
	var pTab *struct_PragmaVtab = (*struct_PragmaVtab)(unsafe.Pointer(pVtabCursor.pVtab))
	var rc int32
	var i int32
	var j int32
	var acc struct_sqlite3_str
	var zSql *int8
	func() int {
		_ = idxNum
		return 0
	}()
	func() int {
		_ = idxStr
		return 0
	}()
	pragmaVtabCursorClear(pCsr)
	j = func() int32 {
		if int32(pTab.pName.mPragFlg)&32 != 0 {
			return 0
		} else {
			return 1
		}
	}()
	for i = int32(0); i < argc; func() int32 {
		i++
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		var zText *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if zText != nil {
			*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(j)*8)) = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zText)
			if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(j)*8)))) == uintptr(unsafe.Pointer(nil)) {
				return int32(7)
			}
		}
	}
	sqlite3StrAccumInit(&acc, nil, nil, 0, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pTab.db.aLimit)))) + uintptr(1)*4)))
	sqlite3_str_appendall(&acc, (*int8)(unsafe.Pointer(&[8]int8{'P', 'R', 'A', 'G', 'M', 'A', ' ', '\x00'})))
	if *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(1)*8)) != nil {
		sqlite3_str_appendf(&acc, (*int8)(unsafe.Pointer(&[4]int8{'%', 'Q', '.', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(1)*8)))
	}
	sqlite3_str_appendall(&acc, pTab.pName.zName)
	if *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(0)*8)) != nil {
		sqlite3_str_appendf(&acc, (*int8)(unsafe.Pointer(&[4]int8{'=', '%', 'Q', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(0)*8)))
	}
	zSql = sqlite3StrAccumFinish(&acc)
	if uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	rc = sqlite3_prepare_v2(pTab.db, zSql, -1, &pCsr.pPragma, nil)
	sqlite3_free(unsafe.Pointer(zSql))
	if rc != 0 {
		pTab.base.zErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3_errmsg(pTab.db))
		return rc
	}
	return pragmaVtabNext(pVtabCursor)
}
func pragmaVtabEof(pVtabCursor *struct_sqlite3_vtab_cursor) int32 {
	var pCsr *struct_PragmaVtabCursor = (*struct_PragmaVtabCursor)(unsafe.Pointer(pVtabCursor))
	return func() int32 {
		if uintptr(unsafe.Pointer(pCsr.pPragma)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
}
func pragmaVtabColumn(pVtabCursor *struct_sqlite3_vtab_cursor, ctx *struct_sqlite3_context, i int32) int32 {
	var pCsr *struct_PragmaVtabCursor = (*struct_PragmaVtabCursor)(unsafe.Pointer(pVtabCursor))
	var pTab *struct_PragmaVtab = (*struct_PragmaVtab)(unsafe.Pointer(pVtabCursor.pVtab))
	if i < int32(pTab.iHidden) {
		sqlite3_result_value(ctx, sqlite3_column_value(pCsr.pPragma, i))
	} else {
		sqlite3_result_text(ctx, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&pCsr.azArg)))) + uintptr(i-int32(pTab.iHidden))*8)), -1, (func(unsafe.Pointer))(-1))
	}
	return int32(0)
}
func pragmaVtabRowid(pVtabCursor *struct_sqlite3_vtab_cursor, p *int64) int32 {
	var pCsr *struct_PragmaVtabCursor = (*struct_PragmaVtabCursor)(unsafe.Pointer(pVtabCursor))
	*p = pCsr.iRowid
	return int32(0)
}

var pragmaVtabModule struct_sqlite3_module = struct_sqlite3_module{0, nil, pragmaVtabConnect, pragmaVtabBestIndex, pragmaVtabDisconnect, nil, pragmaVtabOpen, pragmaVtabClose, pragmaVtabFilter, pragmaVtabNext, pragmaVtabEof, pragmaVtabColumn, pragmaVtabRowid, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil}

func sqlite3PragmaVtabRegister(db *struct_sqlite3, zName *int8) *struct_Module {
	var pName *struct_PragmaName
	func() int {
		_ = 0
		return 0
	}()
	pName = pragmaLocate((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(7))))
	if uintptr(unsafe.Pointer(pName)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_Module)(nil)
	}
	if int32(pName.mPragFlg)&(16|32) == 0 {
		return (*struct_Module)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3VtabCreateModule(db, zName, &pragmaVtabModule, unsafe.Pointer(pName), nil)
}
func corruptSchema(pData *_cgoa_26, azObj **int8, zExtra *int8) {
	var db *struct_sqlite3 = pData.db
	if db.mallocFailed != 0 {
		pData.rc = int32(7)
	} else if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pData.pzErrMsg)) + uintptr(0)*8)))) != uintptr(unsafe.Pointer(nil)) {
	} else if pData.mInitFlags&uint32(3) != 0 {
		var azAlterType [3]*int8 = [3]*int8{(*int8)(unsafe.Pointer(&[7]int8{'r', 'e', 'n', 'a', 'm', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'d', 'r', 'o', 'p', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[11]int8{'a', 'd', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', '\x00'}))}
		*pData.pzErrMsg = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[28]int8{'e', 'r', 'r', 'o', 'r', ' ', 'i', 'n', ' ', '%', 's', ' ', '%', 's', ' ', 'a', 'f', 't', 'e', 'r', ' ', '%', 's', ':', ' ', '%', 's', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azObj)) + uintptr(0)*8)), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azObj)) + uintptr(1)*8)), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azAlterType)))) + uintptr(pData.mInitFlags&uint32(3)-uint32(1))*8)), zExtra)
		pData.rc = int32(1)
	} else if db.flags&uint64(1) != 0 {
		pData.rc = sqlite3CorruptError(133208)
	} else {
		var z *int8
		var zObj *int8 = func() *int8 {
			if *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azObj)) + uintptr(1)*8)) != nil {
				return *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azObj)) + uintptr(1)*8))
			} else {
				return (*int8)(unsafe.Pointer(&[2]int8{'?', '\x00'}))
			}
		}()
		z = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[31]int8{'m', 'a', 'l', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 's', 'c', 'h', 'e', 'm', 'a', ' ', '(', '%', 's', ')', '\x00'})), zObj)
		if zExtra != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zExtra)) + uintptr(0)))) != 0 {
			z = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[8]int8{'%', 'z', ' ', '-', ' ', '%', 's', '\x00'})), z, zExtra)
		}
		*pData.pzErrMsg = z
		pData.rc = sqlite3CorruptError(133215)
	}
}
func sqlite3IndexHasDuplicateRootPage(pIndex *struct_Index) int32 {
	var p *struct_Index
	for p = pIndex.pTable.pIndex; p != nil; p = p.pNext {
		if p.tnum == pIndex.tnum && uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(pIndex)) {
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3InitCallback(pInit unsafe.Pointer, argc int32, argv **int8, NotUsed **int8) int32 {
	var pData *_cgoa_26 = (*_cgoa_26)(pInit)
	var db *struct_sqlite3 = pData.db
	var iDb int32 = pData.iDb
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = argc
			return 0
		}()
	}()
	func() int {
		_ = 0
		return 0
	}()
	db.mDbFlags |= uint32(64)
	if uintptr(unsafe.Pointer(argv)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	pData.nInitRow++
	if db.mallocFailed != 0 {
		corruptSchema(pData, argv, nil)
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)))) == uintptr(unsafe.Pointer(nil)) {
		corruptSchema(pData, argv, nil)
	} else if *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)) != nil && 'c' == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))) + uintptr(0)))))))) && 'r' == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))) + uintptr(1)))))))) {
		var rc int32
		var saved_iDb uint8 = db.init.iDb
		var pStmt *struct_sqlite3_stmt
		func() int {
			_ = 0
			return 0
		}()
		db.init.iDb = uint8(iDb)
		if sqlite3GetUInt32(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)), &db.init.newTnum) == 0 || db.init.newTnum > pData.mxPage && pData.mxPage > uint32(0) {
			if sqlite3Config.bExtraSchemaChecks != 0 {
				corruptSchema(pData, argv, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '\x00'})))
			}
		}
		{
			_autoGo_74 := &db.init.Xbf_0
			*_autoGo_74 = *_autoGo_74&^1 | uint32(0)&1
		}
		db.init.azInit = (**int8)(unsafe.Pointer(argv))
		pStmt = (*struct_sqlite3_stmt)(nil)
		sqlite3Prepare(db, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)), -1, uint32(0), nil, &pStmt, nil)
		rc = db.errCode
		func() int {
			_ = 0
			return 0
		}()
		db.init.iDb = saved_iDb
		if 0 != rc {
			if db.init.Xbf_0&1 != 0 {
				func() int {
					_ = 0
					return 0
				}()
			} else {
				if rc > pData.rc {
					pData.rc = rc
				}
				if rc == 7 {
					sqlite3OomFault(db)
				} else if rc != 9 && rc&255 != 6 {
					corruptSchema(pData, argv, sqlite3_errmsg(db))
				}
			}
		}
		db.init.azInit = (**int8)(unsafe.Pointer(&sqlite3StdType))
		sqlite3_finalize(pStmt)
	} else if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))) != uintptr(unsafe.Pointer(nil)) && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(4)*8)))) + uintptr(0)))) != 0 {
		corruptSchema(pData, argv, nil)
	} else {
		var pIndex *struct_Index
		pIndex = sqlite3FindIndex(db, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName)
		if uintptr(unsafe.Pointer(pIndex)) == uintptr(unsafe.Pointer(nil)) {
			corruptSchema(pData, argv, (*int8)(unsafe.Pointer(&[13]int8{'o', 'r', 'p', 'h', 'a', 'n', ' ', 'i', 'n', 'd', 'e', 'x', '\x00'})))
		} else if sqlite3GetUInt32(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(3)*8)), &pIndex.tnum) == 0 || pIndex.tnum < uint32(2) || pIndex.tnum > pData.mxPage || sqlite3IndexHasDuplicateRootPage(pIndex) != 0 {
			if sqlite3Config.bExtraSchemaChecks != 0 {
				corruptSchema(pData, argv, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '\x00'})))
			}
		}
	}
	return int32(0)
}
func sqlite3InitOne(db *struct_sqlite3, iDb int32, pzErrMsg **int8, mFlags uint32) int32 {
	var rc int32
	var i int32
	var size int32
	var pDb *struct_Db
	var azArg [6]*int8
	var meta [5]int32
	var initData _cgoa_26
	var zSchemaTabName *int8
	var openedTransaction int32 = 0
	var mask int32 = int32(db.mDbFlags&uint32(64) | uint32(4294967231))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db.init.busy = uint8(1)
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(0)*8)) = (*int8)(unsafe.Pointer(&[6]int8{'t', 'a', 'b', 'l', 'e', '\x00'}))
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(1)*8)) = func() (_cgo_ret *int8) {
		_cgo_addr := &zSchemaTabName
		*_cgo_addr = func() *int8 {
			if true && iDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}()
		return *_cgo_addr
	}()
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(2)*8)) = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(1)*8))
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(3)*8)) = (*int8)(unsafe.Pointer(&[2]int8{'1', '\x00'}))
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(4)*8)) = (*int8)(unsafe.Pointer(&[72]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'A', 'B', 'L', 'E', ' ', 'x', '(', 't', 'y', 'p', 'e', ' ', 't', 'e', 'x', 't', ',', 'n', 'a', 'm', 'e', ' ', 't', 'e', 'x', 't', ',', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', ' ', 't', 'e', 'x', 't', ',', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', ' ', 'i', 'n', 't', ',', 's', 'q', 'l', ' ', 't', 'e', 'x', 't', ')', '\x00'}))
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))) + uintptr(5)*8)) = (*int8)(nil)
	initData.db = db
	initData.iDb = iDb
	initData.rc = int32(0)
	initData.pzErrMsg = pzErrMsg
	initData.mInitFlags = mFlags
	initData.nInitRow = uint32(0)
	initData.mxPage = uint32(0)
	sqlite3InitCallback(unsafe.Pointer(&initData), 5, (**int8)(unsafe.Pointer((**int8)(unsafe.Pointer(&azArg)))), nil)
	db.mDbFlags &= uint32(mask)
	if initData.rc != 0 {
		rc = initData.rc
		goto error_out
	}
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	if uintptr(unsafe.Pointer(pDb.pBt)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema.schemaFlags |= uint16(1)
		rc = int32(0)
		goto error_out
	}
	sqlite3BtreeEnter(pDb.pBt)
	if sqlite3BtreeTxnState(pDb.pBt) == 0 {
		rc = sqlite3BtreeBeginTrans(pDb.pBt, 0, nil)
		if rc != 0 {
			sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc))
			goto initone_error_out
		}
		openedTransaction = int32(1)
	}
	for i = int32(0); i < int32(20/4); i++ {
		sqlite3BtreeGetMeta(pDb.pBt, i+1, (*uint32)(unsafe.Pointer(&*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(i)*4)))))
	}
	if db.flags&uint64(33554432) != uint64(0) {
		__builtin___memset_chk(unsafe.Pointer((*int32)(unsafe.Pointer(&meta))), 0, 20, __builtin_object_size(unsafe.Pointer((*int32)(unsafe.Pointer(&meta))), 0))
	}
	pDb.pSchema.schema_cookie = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(1-1)*4))
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(5-1)*4)) != 0 {
		if iDb == 0 && db.mDbFlags&uint32(64) == uint32(0) {
			var encoding uint8
			encoding = uint8(int32(uint8(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(5-1)*4)))) & 3)
			if int32(encoding) == 0 {
				encoding = uint8(1)
			}
			sqlite3SetTextEncoding(db, encoding)
		} else if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(5-1)*4))&3 != int32(db.enc) {
			sqlite3SetString(pzErrMsg, db, (*int8)(unsafe.Pointer(&[68]int8{'a', 't', 't', 'a', 'c', 'h', 'e', 'd', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', 's', ' ', 'm', 'u', 's', 't', ' ', 'u', 's', 'e', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 't', 'e', 'x', 't', ' ', 'e', 'n', 'c', 'o', 'd', 'i', 'n', 'g', ' ', 'a', 's', ' ', 'm', 'a', 'i', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})))
			rc = int32(1)
			goto initone_error_out
		}
	}
	pDb.pSchema.enc = db.enc
	if pDb.pSchema.cache_size == 0 {
		size = sqlite3AbsInt32(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(3-1)*4)))
		if size == 0 {
			size = int32(-2000)
		}
		pDb.pSchema.cache_size = size
		sqlite3BtreeSetCacheSize(pDb.pBt, pDb.pSchema.cache_size)
	}
	pDb.pSchema.file_format = uint8(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(2-1)*4)))
	if int32(pDb.pSchema.file_format) == 0 {
		pDb.pSchema.file_format = uint8(1)
	}
	if int32(pDb.pSchema.file_format) > 4 {
		sqlite3SetString(pzErrMsg, db, (*int8)(unsafe.Pointer(&[24]int8{'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'i', 'l', 'e', ' ', 'f', 'o', 'r', 'm', 'a', 't', '\x00'})))
		rc = int32(1)
		goto initone_error_out
	}
	if iDb == 0 && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&meta)))) + uintptr(2-1)*4)) >= 4 {
		db.flags &= ^uint64(2)
	}
	func() int {
		_ = 0
		return 0
	}()
	initData.mxPage = sqlite3BtreeLastPage(pDb.pBt)
	{
		var zSql *int8
		zSql = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[34]int8{'S', 'E', 'L', 'E', 'C', 'T', '*', 'F', 'R', 'O', 'M', '"', '%', 'w', '"', '.', '%', 's', ' ', 'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', ' ', 'r', 'o', 'w', 'i', 'd', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, zSchemaTabName)
		{
			var xAuth func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32
			xAuth = db.xAuth
			db.xAuth = (func(unsafe.Pointer, int32, *int8, *int8, *int8, *int8) int32)(nil)
			rc = sqlite3_exec(db, zSql, sqlite3InitCallback, unsafe.Pointer(&initData), nil)
			db.xAuth = xAuth
		}
		if rc == 0 {
			rc = initData.rc
		}
		sqlite3DbFree(db, unsafe.Pointer(zSql))
		if rc == 0 {
			sqlite3AnalysisLoad(db, iDb)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		rc = int32(7)
		sqlite3ResetAllSchemasOfConnection(db)
		pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))
	} else if rc == 0 || db.flags&uint64(134217728) != 0 && rc != 7 {
		(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.schemaFlags |= uint16(1)
		rc = int32(0)
	}
initone_error_out:
	if openedTransaction != 0 {
		sqlite3BtreeCommit(pDb.pBt)
	}
	sqlite3BtreeLeave(pDb.pBt)
error_out:
	if rc != 0 {
		if rc == 7 || rc == 10|12<<8 {
			sqlite3OomFault(db)
		}
		sqlite3ResetOneSchema(db, iDb)
	}
	db.init.busy = uint8(0)
	return rc
}
func sqlite3Init(db *struct_sqlite3, pzErrMsg **int8) int32 {
	var i int32
	var rc int32
	var commit_internal int32 = func() int32 {
		if !(db.mDbFlags&uint32(1) != 0) {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db.enc = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.enc
	func() int {
		_ = 0
		return 0
	}()
	if !(int32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.schemaFlags)&1 == 1) {
		rc = sqlite3InitOne(db, 0, pzErrMsg, uint32(0))
		if rc != 0 {
			return rc
		}
	}
	for i = db.nDb - 1; i > 0; i-- {
		func() int {
			_ = 0
			return 0
		}()
		if !(int32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema.schemaFlags)&1 == 1) {
			rc = sqlite3InitOne(db, i, pzErrMsg, uint32(0))
			if rc != 0 {
				return rc
			}
		}
	}
	if commit_internal != 0 {
		sqlite3CommitInternalChanges(db)
	}
	return int32(0)
}
func sqlite3ReadSchema(pParse *struct_Parse) int32 {
	var rc int32 = 0
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if !(db.init.busy != 0) {
		rc = sqlite3Init(db, &pParse.zErrMsg)
		if rc != 0 {
			pParse.rc = rc
			pParse.nErr++
		} else if db.noSharedCache != 0 {
			db.mDbFlags |= uint32(16)
		}
	}
	return rc
}
func schemaIsValid(pParse *struct_Parse) {
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	var rc int32
	var cookie int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for iDb = int32(0); iDb < db.nDb; iDb++ {
		var openedTransaction int32 = 0
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt
		if uintptr(unsafe.Pointer(pBt)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if sqlite3BtreeTxnState(pBt) == 0 {
			rc = sqlite3BtreeBeginTrans(pBt, 0, nil)
			if rc == 7 || rc == 10|12<<8 {
				sqlite3OomFault(db)
				pParse.rc = int32(7)
			}
			if rc != 0 {
				return
			}
			openedTransaction = int32(1)
		}
		sqlite3BtreeGetMeta(pBt, 1, (*uint32)(unsafe.Pointer(&cookie)))
		func() int {
			_ = 0
			return 0
		}()
		if cookie != (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.schema_cookie {
			sqlite3ResetOneSchema(db, iDb)
			pParse.rc = int32(17)
		}
		if openedTransaction != 0 {
			sqlite3BtreeCommit(pBt)
		}
	}
}
func sqlite3SchemaToIndex(db *struct_sqlite3, pSchema *struct_Schema) int32 {
	var i int32 = -32768
	func() int {
		_ = 0
		return 0
	}()
	if pSchema != nil {
		for i = int32(0); 1 != 0; i++ {
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema)) == uintptr(unsafe.Pointer(pSchema)) {
				break
			}
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	return i
}
func sqlite3ParseObjectReset(pParse *struct_Parse) {
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3DbFree(db, unsafe.Pointer(pParse.aTableLock))
	for pParse.pCleanup != nil {
		var pCleanup *struct_ParseCleanup = pParse.pCleanup
		pParse.pCleanup = pCleanup.pNext
		pCleanup.xCleanup(db, pCleanup.pPtr)
		sqlite3DbFreeNN(db, unsafe.Pointer(pCleanup))
	}
	sqlite3DbFree(db, unsafe.Pointer(pParse.aLabel))
	if pParse.pConstExpr != nil {
		sqlite3ExprListDelete(db, pParse.pConstExpr)
	}
	func() int {
		_ = 0
		return 0
	}()
	db.lookaside.bDisable -= uint32(pParse.disableLookaside)
	db.lookaside.sz = uint16(func() int32 {
		if db.lookaside.bDisable != 0 {
			return 0
		} else {
			return int32(db.lookaside.szTrue)
		}
	}())
	func() int {
		_ = 0
		return 0
	}()
	db.pParse = pParse.pOuterParse
	pParse.db = (*struct_sqlite3)(nil)
	pParse.disableLookaside = uint8(0)
}
func sqlite3ParserAddCleanup(pParse *struct_Parse, xCleanup func(*struct_sqlite3, unsafe.Pointer), pPtr unsafe.Pointer) unsafe.Pointer {
	var pCleanup *struct_ParseCleanup = (*struct_ParseCleanup)(sqlite3DbMallocRaw(pParse.db, uint64(24)))
	if pCleanup != nil {
		pCleanup.pNext = pParse.pCleanup
		pParse.pCleanup = pCleanup
		pCleanup.pPtr = pPtr
		pCleanup.xCleanup = xCleanup
	} else {
		xCleanup(pParse.db, pPtr)
		pPtr = unsafe.Pointer(nil)
	}
	return pPtr
}
func sqlite3ParseObjectInit(pParse *struct_Parse, db *struct_sqlite3) {
	__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(8)))), 0, 208-8, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(8)))), 0))
	__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), 0, 392-264, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pParse))))+uintptr(264)))), 0))
	func() int {
		_ = 0
		return 0
	}()
	pParse.pOuterParse = db.pParse
	db.pParse = pParse
	pParse.db = db
	if db.mallocFailed != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
	}
}
func sqlite3Prepare(db *struct_sqlite3, zSql *int8, nBytes int32, prepFlags uint32, pReprepare *struct_Vdbe, ppStmt **struct_sqlite3_stmt, pzTail **int8) int32 {
	var rc int32 = 0
	var i int32
	var sParse struct_Parse
	__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sParse))))+uintptr(8)))), 0, 208-8, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sParse))))+uintptr(8)))), 0))
	__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sParse))))+uintptr(264)))), 0, 392-264, __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&sParse))))+uintptr(264)))), 0))
	sParse.pOuterParse = db.pParse
	db.pParse = &sParse
	sParse.db = db
	sParse.pReprepare = pReprepare
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		sqlite3ErrorMsg(&sParse, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
	}
	func() int {
		_ = 0
		return 0
	}()
	if prepFlags&uint32(1) != 0 {
		sParse.disableLookaside++
		db.lookaside.bDisable++
		db.lookaside.sz = uint16(0)
	}
	sParse.disableVtab = func() uint8 {
		if prepFlags&uint32(4) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	if !(db.noSharedCache != 0) {
		for i = int32(0); i < db.nDb; i++ {
			var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
			if pBt != nil {
				func() int {
					_ = 0
					return 0
				}()
				rc = sqlite3BtreeSchemaLocked(pBt)
				if rc != 0 {
					var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).zDbSName
					sqlite3ErrorWithMsg(db, rc, (*int8)(unsafe.Pointer(&[30]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'i', 's', ' ', 'l', 'o', 'c', 'k', 'e', 'd', ':', ' ', '%', 's', '\x00'})), zDb)
					goto end_prepare
				}
			}
		}
	}
	sqlite3VtabUnlockList(db)
	if nBytes >= 0 && (nBytes == 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(nBytes-1)))) != 0) {
		var zSqlCopy *int8
		var mxLen int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(1)*4))
		if nBytes > mxLen {
			sqlite3ErrorWithMsg(db, 18, (*int8)(unsafe.Pointer(&[19]int8{'s', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', ' ', 't', 'o', 'o', ' ', 'l', 'o', 'n', 'g', '\x00'})))
			rc = sqlite3ApiExit(db, 18)
			goto end_prepare
		}
		zSqlCopy = sqlite3DbStrNDup(db, zSql, uint64(nBytes))
		if zSqlCopy != nil {
			sqlite3RunParser(&sParse, zSqlCopy)
			sParse.zTail = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + (uintptr(unsafe.Pointer(sParse.zTail)) - uintptr(unsafe.Pointer(zSqlCopy)))))
			sqlite3DbFree(db, unsafe.Pointer(zSqlCopy))
		} else {
			sParse.zTail = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(nBytes)))
		}
	} else {
		sqlite3RunParser(&sParse, zSql)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pzTail != nil {
		*pzTail = sParse.zTail
	}
	if int32(db.init.busy) == 0 {
		sqlite3VdbeSetSql(sParse.pVdbe, zSql, int32(uintptr(unsafe.Pointer(sParse.zTail))-uintptr(unsafe.Pointer(zSql))), uint8(prepFlags))
	}
	if db.mallocFailed != 0 {
		sParse.rc = int32(7)
		sParse.checkSchema = uint8(0)
	}
	if sParse.rc != 0 && sParse.rc != 101 {
		if int32(sParse.checkSchema) != 0 && int32(db.init.busy) == 0 {
			schemaIsValid(&sParse)
		}
		if sParse.pVdbe != nil {
			sqlite3VdbeFinalize(sParse.pVdbe)
		}
		func() int {
			_ = 0
			return 0
		}()
		rc = sParse.rc
		if sParse.zErrMsg != nil {
			sqlite3ErrorWithMsg(db, rc, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sParse.zErrMsg)
			sqlite3DbFree(db, unsafe.Pointer(sParse.zErrMsg))
		} else {
			sqlite3Error(db, rc)
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		*ppStmt = (*struct_sqlite3_stmt)(unsafe.Pointer(sParse.pVdbe))
		rc = int32(0)
		sqlite3ErrorClear(db)
	}
	for sParse.pTriggerPrg != nil {
		var pT *struct_TriggerPrg = sParse.pTriggerPrg
		sParse.pTriggerPrg = pT.pNext
		sqlite3DbFree(db, unsafe.Pointer(pT))
	}
end_prepare:
	sqlite3ParseObjectReset(&sParse)
	return rc
}
func sqlite3LockAndPrepare(db *struct_sqlite3, zSql *int8, nBytes int32, prepFlags uint32, pOld *struct_Vdbe, ppStmt **struct_sqlite3_stmt, pzTail **int8) int32 {
	var rc int32
	var cnt int32 = 0
	*ppStmt = (*struct_sqlite3_stmt)(nil)
	if !(sqlite3SafetyCheckOk(db) != 0) || uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3MisuseError(133992)
	}
	sqlite3_mutex_enter(db.mutex)
	sqlite3BtreeEnterAll(db)
	for {
		rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail)
		func() int {
			_ = 0
			return 0
		}()
		if rc == 0 || int32(db.mallocFailed) != 0 {
			break
		}
		if !(rc == 1|2<<8 || rc == 17 && func() int32 {
			sqlite3ResetOneSchema(db, -1)
			return func() (_cgo_ret int32) {
				_cgo_addr := &cnt
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
		}() == 0) {
			break
		}
	}
	sqlite3BtreeLeaveAll(db)
	rc = sqlite3ApiExit(db, rc)
	func() int {
		_ = 0
		return 0
	}()
	db.busyHandler.nBusy = int32(0)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3Reprepare(p *struct_Vdbe) int32 {
	var rc int32
	var pNew *struct_sqlite3_stmt
	var zSql *int8
	var db *struct_sqlite3
	var prepFlags uint8
	func() int {
		_ = 0
		return 0
	}()
	zSql = sqlite3_sql((*struct_sqlite3_stmt)(unsafe.Pointer(p)))
	func() int {
		_ = 0
		return 0
	}()
	db = sqlite3VdbeDb(p)
	func() int {
		_ = 0
		return 0
	}()
	prepFlags = sqlite3VdbePrepareFlags(p)
	rc = sqlite3LockAndPrepare(db, zSql, -1, uint32(prepFlags), p, &pNew, nil)
	if rc != 0 {
		if rc == 7 {
			sqlite3OomFault(db)
		}
		func() int {
			_ = 0
			return 0
		}()
		return rc
	} else {
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3VdbeSwap((*struct_Vdbe)(unsafe.Pointer(pNew)), p)
	sqlite3TransferBindings(pNew, (*struct_sqlite3_stmt)(unsafe.Pointer(p)))
	sqlite3VdbeResetStepResult((*struct_Vdbe)(unsafe.Pointer(pNew)))
	sqlite3VdbeFinalize((*struct_Vdbe)(unsafe.Pointer(pNew)))
	return int32(0)
}
func sqlite3_prepare(db *struct_sqlite3, zSql *int8, nBytes int32, ppStmt **struct_sqlite3_stmt, pzTail **int8) int32 {
	var rc int32
	rc = sqlite3LockAndPrepare(db, zSql, nBytes, uint32(0), nil, ppStmt, pzTail)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3_prepare_v2(db *struct_sqlite3, zSql *int8, nBytes int32, ppStmt **struct_sqlite3_stmt, pzTail **int8) int32 {
	var rc int32
	rc = sqlite3LockAndPrepare(db, zSql, nBytes, uint32(128), nil, ppStmt, pzTail)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3_prepare_v3(db *struct_sqlite3, zSql *int8, nBytes int32, prepFlags uint32, ppStmt **struct_sqlite3_stmt, pzTail **int8) int32 {
	var rc int32
	rc = sqlite3LockAndPrepare(db, zSql, nBytes, uint32(128)|prepFlags&uint32(15), nil, ppStmt, pzTail)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3Prepare16(db *struct_sqlite3, zSql unsafe.Pointer, nBytes int32, prepFlags uint32, ppStmt **struct_sqlite3_stmt, pzTail *unsafe.Pointer) int32 {
	var zSql8 *int8
	var zTail8 *int8 = nil
	var rc int32 = 0
	*ppStmt = (*struct_sqlite3_stmt)(nil)
	if !(sqlite3SafetyCheckOk(db) != 0) || uintptr(unsafe.Pointer(zSql)) == uintptr(unsafe.Pointer(nil)) {
		return sqlite3MisuseError(134140)
	}
	if nBytes >= 0 {
		var sz int32
		var z *int8 = (*int8)(zSql)
		for sz = int32(0); sz < nBytes && (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(sz)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(sz+1)))) != 0); sz += int32(2) {
		}
		nBytes = sz
	}
	sqlite3_mutex_enter(db.mutex)
	zSql8 = sqlite3Utf16to8(db, zSql, nBytes, uint8(2))
	if zSql8 != nil {
		rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, nil, ppStmt, &zTail8)
	}
	if zTail8 != nil && pzTail != nil {
		var chars_parsed int32 = sqlite3Utf8CharLen(zSql8, int32(uintptr(unsafe.Pointer(zTail8))-uintptr(unsafe.Pointer(zSql8))))
		*pzTail = unsafe.Pointer((*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(zSql))) + uintptr(sqlite3Utf16ByteLen(zSql, chars_parsed)))))
	}
	sqlite3DbFree(db, unsafe.Pointer(zSql8))
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_prepare16(db *struct_sqlite3, zSql unsafe.Pointer, nBytes int32, ppStmt **struct_sqlite3_stmt, pzTail *unsafe.Pointer) int32 {
	var rc int32
	rc = sqlite3Prepare16(db, zSql, nBytes, uint32(0), ppStmt, pzTail)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3_prepare16_v2(db *struct_sqlite3, zSql unsafe.Pointer, nBytes int32, ppStmt **struct_sqlite3_stmt, pzTail *unsafe.Pointer) int32 {
	var rc int32
	rc = sqlite3Prepare16(db, zSql, nBytes, uint32(128), ppStmt, pzTail)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3_prepare16_v3(db *struct_sqlite3, zSql unsafe.Pointer, nBytes int32, prepFlags uint32, ppStmt **struct_sqlite3_stmt, pzTail *unsafe.Pointer) int32 {
	var rc int32
	rc = sqlite3Prepare16(db, zSql, nBytes, uint32(128)|prepFlags&uint32(15), ppStmt, pzTail)
	func() int {
		_ = 0
		return 0
	}()
	return rc
}

type DistinctCtx = struct_DistinctCtx
type struct_DistinctCtx struct {
	isTnct    uint8
	eTnctType uint8
	tabTnct   int32
	addrTnct  int32
}
type SortCtx = struct_SortCtx
type struct_SortCtx struct {
	pOrderBy         *struct_ExprList
	nOBSat           int32
	iECursor         int32
	regReturn        int32
	labelBkOut       int32
	addrSortIndex    int32
	labelDone        int32
	labelOBLopt      int32
	sortFlags        uint8
	pDeferredRowLoad *struct_RowLoadInfo
}

func clearSelect(db *struct_sqlite3, p *struct_Select, bFree int32) {
	for p != nil {
		var pPrior *struct_Select = p.pPrior
		sqlite3ExprListDelete(db, p.pEList)
		sqlite3SrcListDelete(db, p.pSrc)
		sqlite3ExprDelete(db, p.pWhere)
		sqlite3ExprListDelete(db, p.pGroupBy)
		sqlite3ExprDelete(db, p.pHaving)
		sqlite3ExprListDelete(db, p.pOrderBy)
		sqlite3ExprDelete(db, p.pLimit)
		if p.pWith != nil {
			sqlite3WithDelete(db, p.pWith)
		}
		if p.pWinDefn != nil {
			sqlite3WindowListDelete(db, p.pWinDefn)
		}
		for p.pWin != nil {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3WindowUnlinkFromSelect(p.pWin)
		}
		if bFree != 0 {
			sqlite3DbFreeNN(db, unsafe.Pointer(p))
		}
		p = pPrior
		bFree = int32(1)
	}
}
func sqlite3SelectDestInit(pDest *struct_SelectDest, eDest int32, iParm int32) {
	pDest.eDest = uint8(eDest)
	pDest.iSDParm = iParm
	pDest.iSDParm2 = int32(0)
	pDest.zAffSdst = (*int8)(nil)
	pDest.iSdst = int32(0)
	pDest.nSdst = int32(0)
}
func sqlite3SelectNew(pParse *struct_Parse, pEList *struct_ExprList, pSrc *struct_SrcList, pWhere *struct_Expr, pGroupBy *struct_ExprList, pHaving *struct_Expr, pOrderBy *struct_ExprList, selFlags uint32, pLimit *struct_Expr) *struct_Select {
	var pNew *struct_Select
	var pAllocated *struct_Select
	var standin struct_Select
	pAllocated = func() (_cgo_ret *struct_Select) {
		_cgo_addr := &pNew
		*_cgo_addr = (*struct_Select)(sqlite3DbMallocRawNN(pParse.db, uint64(128)))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		pNew = &standin
	}
	if uintptr(unsafe.Pointer(pEList)) == uintptr(unsafe.Pointer(nil)) {
		pEList = sqlite3ExprListAppend(pParse, nil, sqlite3Expr(pParse.db, 180, nil))
	}
	pNew.pEList = pEList
	pNew.op = uint8(138)
	pNew.selFlags = selFlags
	pNew.iLimit = int32(0)
	pNew.iOffset = int32(0)
	pNew.selId = uint32(func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nSelect
		*_cgo_addr++
		return *_cgo_addr
	}())
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pNew.addrOpenEphm)))) + uintptr(0)*4)) = int32(-1)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pNew.addrOpenEphm)))) + uintptr(1)*4)) = int32(-1)
	pNew.nSelectRow = int16(0)
	if uintptr(unsafe.Pointer(pSrc)) == uintptr(unsafe.Pointer(nil)) {
		pSrc = (*struct_SrcList)(sqlite3DbMallocZero(pParse.db, uint64(120)))
	}
	pNew.pSrc = pSrc
	pNew.pWhere = pWhere
	pNew.pGroupBy = pGroupBy
	pNew.pHaving = pHaving
	pNew.pOrderBy = pOrderBy
	pNew.pPrior = (*struct_Select)(nil)
	pNew.pNext = (*struct_Select)(nil)
	pNew.pLimit = pLimit
	pNew.pWith = (*struct_With)(nil)
	pNew.pWin = (*struct_Window)(nil)
	pNew.pWinDefn = (*struct_Window)(nil)
	if pParse.db.mallocFailed != 0 {
		clearSelect(pParse.db, pNew, func() int32 {
			if uintptr(unsafe.Pointer(pNew)) != uintptr(unsafe.Pointer(&standin)) {
				return 1
			} else {
				return 0
			}
		}())
		pAllocated = (*struct_Select)(nil)
	} else {
		func() int {
			_ = 0
			return 0
		}()
	}
	return pAllocated
}
func sqlite3SelectDelete(db *struct_sqlite3, p *struct_Select) {
	if p != nil {
		clearSelect(db, p, 1)
	}
}
func findRightmost(p *struct_Select) *struct_Select {
	for p.pNext != nil {
		p = p.pNext
	}
	return p
}
func sqlite3JoinType(pParse *struct_Parse, pA *struct_Token, pB *struct_Token, pC *struct_Token) int32 {
	var jointype int32 = 0
	var apAll [3]*struct_Token
	var p *struct_Token
	var zKeyText [34]int8 = [34]int8{'n', 'a', 't', 'u', 'r', 'a', 'l', 'e', 'f', 't', 'o', 'u', 't', 'e', 'r', 'i', 'g', 'h', 't', 'f', 'u', 'l', 'l', 'i', 'n', 'n', 'e', 'r', 'c', 'r', 'o', 's', 's', '\x00'}
	type _cgoa_80 struct {
		i     uint8
		nChar uint8
		code  uint8
	}
	var aKeyword [7]_cgoa_80 = [7]_cgoa_80{_cgoa_80{uint8(0), uint8(7), uint8(4)}, _cgoa_80{uint8(6), uint8(4), uint8(8 | 32)}, _cgoa_80{uint8(10), uint8(5), uint8(32)}, _cgoa_80{uint8(14), uint8(5), uint8(16 | 32)}, _cgoa_80{uint8(19), uint8(4), uint8(8 | 16 | 32)}, _cgoa_80{uint8(23), uint8(5), uint8(1)}, _cgoa_80{uint8(28), uint8(5), uint8(1 | 2)}}
	var i int32
	var j int32
	*(**struct_Token)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Token)(unsafe.Pointer(&apAll)))) + uintptr(0)*8)) = pA
	*(**struct_Token)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Token)(unsafe.Pointer(&apAll)))) + uintptr(1)*8)) = pB
	*(**struct_Token)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Token)(unsafe.Pointer(&apAll)))) + uintptr(2)*8)) = pC
	for i = int32(0); i < 3 && *(**struct_Token)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Token)(unsafe.Pointer(&apAll)))) + uintptr(i)*8)) != nil; i++ {
		p = *(**struct_Token)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_Token)(unsafe.Pointer(&apAll)))) + uintptr(i)*8))
		for j = int32(0); j < int32(21/3); j++ {
			if p.n == uint32((*(*_cgoa_80)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_80)(unsafe.Pointer(&aKeyword)))) + uintptr(j)*3))).nChar) && sqlite3_strnicmp((*int8)(unsafe.Pointer(p.z)), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zKeyText)))) + uintptr((*(*_cgoa_80)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_80)(unsafe.Pointer(&aKeyword)))) + uintptr(j)*3))).i))), int32(p.n)) == 0 {
				jointype |= int32((*(*_cgoa_80)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_80)(unsafe.Pointer(&aKeyword)))) + uintptr(j)*3))).code)
				break
			}
		}
		if j >= int32(21/3) {
			jointype |= int32(64)
			break
		}
	}
	if jointype&(1|32) == 1|32 || jointype&64 != 0 {
		var zSp *int8 = (*int8)(unsafe.Pointer(&[2]int8{' ', '\x00'}))
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pC)) == uintptr(unsafe.Pointer(nil)) {
			*(*uintptr)(unsafe.Pointer(&zSp))++
		}
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[44]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'o', 'r', ' ', 'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'j', 'o', 'i', 'n', ' ', 't', 'y', 'p', 'e', ':', ' ', '%', 'T', ' ', '%', 'T', '%', 's', '%', 'T', '\x00'})), pA, pB, zSp, pC)
		jointype = int32(1)
	} else if jointype&32 != 0 && jointype&(8|16) != 8 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[55]int8{'R', 'I', 'G', 'H', 'T', ' ', 'a', 'n', 'd', ' ', 'F', 'U', 'L', 'L', ' ', 'O', 'U', 'T', 'E', 'R', ' ', 'J', 'O', 'I', 'N', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'c', 'u', 'r', 'r', 'e', 'n', 't', 'l', 'y', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', '\x00'})))
		jointype = int32(1)
	}
	return jointype
}
func sqlite3ColumnIndex(pTab *struct_Table, zCol *int8) int32 {
	var i int32
	var h uint8 = sqlite3StrIHash(zCol)
	var pCol *struct_Column
	for func() int32 {
		pCol = pTab.aCol
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); i < int32(pTab.nCol); func() int32 {
		*(*uintptr)(unsafe.Pointer(&pCol)) += 20
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		if int32(pCol.hName) == int32(h) && sqlite3StrICmp(pCol.zCnName, zCol) == 0 {
			return i
		}
	}
	return int32(-1)
}
func tableAndColumnIndex(pSrc *struct_SrcList, N int32, zCol *int8, piTab *int32, piCol *int32, bIgnoreHidden int32) int32 {
	var i int32
	var iCol int32
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < N; i++ {
		iCol = sqlite3ColumnIndex((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).pTab, zCol)
		if iCol >= 0 && (bIgnoreHidden == 0 || func() int32 {
			if int32((&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).pTab.aCol)) + uintptr(iCol)*20))).colFlags)&2 != 0 {
				return 1
			} else {
				return 0
			}
		}() == 0) {
			if piTab != nil {
				*piTab = i
				*piCol = iCol
			}
			return int32(1)
		}
	}
	return int32(0)
}
func addWhereTerm(pParse *struct_Parse, pSrc *struct_SrcList, iLeft int32, iColLeft int32, iRight int32, iColRight int32, isOuterJoin int32, ppWhere **struct_Expr) {
	var db *struct_sqlite3 = pParse.db
	var pE1 *struct_Expr
	var pE2 *struct_Expr
	var pEq *struct_Expr
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft)
	pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight)
	pEq = sqlite3PExpr(pParse, 53, pE1, pE2)
	func() int {
		_ = 0
		return 0
	}()
	if pEq != nil && isOuterJoin != 0 {
		pEq.flags |= uint32(1)
		func() int {
			_ = 0
			return 0
		}()
		pEq.w.iRightJoinTable = pE2.iTable
	}
	*ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq)
}
func sqlite3SetJoinExpr(p *struct_Expr, iTable int32) {
	for p != nil {
		p.flags |= uint32(1)
		func() int {
			_ = 0
			return 0
		}()
		p.w.iRightJoinTable = iTable
		if int32(p.op) == 172 {
			func() int {
				_ = 0
				return 0
			}()
			if p.x.pList != nil {
				var i int32
				for i = int32(0); i < p.x.pList.nExpr; i++ {
					sqlite3SetJoinExpr((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.x.pList.a)))) + uintptr(i)*28))).pExpr, iTable)
				}
			}
		}
		sqlite3SetJoinExpr(p.pLeft, iTable)
		p = p.pRight
	}
}
func unsetJoinExpr(p *struct_Expr, iTable int32) {
	for p != nil {
		if p.flags&uint32(1) != uint32(0) && (iTable < 0 || p.w.iRightJoinTable == iTable) {
			p.flags &= uint32(4294967294)
		}
		if int32(p.op) == 167 && p.iTable == iTable {
			p.flags &= uint32(4293918719)
		}
		if int32(p.op) == 172 {
			func() int {
				_ = 0
				return 0
			}()
			if p.x.pList != nil {
				var i int32
				for i = int32(0); i < p.x.pList.nExpr; i++ {
					unsetJoinExpr((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.x.pList.a)))) + uintptr(i)*28))).pExpr, iTable)
				}
			}
		}
		unsetJoinExpr(p.pLeft, iTable)
		p = p.pRight
	}
}
func sqliteProcessJoin(pParse *struct_Parse, p *struct_Select) int32 {
	var pSrc *struct_SrcList
	var i int32
	var j int32
	var pLeft *struct_SrcItem
	var pRight *struct_SrcItem
	pSrc = p.pSrc
	pLeft = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))
	pRight = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer(pLeft)) + uintptr(1)*112))
	for i = int32(0); i < pSrc.nSrc-1; func() *struct_SrcItem {
		func() *struct_SrcItem {
			i++
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pRight
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
				return
			}()
		}()
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pLeft
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		var pRightTab *struct_Table = pRight.pTab
		var isOuter int32
		if uintptr(unsafe.Pointer(pLeft.pTab)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pRightTab)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		isOuter = func() int32 {
			if int32(pRight.fg.jointype)&32 != 0 {
				return 1
			} else {
				return 0
			}
		}()
		if int32(pRight.fg.jointype)&4 != 0 {
			if pRight.pOn != nil || pRight.pUsing != nil {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[50]int8{'a', ' ', 'N', 'A', 'T', 'U', 'R', 'A', 'L', ' ', 'j', 'o', 'i', 'n', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'a', 'n', ' ', 'O', 'N', ' ', 'o', 'r', ' ', 'U', 'S', 'I', 'N', 'G', ' ', 'c', 'l', 'a', 'u', 's', 'e', '\x00'})), 0)
				return int32(1)
			}
			for j = int32(0); j < int32(pRightTab.nCol); j++ {
				var zName *int8
				var iLeft int32
				var iLeftCol int32
				if int32((&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pRightTab.aCol)) + uintptr(j)*20))).colFlags)&2 != 0 {
					continue
				}
				zName = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pRightTab.aCol)) + uintptr(j)*20))).zCnName
				if tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol, 1) != 0 {
					addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j, isOuter, &p.pWhere)
				}
			}
		}
		if pRight.pOn != nil && pRight.pUsing != nil {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[55]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'b', 'o', 't', 'h', ' ', 'O', 'N', ' ', 'a', 'n', 'd', ' ', 'U', 'S', 'I', 'N', 'G', ' ', 'c', 'l', 'a', 'u', 's', 'e', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 'j', 'o', 'i', 'n', '\x00'})))
			return int32(1)
		}
		if pRight.pOn != nil {
			if isOuter != 0 {
				sqlite3SetJoinExpr(pRight.pOn, pRight.iCursor)
			}
			p.pWhere = sqlite3ExprAnd(pParse, p.pWhere, pRight.pOn)
			pRight.pOn = (*struct_Expr)(nil)
		}
		if pRight.pUsing != nil {
			var pList *struct_IdList = pRight.pUsing
			for j = int32(0); j < pList.nId; j++ {
				var zName *int8
				var iLeft int32
				var iLeftCol int32
				var iRightCol int32
				zName = (*(*struct_IdList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(pList.a)) + uintptr(j)*12))).zName
				iRightCol = sqlite3ColumnIndex(pRightTab, zName)
				if iRightCol < 0 || !(tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol, 0) != 0) {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[64]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'j', 'o', 'i', 'n', ' ', 'u', 's', 'i', 'n', 'g', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '%', 's', ' ', '-', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'n', 'o', 't', ' ', 'p', 'r', 'e', 's', 'e', 'n', 't', ' ', 'i', 'n', ' ', 'b', 'o', 't', 'h', ' ', 't', 'a', 'b', 'l', 'e', 's', '\x00'})), zName)
					return int32(1)
				}
				addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol, isOuter, &p.pWhere)
			}
		}
	}
	return int32(0)
}

type RowLoadInfo = struct_RowLoadInfo
type struct_RowLoadInfo struct {
	regResult int32
	ecelFlags uint8
}

func innerLoopLoadRow(pParse *struct_Parse, pSelect *struct_Select, pInfo *struct_RowLoadInfo) {
	sqlite3ExprCodeExprList(pParse, pSelect.pEList, pInfo.regResult, 0, pInfo.ecelFlags)
}
func makeSorterRecord(pParse *struct_Parse, pSort *struct_SortCtx, pSelect *struct_Select, regBase int32, nBase int32) int32 {
	var nOBSat int32 = pSort.nOBSat
	var v *struct_Vdbe = pParse.pVdbe
	var regOut int32 = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	if pSort.pDeferredRowLoad != nil {
		innerLoopLoadRow(pParse, pSelect, pSort.pDeferredRowLoad)
	}
	sqlite3VdbeAddOp3(v, 96, regBase+nOBSat, nBase-nOBSat, regOut)
	return regOut
}
func pushOntoSorter(pParse *struct_Parse, pSort *struct_SortCtx, pSelect *struct_Select, regData int32, regOrigData int32, nData int32, nPrefixReg int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var bSeq int32 = func() int32 {
		if int32(pSort.sortFlags)&1 == 0 {
			return 1
		} else {
			return 0
		}
	}()
	var nExpr int32 = pSort.pOrderBy.nExpr
	var nBase int32 = nExpr + bSeq + nData
	var regBase int32
	var regRecord int32 = 0
	var nOBSat int32 = pSort.nOBSat
	var op int32
	var iLimit int32
	var iSkip int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nPrefixReg != 0 {
		func() int {
			_ = 0
			return 0
		}()
		regBase = regData - nPrefixReg
	} else {
		regBase = pParse.nMem + 1
		pParse.nMem += nBase
	}
	func() int {
		_ = 0
		return 0
	}()
	iLimit = func() int32 {
		if pSelect.iOffset != 0 {
			return pSelect.iOffset + 1
		} else {
			return pSelect.iLimit
		}
	}()
	pSort.labelDone = sqlite3VdbeMakeLabel(pParse)
	sqlite3ExprCodeExprList(pParse, pSort.pOrderBy, regBase, regOrigData, uint8(1|func() int32 {
		if regOrigData != 0 {
			return 4
		} else {
			return 0
		}
	}()))
	if bSeq != 0 {
		sqlite3VdbeAddOp2(v, 125, pSort.iECursor, regBase+nExpr)
	}
	if nPrefixReg == 0 && nData > 0 {
		sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData)
	}
	if nOBSat > 0 {
		var regPrevKey int32
		var addrFirst int32
		var addrJmp int32
		var pOp *struct_VdbeOp
		var nKey int32
		var pKI *struct_KeyInfo
		regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase)
		regPrevKey = pParse.nMem + 1
		pParse.nMem += pSort.nOBSat
		nKey = nExpr - pSort.nOBSat + bSeq
		if bSeq != 0 {
			addrFirst = sqlite3VdbeAddOp1(v, 20, regBase+nExpr)
		} else {
			addrFirst = sqlite3VdbeAddOp1(v, 119, pSort.iECursor)
		}
		sqlite3VdbeAddOp3(v, 89, regPrevKey, regBase, pSort.nOBSat)
		pOp = sqlite3VdbeGetOp(v, pSort.addrSortIndex)
		if pParse.db.mallocFailed != 0 {
			return
		}
		pOp.p2 = nKey + nData
		pKI = *(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4))
		__builtin___memset_chk(unsafe.Pointer(pKI.aSortFlags), 0, uint(pKI.nKeyField), __builtin_object_size(unsafe.Pointer(pKI.aSortFlags), 0))
		sqlite3VdbeChangeP4(v, -1, (*int8)(unsafe.Pointer(pKI)), -9)
		*(**struct_KeyInfo)(unsafe.Pointer(&pOp.p4)) = sqlite3KeyInfoFromExprList(pParse, pSort.pOrderBy, nOBSat, int32(pKI.nAllField)-int32(pKI.nKeyField)-1)
		pOp = (*struct_VdbeOp)(nil)
		addrJmp = sqlite3VdbeCurrentAddr(v)
		sqlite3VdbeAddOp3(v, 16, addrJmp+1, 0, addrJmp+1)
		pSort.labelBkOut = sqlite3VdbeMakeLabel(pParse)
		pSort.regReturn = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 12, pSort.regReturn, pSort.labelBkOut)
		sqlite3VdbeAddOp1(v, 145, pSort.iECursor)
		if iLimit != 0 {
			sqlite3VdbeAddOp2(v, 20, iLimit, pSort.labelDone)
		}
		sqlite3VdbeJumpHere(v, addrFirst)
		sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort.nOBSat)
		sqlite3VdbeJumpHere(v, addrJmp)
	}
	if iLimit != 0 {
		var iCsr int32 = pSort.iECursor
		sqlite3VdbeAddOp2(v, 59, iLimit, sqlite3VdbeCurrentAddr(v)+4)
		sqlite3VdbeAddOp2(v, 34, iCsr, 0)
		iSkip = sqlite3VdbeAddOp4Int(v, 39, iCsr, 0, regBase+nOBSat, nExpr-nOBSat)
		sqlite3VdbeAddOp1(v, 129, iCsr)
	}
	if regRecord == 0 {
		regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase)
	}
	if int32(pSort.sortFlags)&1 != 0 {
		op = int32(138)
	} else {
		op = int32(137)
	}
	sqlite3VdbeAddOp4Int(v, op, pSort.iECursor, regRecord, regBase+nOBSat, nBase-nOBSat)
	if iSkip != 0 {
		sqlite3VdbeChangeP2(v, iSkip, func() int32 {
			if pSort.labelOBLopt != 0 {
				return pSort.labelOBLopt
			} else {
				return sqlite3VdbeCurrentAddr(v)
			}
		}())
	}
}
func codeOffset(v *struct_Vdbe, iOffset int32, iContinue int32) {
	if iOffset > 0 {
		sqlite3VdbeAddOp3(v, 49, iOffset, iContinue, 1)
	}
}
func codeDistinct(pParse *struct_Parse, eTnctType int32, iTab int32, addrRepeat int32, pEList *struct_ExprList, regElem int32) int32 {
	var iRet int32 = 0
	var nResultCol int32 = pEList.nExpr
	var v *struct_Vdbe = pParse.pVdbe
	switch eTnctType {
	case 2:
		{
			var i int32
			var iJump int32
			var regPrev int32
			iRet = func() (_cgo_ret int32) {
				_cgo_addr := &regPrev
				*_cgo_addr = pParse.nMem + 1
				return *_cgo_addr
			}()
			pParse.nMem += nResultCol
			iJump = sqlite3VdbeCurrentAddr(v) + nResultCol
			for i = int32(0); i < nResultCol; i++ {
				var pColl *struct_CollSeq = sqlite3ExprCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr)
				if i < nResultCol-1 {
					sqlite3VdbeAddOp3(v, 52, regElem+i, iJump, regPrev+i)
				} else {
					sqlite3VdbeAddOp3(v, 53, regElem+i, addrRepeat, regPrev+i)
				}
				sqlite3VdbeChangeP4(v, -1, (*int8)(unsafe.Pointer(pColl)), -2)
				sqlite3VdbeChangeP5(v, uint16(128))
			}
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp3(v, 79, regElem, regPrev, nResultCol-1)
			break
		}
	case 1:
		{
			break
		}
	default:
		{
			var r1 int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp4Int(v, 31, iTab, addrRepeat, regElem, nResultCol)
			sqlite3VdbeAddOp3(v, 96, regElem, nResultCol, r1)
			sqlite3VdbeAddOp4Int(v, 137, iTab, r1, regElem, nResultCol)
			sqlite3VdbeChangeP5(v, uint16(16))
			sqlite3ReleaseTempReg(pParse, r1)
			iRet = iTab
			break
		}
	}
	return iRet
}
func fixDistinctOpenEph(pParse *struct_Parse, eTnctType int32, iVal int32, iOpenEphAddr int32) {
	if pParse.nErr == 0 && (eTnctType == 1 || eTnctType == 2) {
		var v *struct_Vdbe = pParse.pVdbe
		sqlite3VdbeChangeToNoop(v, iOpenEphAddr)
		if int32(sqlite3VdbeGetOp(v, iOpenEphAddr+1).opcode) == 183 {
			sqlite3VdbeChangeToNoop(v, iOpenEphAddr+1)
		}
		if eTnctType == 2 {
			var pOp *struct_VdbeOp = sqlite3VdbeGetOp(v, iOpenEphAddr)
			pOp.opcode = uint8(74)
			pOp.p1 = int32(1)
			pOp.p2 = iVal
		}
	}
}
func selectInnerLoop(pParse *struct_Parse, p *struct_Select, srcTab int32, pSort *struct_SortCtx, pDistinct *struct_DistinctCtx, pDest *struct_SelectDest, iContinue int32, iBreak int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var hasDistinct int32
	var eDest int32 = int32(pDest.eDest)
	var iParm int32 = pDest.iSDParm
	var nResultCol int32
	var nPrefixReg int32 = 0
	var sRowLoadInfo struct_RowLoadInfo
	var regResult int32
	var regOrig int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	hasDistinct = func() int32 {
		if pDistinct != nil {
			return int32(pDistinct.eTnctType)
		} else {
			return 0
		}
	}()
	if pSort != nil && uintptr(unsafe.Pointer(pSort.pOrderBy)) == uintptr(unsafe.Pointer(nil)) {
		pSort = (*struct_SortCtx)(nil)
	}
	if uintptr(unsafe.Pointer(pSort)) == uintptr(unsafe.Pointer(nil)) && !(hasDistinct != 0) {
		func() int {
			_ = 0
			return 0
		}()
		codeOffset(v, p.iOffset, iContinue)
	}
	nResultCol = p.pEList.nExpr
	if pDest.iSdst == 0 {
		if pSort != nil {
			nPrefixReg = pSort.pOrderBy.nExpr
			if !(int32(pSort.sortFlags)&1 != 0) {
				nPrefixReg++
			}
			pParse.nMem += nPrefixReg
		}
		pDest.iSdst = pParse.nMem + 1
		pParse.nMem += nResultCol
	} else if pDest.iSdst+nResultCol > pParse.nMem {
		pParse.nMem += nResultCol
	}
	pDest.nSdst = nResultCol
	regOrig = func() (_cgo_ret int32) {
		_cgo_addr := &regResult
		*_cgo_addr = pDest.iSdst
		return *_cgo_addr
	}()
	if srcTab >= 0 {
		for i = int32(0); i < nResultCol; i++ {
			sqlite3VdbeAddOp3(v, 93, srcTab, i, regResult+i)
		}
	} else if eDest != 3 {
		var ecelFlags uint8
		var pEList *struct_ExprList
		if eDest == 10 || eDest == 9 || eDest == 13 {
			ecelFlags = uint8(1)
		} else {
			ecelFlags = uint8(0)
		}
		if pSort != nil && hasDistinct == 0 && eDest != 12 && eDest != 14 {
			ecelFlags |= uint8(8 | 4)
			for i = pSort.nOBSat; i < pSort.pOrderBy.nExpr; i++ {
				var j int32
				if func() (_cgo_ret int32) {
					_cgo_addr := &j
					*_cgo_addr = int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSort.pOrderBy.a)))) + uintptr(i)*28))).u.x.iOrderByCol)
					return *_cgo_addr
				}() > 0 {
					(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.pEList.a)))) + uintptr(j-1)*28))).u.x.iOrderByCol = uint16(i + 1 - pSort.nOBSat)
				}
			}
			pEList = p.pEList
			for i = int32(0); i < pEList.nExpr; i++ {
				if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).u.x.iOrderByCol) > 0 {
					nResultCol--
					regOrig = int32(0)
				}
			}
			func() int {
				_ = 0
				return 0
			}()
		}
		sRowLoadInfo.regResult = regResult
		sRowLoadInfo.ecelFlags = ecelFlags
		if p.iLimit != 0 && int32(ecelFlags)&8 != 0 && nPrefixReg > 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pSort.pDeferredRowLoad = &sRowLoadInfo
			regOrig = int32(0)
		} else {
			innerLoopLoadRow(pParse, p, &sRowLoadInfo)
		}
	}
	if hasDistinct != 0 {
		var eType int32 = int32(pDistinct.eTnctType)
		var iTab int32 = pDistinct.tabTnct
		func() int {
			_ = 0
			return 0
		}()
		iTab = codeDistinct(pParse, eType, iTab, iContinue, p.pEList, regResult)
		fixDistinctOpenEph(pParse, eType, iTab, pDistinct.addrTnct)
		if uintptr(unsafe.Pointer(pSort)) == uintptr(unsafe.Pointer(nil)) {
			codeOffset(v, p.iOffset, iContinue)
		}
	}
	switch eDest {
	case 1:
		{
			var r1 int32
			r1 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp3(v, 96, regResult, nResultCol, r1)
			sqlite3VdbeAddOp4Int(v, 137, iParm, r1, regResult, nResultCol)
			sqlite3ReleaseTempReg(pParse, r1)
			break
		}
	case 2:
		{
			sqlite3VdbeAddOp3(v, 139, iParm, regResult, nResultCol)
			break
		}
	case 8:
		fallthrough
	case 5:
		fallthrough
	case 14:
		fallthrough
	case 12:
		{
			var r1 int32 = sqlite3GetTempRange(pParse, nPrefixReg+1)
			sqlite3VdbeAddOp3(v, 96, regResult, nResultCol, r1+nPrefixReg)
			if eDest == 5 {
				var addr int32 = sqlite3VdbeCurrentAddr(v) + 4
				sqlite3VdbeAddOp4Int(v, 31, iParm+1, addr, r1, 0)
				sqlite3VdbeAddOp4Int(v, 137, iParm+1, r1, regResult, nResultCol)
				func() int {
					_ = 0
					return 0
				}()
			}
			if pSort != nil {
				func() int {
					_ = 0
					return 0
				}()
				pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg)
			} else {
				var r2 int32 = sqlite3GetTempReg(pParse)
				sqlite3VdbeAddOp2(v, 126, iParm, r2)
				sqlite3VdbeAddOp3(v, 127, iParm, r1, r2)
				sqlite3VdbeChangeP5(v, uint16(8))
				sqlite3ReleaseTempReg(pParse, r2)
			}
			sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1)
			break
		}
	case 15:
		{
			if pSort != nil {
				pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg)
			} else {
				var i2 int32 = pDest.iSDParm2
				var r1 int32 = sqlite3GetTempReg(pParse)
				sqlite3VdbeAddOp2(v, 50, regResult, iBreak)
				sqlite3VdbeAddOp3(v, 96, regResult+func() int32 {
					if i2 < 0 {
						return 1
					} else {
						return 0
					}
				}(), nResultCol-func() int32 {
					if i2 < 0 {
						return 1
					} else {
						return 0
					}
				}(), r1)
				if i2 < 0 {
					sqlite3VdbeAddOp3(v, 127, iParm, r1, regResult)
				} else {
					sqlite3VdbeAddOp4Int(v, 137, iParm, r1, regResult, i2)
				}
			}
			break
		}
	case 11:
		{
			if pSort != nil {
				pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg)
			} else {
				var r1 int32 = sqlite3GetTempReg(pParse)
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp4(v, 96, regResult, nResultCol, r1, pDest.zAffSdst, nResultCol)
				sqlite3VdbeAddOp4Int(v, 137, iParm, r1, regResult, nResultCol)
				sqlite3ReleaseTempReg(pParse, r1)
			}
			break
		}
	case 3:
		{
			sqlite3VdbeAddOp2(v, 71, 1, iParm)
			break
		}
	case 10:
		{
			if pSort != nil {
				func() int {
					_ = 0
					return 0
				}()
				pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
			}
			break
		}
	case 13:
		fallthrough
	case 9:
		{
			if pSort != nil {
				pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg)
			} else if eDest == 13 {
				sqlite3VdbeAddOp1(v, 14, pDest.iSDParm)
			} else {
				sqlite3VdbeAddOp2(v, 83, regResult, nResultCol)
			}
			break
		}
	case 6:
		fallthrough
	case 7:
		{
			var nKey int32
			var r1 int32
			var r2 int32
			var r3 int32
			var addrTest int32 = 0
			var pSO *struct_ExprList
			pSO = pDest.pOrderBy
			func() int {
				_ = 0
				return 0
			}()
			nKey = pSO.nExpr
			r1 = sqlite3GetTempReg(pParse)
			r2 = sqlite3GetTempRange(pParse, nKey+2)
			r3 = r2 + nKey + 1
			if eDest == 6 {
				addrTest = sqlite3VdbeAddOp4Int(v, 31, iParm+1, 0, regResult, nResultCol)
			}
			sqlite3VdbeAddOp3(v, 96, regResult, nResultCol, r3)
			if eDest == 6 {
				sqlite3VdbeAddOp2(v, 137, iParm+1, r3)
				sqlite3VdbeChangeP5(v, uint16(16))
			}
			for i = int32(0); i < nKey; i++ {
				sqlite3VdbeAddOp2(v, 80, regResult+int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSO.a)))) + uintptr(i)*28))).u.x.iOrderByCol)-1, r2+i)
			}
			sqlite3VdbeAddOp2(v, 125, iParm, r2+nKey)
			sqlite3VdbeAddOp3(v, 96, r2, nKey+2, r1)
			sqlite3VdbeAddOp4Int(v, 137, iParm, r1, r2, nKey+2)
			if addrTest != 0 {
				sqlite3VdbeJumpHere(v, addrTest)
			}
			sqlite3ReleaseTempReg(pParse, r1)
			sqlite3ReleaseTempRange(pParse, r2, nKey+2)
			break
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			break
		}
	}
	if uintptr(unsafe.Pointer(pSort)) == uintptr(unsafe.Pointer(nil)) && p.iLimit != 0 {
		sqlite3VdbeAddOp2(v, 60, p.iLimit, iBreak)
	}
}
func sqlite3KeyInfoAlloc(db *struct_sqlite3, N int32, X int32) *struct_KeyInfo {
	var nExtra int32 = int32(uint(N+X)*(8+uint(1)) - 8)
	var p *struct_KeyInfo = (*struct_KeyInfo)(sqlite3DbMallocRawNN(db, uint64(40+uint(nExtra))))
	if p != nil {
		p.aSortFlags = (*uint8)(unsafe.Pointer(&*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&p.aColl)))) + uintptr(N+X)*8))))
		p.nKeyField = uint16(N)
		p.nAllField = uint16(N + X)
		p.enc = db.enc
		p.db = db
		p.nRef = uint32(1)
		__builtin___memset_chk(unsafe.Pointer(&*(*struct_KeyInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*40))), 0, uint(nExtra), __builtin_object_size(unsafe.Pointer(&*(*struct_KeyInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*40))), 0))
	} else {
		return (*struct_KeyInfo)(sqlite3OomFault(db))
	}
	return p
}
func sqlite3KeyInfoUnref(p *struct_KeyInfo) {
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		p.nRef--
		if p.nRef == uint32(0) {
			sqlite3DbFreeNN(p.db, unsafe.Pointer(p))
		}
	}
}
func sqlite3KeyInfoRef(p *struct_KeyInfo) *struct_KeyInfo {
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		p.nRef++
	}
	return p
}
func sqlite3KeyInfoFromExprList(pParse *struct_Parse, pList *struct_ExprList, iStart int32, nExtra int32) *struct_KeyInfo {
	var nExpr int32
	var pInfo *struct_KeyInfo
	var pItem *struct_ExprList_item
	var db *struct_sqlite3 = pParse.db
	var i int32
	nExpr = pList.nExpr
	pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1)
	if pInfo != nil {
		func() int {
			_ = 0
			return 0
		}()
		for func() *struct_ExprList_item {
			i = iStart
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(iStart)*28))
				return *_cgo_addr
			}()
		}(); i < nExpr; func() *struct_ExprList_item {
			i++
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}() {
			*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pInfo.aColl)))) + uintptr(i-iStart)*8)) = sqlite3ExprNNCollSeq(pParse, pItem.pExpr)
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pInfo.aSortFlags)) + uintptr(i-iStart))) = pItem.sortFlags
		}
	}
	return pInfo
}
func sqlite3SelectOpName(id int32) *int8 {
	var z *int8
	switch id {
	case 135:
		z = (*int8)(unsafe.Pointer(&[10]int8{'U', 'N', 'I', 'O', 'N', ' ', 'A', 'L', 'L', '\x00'}))
		break
	case 137:
		z = (*int8)(unsafe.Pointer(&[10]int8{'I', 'N', 'T', 'E', 'R', 'S', 'E', 'C', 'T', '\x00'}))
		break
	case 136:
		z = (*int8)(unsafe.Pointer(&[7]int8{'E', 'X', 'C', 'E', 'P', 'T', '\x00'}))
		break
	default:
		z = (*int8)(unsafe.Pointer(&[6]int8{'U', 'N', 'I', 'O', 'N', '\x00'}))
		break
	}
	return z
}
func explainTempTable(pParse *struct_Parse, zUsage *int8) {
	sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[23]int8{'U', 'S', 'E', ' ', 'T', 'E', 'M', 'P', ' ', 'B', '-', 'T', 'R', 'E', 'E', ' ', 'F', 'O', 'R', ' ', '%', 's', '\x00'})), zUsage)
}
func generateSortTail(pParse *struct_Parse, p *struct_Select, pSort *struct_SortCtx, nColumn int32, pDest *struct_SelectDest) {
	var v *struct_Vdbe = pParse.pVdbe
	var addrBreak int32 = pSort.labelDone
	var addrContinue int32 = sqlite3VdbeMakeLabel(pParse)
	var addr int32
	var addrOnce int32 = 0
	var iTab int32
	var pOrderBy *struct_ExprList = pSort.pOrderBy
	var eDest int32 = int32(pDest.eDest)
	var iParm int32 = pDest.iSDParm
	var regRow int32
	var regRowid int32
	var iCol int32
	var nKey int32
	var iSortTab int32
	var i int32
	var bSeq int32
	var nRefKey int32 = 0
	var aOutEx *struct_ExprList_item = (*struct_ExprList_item)(unsafe.Pointer(&p.pEList.a))
	func() int {
		_ = 0
		return 0
	}()
	if pSort.labelBkOut != 0 {
		sqlite3VdbeAddOp2(v, 12, pSort.regReturn, pSort.labelBkOut)
		sqlite3VdbeGoto(v, addrBreak)
		sqlite3VdbeResolveLabel(v, pSort.labelBkOut)
	}
	iTab = pSort.iECursor
	if eDest == 9 || eDest == 13 || eDest == 10 {
		if eDest == 10 && p.iOffset != 0 {
			sqlite3VdbeAddOp2(v, 74, 0, pDest.iSdst)
		}
		regRowid = int32(0)
		regRow = pDest.iSdst
	} else {
		regRowid = sqlite3GetTempReg(pParse)
		if eDest == 12 || eDest == 14 {
			regRow = sqlite3GetTempReg(pParse)
			nColumn = int32(0)
		} else {
			regRow = sqlite3GetTempRange(pParse, nColumn)
		}
	}
	nKey = pOrderBy.nExpr - pSort.nOBSat
	if int32(pSort.sortFlags)&1 != 0 {
		var regSortOut int32 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		iSortTab = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		if pSort.labelBkOut != 0 {
			addrOnce = sqlite3VdbeAddOp0(v, 17)
		}
		sqlite3VdbeAddOp3(v, 120, iSortTab, regSortOut, nKey+1+nColumn+nRefKey)
		if addrOnce != 0 {
			sqlite3VdbeJumpHere(v, addrOnce)
		}
		addr = 1 + sqlite3VdbeAddOp2(v, 36, iTab, addrBreak)
		codeOffset(v, p.iOffset, addrContinue)
		sqlite3VdbeAddOp3(v, 132, iTab, regSortOut, iSortTab)
		bSeq = int32(0)
	} else {
		addr = 1 + sqlite3VdbeAddOp2(v, 37, iTab, addrBreak)
		codeOffset(v, p.iOffset, addrContinue)
		iSortTab = iTab
		bSeq = int32(1)
	}
	for func() int32 {
		i = int32(0)
		return func() (_cgo_ret int32) {
			_cgo_addr := &iCol
			*_cgo_addr = nKey + bSeq - 1
			return *_cgo_addr
		}()
	}(); i < nColumn; i++ {
		if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(aOutEx)) + uintptr(i)*28))).u.x.iOrderByCol) == 0 {
			iCol++
		}
	}
	for i = nColumn - 1; i >= 0; i-- {
		{
			var iRead int32
			if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(aOutEx)) + uintptr(i)*28))).u.x.iOrderByCol != 0 {
				iRead = int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(aOutEx)) + uintptr(i)*28))).u.x.iOrderByCol) - 1
			} else {
				iRead = func() (_cgo_ret int32) {
					_cgo_addr := &iCol
					_cgo_ret = *_cgo_addr
					*_cgo_addr--
					return
				}()
			}
			sqlite3VdbeAddOp3(v, 93, iSortTab, iRead, regRow+i)
		}
	}
	switch eDest {
	case 14:
		fallthrough
	case 12:
		{
			sqlite3VdbeAddOp3(v, 93, iSortTab, nKey+bSeq, regRow)
			sqlite3VdbeAddOp2(v, 126, iParm, regRowid)
			sqlite3VdbeAddOp3(v, 127, iParm, regRow, regRowid)
			sqlite3VdbeChangeP5(v, uint16(8))
			break
		}
	case 11:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp4(v, 96, regRow, nColumn, regRowid, pDest.zAffSdst, nColumn)
			sqlite3VdbeAddOp4Int(v, 137, iParm, regRowid, regRow, nColumn)
			break
		}
	case 10:
		{
			break
		}
	case 15:
		{
			var i2 int32 = pDest.iSDParm2
			var r1 int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp3(v, 96, regRow+func() int32 {
				if i2 < 0 {
					return 1
				} else {
					return 0
				}
			}(), nColumn-func() int32 {
				if i2 < 0 {
					return 1
				} else {
					return 0
				}
			}(), r1)
			if i2 < 0 {
				sqlite3VdbeAddOp3(v, 127, iParm, r1, regRow)
			} else {
				sqlite3VdbeAddOp4Int(v, 137, iParm, r1, regRow, i2)
			}
			break
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			if eDest == 9 {
				sqlite3VdbeAddOp2(v, 83, pDest.iSdst, nColumn)
			} else {
				sqlite3VdbeAddOp1(v, 14, pDest.iSDParm)
			}
			break
		}
	}
	if regRowid != 0 {
		if eDest == 11 {
			sqlite3ReleaseTempRange(pParse, regRow, nColumn)
		} else {
			sqlite3ReleaseTempReg(pParse, regRow)
		}
		sqlite3ReleaseTempReg(pParse, regRowid)
	}
	sqlite3VdbeResolveLabel(v, addrContinue)
	if int32(pSort.sortFlags)&1 != 0 {
		sqlite3VdbeAddOp2(v, 3, iTab, addr)
	} else {
		sqlite3VdbeAddOp2(v, 5, iTab, addr)
	}
	if pSort.regReturn != 0 {
		sqlite3VdbeAddOp1(v, 67, pSort.regReturn)
	}
	sqlite3VdbeResolveLabel(v, addrBreak)
}
func columnTypeImpl(pNC *struct_NameContext, pExpr *struct_Expr) *int8 {
	var zType *int8 = nil
	var j int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	switch int32(pExpr.op) {
	case 167:
		{
			var pTab *struct_Table = nil
			var pS *struct_Select = nil
			var iCol int32 = int32(pExpr.iColumn)
			for pNC != nil && !(pTab != nil) {
				var pTabList *struct_SrcList = pNC.pSrcList
				for j = int32(0); j < pTabList.nSrc && (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(j)*112))).iCursor != pExpr.iTable; j++ {
				}
				if j < pTabList.nSrc {
					pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(j)*112))).pTab
					pS = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(j)*112))).pSelect
				} else {
					pNC = pNC.pNext
				}
			}
			if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
				break
			}
			func() int {
				_ = 0
				return 0
			}()
			if pS != nil {
				if iCol < pS.pEList.nExpr && iCol >= 0 {
					var sNC struct_NameContext
					var p *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pS.pEList.a)))) + uintptr(iCol)*28))).pExpr
					sNC.pSrcList = pS.pSrc
					sNC.pNext = pNC
					sNC.pParse = pNC.pParse
					zType = columnTypeImpl(&sNC, p)
				}
			} else {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if iCol < 0 {
					zType = (*int8)(unsafe.Pointer(&[8]int8{'I', 'N', 'T', 'E', 'G', 'E', 'R', '\x00'}))
				} else {
					zType = sqlite3ColumnType(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20)), nil)
				}
			}
			break
		}
	case 138:
		{
			var sNC struct_NameContext
			var pS *struct_Select
			var p *struct_Expr
			func() int {
				_ = 0
				return 0
			}()
			pS = *(**struct_Select)(unsafe.Pointer(&pExpr.x))
			p = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pS.pEList.a)))) + uintptr(0)*28))).pExpr
			sNC.pSrcList = pS.pSrc
			sNC.pNext = pNC
			sNC.pParse = pNC.pParse
			zType = columnTypeImpl(&sNC, p)
			break
		}
	}
	return zType
}
func generateColumnTypes(pParse *struct_Parse, pTabList *struct_SrcList, pEList *struct_ExprList) {
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var sNC struct_NameContext
	sNC.pSrcList = pTabList
	sNC.pParse = pParse
	sNC.pNext = (*struct_NameContext)(nil)
	for i = int32(0); i < pEList.nExpr; i++ {
		var p *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr
		var zType *int8
		zType = columnTypeImpl(&sNC, p)
		sqlite3VdbeSetColName(v, i, 1, zType, (func(unsafe.Pointer))(-1))
	}
}
func sqlite3GenerateColumnNames(pParse *struct_Parse, pSelect *struct_Select) {
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var pTab *struct_Table
	var pTabList *struct_SrcList
	var pEList *struct_ExprList
	var db *struct_sqlite3 = pParse.db
	var fullName int32
	var srcName int32
	if pParse.explain != 0 {
		return
	}
	if pParse.colNamesSet != 0 {
		return
	}
	for pSelect.pPrior != nil {
		pSelect = pSelect.pPrior
	}
	pTabList = pSelect.pSrc
	pEList = pSelect.pEList
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pParse.colNamesSet = uint8(1)
	fullName = func() int32 {
		if db.flags&uint64(4) != uint64(0) {
			return 1
		} else {
			return 0
		}
	}()
	srcName = func() int32 {
		if db.flags&uint64(64) != uint64(0) || fullName != 0 {
			return 1
		} else {
			return 0
		}
	}()
	sqlite3VdbeSetNumCols(v, pEList.nExpr)
	for i = int32(0); i < pEList.nExpr; i++ {
		var p *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName != nil && int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).Xbf_0&3) == 0 {
			var zName *int8 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName
			sqlite3VdbeSetColName(v, i, 0, zName, (func(unsafe.Pointer))(-1))
		} else if srcName != 0 && int32(p.op) == 167 {
			var zCol *int8
			var iCol int32 = int32(p.iColumn)
			pTab = p.y.pTab
			func() int {
				_ = 0
				return 0
			}()
			if iCol < 0 {
				iCol = int32(pTab.iPKey)
			}
			func() int {
				_ = 0
				return 0
			}()
			if iCol < 0 {
				zCol = (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'w', 'i', 'd', '\x00'}))
			} else {
				zCol = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName
			}
			if fullName != 0 {
				var zName *int8 = nil
				zName = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 's', '\x00'})), pTab.zName, zCol)
				sqlite3VdbeSetColName(v, i, 0, zName, (func(unsafe.Pointer))(sqlite3OomFault))
			} else {
				sqlite3VdbeSetColName(v, i, 0, zCol, (func(unsafe.Pointer))(-1))
			}
		} else {
			var z *int8 = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName
			z = func() *int8 {
				if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
					return sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[9]int8{'c', 'o', 'l', 'u', 'm', 'n', '%', 'd', '\x00'})), i+1)
				} else {
					return sqlite3DbStrDup(db, z)
				}
			}()
			sqlite3VdbeSetColName(v, i, 0, z, (func(unsafe.Pointer))(sqlite3OomFault))
		}
	}
	generateColumnTypes(pParse, pTabList, pEList)
}
func sqlite3ColumnsFromExprList(pParse *struct_Parse, pEList *struct_ExprList, pnCol *int16, paCol **struct_Column) int32 {
	var db *struct_sqlite3 = pParse.db
	var i int32
	var j int32
	var cnt uint32
	var aCol *struct_Column
	var pCol *struct_Column
	var nCol int32
	var zName *int8
	var nName int32
	var ht struct_Hash
	var pTab *struct_Table
	sqlite3HashInit(&ht)
	if pEList != nil {
		nCol = pEList.nExpr
		aCol = (*struct_Column)(sqlite3DbMallocZero(db, uint64(20*uint(nCol))))
		if nCol > 32767 {
			nCol = int32(32767)
		}
	} else {
		nCol = int32(0)
		aCol = (*struct_Column)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	*pnCol = int16(nCol)
	*paCol = aCol
	for func() *struct_Column {
		i = int32(0)
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			*_cgo_addr = aCol
			return *_cgo_addr
		}()
	}(); i < nCol && !(db.mallocFailed != 0); func() *struct_Column {
		i++
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
			return
		}()
	}() {
		if uintptr(unsafe.Pointer(func() (_cgo_ret *int8) {
			_cgo_addr := &zName
			*_cgo_addr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) && int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).Xbf_0&3) == 0 {
		} else {
			var pColExpr *struct_Expr = sqlite3ExprSkipCollateAndLikely((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).pExpr)
			for uintptr(unsafe.Pointer(pColExpr)) != uintptr(unsafe.Pointer(nil)) && int32(pColExpr.op) == 141 {
				pColExpr = pColExpr.pRight
				func() int {
					_ = 0
					return 0
				}()
			}
			if int32(pColExpr.op) == 167 && pColExpr.flags&uint32(16777216|33554432) == uint32(0) && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
				_cgo_addr := &pTab
				*_cgo_addr = pColExpr.y.pTab
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) {
				var iCol int32 = int32(pColExpr.iColumn)
				if iCol < 0 {
					iCol = int32(pTab.iPKey)
				}
				zName = func() *int8 {
					if iCol >= 0 {
						return (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).zCnName
					} else {
						return (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'w', 'i', 'd', '\x00'}))
					}
				}()
			} else if int32(pColExpr.op) == 59 {
				func() int {
					_ = 0
					return 0
				}()
				zName = pColExpr.u.zToken
			} else {
				zName = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(i)*28))).zEName
			}
		}
		if zName != nil && !(sqlite3IsTrueOrFalse(zName) != 0) {
			zName = sqlite3DbStrDup(db, zName)
		} else {
			zName = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[9]int8{'c', 'o', 'l', 'u', 'm', 'n', '%', 'd', '\x00'})), i+1)
		}
		cnt = uint32(0)
		for zName != nil && uintptr(unsafe.Pointer(sqlite3HashFind(&ht, zName))) != uintptr(unsafe.Pointer(nil)) {
			nName = sqlite3Strlen30(zName)
			if nName > 0 {
				for j = nName - 1; j > 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(j))))))))&4 != 0; j-- {
				}
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) + uintptr(j)))) == ':' {
					nName = j
				}
			}
			zName = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[8]int8{'%', '.', '*', 'z', ':', '%', 'u', '\x00'})), nName, zName, func() (_cgo_ret uint32) {
				_cgo_addr := &cnt
				*_cgo_addr++
				return *_cgo_addr
			}())
			if cnt > uint32(3) {
				sqlite3_randomness(int32(4), unsafe.Pointer(&cnt))
			}
		}
		pCol.zCnName = zName
		pCol.hName = sqlite3StrIHash(zName)
		if zName != nil && uintptr(unsafe.Pointer(sqlite3HashInsert(&ht, zName, unsafe.Pointer(pCol)))) == uintptr(unsafe.Pointer(unsafe.Pointer(pCol))) {
			sqlite3OomFault(db)
		}
	}
	sqlite3HashClear(&ht)
	if db.mallocFailed != 0 {
		for j = int32(0); j < i; j++ {
			sqlite3DbFree(db, unsafe.Pointer((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(aCol)) + uintptr(j)*20))).zCnName))
		}
		sqlite3DbFree(db, unsafe.Pointer(aCol))
		*paCol = (*struct_Column)(nil)
		*pnCol = int16(0)
		return int32(7)
	}
	return int32(0)
}
func sqlite3SelectAddColumnTypeAndCollation(pParse *struct_Parse, pTab *struct_Table, pSelect *struct_Select, aff int8) {
	var db *struct_sqlite3 = pParse.db
	var sNC struct_NameContext
	var pCol *struct_Column
	var pColl *struct_CollSeq
	var i int32
	var p *struct_Expr
	var a *struct_ExprList_item
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db.mallocFailed != 0 {
		return
	}
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	sNC.pSrcList = pSelect.pSrc
	a = (*struct_ExprList_item)(unsafe.Pointer(&pSelect.pEList.a))
	for func() *struct_Column {
		i = int32(0)
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			*_cgo_addr = pTab.aCol
			return *_cgo_addr
		}()
	}(); i < int32(pTab.nCol); func() *struct_Column {
		i++
		return func() (_cgo_ret *struct_Column) {
			_cgo_addr := &pCol
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 20
			return
		}()
	}() {
		var zType *int8
		var n int64
		var m int64
		pTab.tabFlags |= uint32(int32(pCol.colFlags) & 98)
		p = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(i)*28))).pExpr
		zType = columnTypeImpl(&sNC, p)
		pCol.affinity = sqlite3ExprAffinity(p)
		if zType != nil {
			m = int64(sqlite3Strlen30(zType))
			n = int64(sqlite3Strlen30(pCol.zCnName))
			pCol.zCnName = (*int8)(sqlite3DbReallocOrFree(db, unsafe.Pointer(pCol.zCnName), uint64(n+m+int64(2))))
			if pCol.zCnName != nil {
				__builtin___memcpy_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.zCnName)) + uintptr(n+int64(1))))), unsafe.Pointer(zType), uint(m+int64(1)), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pCol.zCnName)) + uintptr(n+int64(1))))), 0))
				pCol.colFlags |= uint16(4)
			} else {
				pCol.colFlags &= uint16(^(4 | 512))
			}
		}
		if int32(pCol.affinity) <= 64 {
			pCol.affinity = aff
		}
		pColl = sqlite3ExprCollSeq(pParse, p)
		if pColl != nil {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3ColumnSetColl(db, pCol, pColl.zName)
		}
	}
	pTab.szTabRow = int16(1)
}
func sqlite3ResultSetOfSelect(pParse *struct_Parse, pSelect *struct_Select, aff int8) *struct_Table {
	var pTab *struct_Table
	var db *struct_sqlite3 = pParse.db
	var savedFlags uint64
	savedFlags = db.flags
	db.flags &= ^uint64(4)
	db.flags |= uint64(64)
	sqlite3SelectPrep(pParse, pSelect, nil)
	db.flags = savedFlags
	if pParse.nErr != 0 {
		return (*struct_Table)(nil)
	}
	for pSelect.pPrior != nil {
		pSelect = pSelect.pPrior
	}
	pTab = (*struct_Table)(sqlite3DbMallocZero(db, uint64(104)))
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_Table)(nil)
	}
	pTab.nTabRef = uint32(1)
	pTab.zName = (*int8)(nil)
	pTab.nRowLogEst = int16(200)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ColumnsFromExprList(pParse, pSelect.pEList, &pTab.nCol, &pTab.aCol)
	sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff)
	pTab.iPKey = int16(-1)
	if db.mallocFailed != 0 {
		sqlite3DeleteTable(db, pTab)
		return (*struct_Table)(nil)
	}
	return pTab
}
func sqlite3GetVdbe(pParse *struct_Parse) *struct_Vdbe {
	if pParse.pVdbe != nil {
		return pParse.pVdbe
	}
	if uintptr(unsafe.Pointer(pParse.pToplevel)) == uintptr(unsafe.Pointer(nil)) && pParse.db.dbOptFlags&uint32(8) == uint32(0) {
		pParse.okConstFactor = uint8(1)
	}
	return sqlite3VdbeCreate(pParse)
}
func computeLimitRegisters(pParse *struct_Parse, p *struct_Select, iBreak int32) {
	var v *struct_Vdbe = nil
	var iLimit int32 = 0
	var iOffset int32
	var n int32
	var pLimit *struct_Expr = p.pLimit
	if p.iLimit != 0 {
		return
	}
	if pLimit != nil {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		p.iLimit = func() (_cgo_ret int32) {
			_cgo_addr := &iLimit
			*_cgo_addr = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			return *_cgo_addr
		}()
		v = sqlite3GetVdbe(pParse)
		func() int {
			_ = 0
			return 0
		}()
		if sqlite3ExprIsInteger(pLimit.pLeft, &n) != 0 {
			sqlite3VdbeAddOp2(v, 71, n, iLimit)
			if n == 0 {
				sqlite3VdbeGoto(v, iBreak)
			} else if n >= 0 && int32(p.nSelectRow) > int32(sqlite3LogEst(uint64(n))) {
				p.nSelectRow = sqlite3LogEst(uint64(n))
				p.selFlags |= uint32(16384)
			}
		} else {
			sqlite3ExprCode(pParse, pLimit.pLeft, iLimit)
			sqlite3VdbeAddOp1(v, 15, iLimit)
			sqlite3VdbeAddOp2(v, 20, iLimit, iBreak)
		}
		if pLimit.pRight != nil {
			p.iOffset = func() (_cgo_ret int32) {
				_cgo_addr := &iOffset
				*_cgo_addr = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
				return *_cgo_addr
			}()
			pParse.nMem++
			sqlite3ExprCode(pParse, pLimit.pRight, iOffset)
			sqlite3VdbeAddOp1(v, 15, iOffset)
			sqlite3VdbeAddOp3(v, 159, iLimit, iOffset+1, iOffset)
		}
	}
}
func multiSelectCollSeq(pParse *struct_Parse, p *struct_Select, iCol int32) *struct_CollSeq {
	var pRet *struct_CollSeq
	if p.pPrior != nil {
		pRet = multiSelectCollSeq(pParse, p.pPrior, iCol)
	} else {
		pRet = (*struct_CollSeq)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pRet)) == uintptr(unsafe.Pointer(nil)) && iCol < p.pEList.nExpr {
		pRet = sqlite3ExprCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.pEList.a)))) + uintptr(iCol)*28))).pExpr)
	}
	return pRet
}
func multiSelectOrderByKeyInfo(pParse *struct_Parse, p *struct_Select, nExtra int32) *struct_KeyInfo {
	var pOrderBy *struct_ExprList = p.pOrderBy
	var nOrderBy int32 = func() int32 {
		if uintptr(unsafe.Pointer(pOrderBy)) != uintptr(unsafe.Pointer(nil)) {
			return pOrderBy.nExpr
		} else {
			return 0
		}
	}()
	var db *struct_sqlite3 = pParse.db
	var pRet *struct_KeyInfo = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1)
	if pRet != nil {
		var i int32
		for i = int32(0); i < nOrderBy; i++ {
			var pItem *struct_ExprList_item = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))
			var pTerm *struct_Expr = pItem.pExpr
			var pColl *struct_CollSeq
			if pTerm.flags&uint32(256) != 0 {
				pColl = sqlite3ExprCollSeq(pParse, pTerm)
			} else {
				pColl = multiSelectCollSeq(pParse, p, int32(pItem.u.x.iOrderByCol)-1)
				if uintptr(unsafe.Pointer(pColl)) == uintptr(unsafe.Pointer(nil)) {
					pColl = db.pDfltColl
				}
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr = sqlite3ExprAddCollateString(pParse, pTerm, pColl.zName)
			}
			func() int {
				_ = 0
				return 0
			}()
			*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pRet.aColl)))) + uintptr(i)*8)) = pColl
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pRet.aSortFlags)) + uintptr(i))) = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).sortFlags
		}
	}
	return pRet
}
func generateWithRecursiveQuery(pParse *struct_Parse, p *struct_Select, pDest *struct_SelectDest) {
	var pSrc *struct_SrcList = p.pSrc
	var nCol int32 = p.pEList.nExpr
	var v *struct_Vdbe = pParse.pVdbe
	var pSetup *struct_Select
	var pFirstRec *struct_Select
	var addrTop int32
	var addrCont int32
	var addrBreak int32
	var iCurrent int32 = 0
	var regCurrent int32
	var iQueue int32
	var iDistinct int32 = 0
	var eDest int32 = 8
	var destQueue struct_SelectDest
	var i int32
	var rc int32
	var pOrderBy *struct_ExprList
	var pLimit *struct_Expr
	var regLimit int32
	var regOffset int32
	if p.pWin != nil {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[49]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'u', 's', 'e', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', 's', ' ', 'i', 'n', ' ', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', ' ', 'q', 'u', 'e', 'r', 'i', 'e', 's', '\x00'})))
		return
	}
	if sqlite3AuthCheck(pParse, 33, nil, nil, nil) != 0 {
		return
	}
	addrBreak = sqlite3VdbeMakeLabel(pParse)
	p.nSelectRow = int16(320)
	computeLimitRegisters(pParse, p, addrBreak)
	pLimit = p.pLimit
	regLimit = p.iLimit
	regOffset = p.iOffset
	p.pLimit = (*struct_Expr)(nil)
	p.iLimit = func() (_cgo_ret int32) {
		_cgo_addr := &p.iOffset
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}()
	pOrderBy = p.pOrderBy
	for i = int32(0); i < pSrc.nSrc; i++ {
		if (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).fg.Xbf_0>>5&1 != 0 {
			iCurrent = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).iCursor
			break
		}
	}
	iQueue = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	if int32(p.op) == 134 {
		eDest = func() int32 {
			if pOrderBy != nil {
				return 6
			} else {
				return 5
			}
		}()
		iDistinct = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	} else {
		eDest = func() int32 {
			if pOrderBy != nil {
				return 7
			} else {
				return 8
			}
		}()
	}
	sqlite3SelectDestInit(&destQueue, eDest, iQueue)
	regCurrent = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	sqlite3VdbeAddOp3(v, 120, iCurrent, regCurrent, nCol)
	if pOrderBy != nil {
		var pKeyInfo *struct_KeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1)
		sqlite3VdbeAddOp4(v, 116, iQueue, pOrderBy.nExpr+2, 0, (*int8)(unsafe.Pointer(pKeyInfo)), -9)
		destQueue.pOrderBy = pOrderBy
	} else {
		sqlite3VdbeAddOp2(v, 116, iQueue, nCol)
	}
	if iDistinct != 0 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.addrOpenEphm)))) + uintptr(0)*4)) = sqlite3VdbeAddOp2(v, 116, iDistinct, 0)
		p.selFlags |= uint32(32)
	}
	p.pOrderBy = (*struct_ExprList)(nil)
	for pFirstRec = p; uintptr(unsafe.Pointer(pFirstRec)) != uintptr(unsafe.Pointer(nil)); pFirstRec = pFirstRec.pPrior {
		if pFirstRec.selFlags&uint32(8) != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[42]int8{'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', ' ', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ' ', 'q', 'u', 'e', 'r', 'i', 'e', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', '\x00'})))
			goto end_of_recursive_query
		}
		pFirstRec.op = uint8(135)
		if pFirstRec.pPrior.selFlags&uint32(8192) == uint32(0) {
			break
		}
	}
	pSetup = pFirstRec.pPrior
	pSetup.pNext = (*struct_Select)(nil)
	sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[6]int8{'S', 'E', 'T', 'U', 'P', '\x00'})))
	rc = sqlite3Select(pParse, pSetup, &destQueue)
	pSetup.pNext = p
	if rc != 0 {
		goto end_of_recursive_query
	}
	addrTop = sqlite3VdbeAddOp2(v, 38, iQueue, addrBreak)
	sqlite3VdbeAddOp1(v, 135, iCurrent)
	if pOrderBy != nil {
		sqlite3VdbeAddOp3(v, 93, iQueue, pOrderBy.nExpr+1, regCurrent)
	} else {
		sqlite3VdbeAddOp2(v, 133, iQueue, regCurrent)
	}
	sqlite3VdbeAddOp1(v, 129, iQueue)
	addrCont = sqlite3VdbeMakeLabel(pParse)
	codeOffset(v, regOffset, addrCont)
	selectInnerLoop(pParse, p, iCurrent, nil, nil, pDest, addrCont, addrBreak)
	if regLimit != 0 {
		sqlite3VdbeAddOp2(v, 60, regLimit, addrBreak)
	}
	sqlite3VdbeResolveLabel(v, addrCont)
	pFirstRec.pPrior = (*struct_Select)(nil)
	sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[15]int8{'R', 'E', 'C', 'U', 'R', 'S', 'I', 'V', 'E', ' ', 'S', 'T', 'E', 'P', '\x00'})))
	sqlite3Select(pParse, p, &destQueue)
	func() int {
		_ = 0
		return 0
	}()
	pFirstRec.pPrior = pSetup
	sqlite3VdbeGoto(v, addrTop)
	sqlite3VdbeResolveLabel(v, addrBreak)
end_of_recursive_query:
	sqlite3ExprListDelete(pParse.db, p.pOrderBy)
	p.pOrderBy = pOrderBy
	p.pLimit = pLimit
	return
}
func multiSelectValues(pParse *struct_Parse, p *struct_Select, pDest *struct_SelectDest) int32 {
	var nRow int32 = 1
	var rc int32 = 0
	var bShowAll int32 = func() int32 {
		if uintptr(unsafe.Pointer(p.pLimit)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	for {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if p.pWin != nil {
			return int32(-1)
		}
		if uintptr(unsafe.Pointer(p.pPrior)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		func() int {
			_ = 0
			return 0
		}()
		p = p.pPrior
		nRow += bShowAll
		if false {
			break
		}
	}
	sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[23]int8{'S', 'C', 'A', 'N', ' ', '%', 'd', ' ', 'C', 'O', 'N', 'S', 'T', 'A', 'N', 'T', ' ', 'R', 'O', 'W', '%', 's', '\x00'})), nRow, func() *int8 {
		if nRow == 1 {
			return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
		} else {
			return (*int8)(unsafe.Pointer(&[2]int8{'S', '\x00'}))
		}
	}())
	for p != nil {
		selectInnerLoop(pParse, p, -1, nil, nil, pDest, 1, 1)
		if !(bShowAll != 0) {
			break
		}
		p.nSelectRow = int16(nRow)
		p = p.pNext
	}
	return rc
}
func hasAnchor(p *struct_Select) int32 {
	for p != nil && p.selFlags&uint32(8192) != uint32(0) {
		p = p.pPrior
	}
	return func() int32 {
		if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
}
func multiSelect(pParse *struct_Parse, p *struct_Select, pDest *struct_SelectDest) int32 {
	var rc int32 = 0
	var pPrior *struct_Select
	var v *struct_Vdbe
	var dest struct_SelectDest
	var pDelete *struct_Select = nil
	var db *struct_sqlite3
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	pPrior = p.pPrior
	dest = *pDest
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	v = sqlite3GetVdbe(pParse)
	func() int {
		_ = 0
		return 0
	}()
	if int32(dest.eDest) == 12 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp2(v, 116, dest.iSDParm, p.pEList.nExpr)
		dest.eDest = uint8(14)
	}
	if p.selFlags&uint32(1024) != 0 {
		rc = multiSelectValues(pParse, p, &dest)
		if rc >= 0 {
			goto multi_select_end
		}
		rc = int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.selFlags&uint32(8192) != uint32(0) && hasAnchor(p) != 0 {
		generateWithRecursiveQuery(pParse, p, &dest)
	} else if p.pOrderBy != nil {
		return multiSelectOrderBy(pParse, p, pDest)
	} else {
		if uintptr(unsafe.Pointer(pPrior.pPrior)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[15]int8{'C', 'O', 'M', 'P', 'O', 'U', 'N', 'D', ' ', 'Q', 'U', 'E', 'R', 'Y', '\x00'})))
			sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[19]int8{'L', 'E', 'F', 'T', '-', 'M', 'O', 'S', 'T', ' ', 'S', 'U', 'B', 'Q', 'U', 'E', 'R', 'Y', '\x00'})))
		}
		switch int32(p.op) {
		case 135:
			{
				var addr int32 = 0
				var nLimit int32 = 0
				func() int {
					_ = 0
					return 0
				}()
				pPrior.iLimit = p.iLimit
				pPrior.iOffset = p.iOffset
				pPrior.pLimit = p.pLimit
				rc = sqlite3Select(pParse, pPrior, &dest)
				pPrior.pLimit = (*struct_Expr)(nil)
				if rc != 0 {
					goto multi_select_end
				}
				p.pPrior = (*struct_Select)(nil)
				p.iLimit = pPrior.iLimit
				p.iOffset = pPrior.iOffset
				if p.iLimit != 0 {
					addr = sqlite3VdbeAddOp1(v, 20, p.iLimit)
					if p.iOffset != 0 {
						sqlite3VdbeAddOp3(v, 159, p.iLimit, p.iOffset+1, p.iOffset)
					}
				}
				sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[10]int8{'U', 'N', 'I', 'O', 'N', ' ', 'A', 'L', 'L', '\x00'})))
				rc = sqlite3Select(pParse, p, &dest)
				pDelete = p.pPrior
				p.pPrior = pPrior
				p.nSelectRow = sqlite3LogEstAdd(p.nSelectRow, pPrior.nSelectRow)
				if p.pLimit != nil && sqlite3ExprIsInteger(p.pLimit.pLeft, &nLimit) != 0 && nLimit > 0 && int32(p.nSelectRow) > int32(sqlite3LogEst(uint64(nLimit))) {
					p.nSelectRow = sqlite3LogEst(uint64(nLimit))
				}
				if addr != 0 {
					sqlite3VdbeJumpHere(v, addr)
				}
				break
			}
		case 136:
			fallthrough
		case 134:
			{
				var unionTab int32
				var op uint8 = uint8(0)
				var priorOp int32
				var pLimit *struct_Expr
				var addr int32
				var uniondest struct_SelectDest
				priorOp = int32(1)
				if int32(dest.eDest) == priorOp {
					func() int {
						_ = 0
						return 0
					}()
					unionTab = dest.iSDParm
				} else {
					unionTab = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nTab
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
					func() int {
						_ = 0
						return 0
					}()
					addr = sqlite3VdbeAddOp2(v, 116, unionTab, 0)
					func() int {
						_ = 0
						return 0
					}()
					*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.addrOpenEphm)))) + uintptr(0)*4)) = addr
					findRightmost(p).selFlags |= uint32(32)
					func() int {
						_ = 0
						return 0
					}()
				}
				func() int {
					_ = 0
					return 0
				}()
				sqlite3SelectDestInit(&uniondest, priorOp, unionTab)
				rc = sqlite3Select(pParse, pPrior, &uniondest)
				if rc != 0 {
					goto multi_select_end
				}
				if int32(p.op) == 136 {
					op = uint8(2)
				} else {
					func() int {
						_ = 0
						return 0
					}()
					op = uint8(1)
				}
				p.pPrior = (*struct_Select)(nil)
				pLimit = p.pLimit
				p.pLimit = (*struct_Expr)(nil)
				uniondest.eDest = op
				sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[21]int8{'%', 's', ' ', 'U', 'S', 'I', 'N', 'G', ' ', 'T', 'E', 'M', 'P', ' ', 'B', '-', 'T', 'R', 'E', 'E', '\x00'})), sqlite3SelectOpName(int32(p.op)))
				rc = sqlite3Select(pParse, p, &uniondest)
				func() int {
					_ = 0
					return 0
				}()
				pDelete = p.pPrior
				p.pPrior = pPrior
				p.pOrderBy = (*struct_ExprList)(nil)
				if int32(p.op) == 134 {
					p.nSelectRow = sqlite3LogEstAdd(p.nSelectRow, pPrior.nSelectRow)
				}
				sqlite3ExprDelete(db, p.pLimit)
				p.pLimit = pLimit
				p.iLimit = int32(0)
				p.iOffset = int32(0)
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if int32(dest.eDest) != priorOp && int32(db.mallocFailed) == 0 {
					var iCont int32
					var iBreak int32
					var iStart int32
					iBreak = sqlite3VdbeMakeLabel(pParse)
					iCont = sqlite3VdbeMakeLabel(pParse)
					computeLimitRegisters(pParse, p, iBreak)
					sqlite3VdbeAddOp2(v, 38, unionTab, iBreak)
					iStart = sqlite3VdbeCurrentAddr(v)
					selectInnerLoop(pParse, p, unionTab, nil, nil, &dest, iCont, iBreak)
					sqlite3VdbeResolveLabel(v, iCont)
					sqlite3VdbeAddOp2(v, 5, unionTab, iStart)
					sqlite3VdbeResolveLabel(v, iBreak)
					sqlite3VdbeAddOp2(v, 121, unionTab, 0)
				}
				break
			}
		default:
			func() int {
				_ = 0
				return 0
			}()
			{
				var tab1 int32
				var tab2 int32
				var iCont int32
				var iBreak int32
				var iStart int32
				var pLimit *struct_Expr
				var addr int32
				var intersectdest struct_SelectDest
				var r1 int32
				tab1 = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nTab
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
				tab2 = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nTab
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
				func() int {
					_ = 0
					return 0
				}()
				addr = sqlite3VdbeAddOp2(v, 116, tab1, 0)
				func() int {
					_ = 0
					return 0
				}()
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.addrOpenEphm)))) + uintptr(0)*4)) = addr
				findRightmost(p).selFlags |= uint32(32)
				func() int {
					_ = 0
					return 0
				}()
				sqlite3SelectDestInit(&intersectdest, 1, tab1)
				rc = sqlite3Select(pParse, pPrior, &intersectdest)
				if rc != 0 {
					goto multi_select_end
				}
				addr = sqlite3VdbeAddOp2(v, 116, tab2, 0)
				func() int {
					_ = 0
					return 0
				}()
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&p.addrOpenEphm)))) + uintptr(1)*4)) = addr
				p.pPrior = (*struct_Select)(nil)
				pLimit = p.pLimit
				p.pLimit = (*struct_Expr)(nil)
				intersectdest.iSDParm = tab2
				sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[21]int8{'%', 's', ' ', 'U', 'S', 'I', 'N', 'G', ' ', 'T', 'E', 'M', 'P', ' ', 'B', '-', 'T', 'R', 'E', 'E', '\x00'})), sqlite3SelectOpName(int32(p.op)))
				rc = sqlite3Select(pParse, p, &intersectdest)
				pDelete = p.pPrior
				p.pPrior = pPrior
				if int32(p.nSelectRow) > int32(pPrior.nSelectRow) {
					p.nSelectRow = pPrior.nSelectRow
				}
				sqlite3ExprDelete(db, p.pLimit)
				p.pLimit = pLimit
				if rc != 0 {
					break
				}
				func() int {
					_ = 0
					return 0
				}()
				iBreak = sqlite3VdbeMakeLabel(pParse)
				iCont = sqlite3VdbeMakeLabel(pParse)
				computeLimitRegisters(pParse, p, iBreak)
				sqlite3VdbeAddOp2(v, 38, tab1, iBreak)
				r1 = sqlite3GetTempReg(pParse)
				iStart = sqlite3VdbeAddOp2(v, 133, tab1, r1)
				sqlite3VdbeAddOp4Int(v, 30, tab2, iCont, r1, 0)
				sqlite3ReleaseTempReg(pParse, r1)
				selectInnerLoop(pParse, p, tab1, nil, nil, &dest, iCont, iBreak)
				sqlite3VdbeResolveLabel(v, iCont)
				sqlite3VdbeAddOp2(v, 5, tab1, iStart)
				sqlite3VdbeResolveLabel(v, iBreak)
				sqlite3VdbeAddOp2(v, 121, tab2, 0)
				sqlite3VdbeAddOp2(v, 121, tab1, 0)
				break
			}
		}
		if uintptr(unsafe.Pointer(p.pNext)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3VdbeExplainPop(pParse)
		}
	}
	if pParse.nErr != 0 {
		goto multi_select_end
	}
	if p.selFlags&uint32(32) != 0 {
		var i int32
		var pKeyInfo *struct_KeyInfo
		var pLoop *struct_Select
		var apColl **struct_CollSeq
		var nCol int32
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		nCol = p.pEList.nExpr
		pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1)
		if !(pKeyInfo != nil) {
			rc = int32(7)
			goto multi_select_end
		}
		for func() **struct_CollSeq {
			i = int32(0)
			return func() (_cgo_ret **struct_CollSeq) {
				_cgo_addr := &apColl
				*_cgo_addr = (**struct_CollSeq)(unsafe.Pointer(&pKeyInfo.aColl))
				return *_cgo_addr
			}()
		}(); i < nCol; func() **struct_CollSeq {
			i++
			return func() (_cgo_ret **struct_CollSeq) {
				_cgo_addr := &apColl
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 8
				return
			}()
		}() {
			*apColl = multiSelectCollSeq(pParse, p, i)
			if nil == *apColl {
				*apColl = db.pDfltColl
			}
		}
		for pLoop = p; pLoop != nil; pLoop = pLoop.pPrior {
			for i = int32(0); i < 2; i++ {
				var addr int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pLoop.addrOpenEphm)))) + uintptr(i)*4))
				if addr < 0 {
					func() int {
						_ = 0
						return 0
					}()
					break
				}
				sqlite3VdbeChangeP2(v, addr, nCol)
				sqlite3VdbeChangeP4(v, addr, (*int8)(unsafe.Pointer(sqlite3KeyInfoRef(pKeyInfo))), -9)
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pLoop.addrOpenEphm)))) + uintptr(i)*4)) = int32(-1)
			}
		}
		sqlite3KeyInfoUnref(pKeyInfo)
	}
multi_select_end:
	pDest.iSdst = dest.iSdst
	pDest.nSdst = dest.nSdst
	if pDelete != nil {
		sqlite3ParserAddCleanup(pParse, (func(*struct_sqlite3, unsafe.Pointer))(sqlite3SelectDelete), unsafe.Pointer(pDelete))
	}
	return rc
}
func sqlite3SelectWrongNumTermsError(pParse *struct_Parse, p *struct_Select) {
	if p.selFlags&uint32(512) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[46]int8{'a', 'l', 'l', ' ', 'V', 'A', 'L', 'U', 'E', 'S', ' ', 'm', 'u', 's', 't', ' ', 'h', 'a', 'v', 'e', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 't', 'e', 'r', 'm', 's', '\x00'})))
	} else {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[82]int8{'S', 'E', 'L', 'E', 'C', 'T', 's', ' ', 't', 'o', ' ', 't', 'h', 'e', ' ', 'l', 'e', 'f', 't', ' ', 'a', 'n', 'd', ' ', 'r', 'i', 'g', 'h', 't', ' ', 'o', 'f', ' ', '%', 's', ' ', 'd', 'o', ' ', 'n', 'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 't', 'h', 'e', ' ', 's', 'a', 'm', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'r', 'e', 's', 'u', 'l', 't', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', '\x00'})), sqlite3SelectOpName(int32(p.op)))
	}
}
func generateOutputSubroutine(pParse *struct_Parse, p *struct_Select, pIn *struct_SelectDest, pDest *struct_SelectDest, regReturn int32, regPrev int32, pKeyInfo *struct_KeyInfo, iBreak int32) int32 {
	var v *struct_Vdbe = pParse.pVdbe
	var iContinue int32
	var addr int32
	addr = sqlite3VdbeCurrentAddr(v)
	iContinue = sqlite3VdbeMakeLabel(pParse)
	if regPrev != 0 {
		var addr1 int32
		var addr2 int32
		addr1 = sqlite3VdbeAddOp1(v, 20, regPrev)
		addr2 = sqlite3VdbeAddOp4(v, 89, pIn.iSdst, regPrev+1, pIn.nSdst, (*int8)(unsafe.Pointer(sqlite3KeyInfoRef(pKeyInfo))), -9)
		sqlite3VdbeAddOp3(v, 16, addr2+2, iContinue, addr2+2)
		sqlite3VdbeJumpHere(v, addr1)
		sqlite3VdbeAddOp3(v, 79, pIn.iSdst, regPrev+1, pIn.nSdst-1)
		sqlite3VdbeAddOp2(v, 71, 1, regPrev)
	}
	if pParse.db.mallocFailed != 0 {
		return int32(0)
	}
	codeOffset(v, p.iOffset, iContinue)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	switch int32(pDest.eDest) {
	case 12:
		{
			var r1 int32 = sqlite3GetTempReg(pParse)
			var r2 int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp3(v, 96, pIn.iSdst, pIn.nSdst, r1)
			sqlite3VdbeAddOp2(v, 126, pDest.iSDParm, r2)
			sqlite3VdbeAddOp3(v, 127, pDest.iSDParm, r1, r2)
			sqlite3VdbeChangeP5(v, uint16(8))
			sqlite3ReleaseTempReg(pParse, r2)
			sqlite3ReleaseTempReg(pParse, r1)
			break
		}
	case 11:
		{
			var r1 int32
			r1 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp4(v, 96, pIn.iSdst, pIn.nSdst, r1, pDest.zAffSdst, pIn.nSdst)
			sqlite3VdbeAddOp4Int(v, 137, pDest.iSDParm, r1, pIn.iSdst, pIn.nSdst)
			sqlite3ReleaseTempReg(pParse, r1)
			break
		}
	case 10:
		{
			sqlite3ExprCodeMove(pParse, pIn.iSdst, pDest.iSDParm, pIn.nSdst)
			break
		}
	case 13:
		{
			if pDest.iSdst == 0 {
				pDest.iSdst = sqlite3GetTempRange(pParse, pIn.nSdst)
				pDest.nSdst = pIn.nSdst
			}
			sqlite3ExprCodeMove(pParse, pIn.iSdst, pDest.iSdst, pIn.nSdst)
			sqlite3VdbeAddOp1(v, 14, pDest.iSDParm)
			break
		}
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 83, pIn.iSdst, pIn.nSdst)
			break
		}
	}
	if p.iLimit != 0 {
		sqlite3VdbeAddOp2(v, 60, p.iLimit, iBreak)
	}
	sqlite3VdbeResolveLabel(v, iContinue)
	sqlite3VdbeAddOp1(v, 67, regReturn)
	return addr
}
func multiSelectOrderBy(pParse *struct_Parse, p *struct_Select, pDest *struct_SelectDest) int32 {
	var i int32
	var j int32
	var pPrior *struct_Select
	var pSplit *struct_Select
	var nSelect int32
	var v *struct_Vdbe
	var destA struct_SelectDest
	var destB struct_SelectDest
	var regAddrA int32
	var regAddrB int32
	var addrSelectA int32
	var addrSelectB int32
	var regOutA int32
	var regOutB int32
	var addrOutA int32
	var addrOutB int32 = 0
	var addrEofA int32
	var addrEofA_noB int32
	var addrEofB int32
	var addrAltB int32
	var addrAeqB int32
	var addrAgtB int32
	var regLimitA int32
	var regLimitB int32
	var regPrev int32
	var savedLimit int32
	var savedOffset int32
	var labelCmpr int32
	var labelEnd int32
	var addr1 int32
	var op int32
	var pKeyDup *struct_KeyInfo = nil
	var pKeyMerge *struct_KeyInfo
	var db *struct_sqlite3
	var pOrderBy *struct_ExprList
	var nOrderBy int32
	var aPermute *uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	labelEnd = sqlite3VdbeMakeLabel(pParse)
	labelCmpr = sqlite3VdbeMakeLabel(pParse)
	op = int32(p.op)
	func() int {
		_ = 0
		return 0
	}()
	pOrderBy = p.pOrderBy
	func() int {
		_ = 0
		return 0
	}()
	nOrderBy = pOrderBy.nExpr
	if op != 135 {
		for i = int32(1); int32(db.mallocFailed) == 0 && i <= p.pEList.nExpr; i++ {
			var pItem *struct_ExprList_item
			for func() *struct_ExprList_item {
				j = int32(0)
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a))
					return *_cgo_addr
				}()
			}(); j < nOrderBy; func() *struct_ExprList_item {
				j++
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
					return
				}()
			}() {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if int32(pItem.u.x.iOrderByCol) == i {
					break
				}
			}
			if j == nOrderBy {
				var pNew *struct_Expr = sqlite3Expr(db, 155, nil)
				if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
					return int32(7)
				}
				pNew.flags |= uint32(1024)
				*(*int32)(unsafe.Pointer(&pNew.u)) = i
				p.pOrderBy = func() (_cgo_ret *struct_ExprList) {
					_cgo_addr := &pOrderBy
					*_cgo_addr = sqlite3ExprListAppend(pParse, pOrderBy, pNew)
					return *_cgo_addr
				}()
				if pOrderBy != nil {
					(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &nOrderBy
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}())*28))).u.x.iOrderByCol = uint16(i)
				}
			}
		}
	}
	aPermute = (*uint32)(sqlite3DbMallocRawNN(db, uint64(4*uint(nOrderBy+1))))
	if aPermute != nil {
		var pItem *struct_ExprList_item
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aPermute)) + uintptr(0)*4)) = uint32(nOrderBy)
		for func() *struct_ExprList_item {
			i = int32(1)
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a))
				return *_cgo_addr
			}()
		}(); i <= nOrderBy; func() *struct_ExprList_item {
			i++
			return func() (_cgo_ret *struct_ExprList_item) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
				return
			}()
		}() {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(aPermute)) + uintptr(i)*4)) = uint32(int32(pItem.u.x.iOrderByCol) - 1)
		}
		pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1)
	} else {
		pKeyMerge = (*struct_KeyInfo)(nil)
	}
	if op == 135 {
		regPrev = int32(0)
	} else {
		var nExpr int32 = p.pEList.nExpr
		func() int {
			_ = 0
			return 0
		}()
		regPrev = pParse.nMem + 1
		pParse.nMem += nExpr + 1
		sqlite3VdbeAddOp2(v, 71, 0, regPrev)
		pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1)
		if pKeyDup != nil {
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < nExpr; i++ {
				*(**struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_CollSeq)(unsafe.Pointer(&pKeyDup.aColl)))) + uintptr(i)*8)) = multiSelectCollSeq(pParse, p, i)
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyDup.aSortFlags)) + uintptr(i))) = uint8(0)
			}
		}
	}
	nSelect = int32(1)
	if (op == 135 || op == 134) && db.dbOptFlags&uint32(2097152) == uint32(0) {
		for pSplit = p; uintptr(unsafe.Pointer(pSplit.pPrior)) != uintptr(unsafe.Pointer(nil)) && int32(pSplit.op) == op; pSplit = pSplit.pPrior {
			nSelect++
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	if nSelect <= 3 {
		pSplit = p
	} else {
		pSplit = p
		for i = int32(2); i < nSelect; i += int32(2) {
			pSplit = pSplit.pPrior
		}
	}
	pPrior = pSplit.pPrior
	func() int {
		_ = 0
		return 0
	}()
	pSplit.pPrior = (*struct_Select)(nil)
	pPrior.pNext = (*struct_Select)(nil)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPrior.pOrderBy = sqlite3ExprListDup(pParse.db, pOrderBy, 0)
	sqlite3ResolveOrderGroupBy(pParse, p, p.pOrderBy, (*int8)(unsafe.Pointer(&[6]int8{'O', 'R', 'D', 'E', 'R', '\x00'})))
	sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior.pOrderBy, (*int8)(unsafe.Pointer(&[6]int8{'O', 'R', 'D', 'E', 'R', '\x00'})))
	computeLimitRegisters(pParse, p, labelEnd)
	if p.iLimit != 0 && op == 135 {
		regLimitA = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		regLimitB = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 79, func() int32 {
			if p.iOffset != 0 {
				return p.iOffset + 1
			} else {
				return p.iLimit
			}
		}(), regLimitA)
		sqlite3VdbeAddOp2(v, 79, regLimitA, regLimitB)
	} else {
		regLimitA = func() (_cgo_ret int32) {
			_cgo_addr := &regLimitB
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}
	sqlite3ExprDelete(db, p.pLimit)
	p.pLimit = (*struct_Expr)(nil)
	regAddrA = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	regAddrB = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	regOutA = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	regOutB = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	sqlite3SelectDestInit(&destA, 13, regAddrA)
	sqlite3SelectDestInit(&destB, 13, regAddrB)
	sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[11]int8{'M', 'E', 'R', 'G', 'E', ' ', '(', '%', 's', ')', '\x00'})), sqlite3SelectOpName(int32(p.op)))
	addrSelectA = sqlite3VdbeCurrentAddr(v) + 1
	addr1 = sqlite3VdbeAddOp3(v, 13, regAddrA, 0, addrSelectA)
	pPrior.iLimit = regLimitA
	sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[5]int8{'L', 'E', 'F', 'T', '\x00'})))
	sqlite3Select(pParse, pPrior, &destA)
	sqlite3VdbeEndCoroutine(v, regAddrA)
	sqlite3VdbeJumpHere(v, addr1)
	addrSelectB = sqlite3VdbeCurrentAddr(v) + 1
	addr1 = sqlite3VdbeAddOp3(v, 13, regAddrB, 0, addrSelectB)
	savedLimit = p.iLimit
	savedOffset = p.iOffset
	p.iLimit = regLimitB
	p.iOffset = int32(0)
	sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[6]int8{'R', 'I', 'G', 'H', 'T', '\x00'})))
	sqlite3Select(pParse, p, &destB)
	p.iLimit = savedLimit
	p.iOffset = savedOffset
	sqlite3VdbeEndCoroutine(v, regAddrB)
	addrOutA = generateOutputSubroutine(pParse, p, &destA, pDest, regOutA, regPrev, pKeyDup, labelEnd)
	if op == 135 || op == 134 {
		addrOutB = generateOutputSubroutine(pParse, p, &destB, pDest, regOutB, regPrev, pKeyDup, labelEnd)
	}
	sqlite3KeyInfoUnref(pKeyDup)
	if op == 136 || op == 137 {
		addrEofA_noB = func() (_cgo_ret int32) {
			_cgo_addr := &addrEofA
			*_cgo_addr = labelEnd
			return *_cgo_addr
		}()
	} else {
		addrEofA = sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB)
		addrEofA_noB = sqlite3VdbeAddOp2(v, 14, regAddrB, labelEnd)
		sqlite3VdbeGoto(v, addrEofA)
		p.nSelectRow = sqlite3LogEstAdd(p.nSelectRow, pPrior.nSelectRow)
	}
	if op == 137 {
		addrEofB = addrEofA
		if int32(p.nSelectRow) > int32(pPrior.nSelectRow) {
			p.nSelectRow = pPrior.nSelectRow
		}
	} else {
		addrEofB = sqlite3VdbeAddOp2(v, 12, regOutA, addrOutA)
		sqlite3VdbeAddOp2(v, 14, regAddrA, labelEnd)
		sqlite3VdbeGoto(v, addrEofB)
	}
	addrAltB = sqlite3VdbeAddOp2(v, 12, regOutA, addrOutA)
	sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA)
	sqlite3VdbeGoto(v, labelCmpr)
	if op == 135 {
		addrAeqB = addrAltB
	} else if op == 137 {
		addrAeqB = addrAltB
		addrAltB++
	} else {
		addrAeqB = sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA)
		sqlite3VdbeGoto(v, labelCmpr)
	}
	addrAgtB = sqlite3VdbeCurrentAddr(v)
	if op == 135 || op == 134 {
		sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB)
	}
	sqlite3VdbeAddOp2(v, 14, regAddrB, addrEofB)
	sqlite3VdbeGoto(v, labelCmpr)
	sqlite3VdbeJumpHere(v, addr1)
	sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA_noB)
	sqlite3VdbeAddOp2(v, 14, regAddrB, addrEofB)
	sqlite3VdbeResolveLabel(v, labelCmpr)
	sqlite3VdbeAddOp4(v, 88, 0, 0, 0, (*int8)(unsafe.Pointer(aPermute)), -15)
	sqlite3VdbeAddOp4(v, 89, destA.iSdst, destB.iSdst, nOrderBy, (*int8)(unsafe.Pointer(pKeyMerge)), -9)
	sqlite3VdbeChangeP5(v, uint16(1))
	sqlite3VdbeAddOp3(v, 16, addrAltB, addrAeqB, addrAgtB)
	sqlite3VdbeResolveLabel(v, labelEnd)
	if pSplit.pPrior != nil {
		sqlite3SelectDelete(db, pSplit.pPrior)
	}
	pSplit.pPrior = pPrior
	pPrior.pNext = pSplit
	sqlite3ExprListDelete(db, pPrior.pOrderBy)
	pPrior.pOrderBy = (*struct_ExprList)(nil)
	sqlite3VdbeExplainPop(pParse)
	return func() int32 {
		if pParse.nErr != 0 {
			return 1
		} else {
			return 0
		}
	}()
}

type struct_SubstContext struct {
	pParse     *struct_Parse
	iTable     int32
	iNewTable  int32
	isLeftJoin int32
	pEList     *struct_ExprList
}
type SubstContext = struct_SubstContext

func substExpr(pSubst *struct_SubstContext, pExpr *struct_Expr) *struct_Expr {
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_Expr)(nil)
	}
	if pExpr.flags&uint32(1) != uint32(0) && pExpr.w.iRightJoinTable == pSubst.iTable {
		pExpr.w.iRightJoinTable = pSubst.iNewTable
	}
	if int32(pExpr.op) == 167 && pExpr.iTable == pSubst.iTable && !(pExpr.flags&uint32(8) != uint32(0)) {
		{
			var pNew *struct_Expr
			var pCopy *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSubst.pEList.a)))) + uintptr(pExpr.iColumn)*28))).pExpr
			var ifNullRow struct_Expr
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if sqlite3ExprIsVector(pCopy) != 0 {
				sqlite3VectorErrorMsg(pSubst.pParse, pCopy)
			} else {
				var db *struct_sqlite3 = pSubst.pParse.db
				if pSubst.isLeftJoin != 0 && int32(pCopy.op) != 167 {
					__builtin___memset_chk(unsafe.Pointer(&ifNullRow), 0, 72, __builtin_object_size(unsafe.Pointer(&ifNullRow), 0))
					ifNullRow.op = uint8(179)
					ifNullRow.pLeft = pCopy
					ifNullRow.iTable = pSubst.iNewTable
					ifNullRow.flags = uint32(131072)
					pCopy = &ifNullRow
				}
				pNew = sqlite3ExprDup(db, pCopy, 0)
				if db.mallocFailed != 0 {
					sqlite3ExprDelete(db, pNew)
					return pExpr
				}
				if pSubst.isLeftJoin != 0 {
					pNew.flags |= uint32(1048576)
				}
				if pExpr.flags&uint32(1) != uint32(0) {
					sqlite3SetJoinExpr(pNew, pExpr.w.iRightJoinTable)
				}
				sqlite3ExprDelete(db, pExpr)
				pExpr = pNew
				if int32(pExpr.op) != 167 && int32(pExpr.op) != 113 {
					var pColl *struct_CollSeq = sqlite3ExprCollSeq(pSubst.pParse, pExpr)
					pExpr = sqlite3ExprAddCollateString(pSubst.pParse, pExpr, func() *int8 {
						if pColl != nil {
							return pColl.zName
						} else {
							return (*int8)(unsafe.Pointer(&[7]int8{'B', 'I', 'N', 'A', 'R', 'Y', '\x00'}))
						}
					}())
				}
				pExpr.flags &= uint32(4294967039)
			}
		}
	} else {
		if int32(pExpr.op) == 179 && pExpr.iTable == pSubst.iTable {
			pExpr.iTable = pSubst.iNewTable
		}
		pExpr.pLeft = substExpr(pSubst, pExpr.pLeft)
		pExpr.pRight = substExpr(pSubst, pExpr.pRight)
		if pExpr.flags&uint32(2048) != uint32(0) {
			substSelect(pSubst, *(**struct_Select)(unsafe.Pointer(&pExpr.x)), 1)
		} else {
			substExprList(pSubst, pExpr.x.pList)
		}
		if pExpr.flags&uint32(16777216) != uint32(0) {
			var pWin *struct_Window = *(**struct_Window)(unsafe.Pointer(&pExpr.y))
			pWin.pFilter = substExpr(pSubst, pWin.pFilter)
			substExprList(pSubst, pWin.pPartition)
			substExprList(pSubst, pWin.pOrderBy)
		}
	}
	return pExpr
}
func substExprList(pSubst *struct_SubstContext, pList *struct_ExprList) {
	var i int32
	if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	for i = int32(0); i < pList.nExpr; i++ {
		(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr = substExpr(pSubst, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr)
	}
}
func substSelect(pSubst *struct_SubstContext, p *struct_Select, doPrior int32) {
	var pSrc *struct_SrcList
	var pItem *struct_SrcItem
	var i int32
	if !(p != nil) {
		return
	}
	for {
		substExprList(pSubst, p.pEList)
		substExprList(pSubst, p.pGroupBy)
		substExprList(pSubst, p.pOrderBy)
		p.pHaving = substExpr(pSubst, p.pHaving)
		p.pWhere = substExpr(pSubst, p.pWhere)
		pSrc = p.pSrc
		func() int {
			_ = 0
			return 0
		}()
		for func() *struct_SrcItem {
			i = pSrc.nSrc
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pItem
				*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pSrc.a))
				return *_cgo_addr
			}()
		}(); i > 0; func() *struct_SrcItem {
			i--
			return func() (_cgo_ret *struct_SrcItem) {
				_cgo_addr := &pItem
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
				return
			}()
		}() {
			substSelect(pSubst, pItem.pSelect, 1)
			if pItem.fg.Xbf_0>>2&1 != 0 {
				substExprList(pSubst, *(**struct_ExprList)(unsafe.Pointer(&pItem.u1)))
			}
		}
		if !(doPrior != 0 && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Select) {
			_cgo_addr := &p
			*_cgo_addr = p.pPrior
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil))) {
			break
		}
	}
}
func recomputeColumnsUsedExpr(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var pItem *struct_SrcItem
	if int32(pExpr.op) != 167 {
		return int32(0)
	}
	pItem = *(**struct_SrcItem)(unsafe.Pointer(&pWalker.u))
	if pItem.iCursor != pExpr.iTable {
		return int32(0)
	}
	if int32(pExpr.iColumn) < 0 {
		return int32(0)
	}
	pItem.colUsed |= sqlite3ExprColUsed(pExpr)
	return int32(0)
}
func recomputeColumnsUsed(pSelect *struct_Select, pSrcItem *struct_SrcItem) {
	var w struct_Walker
	if uintptr(unsafe.Pointer(pSrcItem.pTab)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	w.xExprCallback = recomputeColumnsUsedExpr
	w.xSelectCallback = sqlite3SelectWalkNoop
	*(**struct_SrcItem)(unsafe.Pointer(&w.u)) = pSrcItem
	pSrcItem.colUsed = uint64(0)
	sqlite3WalkSelect(&w, pSelect)
}
func srclistRenumberCursors(pParse *struct_Parse, aCsrMap *int32, pSrc *struct_SrcList, iExcept int32) {
	var i int32
	var pItem *struct_SrcItem
	for func() *struct_SrcItem {
		i = int32(0)
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pSrc.a))
			return *_cgo_addr
		}()
	}(); i < pSrc.nSrc; func() *struct_SrcItem {
		i++
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		if i != iExcept {
			var p *struct_Select
			func() int {
				_ = 0
				return 0
			}()
			if !(pItem.fg.Xbf_0>>5&1 != 0) || *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(pItem.iCursor+1)*4)) == 0 {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(pItem.iCursor+1)*4)) = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nTab
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
			}
			pItem.iCursor = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(pItem.iCursor+1)*4))
			for p = pItem.pSelect; p != nil; p = p.pPrior {
				srclistRenumberCursors(pParse, aCsrMap, p.pSrc, -1)
			}
		}
	}
}
func renumberCursorDoMapping(pWalker *struct_Walker, piCursor *int32) {
	var aCsrMap *int32 = *(**int32)(unsafe.Pointer(&pWalker.u))
	var iCsr int32 = *piCursor
	if iCsr < *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(0)*4)) && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(iCsr+1)*4)) > 0 {
		*piCursor = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(iCsr+1)*4))
	}
}
func renumberCursorsCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var op int32 = int32(pExpr.op)
	if op == 167 || op == 179 {
		renumberCursorDoMapping(pWalker, &pExpr.iTable)
	}
	if pExpr.flags&uint32(1) != uint32(0) {
		renumberCursorDoMapping(pWalker, &pExpr.w.iRightJoinTable)
	}
	return int32(0)
}
func renumberCursors(pParse *struct_Parse, p *struct_Select, iExcept int32, aCsrMap *int32) {
	var w struct_Walker
	srclistRenumberCursors(pParse, aCsrMap, p.pSrc, iExcept)
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	*(**int32)(unsafe.Pointer(&w.u)) = aCsrMap
	w.xExprCallback = renumberCursorsCb
	w.xSelectCallback = sqlite3SelectWalkNoop
	sqlite3WalkSelect(&w, p)
}
func flattenSubquery(pParse *struct_Parse, p *struct_Select, iFrom int32, isAgg int32) int32 {
	var zSavedAuthContext *int8 = pParse.zAuthContext
	var pParent *struct_Select
	var pSub *struct_Select
	var pSub1 *struct_Select
	var pSrc *struct_SrcList
	var pSubSrc *struct_SrcList
	var iParent int32
	var iNewParent int32 = -1
	var isLeftJoin int32 = 0
	var i int32
	var pWhere *struct_Expr
	var pSubitem *struct_SrcItem
	var db *struct_sqlite3 = pParse.db
	var w struct_Walker
	var aCsrMap *int32 = nil
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db.dbOptFlags&uint32(1) != uint32(0) {
		return int32(0)
	}
	pSrc = p.pSrc
	func() int {
		_ = 0
		return 0
	}()
	pSubitem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(iFrom)*112))
	iParent = pSubitem.iCursor
	pSub = pSubitem.pSelect
	func() int {
		_ = 0
		return 0
	}()
	if p.pWin != nil || pSub.pWin != nil {
		return int32(0)
	}
	pSubSrc = pSub.pSrc
	func() int {
		_ = 0
		return 0
	}()
	if pSub.pLimit != nil && p.pLimit != nil {
		return int32(0)
	}
	if pSub.pLimit != nil && pSub.pLimit.pRight != nil {
		return int32(0)
	}
	if p.selFlags&uint32(256) != uint32(0) && pSub.pLimit != nil {
		return int32(0)
	}
	if pSubSrc.nSrc == 0 {
		return int32(0)
	}
	if pSub.selFlags&uint32(1) != 0 {
		return int32(0)
	}
	if pSub.pLimit != nil && (pSrc.nSrc > 1 || isAgg != 0) {
		return int32(0)
	}
	if p.pOrderBy != nil && pSub.pOrderBy != nil {
		return int32(0)
	}
	if isAgg != 0 && pSub.pOrderBy != nil {
		return int32(0)
	}
	if pSub.pLimit != nil && p.pWhere != nil {
		return int32(0)
	}
	if pSub.pLimit != nil && p.selFlags&uint32(1) != uint32(0) {
		return int32(0)
	}
	if pSub.selFlags&uint32(8192) != 0 {
		return int32(0)
	}
	if int32(pSubitem.fg.jointype)&32 != 0 {
		isLeftJoin = int32(1)
		if pSubSrc.nSrc > 1 || isAgg != 0 || int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSubSrc.a)))) + uintptr(0)*112))).pTab.eTabType) == 1 || p.selFlags&uint32(1) != uint32(0) {
			return int32(0)
		}
	}
	if pSub.pPrior != nil {
		if pSub.pOrderBy != nil {
			return int32(0)
		}
		if isAgg != 0 || p.selFlags&uint32(1) != uint32(0) || isLeftJoin > 0 {
			return int32(0)
		}
		for pSub1 = pSub; pSub1 != nil; pSub1 = pSub1.pPrior {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if pSub1.selFlags&uint32(1|8) != uint32(0) || pSub1.pPrior != nil && int32(pSub1.op) != 135 || pSub1.pSrc.nSrc < 1 || pSub1.pWin != nil {
				return int32(0)
			}
		}
		if p.pOrderBy != nil {
			var ii int32
			for ii = int32(0); ii < p.pOrderBy.nExpr; ii++ {
				if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.pOrderBy.a)))) + uintptr(ii)*28))).u.x.iOrderByCol) == 0 {
					return int32(0)
				}
			}
		}
		if p.selFlags&uint32(8192) != 0 {
			return int32(0)
		}
		if pSrc.nSrc > 1 {
			if pParse.nSelect > 500 {
				return int32(0)
			}
			aCsrMap = (*int32)(sqlite3DbMallocZero(db, uint64(int64(pParse.nTab)+int64(1))*uint64(4)))
			if aCsrMap != nil {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aCsrMap)) + uintptr(0)*4)) = pParse.nTab
			}
		}
	}
	pParse.zAuthContext = pSubitem.zName
	sqlite3AuthCheck(pParse, 21, nil, nil, nil)
	pParse.zAuthContext = zSavedAuthContext
	pSub1 = pSubitem.pSelect
	sqlite3DbFree(db, unsafe.Pointer(pSubitem.zDatabase))
	sqlite3DbFree(db, unsafe.Pointer(pSubitem.zName))
	sqlite3DbFree(db, unsafe.Pointer(pSubitem.zAlias))
	pSubitem.zDatabase = (*int8)(nil)
	pSubitem.zName = (*int8)(nil)
	pSubitem.zAlias = (*int8)(nil)
	pSubitem.pSelect = (*struct_Select)(nil)
	func() int {
		_ = 0
		return 0
	}()
	for pSub = pSub.pPrior; pSub != nil; pSub = pSub.pPrior {
		var pNew *struct_Select
		var pOrderBy *struct_ExprList = p.pOrderBy
		var pLimit *struct_Expr = p.pLimit
		var pPrior *struct_Select = p.pPrior
		var pItemTab *struct_Table = pSubitem.pTab
		pSubitem.pTab = (*struct_Table)(nil)
		p.pOrderBy = (*struct_ExprList)(nil)
		p.pPrior = (*struct_Select)(nil)
		p.pLimit = (*struct_Expr)(nil)
		pNew = sqlite3SelectDup(db, p, 0)
		p.pLimit = pLimit
		p.pOrderBy = pOrderBy
		p.op = uint8(135)
		pSubitem.pTab = pItemTab
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			p.pPrior = pPrior
		} else {
			pNew.selId = uint32(func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nSelect
				*_cgo_addr++
				return *_cgo_addr
			}())
			if aCsrMap != nil && int32(db.mallocFailed) == 0 {
				renumberCursors(pParse, pNew, iFrom, aCsrMap)
			}
			pNew.pPrior = pPrior
			if pPrior != nil {
				pPrior.pNext = pNew
			}
			pNew.pNext = p
			p.pPrior = pNew
		}
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3DbFree(db, unsafe.Pointer(aCsrMap))
	if db.mallocFailed != 0 {
		pSubitem.pSelect = pSub1
		return int32(1)
	}
	if uintptr(unsafe.Pointer(pSubitem.pTab)) != uintptr(unsafe.Pointer(nil)) {
		var pTabToDel *struct_Table = pSubitem.pTab
		if pTabToDel.nTabRef == uint32(1) {
			var pToplevel *struct_Parse = func() *struct_Parse {
				if pParse.pToplevel != nil {
					return pParse.pToplevel
				} else {
					return pParse
				}
			}()
			sqlite3ParserAddCleanup(pToplevel, (func(*struct_sqlite3, unsafe.Pointer))(sqlite3DeleteTable), unsafe.Pointer(pTabToDel))
		} else {
			pTabToDel.nTabRef--
		}
		pSubitem.pTab = (*struct_Table)(nil)
	}
	pSub = pSub1
	for pParent = p; pParent != nil; func() *struct_Select {
		pParent = pParent.pPrior
		return func() (_cgo_ret *struct_Select) {
			_cgo_addr := &pSub
			*_cgo_addr = pSub.pPrior
			return *_cgo_addr
		}()
	}() {
		var nSubSrc int32
		var jointype uint8 = uint8(0)
		func() int {
			_ = 0
			return 0
		}()
		pSubSrc = pSub.pSrc
		nSubSrc = pSubSrc.nSrc
		pSrc = pParent.pSrc
		if uintptr(unsafe.Pointer(pParent)) == uintptr(unsafe.Pointer(p)) {
			jointype = pSubitem.fg.jointype
		}
		if nSubSrc > 1 {
			pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1, iFrom+1)
			if uintptr(unsafe.Pointer(pSrc)) == uintptr(unsafe.Pointer(nil)) {
				break
			}
			pParent.pSrc = pSrc
		}
		for i = int32(0); i < nSubSrc; i++ {
			sqlite3IdListDelete(db, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i+iFrom)*112))).pUsing)
			func() int {
				_ = 0
				return 0
			}()
			*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i+iFrom)*112)) = *(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSubSrc.a)))) + uintptr(i)*112))
			iNewParent = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSubSrc.a)))) + uintptr(i)*112))).iCursor
			__builtin___memset_chk(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSubSrc.a)))) + uintptr(i)*112))), 0, 112, __builtin_object_size(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSubSrc.a)))) + uintptr(i)*112))), 0))
		}
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(iFrom)*112))).fg.jointype = jointype
		if pSub.pOrderBy != nil && pParent.selFlags&uint32(4194304) == uint32(0) {
			var pOrderBy *struct_ExprList = pSub.pOrderBy
			for i = int32(0); i < pOrderBy.nExpr; i++ {
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).u.x.iOrderByCol = uint16(0)
			}
			func() int {
				_ = 0
				return 0
			}()
			pParent.pOrderBy = pOrderBy
			pSub.pOrderBy = (*struct_ExprList)(nil)
		}
		pWhere = pSub.pWhere
		pSub.pWhere = (*struct_Expr)(nil)
		if isLeftJoin > 0 {
			sqlite3SetJoinExpr(pWhere, iNewParent)
		}
		if pWhere != nil {
			if pParent.pWhere != nil {
				pParent.pWhere = sqlite3PExpr(pParse, 44, pWhere, pParent.pWhere)
			} else {
				pParent.pWhere = pWhere
			}
		}
		if int32(db.mallocFailed) == 0 {
			var x struct_SubstContext
			x.pParse = pParse
			x.iTable = iParent
			x.iNewTable = iNewParent
			x.isLeftJoin = isLeftJoin
			x.pEList = pSub.pEList
			substSelect(&x, pParent, 0)
		}
		pParent.selFlags |= pSub.selFlags & uint32(256)
		func() int {
			_ = 0
			return 0
		}()
		if pSub.pLimit != nil {
			pParent.pLimit = pSub.pLimit
			pSub.pLimit = (*struct_Expr)(nil)
		}
		for i = int32(0); i < nSubSrc; i++ {
			recomputeColumnsUsed(pParent, &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i+iFrom)*112)))
		}
	}
	sqlite3AggInfoPersistWalkerInit(&w, pParse)
	sqlite3WalkSelect(&w, pSub1)
	sqlite3SelectDelete(db, pSub1)
	return int32(1)
}

type WhereConst = struct_WhereConst
type struct_WhereConst struct {
	pParse      *struct_Parse
	pOomFault   *uint8
	nConst      int32
	nChng       int32
	bHasAffBlob int32
	apExpr      **struct_Expr
}

func constInsert(pConst *struct_WhereConst, pColumn *struct_Expr, pValue *struct_Expr, pExpr *struct_Expr) {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pColumn.flags&uint32(8) != uint32(0) {
		return
	}
	if int32(sqlite3ExprAffinity(pValue)) != 0 {
		return
	}
	if !(sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst.pParse, pExpr)) != 0) {
		return
	}
	for i = int32(0); i < pConst.nConst; i++ {
		var pE2 *struct_Expr = *(**struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.apExpr)) + uintptr(i*2)*8))
		func() int {
			_ = 0
			return 0
		}()
		if pE2.iTable == pColumn.iTable && int32(pE2.iColumn) == int32(pColumn.iColumn) {
			return
		}
	}
	if int32(sqlite3ExprAffinity(pColumn)) == 65 {
		pConst.bHasAffBlob = int32(1)
	}
	pConst.nConst++
	pConst.apExpr = (**struct_Expr)(sqlite3DbReallocOrFree(pConst.pParse.db, unsafe.Pointer(pConst.apExpr), uint64(uint(pConst.nConst*2)*8)))
	if uintptr(unsafe.Pointer(pConst.apExpr)) == uintptr(unsafe.Pointer(nil)) {
		pConst.nConst = int32(0)
	} else {
		*(**struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.apExpr)) + uintptr(pConst.nConst*2-2)*8)) = pColumn
		*(**struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.apExpr)) + uintptr(pConst.nConst*2-1)*8)) = pValue
	}
}
func findConstInWhere(pConst *struct_WhereConst, pExpr *struct_Expr) {
	var pRight *struct_Expr
	var pLeft *struct_Expr
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if pExpr.flags&uint32(1) != uint32(0) {
		return
	}
	if int32(pExpr.op) == 44 {
		findConstInWhere(pConst, pExpr.pRight)
		findConstInWhere(pConst, pExpr.pLeft)
		return
	}
	if int32(pExpr.op) != 53 {
		return
	}
	pRight = pExpr.pRight
	pLeft = pExpr.pLeft
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pRight.op) == 167 && sqlite3ExprIsConstant(pLeft) != 0 {
		constInsert(pConst, pRight, pLeft, pExpr)
	}
	if int32(pLeft.op) == 167 && sqlite3ExprIsConstant(pRight) != 0 {
		constInsert(pConst, pLeft, pRight, pExpr)
	}
}
func propagateConstantExprRewriteOne(pConst *struct_WhereConst, pExpr *struct_Expr, bIgnoreAffBlob int32) int32 {
	var i int32
	if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.pOomFault)) + uintptr(0))) != 0 {
		return int32(1)
	}
	if int32(pExpr.op) != 167 {
		return int32(0)
	}
	if pExpr.flags&uint32(8|1) != uint32(0) {
		return int32(0)
	}
	for i = int32(0); i < pConst.nConst; i++ {
		var pColumn *struct_Expr = *(**struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.apExpr)) + uintptr(i*2)*8))
		if uintptr(unsafe.Pointer(pColumn)) == uintptr(unsafe.Pointer(pExpr)) {
			continue
		}
		if pColumn.iTable != pExpr.iTable {
			continue
		}
		if int32(pColumn.iColumn) != int32(pExpr.iColumn) {
			continue
		}
		if bIgnoreAffBlob != 0 && int32(sqlite3ExprAffinity(pColumn)) == 65 {
			break
		}
		pConst.nChng++
		pExpr.flags &= uint32(4286578687)
		pExpr.flags |= uint32(8)
		func() int {
			_ = 0
			return 0
		}()
		pExpr.pLeft = sqlite3ExprDup(pConst.pParse.db, *(**struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.apExpr)) + uintptr(i*2+1)*8)), 0)
		if pConst.pParse.db.mallocFailed != 0 {
			return int32(1)
		}
		break
	}
	return int32(1)
}
func propagateConstantExprRewrite(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var pConst *struct_WhereConst = *(**struct_WhereConst)(unsafe.Pointer(&pWalker.u))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pConst.bHasAffBlob != 0 {
		if int32(pExpr.op) >= 53 && int32(pExpr.op) <= 57 || int32(pExpr.op) == 45 {
			propagateConstantExprRewriteOne(pConst, pExpr.pLeft, 0)
			if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pConst.pOomFault)) + uintptr(0))) != 0 {
				return int32(1)
			}
			if int32(sqlite3ExprAffinity(pExpr.pLeft)) != 66 {
				propagateConstantExprRewriteOne(pConst, pExpr.pRight, 0)
			}
		}
	}
	return propagateConstantExprRewriteOne(pConst, pExpr, pConst.bHasAffBlob)
}
func propagateConstants(pParse *struct_Parse, p *struct_Select) int32 {
	var x struct_WhereConst
	var w struct_Walker
	var nChng int32 = 0
	x.pParse = pParse
	x.pOomFault = &pParse.db.mallocFailed
	for {
		x.nConst = int32(0)
		x.nChng = int32(0)
		x.apExpr = (**struct_Expr)(nil)
		x.bHasAffBlob = int32(0)
		findConstInWhere(&x, p.pWhere)
		if x.nConst != 0 {
			__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
			w.pParse = pParse
			w.xExprCallback = propagateConstantExprRewrite
			w.xSelectCallback = sqlite3SelectWalkNoop
			w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
			w.walkerDepth = int32(0)
			*(**struct_WhereConst)(unsafe.Pointer(&w.u)) = &x
			sqlite3WalkExpr(&w, p.pWhere)
			sqlite3DbFree(x.pParse.db, unsafe.Pointer(x.apExpr))
			nChng += x.nChng
		}
		if !(x.nChng != 0) {
			break
		}
	}
	return nChng
}
func pushDownWindowCheck(pParse *struct_Parse, pSubq *struct_Select, pExpr *struct_Expr) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3ExprIsConstantOrGroupBy(pParse, pExpr, pSubq.pWin.pPartition)
}
func pushDownWhereTerms(pParse *struct_Parse, pSubq *struct_Select, pWhere *struct_Expr, iCursor int32, isLeftJoin int32) int32 {
	var pNew *struct_Expr
	var nChng int32 = 0
	if uintptr(unsafe.Pointer(pWhere)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if pSubq.selFlags&uint32(8192|33554432) != 0 {
		return int32(0)
	}
	if pSubq.pPrior != nil {
		var pSel *struct_Select
		for pSel = pSubq; pSel != nil; pSel = pSel.pPrior {
			if pSel.pWin != nil {
				return int32(0)
			}
		}
	} else if pSubq.pWin != nil && uintptr(unsafe.Pointer(pSubq.pWin.pPartition)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pSubq.pLimit)) != uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	for int32(pWhere.op) == 44 {
		nChng += pushDownWhereTerms(pParse, pSubq, pWhere.pRight, iCursor, isLeftJoin)
		pWhere = pWhere.pLeft
	}
	if isLeftJoin != 0 && (func() int32 {
		if pWhere.flags&uint32(1) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}() == 0 || pWhere.w.iRightJoinTable != iCursor) {
		return int32(0)
	}
	if pWhere.flags&uint32(1) != uint32(0) && pWhere.w.iRightJoinTable != iCursor {
		return int32(0)
	}
	if sqlite3ExprIsTableConstant(pWhere, iCursor) != 0 {
		nChng++
		pSubq.selFlags |= uint32(16777216)
		for pSubq != nil {
			var x struct_SubstContext
			pNew = sqlite3ExprDup(pParse.db, pWhere, 0)
			unsetJoinExpr(pNew, -1)
			x.pParse = pParse
			x.iTable = iCursor
			x.iNewTable = iCursor
			x.isLeftJoin = int32(0)
			x.pEList = pSubq.pEList
			pNew = substExpr(&x, pNew)
			if pSubq.pWin != nil && 0 == pushDownWindowCheck(pParse, pSubq, pNew) {
				sqlite3ExprDelete(pParse.db, pNew)
				nChng--
				break
			}
			if pSubq.selFlags&uint32(8) != 0 {
				pSubq.pHaving = sqlite3ExprAnd(pParse, pSubq.pHaving, pNew)
			} else {
				pSubq.pWhere = sqlite3ExprAnd(pParse, pSubq.pWhere, pNew)
			}
			pSubq = pSubq.pPrior
		}
	}
	return nChng
}
func minMaxQuery(db *struct_sqlite3, pFunc *struct_Expr, ppMinMax **struct_ExprList) uint8 {
	var eRet int32 = 0
	var pEList *struct_ExprList
	var zFunc *int8
	var pOrderBy *struct_ExprList
	var sortFlags uint8 = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pEList = pFunc.x.pList
	if uintptr(unsafe.Pointer(pEList)) == uintptr(unsafe.Pointer(nil)) || pEList.nExpr != 1 || pFunc.flags&uint32(16777216) != uint32(0) || db.dbOptFlags&uint32(65536) != uint32(0) {
		return uint8(eRet)
	}
	func() int {
		_ = 0
		return 0
	}()
	zFunc = pFunc.u.zToken
	if sqlite3StrICmp(zFunc, (*int8)(unsafe.Pointer(&[4]int8{'m', 'i', 'n', '\x00'}))) == 0 {
		eRet = int32(1)
		if sqlite3ExprCanBeNull((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(0)*28))).pExpr) != 0 {
			sortFlags = uint8(2)
		}
	} else if sqlite3StrICmp(zFunc, (*int8)(unsafe.Pointer(&[4]int8{'m', 'a', 'x', '\x00'}))) == 0 {
		eRet = int32(2)
		sortFlags = uint8(1)
	} else {
		return uint8(eRet)
	}
	*ppMinMax = func() (_cgo_ret *struct_ExprList) {
		_cgo_addr := &pOrderBy
		*_cgo_addr = sqlite3ExprListDup(db, pEList, 0)
		return *_cgo_addr
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pOrderBy != nil {
		(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(0)*28))).sortFlags = sortFlags
	}
	return uint8(eRet)
}
func isSimpleCount(p *struct_Select, pAggInfo *struct_AggInfo) *struct_Table {
	var pTab *struct_Table
	var pExpr *struct_Expr
	func() int {
		_ = 0
		return 0
	}()
	if p.pWhere != nil || p.pEList.nExpr != 1 || p.pSrc.nSrc != 1 || (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pSelect != nil || pAggInfo.nFunc != 1 {
		return (*struct_Table)(nil)
	}
	pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pTab
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if !(int32(pTab.eTabType) == 0) {
		return (*struct_Table)(nil)
	}
	pExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.pEList.a)))) + uintptr(0)*28))).pExpr
	func() int {
		_ = 0
		return 0
	}()
	if int32(pExpr.op) != 168 {
		return (*struct_Table)(nil)
	}
	if uintptr(unsafe.Pointer(pExpr.pAggInfo)) != uintptr(unsafe.Pointer(pAggInfo)) {
		return (*struct_Table)(nil)
	}
	if (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFunc.funcFlags&uint32(256) == uint32(0) {
		return (*struct_Table)(nil)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pExpr.flags&uint32(2|16777216) != uint32(0) {
		return (*struct_Table)(nil)
	}
	return pTab
}
func sqlite3IndexedByLookup(pParse *struct_Parse, pFrom *struct_SrcItem) int32 {
	var pTab *struct_Table = pFrom.pTab
	var zIndexedBy *int8 = pFrom.u1.zIndexedBy
	var pIdx *struct_Index
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for pIdx = pTab.pIndex; pIdx != nil && sqlite3StrICmp(pIdx.zName, zIndexedBy) != 0; pIdx = pIdx.pNext {
	}
	if !(pIdx != nil) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'i', 'n', 'd', 'e', 'x', ':', ' ', '%', 's', '\x00'})), zIndexedBy, 0)
		pParse.checkSchema = uint8(1)
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	pFrom.u2.pIBIndex = pIdx
	return int32(0)
}
func convertCompoundSelectToSubquery(pWalker *struct_Walker, p *struct_Select) int32 {
	var i int32
	var pNew *struct_Select
	var pX *struct_Select
	var db *struct_sqlite3
	var a *struct_ExprList_item
	var pNewSrc *struct_SrcList
	var pParse *struct_Parse
	var dummy struct_Token
	if uintptr(unsafe.Pointer(p.pPrior)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(p.pOrderBy)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	for pX = p; pX != nil && (int32(pX.op) == 135 || int32(pX.op) == 138); pX = pX.pPrior {
	}
	if uintptr(unsafe.Pointer(pX)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	a = (*struct_ExprList_item)(unsafe.Pointer(&p.pOrderBy.a))
	if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(0)*28))).u.x.iOrderByCol != 0 {
		return int32(0)
	}
	for i = p.pOrderBy.nExpr - 1; i >= 0; i-- {
		if (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(i)*28))).pExpr.flags&uint32(256) != 0 {
			break
		}
	}
	if i < 0 {
		return int32(0)
	}
	pParse = pWalker.pParse
	db = pParse.db
	pNew = (*struct_Select)(sqlite3DbMallocZero(db, uint64(128)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return int32(2)
	}
	__builtin___memset_chk(unsafe.Pointer(&dummy), 0, 12, __builtin_object_size(unsafe.Pointer(&dummy), 0))
	pNewSrc = sqlite3SrcListAppendFromTerm(pParse, nil, nil, nil, &dummy, pNew, nil, nil)
	if uintptr(unsafe.Pointer(pNewSrc)) == uintptr(unsafe.Pointer(nil)) {
		return int32(2)
	}
	*pNew = *p
	p.pSrc = pNewSrc
	p.pEList = sqlite3ExprListAppend(pParse, nil, sqlite3Expr(db, 180, nil))
	p.op = uint8(138)
	p.pWhere = (*struct_Expr)(nil)
	pNew.pGroupBy = (*struct_ExprList)(nil)
	pNew.pHaving = (*struct_Expr)(nil)
	pNew.pOrderBy = (*struct_ExprList)(nil)
	p.pPrior = (*struct_Select)(nil)
	p.pNext = (*struct_Select)(nil)
	p.pWith = (*struct_With)(nil)
	p.pWinDefn = (*struct_Window)(nil)
	p.selFlags &= uint32(4294967039)
	func() int {
		_ = 0
		return 0
	}()
	p.selFlags |= uint32(65536)
	func() int {
		_ = 0
		return 0
	}()
	pNew.pPrior.pNext = pNew
	pNew.pLimit = (*struct_Expr)(nil)
	return int32(0)
}
func cannotBeFunction(pParse *struct_Parse, pFrom *struct_SrcItem) int32 {
	if pFrom.fg.Xbf_0>>2&1 != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[23]int8{'\'', '%', 's', '\'', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', '\x00'})), pFrom.zName)
		return int32(1)
	}
	return int32(0)
}
func searchWith(pWith *struct_With, pItem *struct_SrcItem, ppContext **struct_With) *struct_Cte {
	var zName *int8 = pItem.zName
	var p *struct_With
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for p = pWith; p != nil; p = p.pOuter {
		var i int32
		for i = int32(0); i < p.nCte; i++ {
			if sqlite3StrICmp(zName, (*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&p.a)))) + uintptr(i)*41))).zName) == 0 {
				*ppContext = p
				return &*(*struct_Cte)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Cte)(unsafe.Pointer(&p.a)))) + uintptr(i)*41))
			}
		}
		if p.bView != 0 {
			break
		}
	}
	return (*struct_Cte)(nil)
}
func sqlite3WithPush(pParse *struct_Parse, pWith *struct_With, bFree uint8) *struct_With {
	if pWith != nil {
		if bFree != 0 {
			pWith = (*struct_With)(sqlite3ParserAddCleanup(pParse, (func(*struct_sqlite3, unsafe.Pointer))(sqlite3WithDelete), unsafe.Pointer(pWith)))
			if uintptr(unsafe.Pointer(pWith)) == uintptr(unsafe.Pointer(nil)) {
				return (*struct_With)(nil)
			}
		}
		if pParse.nErr == 0 {
			func() int {
				_ = 0
				return 0
			}()
			pWith.pOuter = pParse.pWith
			pParse.pWith = pWith
		}
	}
	return pWith
}
func resolveFromTermToCte(pParse *struct_Parse, pWalker *struct_Walker, pFrom *struct_SrcItem) int32 {
	var pCte *struct_Cte
	var pWith *struct_With
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pParse.pWith)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if pParse.nErr != 0 {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(pFrom.zDatabase)) != uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	if pFrom.fg.Xbf_0>>8&1 != 0 {
		return int32(0)
	}
	pCte = searchWith(pParse.pWith, pFrom, &pWith)
	if pCte != nil {
		var db *struct_sqlite3 = pParse.db
		var pTab *struct_Table
		var pEList *struct_ExprList
		var pSel *struct_Select
		var pLeft *struct_Select
		var pRecTerm *struct_Select
		var bMayRecursive int32
		var pSavedWith *struct_With
		var iRecTab int32 = -1
		var pCteUse *struct_CteUse
		if pCte.zCteErr != nil {
			sqlite3ErrorMsg(pParse, pCte.zCteErr, pCte.zName)
			return int32(2)
		}
		if cannotBeFunction(pParse, pFrom) != 0 {
			return int32(2)
		}
		func() int {
			_ = 0
			return 0
		}()
		pTab = (*struct_Table)(sqlite3DbMallocZero(db, uint64(104)))
		if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
			return int32(2)
		}
		pCteUse = pCte.pUse
		if uintptr(unsafe.Pointer(pCteUse)) == uintptr(unsafe.Pointer(nil)) {
			pCte.pUse = func() (_cgo_ret *struct_CteUse) {
				_cgo_addr := &pCteUse
				*_cgo_addr = (*struct_CteUse)(sqlite3DbMallocZero(db, uint64(19)))
				return *_cgo_addr
			}()
			if uintptr(unsafe.Pointer(pCteUse)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(sqlite3ParserAddCleanup(pParse, sqlite3DbFree, unsafe.Pointer(pCteUse)))) == uintptr(unsafe.Pointer(nil)) {
				sqlite3DbFree(db, unsafe.Pointer(pTab))
				return int32(2)
			}
			pCteUse.eM10d = pCte.eM10d
		}
		pFrom.pTab = pTab
		pTab.nTabRef = uint32(1)
		pTab.zName = sqlite3DbStrDup(db, pCte.zName)
		pTab.iPKey = int16(-1)
		pTab.nRowLogEst = int16(200)
		func() int {
			_ = 0
			return 0
		}()
		pTab.tabFlags |= uint32(16384 | 512)
		pFrom.pSelect = sqlite3SelectDup(db, pCte.pSelect, 0)
		if db.mallocFailed != 0 {
			return int32(2)
		}
		pFrom.pSelect.selFlags |= uint32(67108864)
		func() int {
			_ = 0
			return 0
		}()
		if pFrom.fg.Xbf_0>>1&1 != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[20]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'i', 'n', 'd', 'e', 'x', ':', ' ', '"', '%', 's', '"', '\x00'})), pFrom.u1.zIndexedBy)
			return int32(2)
		}
		{
			_autoGo_75 := &pFrom.fg.Xbf_0
			*_autoGo_75 = *_autoGo_75&^128 | uint32(1)&1<<7
		}
		*(**struct_CteUse)(unsafe.Pointer(&pFrom.u2)) = pCteUse
		pCteUse.nUse++
		if pCteUse.nUse >= 2 && int32(pCteUse.eM10d) == 1 {
			pCteUse.eM10d = uint8(0)
		}
		pRecTerm = func() (_cgo_ret *struct_Select) {
			_cgo_addr := &pSel
			*_cgo_addr = pFrom.pSelect
			return *_cgo_addr
		}()
		bMayRecursive = func() int32 {
			if int32(pSel.op) == 135 || int32(pSel.op) == 134 {
				return 1
			} else {
				return 0
			}
		}()
		for bMayRecursive != 0 && int32(pRecTerm.op) == int32(pSel.op) {
			var i int32
			var pSrc *struct_SrcList = pRecTerm.pSrc
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < pSrc.nSrc; i++ {
				var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))
				if uintptr(unsafe.Pointer(pItem.zDatabase)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pItem.zName)) != uintptr(unsafe.Pointer(nil)) && 0 == sqlite3StrICmp(pItem.zName, pCte.zName) {
					pItem.pTab = pTab
					pTab.nTabRef++
					{
						_autoGo_76 := &pItem.fg.Xbf_0
						*_autoGo_76 = *_autoGo_76&^32 | uint32(1)&1<<5
					}
					if pRecTerm.selFlags&uint32(8192) != 0 {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[43]int8{'m', 'u', 'l', 't', 'i', 'p', 'l', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 's', ' ', 't', 'o', ' ', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', ' ', 't', 'a', 'b', 'l', 'e', ':', ' ', '%', 's', '\x00'})), pCte.zName)
						return int32(2)
					}
					pRecTerm.selFlags |= uint32(8192)
					if iRecTab < 0 {
						iRecTab = func() (_cgo_ret int32) {
							_cgo_addr := &pParse.nTab
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}()
					}
					pItem.iCursor = iRecTab
				}
			}
			if pRecTerm.selFlags&uint32(8192) == uint32(0) {
				break
			}
			pRecTerm = pRecTerm.pPrior
		}
		pCte.zCteErr = (*int8)(unsafe.Pointer(&[23]int8{'c', 'i', 'r', 'c', 'u', 'l', 'a', 'r', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ':', ' ', '%', 's', '\x00'}))
		pSavedWith = pParse.pWith
		pParse.pWith = pWith
		if pSel.selFlags&uint32(8192) != 0 {
			var rc int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pRecTerm.pWith = pSel.pWith
			rc = sqlite3WalkSelect(pWalker, pRecTerm)
			pRecTerm.pWith = (*struct_With)(nil)
			if rc != 0 {
				pParse.pWith = pSavedWith
				return int32(2)
			}
		} else if sqlite3WalkSelect(pWalker, pSel) != 0 {
			pParse.pWith = pSavedWith
			return int32(2)
		}
		pParse.pWith = pWith
		for pLeft = pSel; pLeft.pPrior != nil; pLeft = pLeft.pPrior {
		}
		pEList = pLeft.pEList
		if pCte.pCols != nil {
			if pEList != nil && pEList.nExpr != pCte.pCols.nExpr {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[38]int8{'t', 'a', 'b', 'l', 'e', ' ', '%', 's', ' ', 'h', 'a', 's', ' ', '%', 'd', ' ', 'v', 'a', 'l', 'u', 'e', 's', ' ', 'f', 'o', 'r', ' ', '%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', '\x00'})), pCte.zName, pEList.nExpr, pCte.pCols.nExpr)
				pParse.pWith = pSavedWith
				return int32(2)
			}
			pEList = pCte.pCols
		}
		sqlite3ColumnsFromExprList(pParse, pEList, &pTab.nCol, &pTab.aCol)
		if bMayRecursive != 0 {
			if pSel.selFlags&uint32(8192) != 0 {
				pCte.zCteErr = (*int8)(unsafe.Pointer(&[34]int8{'m', 'u', 'l', 't', 'i', 'p', 'l', 'e', ' ', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 's', ':', ' ', '%', 's', '\x00'}))
			} else {
				pCte.zCteErr = (*int8)(unsafe.Pointer(&[38]int8{'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', ' ', 'i', 'n', ' ', 'a', ' ', 's', 'u', 'b', 'q', 'u', 'e', 'r', 'y', ':', ' ', '%', 's', '\x00'}))
			}
			sqlite3WalkSelect(pWalker, pSel)
		}
		pCte.zCteErr = (*int8)(nil)
		pParse.pWith = pSavedWith
		return int32(1)
	}
	return int32(0)
}
func sqlite3SelectPopWith(pWalker *struct_Walker, p *struct_Select) {
	var pParse *struct_Parse = pWalker.pParse
	if pParse.pWith != nil && uintptr(unsafe.Pointer(p.pPrior)) == uintptr(unsafe.Pointer(nil)) {
		var pWith *struct_With = findRightmost(p).pWith
		if uintptr(unsafe.Pointer(pWith)) != uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			pParse.pWith = pWith.pOuter
		}
	}
}
func sqlite3ExpandSubquery(pParse *struct_Parse, pFrom *struct_SrcItem) int32 {
	var pSel *struct_Select = pFrom.pSelect
	var pTab *struct_Table
	func() int {
		_ = 0
		return 0
	}()
	pFrom.pTab = func() (_cgo_ret *struct_Table) {
		_cgo_addr := &pTab
		*_cgo_addr = (*struct_Table)(sqlite3DbMallocZero(pParse.db, uint64(104)))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	pTab.nTabRef = uint32(1)
	if pFrom.zAlias != nil {
		pTab.zName = sqlite3DbStrDup(pParse.db, pFrom.zAlias)
	} else {
		pTab.zName = sqlite3MPrintf(pParse.db, (*int8)(unsafe.Pointer(&[12]int8{'s', 'u', 'b', 'q', 'u', 'e', 'r', 'y', '_', '%', 'u', '\x00'})), pSel.selId)
	}
	for pSel.pPrior != nil {
		pSel = pSel.pPrior
	}
	sqlite3ColumnsFromExprList(pParse, pSel.pEList, &pTab.nCol, &pTab.aCol)
	pTab.iPKey = int16(-1)
	pTab.nRowLogEst = int16(200)
	func() int {
		_ = 0
		return 0
	}()
	pTab.tabFlags |= uint32(16384 | 512)
	return func() int32 {
		if pParse.nErr != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func selectExpander(pWalker *struct_Walker, p *struct_Select) int32 {
	var pParse *struct_Parse = pWalker.pParse
	var i int32
	var j int32
	var k int32
	var rc int32
	var pTabList *struct_SrcList
	var pEList *struct_ExprList
	var pFrom *struct_SrcItem
	var db *struct_sqlite3 = pParse.db
	var pE *struct_Expr
	var pRight *struct_Expr
	var pExpr *struct_Expr
	var selFlags uint16 = uint16(p.selFlags)
	var elistFlags uint32 = uint32(0)
	p.selFlags |= uint32(64)
	if db.mallocFailed != 0 {
		return int32(2)
	}
	func() int {
		_ = 0
		return 0
	}()
	if int32(selFlags)&64 != 0 {
		return int32(1)
	}
	if pWalker.eCode != 0 {
		p.selId = uint32(func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nSelect
			*_cgo_addr++
			return *_cgo_addr
		}())
	}
	pTabList = p.pSrc
	pEList = p.pEList
	if pParse.pWith != nil && p.selFlags&uint32(2097152) != 0 {
		if uintptr(unsafe.Pointer(p.pWith)) == uintptr(unsafe.Pointer(nil)) {
			p.pWith = (*struct_With)(sqlite3DbMallocZero(db, uint64(57)))
			if uintptr(unsafe.Pointer(p.pWith)) == uintptr(unsafe.Pointer(nil)) {
				return int32(2)
			}
		}
		p.pWith.bView = int32(1)
	}
	sqlite3WithPush(pParse, p.pWith, uint8(0))
	sqlite3SrcListAssignCursors(pParse, pTabList)
	for func() *struct_SrcItem {
		i = int32(0)
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pFrom
			*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pTabList.a))
			return *_cgo_addr
		}()
	}(); i < pTabList.nSrc; func() *struct_SrcItem {
		i++
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pFrom
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		var pTab *struct_Table
		func() int {
			_ = 0
			return 0
		}()
		if pFrom.pTab != nil {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pFrom.zName)) == uintptr(unsafe.Pointer(nil)) {
			var pSel *struct_Select = pFrom.pSelect
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if sqlite3WalkSelect(pWalker, pSel) != 0 {
				return int32(2)
			}
			if sqlite3ExpandSubquery(pParse, pFrom) != 0 {
				return int32(2)
			}
		} else if func() (_cgo_ret int32) {
			_cgo_addr := &rc
			*_cgo_addr = resolveFromTermToCte(pParse, pWalker, pFrom)
			return *_cgo_addr
		}() != 0 {
			if rc > 1 {
				return int32(2)
			}
			pTab = pFrom.pTab
			func() int {
				_ = 0
				return 0
			}()
		} else {
			func() int {
				_ = 0
				return 0
			}()
			pFrom.pTab = func() (_cgo_ret *struct_Table) {
				_cgo_addr := &pTab
				*_cgo_addr = sqlite3LocateTableItem(pParse, uint32(0), pFrom)
				return *_cgo_addr
			}()
			if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
				return int32(2)
			}
			if pTab.nTabRef >= uint32(65535) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[39]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 's', ' ', 't', 'o', ' ', '"', '%', 's', '"', ':', ' ', 'm', 'a', 'x', ' ', '6', '5', '5', '3', '5', '\x00'})), pTab.zName)
				pFrom.pTab = (*struct_Table)(nil)
				return int32(2)
			}
			pTab.nTabRef++
			if !(int32(pTab.eTabType) == 1) && cannotBeFunction(pParse, pFrom) != 0 {
				return int32(2)
			}
			if !(int32(pTab.eTabType) == 0) {
				var nCol int16
				var eCodeOrig uint8 = uint8(pWalker.eCode)
				if sqlite3ViewGetColumnNames(pParse, pTab) != 0 {
					return int32(2)
				}
				func() int {
					_ = 0
					return 0
				}()
				if int32(pTab.eTabType) == 2 {
					if db.flags&uint64(2147483648) == uint64(0) && uintptr(unsafe.Pointer(pTab.pSchema)) != uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema)) {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[31]int8{'a', 'c', 'c', 'e', 's', 's', ' ', 't', 'o', ' ', 'v', 'i', 'e', 'w', ' ', '"', '%', 's', '"', ' ', 'p', 'r', 'o', 'h', 'i', 'b', 'i', 't', 'e', 'd', '\x00'})), pTab.zName)
					}
					pFrom.pSelect = sqlite3SelectDup(db, (*(*_cgoa_12)(unsafe.Pointer(&pTab.u))).pSelect, 0)
				} else if int32(pTab.eTabType) == 1 && int32(pFrom.fg.Xbf_0>>6&1) != 0 && uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p)) != uintptr(unsafe.Pointer(nil)) && int32((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p.eVtabRisk) > func() int32 {
					if db.flags&uint64(128) != uint64(0) {
						return 1
					} else {
						return 0
					}
				}() {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[33]int8{'u', 'n', 's', 'a', 'f', 'e', ' ', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', ' ', '"', '%', 's', '"', '\x00'})), pTab.zName)
				}
				func() int {
					_ = 0
					return 0
				}()
				nCol = pTab.nCol
				pTab.nCol = int16(-1)
				pWalker.eCode = uint16(1)
				sqlite3WalkSelect(pWalker, pFrom.pSelect)
				pWalker.eCode = uint16(eCodeOrig)
				pTab.nCol = nCol
			}
		}
		if int32(pFrom.fg.Xbf_0>>1&1) != 0 && sqlite3IndexedByLookup(pParse, pFrom) != 0 {
			return int32(2)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 || sqliteProcessJoin(pParse, p) != 0 {
		return int32(2)
	}
	for k = int32(0); k < pEList.nExpr; k++ {
		pE = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(k)*28))).pExpr
		if int32(pE.op) == 180 {
			break
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if int32(pE.op) == 141 && int32(pE.pRight.op) == 180 {
			break
		}
		elistFlags |= pE.flags
	}
	if k < pEList.nExpr {
		var a *struct_ExprList_item = (*struct_ExprList_item)(unsafe.Pointer(&pEList.a))
		var pNew *struct_ExprList = nil
		var flags int32 = int32(pParse.db.flags)
		var longNames int32 = func() int32 {
			if flags&4 != 0 && flags&64 == 0 {
				return 1
			} else {
				return 0
			}
		}()
		for k = int32(0); k < pEList.nExpr; k++ {
			pE = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(k)*28))).pExpr
			elistFlags |= pE.flags
			pRight = pE.pRight
			func() int {
				_ = 0
				return 0
			}()
			if int32(pE.op) != 180 && (int32(pE.op) != 141 || int32(pRight.op) != 180) {
				pNew = sqlite3ExprListAppend(pParse, pNew, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(k)*28))).pExpr)
				if pNew != nil {
					(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pNew.a)))) + uintptr(pNew.nExpr-1)*28))).zEName = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(k)*28))).zEName
					{
						_autoGo_77 := &(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pNew.a)))) + uintptr(pNew.nExpr-1)*28))).Xbf_0
						*_autoGo_77 = *_autoGo_77&^3 | (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(k)*28))).Xbf_0&3&3
					}
					(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(k)*28))).zEName = (*int8)(nil)
				}
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer(a)) + uintptr(k)*28))).pExpr = (*struct_Expr)(nil)
			} else {
				var tableSeen int32 = 0
				var zTName *int8 = nil
				if int32(pE.op) == 141 {
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					zTName = pE.pLeft.u.zToken
				}
				for func() *struct_SrcItem {
					i = int32(0)
					return func() (_cgo_ret *struct_SrcItem) {
						_cgo_addr := &pFrom
						*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pTabList.a))
						return *_cgo_addr
					}()
				}(); i < pTabList.nSrc; func() *struct_SrcItem {
					i++
					return func() (_cgo_ret *struct_SrcItem) {
						_cgo_addr := &pFrom
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
						return
					}()
				}() {
					var pTab *struct_Table = pFrom.pTab
					var pSub *struct_Select = pFrom.pSelect
					var zTabName *int8 = pFrom.zAlias
					var zSchemaName *int8 = nil
					var iDb int32
					if uintptr(unsafe.Pointer(zTabName)) == uintptr(unsafe.Pointer(nil)) {
						zTabName = pTab.zName
					}
					if db.mallocFailed != 0 {
						break
					}
					if uintptr(unsafe.Pointer(pSub)) == uintptr(unsafe.Pointer(nil)) || pSub.selFlags&uint32(2048) == uint32(0) {
						pSub = (*struct_Select)(nil)
						if zTName != nil && sqlite3StrICmp(zTName, zTabName) != 0 {
							continue
						}
						iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
						zSchemaName = func() *int8 {
							if iDb >= 0 {
								return (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
							} else {
								return (*int8)(unsafe.Pointer(&[2]int8{'*', '\x00'}))
							}
						}()
					}
					for j = int32(0); j < int32(pTab.nCol); j++ {
						var zName *int8 = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName
						var zColname *int8
						var zToFree *int8
						var sColname struct_Token
						func() int {
							_ = 0
							return 0
						}()
						if zTName != nil && pSub != nil && sqlite3MatchEName(&*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSub.pEList.a)))) + uintptr(j)*28)), nil, zTName, nil) == 0 {
							continue
						}
						if p.selFlags&uint32(131072) == uint32(0) && int32((&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).colFlags)&2 != 0 {
							continue
						}
						tableSeen = int32(1)
						if i > 0 && uintptr(unsafe.Pointer(zTName)) == uintptr(unsafe.Pointer(nil)) {
							if int32(pFrom.fg.jointype)&4 != 0 && tableAndColumnIndex(pTabList, i, zName, nil, nil, 1) != 0 {
								continue
							}
							if sqlite3IdListIndex(pFrom.pUsing, zName) >= 0 {
								continue
							}
						}
						pRight = sqlite3Expr(db, 59, zName)
						zColname = zName
						zToFree = (*int8)(nil)
						if longNames != 0 || pTabList.nSrc > 1 {
							var pLeft *struct_Expr
							pLeft = sqlite3Expr(db, 59, zTabName)
							pExpr = sqlite3PExpr(pParse, 141, pLeft, pRight)
							if zSchemaName != nil {
								pLeft = sqlite3Expr(db, 59, zSchemaName)
								pExpr = sqlite3PExpr(pParse, 141, pLeft, pExpr)
							}
							if longNames != 0 {
								zColname = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[6]int8{'%', 's', '.', '%', 's', '\x00'})), zTabName, zName)
								zToFree = zColname
							}
						} else {
							pExpr = pRight
						}
						pNew = sqlite3ExprListAppend(pParse, pNew, pExpr)
						sqlite3TokenInit(&sColname, zColname)
						sqlite3ExprListSetName(pParse, pNew, &sColname, 0)
						if pNew != nil && p.selFlags&uint32(2048) != uint32(0) && !(int32(pParse.eParseMode) >= 2) {
							var pX *struct_ExprList_item = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pNew.a)))) + uintptr(pNew.nExpr-1)*28))
							sqlite3DbFree(db, unsafe.Pointer(pX.zEName))
							if pSub != nil {
								pX.zEName = sqlite3DbStrDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pSub.pEList.a)))) + uintptr(j)*28))).zEName)
							} else {
								pX.zEName = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[9]int8{'%', 's', '.', '%', 's', '.', '%', 's', '\x00'})), zSchemaName, zTabName, zColname)
							}
							{
								_autoGo_78 := &pX.Xbf_0
								*_autoGo_78 = *_autoGo_78&^3 | uint32(2)&3
							}
						}
						sqlite3DbFree(db, unsafe.Pointer(zToFree))
					}
				}
				if !(tableSeen != 0) {
					if zTName != nil {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 't', 'a', 'b', 'l', 'e', ':', ' ', '%', 's', '\x00'})), zTName)
					} else {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[20]int8{'n', 'o', ' ', 't', 'a', 'b', 'l', 'e', 's', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'e', 'd', '\x00'})))
					}
				}
			}
		}
		sqlite3ExprListDelete(db, pEList)
		p.pEList = pNew
	}
	if p.pEList != nil {
		if p.pEList.nExpr > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(2)*4)) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[31]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'i', 'n', ' ', 'r', 'e', 's', 'u', 'l', 't', ' ', 's', 'e', 't', '\x00'})))
			return int32(2)
		}
		if elistFlags&uint32(4|2097152) != uint32(0) {
			p.selFlags |= uint32(262144)
		}
	}
	return int32(0)
}
func sqlite3SelectExpand(pParse *struct_Parse, pSelect *struct_Select) {
	var w struct_Walker
	w.xExprCallback = sqlite3ExprWalkNoop
	w.pParse = pParse
	if pParse.hasCompound != 0 {
		w.xSelectCallback = convertCompoundSelectToSubquery
		w.xSelectCallback2 = (func(*struct_Walker, *struct_Select))(nil)
		sqlite3WalkSelect(&w, pSelect)
	}
	w.xSelectCallback = selectExpander
	w.xSelectCallback2 = sqlite3SelectPopWith
	w.eCode = uint16(0)
	sqlite3WalkSelect(&w, pSelect)
}
func selectAddSubqueryTypeInfo(pWalker *struct_Walker, p *struct_Select) {
	var pParse *struct_Parse
	var i int32
	var pTabList *struct_SrcList
	var pFrom *struct_SrcItem
	func() int {
		_ = 0
		return 0
	}()
	if p.selFlags&uint32(128) != 0 {
		return
	}
	p.selFlags |= uint32(128)
	pParse = pWalker.pParse
	pTabList = p.pSrc
	for func() *struct_SrcItem {
		i = int32(0)
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pFrom
			*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pTabList.a))
			return *_cgo_addr
		}()
	}(); i < pTabList.nSrc; func() *struct_SrcItem {
		i++
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pFrom
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		var pTab *struct_Table = pFrom.pTab
		func() int {
			_ = 0
			return 0
		}()
		if pTab.tabFlags&uint32(16384) != uint32(0) {
			var pSel *struct_Select = pFrom.pSelect
			if pSel != nil {
				for pSel.pPrior != nil {
					pSel = pSel.pPrior
				}
				sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel, int8(64))
			}
		}
	}
}
func sqlite3SelectAddTypeInfo(pParse *struct_Parse, pSelect *struct_Select) {
	var w struct_Walker
	w.xSelectCallback = sqlite3SelectWalkNoop
	w.xSelectCallback2 = selectAddSubqueryTypeInfo
	w.xExprCallback = sqlite3ExprWalkNoop
	w.pParse = pParse
	sqlite3WalkSelect(&w, pSelect)
}
func sqlite3SelectPrep(pParse *struct_Parse, p *struct_Select, pOuterNC *struct_NameContext) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pParse.db.mallocFailed != 0 {
		return
	}
	if p.selFlags&uint32(128) != 0 {
		return
	}
	sqlite3SelectExpand(pParse, p)
	if pParse.nErr != 0 {
		return
	}
	sqlite3ResolveSelectNames(pParse, p, pOuterNC)
	if pParse.nErr != 0 {
		return
	}
	sqlite3SelectAddTypeInfo(pParse, p)
}
func resetAccumulator(pParse *struct_Parse, pAggInfo *struct_AggInfo) {
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var pFunc *struct_AggInfo_func
	var nReg int32 = pAggInfo.nFunc + pAggInfo.nColumn
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if nReg == 0 {
		return
	}
	if pParse.nErr != 0 {
		return
	}
	sqlite3VdbeAddOp3(v, 74, 0, pAggInfo.mnReg, pAggInfo.mxReg)
	for func() int32 {
		pFunc = pAggInfo.aFunc
		return func() (_cgo_ret int32) {
			_cgo_addr := &i
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}(); i < pAggInfo.nFunc; func() *struct_AggInfo_func {
		i++
		return func() (_cgo_ret *struct_AggInfo_func) {
			_cgo_addr := &pFunc
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		if pFunc.iDistinct >= 0 {
			var pE *struct_Expr = pFunc.pFExpr
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pE.x.pList)) == uintptr(unsafe.Pointer(nil)) || pE.x.pList.nExpr != 1 {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[51]int8{'D', 'I', 'S', 'T', 'I', 'N', 'C', 'T', ' ', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', 's', ' ', 'm', 'u', 's', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'e', 'x', 'a', 'c', 't', 'l', 'y', ' ', 'o', 'n', 'e', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', '\x00'})))
				pFunc.iDistinct = int32(-1)
			} else {
				var pKeyInfo *struct_KeyInfo = sqlite3KeyInfoFromExprList(pParse, pE.x.pList, 0, 0)
				pFunc.iDistAddr = sqlite3VdbeAddOp4(v, 116, pFunc.iDistinct, 0, 0, (*int8)(unsafe.Pointer(pKeyInfo)), -9)
				sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[33]int8{'U', 'S', 'E', ' ', 'T', 'E', 'M', 'P', ' ', 'B', '-', 'T', 'R', 'E', 'E', ' ', 'F', 'O', 'R', ' ', '%', 's', '(', 'D', 'I', 'S', 'T', 'I', 'N', 'C', 'T', ')', '\x00'})), pFunc.pFunc.zName)
			}
		}
	}
}
func finalizeAggFunctions(pParse *struct_Parse, pAggInfo *struct_AggInfo) {
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var pF *struct_AggInfo_func
	for func() *struct_AggInfo_func {
		i = int32(0)
		return func() (_cgo_ret *struct_AggInfo_func) {
			_cgo_addr := &pF
			*_cgo_addr = pAggInfo.aFunc
			return *_cgo_addr
		}()
	}(); i < pAggInfo.nFunc; func() *struct_AggInfo_func {
		i++
		return func() (_cgo_ret *struct_AggInfo_func) {
			_cgo_addr := &pF
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		var pList *struct_ExprList
		func() int {
			_ = 0
			return 0
		}()
		pList = pF.pFExpr.x.pList
		sqlite3VdbeAddOp2(v, 164, pF.iMem, func() int32 {
			if pList != nil {
				return pList.nExpr
			} else {
				return 0
			}
		}())
		sqlite3VdbeAppendP4(v, unsafe.Pointer(pF.pFunc), -8)
	}
}
func updateAccumulator(pParse *struct_Parse, regAcc int32, pAggInfo *struct_AggInfo, eDistinctType int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var regHit int32 = 0
	var addrHitTest int32 = 0
	var pF *struct_AggInfo_func
	var pC *struct_AggInfo_col
	pAggInfo.directMode = uint8(1)
	for func() *struct_AggInfo_func {
		i = int32(0)
		return func() (_cgo_ret *struct_AggInfo_func) {
			_cgo_addr := &pF
			*_cgo_addr = pAggInfo.aFunc
			return *_cgo_addr
		}()
	}(); i < pAggInfo.nFunc; func() *struct_AggInfo_func {
		i++
		return func() (_cgo_ret *struct_AggInfo_func) {
			_cgo_addr := &pF
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		var nArg int32
		var addrNext int32 = 0
		var regAgg int32
		var pList *struct_ExprList
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pList = pF.pFExpr.x.pList
		if pF.pFExpr.flags&uint32(16777216) != uint32(0) {
			var pFilter *struct_Expr = (*(**struct_Window)(unsafe.Pointer(&pF.pFExpr.y))).pFilter
			if pAggInfo.nAccumulator != 0 && pF.pFunc.funcFlags&uint32(32) != 0 && regAcc != 0 {
				if regHit == 0 {
					regHit = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nMem
						*_cgo_addr++
						return *_cgo_addr
					}()
				}
				sqlite3VdbeAddOp2(v, 79, regAcc, regHit)
			}
			addrNext = sqlite3VdbeMakeLabel(pParse)
			sqlite3ExprIfFalse(pParse, pFilter, addrNext, 16)
		}
		if pList != nil {
			nArg = pList.nExpr
			regAgg = sqlite3GetTempRange(pParse, nArg)
			sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, uint8(1))
		} else {
			nArg = int32(0)
			regAgg = int32(0)
		}
		if pF.iDistinct >= 0 && pList != nil {
			if addrNext == 0 {
				addrNext = sqlite3VdbeMakeLabel(pParse)
			}
			pF.iDistinct = codeDistinct(pParse, eDistinctType, pF.iDistinct, addrNext, pList, regAgg)
		}
		if pF.pFunc.funcFlags&uint32(32) != 0 {
			var pColl *struct_CollSeq = nil
			var pItem *struct_ExprList_item
			var j int32
			func() int {
				_ = 0
				return 0
			}()
			for func() *struct_ExprList_item {
				j = int32(0)
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pList.a))
					return *_cgo_addr
				}()
			}(); !(pColl != nil) && j < nArg; func() *struct_ExprList_item {
				j++
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
					return
				}()
			}() {
				pColl = sqlite3ExprCollSeq(pParse, pItem.pExpr)
			}
			if !(pColl != nil) {
				pColl = pParse.db.pDfltColl
			}
			if regHit == 0 && pAggInfo.nAccumulator != 0 {
				regHit = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
			}
			sqlite3VdbeAddOp4(v, 84, regHit, 0, 0, (*int8)(unsafe.Pointer(pColl)), -2)
		}
		sqlite3VdbeAddOp3(v, 161, 0, regAgg, pF.iMem)
		sqlite3VdbeAppendP4(v, unsafe.Pointer(pF.pFunc), -8)
		sqlite3VdbeChangeP5(v, uint16(uint8(nArg)))
		sqlite3ReleaseTempRange(pParse, regAgg, nArg)
		if addrNext != 0 {
			sqlite3VdbeResolveLabel(v, addrNext)
		}
	}
	if regHit == 0 && pAggInfo.nAccumulator != 0 {
		regHit = regAcc
	}
	if regHit != 0 {
		addrHitTest = sqlite3VdbeAddOp1(v, 18, regHit)
	}
	for func() *struct_AggInfo_col {
		i = int32(0)
		return func() (_cgo_ret *struct_AggInfo_col) {
			_cgo_addr := &pC
			*_cgo_addr = pAggInfo.aCol
			return *_cgo_addr
		}()
	}(); i < pAggInfo.nAccumulator; func() *struct_AggInfo_col {
		i++
		return func() (_cgo_ret *struct_AggInfo_col) {
			_cgo_addr := &pC
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
			return
		}()
	}() {
		sqlite3ExprCode(pParse, pC.pCExpr, pC.iMem)
	}
	pAggInfo.directMode = uint8(0)
	if addrHitTest != 0 {
		sqlite3VdbeJumpHereOrPopInst(v, addrHitTest)
	}
}
func explainSimpleCount(pParse *struct_Parse, pTab *struct_Table, pIdx *struct_Index) {
	if int32(pParse.explain) == 2 {
		var bCover int32 = func() int32 {
			if uintptr(unsafe.Pointer(pIdx)) != uintptr(unsafe.Pointer(nil)) && (pTab.tabFlags&uint32(128) == uint32(0) || !(int32(pIdx.Xbf_0&3) == 2)) {
				return 1
			} else {
				return 0
			}
		}()
		sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[12]int8{'S', 'C', 'A', 'N', ' ', '%', 's', '%', 's', '%', 's', '\x00'})), pTab.zName, func() *int8 {
			if bCover != 0 {
				return (*int8)(unsafe.Pointer(&[23]int8{' ', 'U', 'S', 'I', 'N', 'G', ' ', 'C', 'O', 'V', 'E', 'R', 'I', 'N', 'G', ' ', 'I', 'N', 'D', 'E', 'X', ' ', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
			}
		}(), func() *int8 {
			if bCover != 0 {
				return pIdx.zName
			} else {
				return (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
			}
		}())
	}
}
func havingToWhereExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) != 44 {
		var pS *struct_Select = *(**struct_Select)(unsafe.Pointer(&pWalker.u))
		if sqlite3ExprIsConstantOrGroupBy(pWalker.pParse, pExpr, pS.pGroupBy) != 0 && func() int32 {
			if pExpr.flags&uint32(1|536870912) == uint32(536870912) {
				return 1
			} else {
				return 0
			}
		}() == 0 && uintptr(unsafe.Pointer(pExpr.pAggInfo)) == uintptr(unsafe.Pointer(nil)) {
			var db *struct_sqlite3 = pWalker.pParse.db
			var pNew *struct_Expr = sqlite3Expr(db, 155, (*int8)(unsafe.Pointer(&[2]int8{'1', '\x00'})))
			if pNew != nil {
				var pWhere *struct_Expr = pS.pWhere
				{
					var t struct_Expr = *pNew
					*pNew = *pExpr
					*pExpr = t
				}
				pNew = sqlite3ExprAnd(pWalker.pParse, pWhere, pNew)
				pS.pWhere = pNew
				pWalker.eCode = uint16(1)
			}
		}
		return int32(1)
	}
	return int32(0)
}
func havingToWhere(pParse *struct_Parse, p *struct_Select) {
	var sWalker struct_Walker
	__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
	sWalker.pParse = pParse
	sWalker.xExprCallback = havingToWhereExprCb
	*(**struct_Select)(unsafe.Pointer(&sWalker.u)) = p
	sqlite3WalkExpr(&sWalker, p.pHaving)
}
func isSelfJoinView(pTabList *struct_SrcList, pThis *struct_SrcItem) *struct_SrcItem {
	var pItem *struct_SrcItem
	func() int {
		_ = 0
		return 0
	}()
	if pThis.pSelect.selFlags&uint32(16777216) != 0 {
		return (*struct_SrcItem)(nil)
	}
	for pItem = (*struct_SrcItem)(unsafe.Pointer(&pTabList.a)); uintptr(unsafe.Pointer(pItem)) < uintptr(unsafe.Pointer(pThis)); *(*uintptr)(unsafe.Pointer(&pItem)) += 112 {
		var pS1 *struct_Select
		if uintptr(unsafe.Pointer(pItem.pSelect)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if pItem.fg.Xbf_0>>4&1 != 0 {
			continue
		}
		if uintptr(unsafe.Pointer(pItem.zName)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pItem.pTab.pSchema)) != uintptr(unsafe.Pointer(pThis.pTab.pSchema)) {
			continue
		}
		if sqlite3_stricmp(pItem.zName, pThis.zName) != 0 {
			continue
		}
		pS1 = pItem.pSelect
		if uintptr(unsafe.Pointer(pItem.pTab.pSchema)) == uintptr(unsafe.Pointer(nil)) && pThis.pSelect.selId != pS1.selId {
			continue
		}
		if pItem.pSelect.selFlags&uint32(16777216) != 0 {
			continue
		}
		return pItem
	}
	return (*struct_SrcItem)(nil)
}
func agginfoFree(db *struct_sqlite3, p *struct_AggInfo) {
	sqlite3DbFree(db, unsafe.Pointer(p.aCol))
	sqlite3DbFree(db, unsafe.Pointer(p.aFunc))
	sqlite3DbFreeNN(db, unsafe.Pointer(p))
}
func sqlite3Select(pParse *struct_Parse, p *struct_Select, pDest *struct_SelectDest) int32 {
	var i int32
	var j int32
	var pWInfo *struct_WhereInfo
	var v *struct_Vdbe
	var isAgg int32
	var pEList *struct_ExprList = nil
	var pTabList *struct_SrcList
	var pWhere *struct_Expr
	var pGroupBy *struct_ExprList
	var pHaving *struct_Expr
	var pAggInfo *struct_AggInfo = nil
	var rc int32 = 1
	var sDistinct struct_DistinctCtx
	var sSort struct_SortCtx
	var iEnd int32
	var db *struct_sqlite3
	var pMinMaxOrderBy *struct_ExprList = nil
	var minMaxFlag uint8
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || pParse.nErr != 0 {
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3AuthCheck(pParse, 21, nil, nil, nil) != 0 {
		return int32(1)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pDest.eDest) <= 6 {
		func() int {
			_ = 0
			return 0
		}()
		if p.pOrderBy != nil {
			sqlite3ParserAddCleanup(pParse, (func(*struct_sqlite3, unsafe.Pointer))(sqlite3ExprListDelete), unsafe.Pointer(p.pOrderBy))
			p.pOrderBy = (*struct_ExprList)(nil)
		}
		p.selFlags &= uint32(4294967294)
		p.selFlags |= uint32(4194304)
	}
	sqlite3SelectPrep(pParse, p, nil)
	if pParse.nErr != 0 {
		goto select_end
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.selFlags&uint32(8388608) != 0 {
		var p0 *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))
		for i = int32(1); i < p.pSrc.nSrc; i++ {
			var p1 *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(i)*112))
			if uintptr(unsafe.Pointer(p0.pTab)) == uintptr(unsafe.Pointer(p1.pTab)) && 0 == sqlite3_stricmp(p0.zAlias, p1.zAlias) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[54]int8{'t', 'a', 'r', 'g', 'e', 't', ' ', 'o', 'b', 'j', 'e', 'c', 't', '/', 'a', 'l', 'i', 'a', 's', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'a', 'p', 'p', 'e', 'a', 'r', ' ', 'i', 'n', ' ', 'F', 'R', 'O', 'M', ' ', 'c', 'l', 'a', 'u', 's', 'e', ':', ' ', '%', 's', '\x00'})), func() *int8 {
					if p0.zAlias != nil {
						return p0.zAlias
					} else {
						return p0.pTab.zName
					}
				}())
				goto select_end
			}
		}
		p.selFlags &= uint32(4286578687)
	}
	if int32(pDest.eDest) == 9 {
		sqlite3GenerateColumnNames(pParse, p)
	}
	if sqlite3WindowRewrite(pParse, p) != 0 {
		func() int {
			_ = 0
			return 0
		}()
		goto select_end
	}
	pTabList = p.pSrc
	isAgg = func() int32 {
		if p.selFlags&uint32(8) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	__builtin___memset_chk(unsafe.Pointer(&sSort), 0, 48, __builtin_object_size(unsafe.Pointer(&sSort), 0))
	sSort.pOrderBy = p.pOrderBy
	for i = int32(0); !(p.pPrior != nil) && i < pTabList.nSrc; i++ {
		var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(i)*112))
		var pSub *struct_Select = pItem.pSelect
		var pTab *struct_Table = pItem.pTab
		func() int {
			_ = 0
			return 0
		}()
		if int32(pItem.fg.jointype)&8 != 0 && sqlite3ExprImpliesNonNullRow(p.pWhere, pItem.iCursor) != 0 && db.dbOptFlags&uint32(8192) == uint32(0) {
			pItem.fg.jointype &= uint8(^(8 | 32))
			unsetJoinExpr(p.pWhere, pItem.iCursor)
		}
		if uintptr(unsafe.Pointer(pSub)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if int32(pTab.nCol) != pSub.pEList.nExpr {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[40]int8{'e', 'x', 'p', 'e', 'c', 't', 'e', 'd', ' ', '%', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'f', 'o', 'r', ' ', '\'', '%', 's', '\'', ' ', 'b', 'u', 't', ' ', 'g', 'o', 't', ' ', '%', 'd', '\x00'})), int32(pTab.nCol), pTab.zName, pSub.pEList.nExpr)
			goto select_end
		}
		if pSub.selFlags&uint32(8) != uint32(0) {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(pSub.pOrderBy)) != uintptr(unsafe.Pointer(nil)) && (uintptr(unsafe.Pointer(p.pOrderBy)) != uintptr(unsafe.Pointer(nil)) || pTabList.nSrc > 1) && uintptr(unsafe.Pointer(pSub.pLimit)) == uintptr(unsafe.Pointer(nil)) && pSub.selFlags&uint32(134217728) == uint32(0) && p.selFlags&uint32(134217728) == uint32(0) && db.dbOptFlags&uint32(262144) == uint32(0) {
			sqlite3ExprListDelete(db, pSub.pOrderBy)
			pSub.pOrderBy = (*struct_ExprList)(nil)
		}
		if uintptr(unsafe.Pointer(pSub.pOrderBy)) != uintptr(unsafe.Pointer(nil)) && i == 0 && p.selFlags&uint32(262144) != uint32(0) && (pTabList.nSrc == 1 || int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(1)*112))).fg.jointype)&(8|2) != 0) {
			continue
		}
		if flattenSubquery(pParse, p, i, isAgg) != 0 {
			if pParse.nErr != 0 {
				goto select_end
			}
			i = int32(-1)
		}
		pTabList = p.pSrc
		if db.mallocFailed != 0 {
			goto select_end
		}
		if !(int32(pDest.eDest) <= 8) {
			sSort.pOrderBy = p.pOrderBy
		}
	}
	if p.pPrior != nil {
		rc = multiSelect(pParse, p, pDest)
		if uintptr(unsafe.Pointer(p.pNext)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3VdbeExplainPop(pParse)
		}
		return rc
	}
	if uintptr(unsafe.Pointer(p.pWhere)) != uintptr(unsafe.Pointer(nil)) && int32(p.pWhere.op) == 44 && db.dbOptFlags&uint32(32768) == uint32(0) && propagateConstants(pParse, p) != 0 {
	} else {
	}
	for i = int32(0); i < pTabList.nSrc; i++ {
		var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(i)*112))
		var pPrior *struct_SrcItem
		var dest struct_SelectDest
		var pSub *struct_Select
		var zSavedAuthContext *int8
		if pItem.colUsed == uint64(0) && uintptr(unsafe.Pointer(pItem.zName)) != uintptr(unsafe.Pointer(nil)) {
			sqlite3AuthCheck(pParse, 20, pItem.zName, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), pItem.zDatabase)
		}
		pSub = pItem.pSelect
		if uintptr(unsafe.Pointer(pSub)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		pParse.nHeight += sqlite3SelectExprHeight(p)
		if db.dbOptFlags&uint32(4096) == uint32(0) && (int32(pItem.fg.Xbf_0>>7&1) == 0 || int32((*(**struct_CteUse)(unsafe.Pointer(&pItem.u2))).eM10d) != 0 && (*(**struct_CteUse)(unsafe.Pointer(&pItem.u2))).nUse < 2) && pushDownWhereTerms(pParse, pSub, p.pWhere, pItem.iCursor, func() int32 {
			if int32(pItem.fg.jointype)&32 != 0 {
				return 1
			} else {
				return 0
			}
		}()) != 0 {
			func() int {
				_ = 0
				return 0
			}()
		} else {
		}
		zSavedAuthContext = pParse.zAuthContext
		pParse.zAuthContext = pItem.zName
		if i == 0 && (pTabList.nSrc == 1 || int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(1)*112))).fg.jointype)&(8|2) != 0) && (int32(pItem.fg.Xbf_0>>7&1) == 0 || int32((*(**struct_CteUse)(unsafe.Pointer(&pItem.u2))).eM10d) != 0) {
			var addrTop int32 = sqlite3VdbeCurrentAddr(v) + 1
			pItem.regReturn = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3VdbeAddOp3(v, 13, pItem.regReturn, 0, addrTop)
			pItem.addrFillSub = addrTop
			sqlite3SelectDestInit(&dest, 13, pItem.regReturn)
			sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[15]int8{'C', 'O', '-', 'R', 'O', 'U', 'T', 'I', 'N', 'E', ' ', '%', '!', 'S', '\x00'})), pItem)
			sqlite3Select(pParse, pSub, &dest)
			pItem.pTab.nRowLogEst = pSub.nSelectRow
			{
				_autoGo_79 := &pItem.fg.Xbf_0
				*_autoGo_79 = *_autoGo_79&^16 | uint32(1)&1<<4
			}
			pItem.regResult = dest.iSdst
			sqlite3VdbeEndCoroutine(v, pItem.regReturn)
			sqlite3VdbeJumpHere(v, addrTop-1)
			sqlite3ClearTempRegCache(pParse)
		} else if int32(pItem.fg.Xbf_0>>7&1) != 0 && (*(**struct_CteUse)(unsafe.Pointer(&pItem.u2))).addrM9e > 0 {
			var pCteUse *struct_CteUse = *(**struct_CteUse)(unsafe.Pointer(&pItem.u2))
			sqlite3VdbeAddOp2(v, 12, pCteUse.regRtn, pCteUse.addrM9e)
			if pItem.iCursor != pCteUse.iCur {
				sqlite3VdbeAddOp2(v, 113, pItem.iCursor, pCteUse.iCur)
			}
			pSub.nSelectRow = pCteUse.nRowEst
		} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pPrior
			*_cgo_addr = isSelfJoinView(pTabList, pItem)
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			if pPrior.addrFillSub != 0 {
				sqlite3VdbeAddOp2(v, 12, pPrior.regReturn, pPrior.addrFillSub)
			}
			sqlite3VdbeAddOp2(v, 113, pItem.iCursor, pPrior.iCursor)
			pSub.nSelectRow = pPrior.pSelect.nSelectRow
		} else {
			var topAddr int32
			var onceAddr int32 = 0
			var retAddr int32
			pItem.regReturn = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			topAddr = sqlite3VdbeAddOp2(v, 71, 0, pItem.regReturn)
			pItem.addrFillSub = topAddr + 1
			if int32(pItem.fg.Xbf_0>>3&1) == 0 {
				onceAddr = sqlite3VdbeAddOp0(v, 17)
			} else {
			}
			sqlite3SelectDestInit(&dest, 12, pItem.iCursor)
			sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[16]int8{'M', 'A', 'T', 'E', 'R', 'I', 'A', 'L', 'I', 'Z', 'E', ' ', '%', '!', 'S', '\x00'})), pItem)
			sqlite3Select(pParse, pSub, &dest)
			pItem.pTab.nRowLogEst = pSub.nSelectRow
			if onceAddr != 0 {
				sqlite3VdbeJumpHere(v, onceAddr)
			}
			retAddr = sqlite3VdbeAddOp1(v, 67, pItem.regReturn)
			sqlite3VdbeChangeP1(v, topAddr, retAddr)
			sqlite3ClearTempRegCache(pParse)
			if int32(pItem.fg.Xbf_0>>7&1) != 0 && int32(pItem.fg.Xbf_0>>3&1) == 0 {
				var pCteUse *struct_CteUse = *(**struct_CteUse)(unsafe.Pointer(&pItem.u2))
				pCteUse.addrM9e = pItem.addrFillSub
				pCteUse.regRtn = pItem.regReturn
				pCteUse.iCur = pItem.iCursor
				pCteUse.nRowEst = pSub.nSelectRow
			}
		}
		if db.mallocFailed != 0 {
			goto select_end
		}
		pParse.nHeight -= sqlite3SelectExprHeight(p)
		pParse.zAuthContext = zSavedAuthContext
	}
	pEList = p.pEList
	pWhere = p.pWhere
	pGroupBy = p.pGroupBy
	pHaving = p.pHaving
	sDistinct.isTnct = func() uint8 {
		if p.selFlags&uint32(1) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}()
	if p.selFlags&uint32(1|8) == uint32(1) && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1) == 0 && uintptr(unsafe.Pointer(p.pWin)) == uintptr(unsafe.Pointer(nil)) {
		p.selFlags &= uint32(4294967294)
		pGroupBy = func() (_cgo_ret *struct_ExprList) {
			_cgo_addr := &p.pGroupBy
			*_cgo_addr = sqlite3ExprListDup(db, pEList, 0)
			return *_cgo_addr
		}()
		p.selFlags |= uint32(8)
		func() int {
			_ = 0
			return 0
		}()
	}
	if sSort.pOrderBy != nil {
		var pKeyInfo *struct_KeyInfo
		pKeyInfo = sqlite3KeyInfoFromExprList(pParse, sSort.pOrderBy, 0, pEList.nExpr)
		sSort.iECursor = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		sSort.addrSortIndex = sqlite3VdbeAddOp4(v, 116, sSort.iECursor, sSort.pOrderBy.nExpr+1+pEList.nExpr, 0, (*int8)(unsafe.Pointer(pKeyInfo)), -9)
	} else {
		sSort.addrSortIndex = int32(-1)
	}
	if int32(pDest.eDest) == 12 {
		sqlite3VdbeAddOp2(v, 116, pDest.iSDParm, pEList.nExpr)
	}
	iEnd = sqlite3VdbeMakeLabel(pParse)
	if p.selFlags&uint32(16384) == uint32(0) {
		p.nSelectRow = int16(320)
	}
	computeLimitRegisters(pParse, p, iEnd)
	if p.iLimit == 0 && sSort.addrSortIndex >= 0 {
		sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, uint8(118))
		sSort.sortFlags |= uint8(1)
	}
	if p.selFlags&uint32(1) != 0 {
		sDistinct.tabTnct = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 116, sDistinct.tabTnct, 0, 0, (*int8)(unsafe.Pointer(sqlite3KeyInfoFromExprList(pParse, p.pEList, 0, 0))), -9)
		sqlite3VdbeChangeP5(v, uint16(8))
		sDistinct.eTnctType = uint8(3)
	} else {
		sDistinct.eTnctType = uint8(0)
	}
	if !(isAgg != 0) && uintptr(unsafe.Pointer(pGroupBy)) == uintptr(unsafe.Pointer(nil)) {
		var wctrlFlags uint16 = uint16(uint32(func() int32 {
			if int32(sDistinct.isTnct) != 0 {
				return 256
			} else {
				return 0
			}
		}()) | p.selFlags&uint32(16384))
		var pWin *struct_Window = p.pWin
		if pWin != nil {
			sqlite3WindowCodeInit(pParse, p)
		}
		func() int {
			_ = 0
			return 0
		}()
		pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy, p.pEList, p, wctrlFlags, int32(p.nSelectRow))
		if uintptr(unsafe.Pointer(pWInfo)) == uintptr(unsafe.Pointer(nil)) {
			goto select_end
		}
		if int32(sqlite3WhereOutputRowCount(pWInfo)) < int32(p.nSelectRow) {
			p.nSelectRow = sqlite3WhereOutputRowCount(pWInfo)
		}
		if int32(sDistinct.isTnct) != 0 && sqlite3WhereIsDistinct(pWInfo) != 0 {
			sDistinct.eTnctType = uint8(sqlite3WhereIsDistinct(pWInfo))
		}
		if sSort.pOrderBy != nil {
			sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo)
			sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo)
			if sSort.nOBSat == sSort.pOrderBy.nExpr {
				sSort.pOrderBy = (*struct_ExprList)(nil)
			}
		}
		if sSort.addrSortIndex >= 0 && uintptr(unsafe.Pointer(sSort.pOrderBy)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex)
		}
		func() int {
			_ = 0
			return 0
		}()
		if pWin != nil {
			var addrGosub int32 = sqlite3VdbeMakeLabel(pParse)
			var iCont int32 = sqlite3VdbeMakeLabel(pParse)
			var iBreak int32 = sqlite3VdbeMakeLabel(pParse)
			var regGosub int32 = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub)
			sqlite3VdbeAddOp2(v, 11, 0, iBreak)
			sqlite3VdbeResolveLabel(v, addrGosub)
			sSort.labelOBLopt = int32(0)
			selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak)
			sqlite3VdbeResolveLabel(v, iCont)
			sqlite3VdbeAddOp1(v, 67, regGosub)
			sqlite3VdbeResolveLabel(v, iBreak)
		} else {
			selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, sqlite3WhereContinueLabel(pWInfo), sqlite3WhereBreakLabel(pWInfo))
			sqlite3WhereEnd(pWInfo)
		}
	} else {
		var sNC struct_NameContext
		var iAMem int32
		var iBMem int32
		var iUseFlag int32
		var iAbortFlag int32
		var groupBySort int32
		var addrEnd int32
		var sortPTab int32 = 0
		var sortOut int32 = 0
		var orderByGrp int32 = 0
		if pGroupBy != nil {
			var k int32
			var pItem *struct_ExprList_item
			for func() *struct_ExprList_item {
				k = p.pEList.nExpr
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&p.pEList.a))
					return *_cgo_addr
				}()
			}(); k > 0; func() *struct_ExprList_item {
				k--
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
					return
				}()
			}() {
				pItem.u.x.iAlias = uint16(0)
			}
			for func() *struct_ExprList_item {
				k = pGroupBy.nExpr
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					*_cgo_addr = (*struct_ExprList_item)(unsafe.Pointer(&pGroupBy.a))
					return *_cgo_addr
				}()
			}(); k > 0; func() *struct_ExprList_item {
				k--
				return func() (_cgo_ret *struct_ExprList_item) {
					_cgo_addr := &pItem
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 28
					return
				}()
			}() {
				pItem.u.x.iAlias = uint16(0)
			}
			func() int {
				_ = 0
				return 0
			}()
			if int32(p.nSelectRow) > 66 {
				p.nSelectRow = int16(66)
			}
			if sSort.pOrderBy != nil && pGroupBy.nExpr == sSort.pOrderBy.nExpr {
				var ii int32
				for ii = int32(0); ii < pGroupBy.nExpr; ii++ {
					var sortFlags uint8 = uint8(int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&sSort.pOrderBy.a)))) + uintptr(ii)*28))).sortFlags) & 1)
					(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pGroupBy.a)))) + uintptr(ii)*28))).sortFlags = sortFlags
				}
				if sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1) == 0 {
					orderByGrp = int32(1)
				}
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			p.nSelectRow = int16(0)
		}
		addrEnd = sqlite3VdbeMakeLabel(pParse)
		pAggInfo = (*struct_AggInfo)(sqlite3DbMallocZero(db, uint64(64)))
		if pAggInfo != nil {
			sqlite3ParserAddCleanup(pParse, (func(*struct_sqlite3, unsafe.Pointer))(agginfoFree), unsafe.Pointer(pAggInfo))
		}
		if db.mallocFailed != 0 {
			goto select_end
		}
		pAggInfo.selId = p.selId
		__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
		sNC.pParse = pParse
		sNC.pSrcList = pTabList
		*(**struct_AggInfo)(unsafe.Pointer(&sNC.uNC)) = pAggInfo
		pAggInfo.mnReg = pParse.nMem + 1
		pAggInfo.nSortingColumn = func() int32 {
			if pGroupBy != nil {
				return pGroupBy.nExpr
			} else {
				return 0
			}
		}()
		pAggInfo.pGroupBy = pGroupBy
		sqlite3ExprAnalyzeAggList(&sNC, pEList)
		sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy)
		if pHaving != nil {
			if pGroupBy != nil {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				havingToWhere(pParse, p)
				pWhere = p.pWhere
			}
			sqlite3ExprAnalyzeAggregates(&sNC, pHaving)
		}
		pAggInfo.nAccumulator = pAggInfo.nColumn
		if uintptr(unsafe.Pointer(p.pGroupBy)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(p.pHaving)) == uintptr(unsafe.Pointer(nil)) && pAggInfo.nFunc == 1 {
			minMaxFlag = minMaxQuery(db, (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFExpr, &pMinMaxOrderBy)
		} else {
			minMaxFlag = uint8(0)
		}
		for i = int32(0); i < pAggInfo.nFunc; i++ {
			var pExpr *struct_Expr = (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(i)*28))).pFExpr
			func() int {
				_ = 0
				return 0
			}()
			sNC.ncFlags |= int32(131072)
			sqlite3ExprAnalyzeAggList(&sNC, pExpr.x.pList)
			func() int {
				_ = 0
				return 0
			}()
			if pExpr.flags&uint32(16777216) != uint32(0) {
				sqlite3ExprAnalyzeAggregates(&sNC, (*(**struct_Window)(unsafe.Pointer(&pExpr.y))).pFilter)
			}
			sNC.ncFlags &= int32(^131072)
		}
		pAggInfo.mxReg = pParse.nMem
		if db.mallocFailed != 0 {
			goto select_end
		}
		if pGroupBy != nil {
			var pKeyInfo *struct_KeyInfo
			var addr1 int32
			var addrOutputRow int32
			var regOutputRow int32
			var addrSetAbort int32
			var addrTopOfLoop int32
			var addrSortingIdx int32
			var addrReset int32
			var regReset int32
			var pDistinct *struct_ExprList = nil
			var distFlag uint16 = uint16(0)
			var eDist int32 = 0
			if pAggInfo.nFunc == 1 && (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).iDistinct >= 0 && uintptr(unsafe.Pointer((*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFExpr)) != uintptr(unsafe.Pointer(nil)) && (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFExpr.flags&uint32(2048) == uint32(0) && uintptr(unsafe.Pointer((*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFExpr.x.pList)) != uintptr(unsafe.Pointer(nil)) {
				var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFExpr.x.pList.a)))) + uintptr(0)*28))).pExpr
				pExpr = sqlite3ExprDup(db, pExpr, 0)
				pDistinct = sqlite3ExprListDup(db, pGroupBy, 0)
				pDistinct = sqlite3ExprListAppend(pParse, pDistinct, pExpr)
				distFlag = uint16(func() int32 {
					if pDistinct != nil {
						return 256 | 1024
					} else {
						return 0
					}
				}())
			}
			pAggInfo.sortingIdx = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pGroupBy, 0, pAggInfo.nColumn)
			addrSortingIdx = sqlite3VdbeAddOp4(v, 118, pAggInfo.sortingIdx, pAggInfo.nSortingColumn, 0, (*int8)(unsafe.Pointer(pKeyInfo)), -9)
			iUseFlag = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			iAbortFlag = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			regOutputRow = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			addrOutputRow = sqlite3VdbeMakeLabel(pParse)
			regReset = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			addrReset = sqlite3VdbeMakeLabel(pParse)
			iAMem = pParse.nMem + 1
			pParse.nMem += pGroupBy.nExpr
			iBMem = pParse.nMem + 1
			pParse.nMem += pGroupBy.nExpr
			sqlite3VdbeAddOp2(v, 71, 0, iAbortFlag)
			sqlite3VdbeAddOp3(v, 74, 0, iAMem, iAMem+pGroupBy.nExpr-1)
			sqlite3VdbeAddOp2(v, 12, regReset, addrReset)
			pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, pDistinct, nil, uint16(64|func() int32 {
				if orderByGrp != 0 {
					return 512
				} else {
					return 0
				}
			}()|int32(distFlag)), 0)
			if uintptr(unsafe.Pointer(pWInfo)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3ExprListDelete(db, pDistinct)
				goto select_end
			}
			eDist = sqlite3WhereIsDistinct(pWInfo)
			if sqlite3WhereIsOrdered(pWInfo) == pGroupBy.nExpr {
				groupBySort = int32(0)
			} else {
				var regBase int32
				var regRecord int32
				var nCol int32
				var nGroupBy int32
				explainTempTable(pParse, func() *int8 {
					if int32(sDistinct.isTnct) != 0 && p.selFlags&uint32(1) == uint32(0) {
						return (*int8)(unsafe.Pointer(&[9]int8{'D', 'I', 'S', 'T', 'I', 'N', 'C', 'T', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[9]int8{'G', 'R', 'O', 'U', 'P', ' ', 'B', 'Y', '\x00'}))
					}
				}())
				groupBySort = int32(1)
				nGroupBy = pGroupBy.nExpr
				nCol = nGroupBy
				j = nGroupBy
				for i = int32(0); i < pAggInfo.nColumn; i++ {
					if int32((*(*struct_AggInfo_col)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aCol)) + uintptr(i)*28))).iSorterColumn) >= j {
						nCol++
						j++
					}
				}
				regBase = sqlite3GetTempRange(pParse, nCol)
				sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, uint8(0))
				j = nGroupBy
				for i = int32(0); i < pAggInfo.nColumn; i++ {
					var pCol *struct_AggInfo_col = &*(*struct_AggInfo_col)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aCol)) + uintptr(i)*28))
					if int32(pCol.iSorterColumn) >= j {
						var r1 int32 = j + regBase
						sqlite3ExprCodeGetColumnOfTable(v, pCol.pTab, pCol.iTable, int32(pCol.iColumn), r1)
						j++
					}
				}
				regRecord = sqlite3GetTempReg(pParse)
				sqlite3VdbeAddOp3(v, 96, regBase, nCol, regRecord)
				sqlite3VdbeAddOp2(v, 138, pAggInfo.sortingIdx, regRecord)
				sqlite3ReleaseTempReg(pParse, regRecord)
				sqlite3ReleaseTempRange(pParse, regBase, nCol)
				sqlite3WhereEnd(pWInfo)
				pAggInfo.sortingIdxPTab = func() (_cgo_ret int32) {
					_cgo_addr := &sortPTab
					*_cgo_addr = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nTab
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
					return *_cgo_addr
				}()
				sortOut = sqlite3GetTempReg(pParse)
				sqlite3VdbeAddOp3(v, 120, sortPTab, sortOut, nCol)
				sqlite3VdbeAddOp2(v, 36, pAggInfo.sortingIdx, addrEnd)
				pAggInfo.useSortingIdx = uint8(1)
			}
			if orderByGrp != 0 && db.dbOptFlags&uint32(4) == uint32(0) && (groupBySort != 0 || sqlite3WhereIsSorted(pWInfo) != 0) {
				sSort.pOrderBy = (*struct_ExprList)(nil)
				sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex)
			}
			addrTopOfLoop = sqlite3VdbeCurrentAddr(v)
			if groupBySort != 0 {
				sqlite3VdbeAddOp3(v, 132, pAggInfo.sortingIdx, sortOut, sortPTab)
			}
			for j = int32(0); j < pGroupBy.nExpr; j++ {
				if groupBySort != 0 {
					sqlite3VdbeAddOp3(v, 93, sortPTab, j, iBMem+j)
				} else {
					pAggInfo.directMode = uint8(1)
					sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pGroupBy.a)))) + uintptr(j)*28))).pExpr, iBMem+j)
				}
			}
			sqlite3VdbeAddOp4(v, 89, iAMem, iBMem, pGroupBy.nExpr, (*int8)(unsafe.Pointer(sqlite3KeyInfoRef(pKeyInfo))), -9)
			addr1 = sqlite3VdbeCurrentAddr(v)
			sqlite3VdbeAddOp3(v, 16, addr1+1, 0, addr1+1)
			sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy.nExpr)
			sqlite3VdbeAddOp2(v, 12, regOutputRow, addrOutputRow)
			sqlite3VdbeAddOp2(v, 49, iAbortFlag, addrEnd)
			sqlite3VdbeAddOp2(v, 12, regReset, addrReset)
			sqlite3VdbeJumpHere(v, addr1)
			updateAccumulator(pParse, iUseFlag, pAggInfo, eDist)
			sqlite3VdbeAddOp2(v, 71, 1, iUseFlag)
			if groupBySort != 0 {
				sqlite3VdbeAddOp2(v, 3, pAggInfo.sortingIdx, addrTopOfLoop)
			} else {
				sqlite3WhereEnd(pWInfo)
				sqlite3VdbeChangeToNoop(v, addrSortingIdx)
			}
			sqlite3ExprListDelete(db, pDistinct)
			sqlite3VdbeAddOp2(v, 12, regOutputRow, addrOutputRow)
			sqlite3VdbeGoto(v, addrEnd)
			addrSetAbort = sqlite3VdbeCurrentAddr(v)
			sqlite3VdbeAddOp2(v, 71, 1, iAbortFlag)
			sqlite3VdbeAddOp1(v, 67, regOutputRow)
			sqlite3VdbeResolveLabel(v, addrOutputRow)
			addrOutputRow = sqlite3VdbeCurrentAddr(v)
			sqlite3VdbeAddOp2(v, 49, iUseFlag, addrOutputRow+2)
			sqlite3VdbeAddOp1(v, 67, regOutputRow)
			finalizeAggFunctions(pParse, pAggInfo)
			sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, 16)
			selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, addrOutputRow+1, addrSetAbort)
			sqlite3VdbeAddOp1(v, 67, regOutputRow)
			sqlite3VdbeResolveLabel(v, addrReset)
			resetAccumulator(pParse, pAggInfo)
			sqlite3VdbeAddOp2(v, 71, 0, iUseFlag)
			sqlite3VdbeAddOp1(v, 67, regReset)
			if eDist != 0 {
				var pF *struct_AggInfo_func = &*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))
				fixDistinctOpenEph(pParse, eDist, pF.iDistinct, pF.iDistAddr)
			}
		} else {
			var pTab *struct_Table
			if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Table) {
				_cgo_addr := &pTab
				*_cgo_addr = isSimpleCount(p, pAggInfo)
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) {
				var iDb int32 = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
				var iCsr int32 = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nTab
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
				var pIdx *struct_Index
				var pKeyInfo *struct_KeyInfo = nil
				var pBest *struct_Index = nil
				var iRoot uint32 = pTab.tnum
				sqlite3CodeVerifySchema(pParse, iDb)
				sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(0), pTab.zName)
				if !(pTab.tabFlags&uint32(128) == uint32(0)) {
					pBest = sqlite3PrimaryKeyIndex(pTab)
				}
				if !((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).fg.Xbf_0&1 != 0) {
					for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
						if int32(pIdx.Xbf_0>>2&1) == 0 && int32(pIdx.szIdxRow) < int32(pTab.szTabRow) && uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) == uintptr(unsafe.Pointer(nil)) && (!(pBest != nil) || int32(pIdx.szIdxRow) < int32(pBest.szIdxRow)) {
							pBest = pIdx
						}
					}
				}
				if pBest != nil {
					iRoot = pBest.tnum
					pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest)
				}
				sqlite3VdbeAddOp4Int(v, 101, iCsr, int32(iRoot), iDb, 1)
				if pKeyInfo != nil {
					sqlite3VdbeChangeP4(v, -1, (*int8)(unsafe.Pointer(pKeyInfo)), -9)
				}
				sqlite3VdbeAddOp2(v, 97, iCsr, (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).iMem)
				sqlite3VdbeAddOp1(v, 121, iCsr)
				explainSimpleCount(pParse, pTab, pBest)
			} else {
				var regAcc int32 = 0
				var pDistinct *struct_ExprList = nil
				var distFlag uint16 = uint16(0)
				var eDist int32
				if pAggInfo.nAccumulator != 0 {
					for i = int32(0); i < pAggInfo.nFunc; i++ {
						if (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(i)*28))).pFExpr.flags&uint32(16777216) != uint32(0) {
							continue
						}
						if (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(i)*28))).pFunc.funcFlags&uint32(32) != 0 {
							break
						}
					}
					if i == pAggInfo.nFunc {
						regAcc = func() (_cgo_ret int32) {
							_cgo_addr := &pParse.nMem
							*_cgo_addr++
							return *_cgo_addr
						}()
						sqlite3VdbeAddOp2(v, 71, 0, regAcc)
					}
				} else if pAggInfo.nFunc == 1 && (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).iDistinct >= 0 {
					func() int {
						_ = 0
						return 0
					}()
					pDistinct = (*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))).pFExpr.x.pList
					distFlag = uint16(func() int32 {
						if pDistinct != nil {
							return 256 | 1024
						} else {
							return 0
						}
					}())
				}
				func() int {
					_ = 0
					return 0
				}()
				resetAccumulator(pParse, pAggInfo)
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy, pDistinct, nil, uint16(int32(minMaxFlag)|int32(distFlag)), 0)
				if uintptr(unsafe.Pointer(pWInfo)) == uintptr(unsafe.Pointer(nil)) {
					goto select_end
				}
				eDist = sqlite3WhereIsDistinct(pWInfo)
				updateAccumulator(pParse, regAcc, pAggInfo, eDist)
				if eDist != 0 {
					var pF *struct_AggInfo_func = &*(*struct_AggInfo_func)(unsafe.Pointer(uintptr(unsafe.Pointer(pAggInfo.aFunc)) + uintptr(0)*28))
					fixDistinctOpenEph(pParse, eDist, pF.iDistinct, pF.iDistAddr)
				}
				if regAcc != 0 {
					sqlite3VdbeAddOp2(v, 71, 1, regAcc)
				}
				if minMaxFlag != 0 {
					sqlite3WhereMinMaxOptEarlyOut(v, pWInfo)
				}
				sqlite3WhereEnd(pWInfo)
				finalizeAggFunctions(pParse, pAggInfo)
			}
			sSort.pOrderBy = (*struct_ExprList)(nil)
			sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 16)
			selectInnerLoop(pParse, p, -1, nil, nil, pDest, addrEnd, addrEnd)
		}
		sqlite3VdbeResolveLabel(v, addrEnd)
	}
	if int32(sDistinct.eTnctType) == 3 {
		explainTempTable(pParse, (*int8)(unsafe.Pointer(&[9]int8{'D', 'I', 'S', 'T', 'I', 'N', 'C', 'T', '\x00'})))
	}
	if sSort.pOrderBy != nil {
		explainTempTable(pParse, func() *int8 {
			if sSort.nOBSat > 0 {
				return (*int8)(unsafe.Pointer(&[23]int8{'R', 'I', 'G', 'H', 'T', ' ', 'P', 'A', 'R', 'T', ' ', 'O', 'F', ' ', 'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[9]int8{'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', '\x00'}))
			}
		}())
		func() int {
			_ = 0
			return 0
		}()
		generateSortTail(pParse, p, &sSort, pEList.nExpr, pDest)
	}
	sqlite3VdbeResolveLabel(v, iEnd)
	rc = func() int32 {
		if pParse.nErr > 0 {
			return 1
		} else {
			return 0
		}
	}()
select_end:
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ExprListDelete(db, pMinMaxOrderBy)
	sqlite3VdbeExplainPop(pParse)
	return rc
}

type struct_TabResult struct {
	azResult **int8
	zErrMsg  *int8
	nAlloc   uint32
	nRow     uint32
	nColumn  uint32
	nData    uint32
	rc       int32
}
type TabResult = struct_TabResult

func sqlite3_get_table_cb(pArg unsafe.Pointer, nCol int32, argv **int8, colv **int8) int32 {
	var p *struct_TabResult = (*struct_TabResult)(pArg)
	var need int32
	var i int32
	var z *int8
	if p.nRow == uint32(0) && uintptr(unsafe.Pointer(argv)) != uintptr(unsafe.Pointer(nil)) {
		need = nCol * 2
	} else {
		need = nCol
	}
	if p.nData+uint32(need) > p.nAlloc {
		var azNew **int8
		p.nAlloc = p.nAlloc*uint32(2) + uint32(need)
		azNew = (**int8)(sqlite3Realloc(unsafe.Pointer(p.azResult), uint64(8*uint(p.nAlloc))))
		if uintptr(unsafe.Pointer(azNew)) == uintptr(unsafe.Pointer(nil)) {
			goto malloc_failed
		}
		p.azResult = azNew
	}
	if p.nRow == uint32(0) {
		p.nColumn = uint32(nCol)
		for i = int32(0); i < nCol; i++ {
			z = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(colv)) + uintptr(i)*8)))
			if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
				goto malloc_failed
			}
			*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.azResult)) + uintptr(func() (_cgo_ret uint32) {
				_cgo_addr := &p.nData
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8)) = z
		}
	} else if int32(p.nColumn) != nCol {
		sqlite3_free(unsafe.Pointer(p.zErrMsg))
		p.zErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[65]int8{'s', 'q', 'l', 'i', 't', 'e', '3', '_', 'g', 'e', 't', '_', 't', 'a', 'b', 'l', 'e', '(', ')', ' ', 'c', 'a', 'l', 'l', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 't', 'w', 'o', ' ', 'o', 'r', ' ', 'm', 'o', 'r', 'e', ' ', 'i', 'n', 'c', 'o', 'm', 'p', 'a', 't', 'i', 'b', 'l', 'e', ' ', 'q', 'u', 'e', 'r', 'i', 'e', 's', '\x00'})))
		p.rc = int32(1)
		return int32(1)
	}
	if uintptr(unsafe.Pointer(argv)) != uintptr(unsafe.Pointer(nil)) {
		for i = int32(0); i < nCol; i++ {
			if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
				z = (*int8)(nil)
			} else {
				var n int32 = sqlite3Strlen30(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8))) + 1
				z = (*int8)(sqlite3_malloc64(uint64(n)))
				if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
					goto malloc_failed
				}
				__builtin___memcpy_chk(unsafe.Pointer(z), unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8))), uint(n), __builtin_object_size(unsafe.Pointer(z), 0))
			}
			*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.azResult)) + uintptr(func() (_cgo_ret uint32) {
				_cgo_addr := &p.nData
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8)) = z
		}
		p.nRow++
	}
	return int32(0)
malloc_failed:
	p.rc = int32(7)
	return int32(1)
}
func sqlite3_get_table(db *struct_sqlite3, zSql *int8, pazResult ***int8, pnRow *int32, pnColumn *int32, pzErrMsg **int8) int32 {
	var rc int32
	var res struct_TabResult
	*pazResult = (**int8)(nil)
	if pnColumn != nil {
		*pnColumn = int32(0)
	}
	if pnRow != nil {
		*pnRow = int32(0)
	}
	if pzErrMsg != nil {
		*pzErrMsg = (*int8)(nil)
	}
	res.zErrMsg = (*int8)(nil)
	res.nRow = uint32(0)
	res.nColumn = uint32(0)
	res.nData = uint32(1)
	res.nAlloc = uint32(20)
	res.rc = int32(0)
	res.azResult = (**int8)(sqlite3_malloc64(uint64(8 * uint(res.nAlloc))))
	if uintptr(unsafe.Pointer(res.azResult)) == uintptr(unsafe.Pointer(nil)) {
		db.errCode = int32(7)
		return int32(7)
	}
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(res.azResult)) + uintptr(0)*8)) = (*int8)(nil)
	rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, unsafe.Pointer(&res), pzErrMsg)
	func() int {
		_ = 0
		return 0
	}()
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(res.azResult)) + uintptr(0)*8)) = (*int8)(unsafe.Pointer(int(res.nData)))
	if rc&255 == 4 {
		sqlite3_free_table(&*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(res.azResult)) + uintptr(1)*8)))
		if res.zErrMsg != nil {
			if pzErrMsg != nil {
				sqlite3_free(unsafe.Pointer(*pzErrMsg))
				*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), res.zErrMsg)
			}
			sqlite3_free(unsafe.Pointer(res.zErrMsg))
		}
		db.errCode = res.rc
		return res.rc
	}
	sqlite3_free(unsafe.Pointer(res.zErrMsg))
	if rc != 0 {
		sqlite3_free_table(&*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(res.azResult)) + uintptr(1)*8)))
		return rc
	}
	if res.nAlloc > res.nData {
		var azNew **int8
		azNew = (**int8)(sqlite3Realloc(unsafe.Pointer(res.azResult), uint64(8*uint(res.nData))))
		if uintptr(unsafe.Pointer(azNew)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3_free_table(&*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(res.azResult)) + uintptr(1)*8)))
			db.errCode = int32(7)
			return int32(7)
		}
		res.azResult = azNew
	}
	*pazResult = &*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(res.azResult)) + uintptr(1)*8))
	if pnColumn != nil {
		*pnColumn = int32(res.nColumn)
	}
	if pnRow != nil {
		*pnRow = int32(res.nRow)
	}
	return rc
}
func sqlite3_free_table(azResult **int8) {
	if azResult != nil {
		var i int32
		var n int32
		*(*uintptr)(unsafe.Pointer(&azResult)) -= 8
		func() int {
			_ = 0
			return 0
		}()
		n = int32(int(uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azResult)) + uintptr(0)*8))))))
		for i = int32(1); i < n; i++ {
			if *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azResult)) + uintptr(i)*8)) != nil {
				sqlite3_free(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azResult)) + uintptr(i)*8))))
			}
		}
		sqlite3_free(unsafe.Pointer(azResult))
	}
}
func sqlite3DeleteTriggerStep(db *struct_sqlite3, pTriggerStep *struct_TriggerStep) {
	for pTriggerStep != nil {
		var pTmp *struct_TriggerStep = pTriggerStep
		pTriggerStep = pTriggerStep.pNext
		sqlite3ExprDelete(db, pTmp.pWhere)
		sqlite3ExprListDelete(db, pTmp.pExprList)
		sqlite3SelectDelete(db, pTmp.pSelect)
		sqlite3IdListDelete(db, pTmp.pIdList)
		sqlite3UpsertDelete(db, pTmp.pUpsert)
		sqlite3SrcListDelete(db, pTmp.pFrom)
		sqlite3DbFree(db, unsafe.Pointer(pTmp.zSpan))
		sqlite3DbFree(db, unsafe.Pointer(pTmp))
	}
}
func sqlite3TriggerList(pParse *struct_Parse, pTab *struct_Table) *struct_Trigger {
	var pTmpSchema *struct_Schema
	var pList *struct_Trigger
	var p *struct_HashElem
	if pParse.disableTriggers != 0 {
		return (*struct_Trigger)(nil)
	}
	pTmpSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(1)*32))).pSchema
	p = (&pTmpSchema.trigHash).first
	pList = pTab.pTrigger
	for p != nil {
		var pTrig *struct_Trigger = (*struct_Trigger)(p.data)
		if uintptr(unsafe.Pointer(pTrig.pTabSchema)) == uintptr(unsafe.Pointer(pTab.pSchema)) && pTrig.table != nil && 0 == sqlite3StrICmp(pTrig.table, pTab.zName) && uintptr(unsafe.Pointer(pTrig.pTabSchema)) != uintptr(unsafe.Pointer(pTmpSchema)) {
			pTrig.pNext = pList
			pList = pTrig
		} else if int32(pTrig.op) == 150 && uintptr(unsafe.Pointer(pParse.db.pVtabCtx)) == uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pTrig.table = pTab.zName
			pTrig.pTabSchema = pTab.pSchema
			pTrig.pNext = pList
			pList = pTrig
		}
		p = p.next
	}
	return pList
}
func sqlite3BeginTrigger(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token, tr_tm int32, op int32, pColumns *struct_IdList, pTableName *struct_SrcList, pWhen *struct_Expr, isTemp int32, noErr int32) {
	var pTrigger *struct_Trigger = nil
	var pTab *struct_Table
	var zName *int8 = nil
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	var pName *struct_Token
	var sFix struct_DbFixer
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if isTemp != 0 {
		if pName2.n > uint32(0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[46]int8{'t', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'h', 'a', 'v', 'e', ' ', 'q', 'u', 'a', 'l', 'i', 'f', 'i', 'e', 'd', ' ', 'n', 'a', 'm', 'e', '\x00'})))
			goto trigger_cleanup
		}
		iDb = int32(1)
		pName = pName1
	} else {
		iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName)
		if iDb < 0 {
			goto trigger_cleanup
		}
	}
	if !(pTableName != nil) || int32(db.mallocFailed) != 0 {
		goto trigger_cleanup
	}
	if int32(db.init.busy) != 0 && iDb != 1 {
		sqlite3DbFree(db, unsafe.Pointer((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTableName.a)))) + uintptr(0)*112))).zDatabase))
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTableName.a)))) + uintptr(0)*112))).zDatabase = (*int8)(nil)
	}
	pTab = sqlite3SrcListLookup(pParse, pTableName)
	if int32(db.init.busy) == 0 && pName2.n == uint32(0) && pTab != nil && uintptr(unsafe.Pointer(pTab.pSchema)) == uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema)) {
		iDb = int32(1)
	}
	if db.mallocFailed != 0 {
		goto trigger_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3FixInit(&sFix, pParse, iDb, (*int8)(unsafe.Pointer(&[8]int8{'t', 'r', 'i', 'g', 'g', 'e', 'r', '\x00'})), pName)
	if sqlite3FixSrcList(&sFix, pTableName) != 0 {
		goto trigger_cleanup
	}
	pTab = sqlite3SrcListLookup(pParse, pTableName)
	if !(pTab != nil) {
		goto trigger_orphan_error
	}
	if int32(pTab.eTabType) == 1 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[41]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'r', 'e', 'a', 't', 'e', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', 's', ' ', 'o', 'n', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', 's', '\x00'})))
		goto trigger_orphan_error
	}
	zName = sqlite3NameFromToken(db, pName)
	if uintptr(unsafe.Pointer(zName)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		goto trigger_cleanup
	}
	if sqlite3CheckObjectName(pParse, zName, (*int8)(unsafe.Pointer(&[8]int8{'t', 'r', 'i', 'g', 'g', 'e', 'r', '\x00'})), pTab.zName) != 0 {
		goto trigger_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	if !(int32(pParse.eParseMode) >= 2) {
		if sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.trigHash, zName) != nil {
			if !(noErr != 0) {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[26]int8{'t', 'r', 'i', 'g', 'g', 'e', 'r', ' ', '%', 'T', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'e', 'x', 'i', 's', 't', 's', '\x00'})), pName)
			} else {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3CodeVerifySchema(pParse, iDb)
			}
			goto trigger_cleanup
		}
	}
	if sqlite3_strnicmp(pTab.zName, (*int8)(unsafe.Pointer(&[8]int8{'s', 'q', 'l', 'i', 't', 'e', '_', '\x00'})), 7) == 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[38]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'r', 'e', 'a', 't', 'e', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', ' ', 'o', 'n', ' ', 's', 'y', 's', 't', 'e', 'm', ' ', 't', 'a', 'b', 'l', 'e', '\x00'})))
		goto trigger_cleanup
	}
	if int32(pTab.eTabType) == 2 && tr_tm != 65 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[37]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'r', 'e', 'a', 't', 'e', ' ', '%', 's', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', ' ', 'o', 'n', ' ', 'v', 'i', 'e', 'w', ':', ' ', '%', 'S', '\x00'})), func() *int8 {
			if tr_tm == 33 {
				return (*int8)(unsafe.Pointer(&[7]int8{'B', 'E', 'F', 'O', 'R', 'E', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[6]int8{'A', 'F', 'T', 'E', 'R', '\x00'}))
			}
		}(), (*struct_SrcItem)(unsafe.Pointer(&pTableName.a)))
		goto trigger_orphan_error
	}
	if !(int32(pTab.eTabType) == 2) && tr_tm == 65 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[46]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'c', 'r', 'e', 'a', 't', 'e', ' ', 'I', 'N', 'S', 'T', 'E', 'A', 'D', ' ', 'O', 'F', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', ' ', 'o', 'n', ' ', 't', 'a', 'b', 'l', 'e', ':', ' ', '%', 'S', '\x00'})), (*struct_SrcItem)(unsafe.Pointer(&pTableName.a)))
		goto trigger_orphan_error
	}
	if !(int32(pParse.eParseMode) >= 2) {
		var iTabDb int32 = sqlite3SchemaToIndex(db, pTab.pSchema)
		var code int32 = 7
		var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iTabDb)*32))).zDbSName
		var zDbTrig *int8 = func() *int8 {
			if isTemp != 0 {
				return (*int8)(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).zDbSName))
			} else {
				return zDb
			}
		}()
		if iTabDb == 1 || isTemp != 0 {
			code = int32(5)
		}
		if sqlite3AuthCheck(pParse, code, zName, pTab.zName, zDbTrig) != 0 {
			goto trigger_cleanup
		}
		if sqlite3AuthCheck(pParse, 18, func() *int8 {
			if true && iTabDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}(), nil, zDb) != 0 {
			goto trigger_cleanup
		}
	}
	if tr_tm == 65 {
		tr_tm = int32(33)
	}
	pTrigger = (*struct_Trigger)(sqlite3DbMallocZero(db, uint64(72)))
	if uintptr(unsafe.Pointer(pTrigger)) == uintptr(unsafe.Pointer(nil)) {
		goto trigger_cleanup
	}
	pTrigger.zName = zName
	zName = (*int8)(nil)
	pTrigger.table = sqlite3DbStrDup(db, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTableName.a)))) + uintptr(0)*112))).zName)
	pTrigger.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema
	pTrigger.pTabSchema = pTab.pSchema
	pTrigger.op = uint8(op)
	pTrigger.tr_tm = uint8(func() int32 {
		if tr_tm == 33 {
			return 1
		} else {
			return 2
		}
	}())
	if int32(pParse.eParseMode) >= 2 {
		sqlite3RenameTokenRemap(pParse, unsafe.Pointer(pTrigger.table), unsafe.Pointer((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTableName.a)))) + uintptr(0)*112))).zName))
		pTrigger.pWhen = pWhen
		pWhen = (*struct_Expr)(nil)
	} else {
		pTrigger.pWhen = sqlite3ExprDup(db, pWhen, 1)
	}
	pTrigger.pColumns = pColumns
	pColumns = (*struct_IdList)(nil)
	func() int {
		_ = 0
		return 0
	}()
	pParse.pNewTrigger = pTrigger
trigger_cleanup:
	sqlite3DbFree(db, unsafe.Pointer(zName))
	sqlite3SrcListDelete(db, pTableName)
	sqlite3IdListDelete(db, pColumns)
	sqlite3ExprDelete(db, pWhen)
	if !(pParse.pNewTrigger != nil) {
		sqlite3DeleteTrigger(db, pTrigger)
	} else {
		func() int {
			_ = 0
			return 0
		}()
	}
	return
trigger_orphan_error:
	if int32(db.init.iDb) == 1 {
		{
			_autoGo_80 := &db.init.Xbf_0
			*_autoGo_80 = *_autoGo_80&^1 | uint32(1)&1
		}
	}
	goto trigger_cleanup
}
func sqlite3FinishTrigger(pParse *struct_Parse, pStepList *struct_TriggerStep, pAll *struct_Token) {
	var pTrig *struct_Trigger = pParse.pNewTrigger
	var zName *int8
	var db *struct_sqlite3 = pParse.db
	var sFix struct_DbFixer
	var iDb int32
	var nameToken struct_Token
	pParse.pNewTrigger = (*struct_Trigger)(nil)
	if pParse.nErr != 0 || !(pTrig != nil) {
		goto triggerfinish_cleanup
	}
	zName = pTrig.zName
	iDb = sqlite3SchemaToIndex(pParse.db, pTrig.pSchema)
	pTrig.step_list = pStepList
	for pStepList != nil {
		pStepList.pTrig = pTrig
		pStepList = pStepList.pNext
	}
	sqlite3TokenInit(&nameToken, pTrig.zName)
	sqlite3FixInit(&sFix, pParse, iDb, (*int8)(unsafe.Pointer(&[8]int8{'t', 'r', 'i', 'g', 'g', 'e', 'r', '\x00'})), &nameToken)
	if sqlite3FixTriggerStep(&sFix, pTrig.step_list) != 0 || sqlite3FixExpr(&sFix, pTrig.pWhen) != 0 {
		goto triggerfinish_cleanup
	}
	if int32(pParse.eParseMode) >= 2 {
		func() int {
			_ = 0
			return 0
		}()
		pParse.pNewTrigger = pTrig
		pTrig = (*struct_Trigger)(nil)
	} else if !(db.init.busy != 0) {
		var v *struct_Vdbe
		var z *int8
		v = sqlite3GetVdbe(pParse)
		if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
			goto triggerfinish_cleanup
		}
		sqlite3BeginWriteOperation(pParse, 0, iDb)
		z = sqlite3DbStrNDup(db, (*int8)(unsafe.Pointer(pAll.z)), uint64(pAll.n))
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[75]int8{'I', 'N', 'S', 'E', 'R', 'T', ' ', 'I', 'N', 'T', 'O', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'V', 'A', 'L', 'U', 'E', 'S', '(', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', ',', '%', 'Q', ',', '%', 'Q', ',', '0', ',', '\'', 'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'R', 'I', 'G', 'G', 'E', 'R', ' ', '%', 'q', '\'', ')', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, zName, pTrig.table, z)
		sqlite3DbFree(db, unsafe.Pointer(z))
		sqlite3ChangeCookie(pParse, iDb)
		sqlite3VdbeAddParseSchemaOp(v, iDb, sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[29]int8{'t', 'y', 'p', 'e', '=', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', ' ', 'A', 'N', 'D', ' ', 'n', 'a', 'm', 'e', '=', '\'', '%', 'q', '\'', '\x00'})), zName), uint16(0))
	}
	if db.init.busy != 0 {
		var pLink *struct_Trigger = pTrig
		var pHash *struct_Hash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.trigHash
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pTrig = (*struct_Trigger)(sqlite3HashInsert(pHash, zName, unsafe.Pointer(pTrig)))
		if pTrig != nil {
			sqlite3OomFault(db)
		} else if uintptr(unsafe.Pointer(pLink.pSchema)) == uintptr(unsafe.Pointer(pLink.pTabSchema)) {
			var pTab *struct_Table
			pTab = (*struct_Table)(sqlite3HashFind(&pLink.pTabSchema.tblHash, pLink.table))
			func() int {
				_ = 0
				return 0
			}()
			pLink.pNext = pTab.pTrigger
			pTab.pTrigger = pLink
		}
	}
triggerfinish_cleanup:
	sqlite3DeleteTrigger(db, pTrig)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3DeleteTriggerStep(db, pStepList)
}
func triggerSpanDup(db *struct_sqlite3, zStart *int8, zEnd *int8) *int8 {
	var z *int8 = sqlite3DbSpanDup(db, zStart, zEnd)
	var i int32
	if z != nil {
		for i = int32(0); *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))) != 0; i++ {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&1 != 0 {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))) = int8(' ')
			}
		}
	}
	return z
}
func sqlite3TriggerSelectStep(db *struct_sqlite3, pSelect *struct_Select, zStart *int8, zEnd *int8) *struct_TriggerStep {
	var pTriggerStep *struct_TriggerStep = (*struct_TriggerStep)(sqlite3DbMallocZero(db, uint64(96)))
	if uintptr(unsafe.Pointer(pTriggerStep)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3SelectDelete(db, pSelect)
		return (*struct_TriggerStep)(nil)
	}
	pTriggerStep.op = uint8(138)
	pTriggerStep.pSelect = pSelect
	pTriggerStep.orconf = uint8(11)
	pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd)
	return pTriggerStep
}
func triggerStepAllocate(pParse *struct_Parse, op uint8, pName *struct_Token, zStart *int8, zEnd *int8) *struct_TriggerStep {
	var db *struct_sqlite3 = pParse.db
	var pTriggerStep *struct_TriggerStep
	if pParse.nErr != 0 {
		return (*struct_TriggerStep)(nil)
	}
	pTriggerStep = (*struct_TriggerStep)(sqlite3DbMallocZero(db, uint64(96+uint(pName.n)+uint(1))))
	if pTriggerStep != nil {
		var z *int8 = (*int8)(unsafe.Pointer(&*(*struct_TriggerStep)(unsafe.Pointer(uintptr(unsafe.Pointer(pTriggerStep)) + uintptr(1)*96))))
		__builtin___memcpy_chk(unsafe.Pointer(z), unsafe.Pointer(pName.z), uint(pName.n), __builtin_object_size(unsafe.Pointer(z), 0))
		sqlite3Dequote(z)
		pTriggerStep.zTarget = z
		pTriggerStep.op = op
		pTriggerStep.zSpan = triggerSpanDup(db, zStart, zEnd)
		if int32(pParse.eParseMode) >= 2 {
			sqlite3RenameTokenMap(pParse, unsafe.Pointer(pTriggerStep.zTarget), pName)
		}
	}
	return pTriggerStep
}
func sqlite3TriggerInsertStep(pParse *struct_Parse, pTableName *struct_Token, pColumn *struct_IdList, pSelect *struct_Select, orconf uint8, pUpsert *struct_Upsert, zStart *int8, zEnd *int8) *struct_TriggerStep {
	var db *struct_sqlite3 = pParse.db
	var pTriggerStep *struct_TriggerStep
	func() int {
		_ = 0
		return 0
	}()
	pTriggerStep = triggerStepAllocate(pParse, uint8(127), pTableName, zStart, zEnd)
	if pTriggerStep != nil {
		if int32(pParse.eParseMode) >= 2 {
			pTriggerStep.pSelect = pSelect
			pSelect = (*struct_Select)(nil)
		} else {
			pTriggerStep.pSelect = sqlite3SelectDup(db, pSelect, 1)
		}
		pTriggerStep.pIdList = pColumn
		pTriggerStep.pUpsert = pUpsert
		pTriggerStep.orconf = orconf
		if pUpsert != nil {
			sqlite3HasExplicitNulls(pParse, pUpsert.pUpsertTarget)
		}
	} else {
		sqlite3IdListDelete(db, pColumn)
		sqlite3UpsertDelete(db, pUpsert)
	}
	sqlite3SelectDelete(db, pSelect)
	return pTriggerStep
}
func sqlite3TriggerUpdateStep(pParse *struct_Parse, pTableName *struct_Token, pFrom *struct_SrcList, pEList *struct_ExprList, pWhere *struct_Expr, orconf uint8, zStart *int8, zEnd *int8) *struct_TriggerStep {
	var db *struct_sqlite3 = pParse.db
	var pTriggerStep *struct_TriggerStep
	pTriggerStep = triggerStepAllocate(pParse, uint8(129), pTableName, zStart, zEnd)
	if pTriggerStep != nil {
		if int32(pParse.eParseMode) >= 2 {
			pTriggerStep.pExprList = pEList
			pTriggerStep.pWhere = pWhere
			pTriggerStep.pFrom = pFrom
			pEList = (*struct_ExprList)(nil)
			pWhere = (*struct_Expr)(nil)
			pFrom = (*struct_SrcList)(nil)
		} else {
			pTriggerStep.pExprList = sqlite3ExprListDup(db, pEList, 1)
			pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, 1)
			pTriggerStep.pFrom = sqlite3SrcListDup(db, pFrom, 1)
		}
		pTriggerStep.orconf = orconf
	}
	sqlite3ExprListDelete(db, pEList)
	sqlite3ExprDelete(db, pWhere)
	sqlite3SrcListDelete(db, pFrom)
	return pTriggerStep
}
func sqlite3TriggerDeleteStep(pParse *struct_Parse, pTableName *struct_Token, pWhere *struct_Expr, zStart *int8, zEnd *int8) *struct_TriggerStep {
	var db *struct_sqlite3 = pParse.db
	var pTriggerStep *struct_TriggerStep
	pTriggerStep = triggerStepAllocate(pParse, uint8(128), pTableName, zStart, zEnd)
	if pTriggerStep != nil {
		if int32(pParse.eParseMode) >= 2 {
			pTriggerStep.pWhere = pWhere
			pWhere = (*struct_Expr)(nil)
		} else {
			pTriggerStep.pWhere = sqlite3ExprDup(db, pWhere, 1)
		}
		pTriggerStep.orconf = uint8(11)
	}
	sqlite3ExprDelete(db, pWhere)
	return pTriggerStep
}
func sqlite3DeleteTrigger(db *struct_sqlite3, pTrigger *struct_Trigger) {
	if uintptr(unsafe.Pointer(pTrigger)) == uintptr(unsafe.Pointer(nil)) || int32(pTrigger.bReturning) != 0 {
		return
	}
	sqlite3DeleteTriggerStep(db, pTrigger.step_list)
	sqlite3DbFree(db, unsafe.Pointer(pTrigger.zName))
	sqlite3DbFree(db, unsafe.Pointer(pTrigger.table))
	sqlite3ExprDelete(db, pTrigger.pWhen)
	sqlite3IdListDelete(db, pTrigger.pColumns)
	sqlite3DbFree(db, unsafe.Pointer(pTrigger))
}
func sqlite3DropTrigger(pParse *struct_Parse, pName *struct_SrcList, noErr int32) {
	var pTrigger *struct_Trigger = nil
	var i int32
	var zDb *int8
	var zName *int8
	var db *struct_sqlite3 = pParse.db
	if db.mallocFailed != 0 {
		goto drop_trigger_cleanup
	}
	if 0 != sqlite3ReadSchema(pParse) {
		goto drop_trigger_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	zDb = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112))).zDatabase
	zName = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pName.a)))) + uintptr(0)*112))).zName
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nDb; i++ {
		var j int32 = func() int32 {
			if i < 2 {
				return i ^ 1
			} else {
				return i
			}
		}()
		if zDb != nil && sqlite3DbIsNamed(db, j, zDb) == 0 {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		pTrigger = (*struct_Trigger)(sqlite3HashFind(&(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(j)*32))).pSchema.trigHash, zName))
		if pTrigger != nil {
			break
		}
	}
	if !(pTrigger != nil) {
		if !(noErr != 0) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[20]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', ':', ' ', '%', 'S', '\x00'})), (*struct_SrcItem)(unsafe.Pointer(&pName.a)))
		} else {
			sqlite3CodeVerifyNamedSchema(pParse, zDb)
		}
		pParse.checkSchema = uint8(1)
		goto drop_trigger_cleanup
	}
	sqlite3DropTriggerPtr(pParse, pTrigger)
drop_trigger_cleanup:
	sqlite3SrcListDelete(db, pName)
}
func tableOfTrigger(pTrigger *struct_Trigger) *struct_Table {
	return (*struct_Table)(sqlite3HashFind(&pTrigger.pTabSchema.tblHash, pTrigger.table))
}
func sqlite3DropTriggerPtr(pParse *struct_Parse, pTrigger *struct_Trigger) {
	var pTable *struct_Table
	var v *struct_Vdbe
	var db *struct_sqlite3 = pParse.db
	var iDb int32
	iDb = sqlite3SchemaToIndex(pParse.db, pTrigger.pSchema)
	func() int {
		_ = 0
		return 0
	}()
	pTable = tableOfTrigger(pTrigger)
	func() int {
		_ = 0
		return 0
	}()
	if pTable != nil {
		var code int32 = 16
		var zDb *int8 = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
		var zTab *int8 = func() *int8 {
			if true && iDb == 1 {
				return (*int8)(unsafe.Pointer(&[19]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 't', 'e', 'm', 'p', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[14]int8{'s', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', '\x00'}))
			}
		}()
		if iDb == 1 {
			code = int32(14)
		}
		if sqlite3AuthCheck(pParse, code, pTrigger.zName, pTable.zName, zDb) != 0 || sqlite3AuthCheck(pParse, 9, zTab, nil, zDb) != 0 {
			return
		}
	}
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Vdbe) {
		_cgo_addr := &v
		*_cgo_addr = sqlite3GetVdbe(pParse)
		return *_cgo_addr
	}())) != uintptr(unsafe.Pointer(nil)) {
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[62]int8{'D', 'E', 'L', 'E', 'T', 'E', ' ', 'F', 'R', 'O', 'M', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'A', 'N', 'D', ' ', 't', 'y', 'p', 'e', '=', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, pTrigger.zName)
		sqlite3ChangeCookie(pParse, iDb)
		sqlite3VdbeAddOp4(v, 152, iDb, 0, 0, pTrigger.zName, 0)
	}
}
func sqlite3UnlinkAndDeleteTrigger(db *struct_sqlite3, iDb int32, zName *int8) {
	var pTrigger *struct_Trigger
	var pHash *struct_Hash
	func() int {
		_ = 0
		return 0
	}()
	pHash = &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.trigHash
	pTrigger = (*struct_Trigger)(sqlite3HashInsert(pHash, zName, nil))
	if pTrigger != nil {
		if uintptr(unsafe.Pointer(pTrigger.pSchema)) == uintptr(unsafe.Pointer(pTrigger.pTabSchema)) {
			var pTab *struct_Table = tableOfTrigger(pTrigger)
			if pTab != nil {
				var pp **struct_Trigger
				for pp = &pTab.pTrigger; *pp != nil; pp = &(*pp).pNext {
					if uintptr(unsafe.Pointer(*pp)) == uintptr(unsafe.Pointer(pTrigger)) {
						*pp = (*pp).pNext
						break
					}
				}
			}
		}
		sqlite3DeleteTrigger(db, pTrigger)
		db.mDbFlags |= uint32(1)
	}
}
func checkColumnOverlap(pIdList *struct_IdList, pEList *struct_ExprList) int32 {
	var e int32
	if uintptr(unsafe.Pointer(pIdList)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pEList)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	for e = int32(0); e < pEList.nExpr; e++ {
		if sqlite3IdListIndex(pIdList, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pEList.a)))) + uintptr(e)*28))).zEName) >= 0 {
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3TriggersExist(pParse *struct_Parse, pTab *struct_Table, op int32, pChanges *struct_ExprList, pMask *int32) *struct_Trigger {
	var mask int32 = 0
	var pList *struct_Trigger = nil
	var p *struct_Trigger
	pList = sqlite3TriggerList(pParse, pTab)
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pList)) != uintptr(unsafe.Pointer(nil)) {
		p = pList
		if pParse.db.flags&uint64(262144) == uint64(0) && uintptr(unsafe.Pointer(pTab.pTrigger)) != uintptr(unsafe.Pointer(nil)) {
			if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(pTab.pTrigger)) {
				pList = (*struct_Trigger)(nil)
				goto exit_triggers_exist
			}
			for p.pNext != nil && uintptr(unsafe.Pointer(p.pNext)) != uintptr(unsafe.Pointer(pTab.pTrigger)) {
				p = p.pNext
			}
			p.pNext = (*struct_Trigger)(nil)
			p = pList
		}
		for {
			if int32(p.op) == op && checkColumnOverlap(p.pColumns, pChanges) != 0 {
				mask |= int32(p.tr_tm)
			} else if int32(p.op) == 150 {
				func() int {
					_ = 0
					return 0
				}()
				p.op = uint8(op)
				if int32(pTab.eTabType) == 1 {
					if op != 127 {
						sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[48]int8{'%', 's', ' ', 'R', 'E', 'T', 'U', 'R', 'N', 'I', 'N', 'G', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', ' ', 'o', 'n', ' ', 'v', 'i', 'r', 't', 'u', 'a', 'l', ' ', 't', 'a', 'b', 'l', 'e', 's', '\x00'})), func() *int8 {
							if op == 128 {
								return (*int8)(unsafe.Pointer(&[7]int8{'D', 'E', 'L', 'E', 'T', 'E', '\x00'}))
							} else {
								return (*int8)(unsafe.Pointer(&[7]int8{'U', 'P', 'D', 'A', 'T', 'E', '\x00'}))
							}
						}())
					}
					p.tr_tm = uint8(1)
				} else {
					p.tr_tm = uint8(2)
				}
				mask |= int32(p.tr_tm)
			} else if int32(p.bReturning) != 0 && int32(p.op) == 127 && op == 129 && uintptr(unsafe.Pointer(pParse.pToplevel)) == uintptr(unsafe.Pointer(nil)) {
				mask |= int32(p.tr_tm)
			}
			p = p.pNext
			if !(p != nil) {
				break
			}
		}
	}
exit_triggers_exist:
	if pMask != nil {
		*pMask = mask
	}
	return func() *struct_Trigger {
		if mask != 0 {
			return pList
		} else {
			return nil
		}
	}()
}
func sqlite3TriggerStepSrc(pParse *struct_Parse, pStep *struct_TriggerStep) *struct_SrcList {
	var db *struct_sqlite3 = pParse.db
	var pSrc *struct_SrcList
	var zName *int8 = sqlite3DbStrDup(db, pStep.zTarget)
	pSrc = sqlite3SrcListAppend(pParse, nil, nil, nil)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pSrc != nil {
		var pSchema *struct_Schema = pStep.pTrig.pSchema
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).zName = zName
		if uintptr(unsafe.Pointer(pSchema)) != uintptr(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema)) {
			(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).pSchema = pSchema
		}
		if pStep.pFrom != nil {
			var pDup *struct_SrcList = sqlite3SrcListDup(db, pStep.pFrom, 0)
			pSrc = sqlite3SrcListAppendList(pParse, pSrc, pDup)
		}
	} else {
		sqlite3DbFree(db, unsafe.Pointer(zName))
	}
	return pSrc
}
func isAsteriskTerm(pParse *struct_Parse, pTerm *struct_Expr) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTerm.op) == 180 {
		return int32(1)
	}
	if int32(pTerm.op) != 141 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTerm.pRight.op) != 180 {
		return int32(0)
	}
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[42]int8{'R', 'E', 'T', 'U', 'R', 'N', 'I', 'N', 'G', ' ', 'm', 'a', 'y', ' ', 'n', 'o', 't', ' ', 'u', 's', 'e', ' ', '"', 'T', 'A', 'B', 'L', 'E', '.', '*', '"', ' ', 'w', 'i', 'l', 'd', 'c', 'a', 'r', 'd', 's', '\x00'})))
	return int32(1)
}
func sqlite3ExpandReturning(pParse *struct_Parse, pList *struct_ExprList, pTab *struct_Table) *struct_ExprList {
	var pNew *struct_ExprList = nil
	var db *struct_sqlite3 = pParse.db
	var i int32
	for i = int32(0); i < pList.nExpr; i++ {
		var pOldExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr
		if uintptr(unsafe.Pointer(pOldExpr)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if isAsteriskTerm(pParse, pOldExpr) != 0 {
			var jj int32
			for jj = int32(0); jj < int32(pTab.nCol); jj++ {
				var pNewExpr *struct_Expr
				if int32((*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol))+uintptr(jj)*20)).colFlags)&2 != 0 {
					continue
				}
				pNewExpr = sqlite3Expr(db, 59, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(jj)*20))).zCnName)
				pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr)
				if !(db.mallocFailed != 0) {
					var pItem *struct_ExprList_item = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pNew.a)))) + uintptr(pNew.nExpr-1)*28))
					pItem.zEName = sqlite3DbStrDup(db, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(jj)*20))).zCnName)
					{
						_autoGo_81 := &pItem.Xbf_0
						*_autoGo_81 = *_autoGo_81&^3 | uint32(0)&3
					}
				}
			}
		} else {
			var pNewExpr *struct_Expr = sqlite3ExprDup(db, pOldExpr, 0)
			pNew = sqlite3ExprListAppend(pParse, pNew, pNewExpr)
			if !(db.mallocFailed != 0) && uintptr(unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).zEName)) != uintptr(unsafe.Pointer(nil)) {
				var pItem *struct_ExprList_item = &*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pNew.a)))) + uintptr(pNew.nExpr-1)*28))
				pItem.zEName = sqlite3DbStrDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).zEName)
				{
					_autoGo_82 := &pItem.Xbf_0
					*_autoGo_82 = *_autoGo_82&^3 | (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).Xbf_0&3&3
				}
			}
		}
	}
	return pNew
}
func codeReturningTrigger(pParse *struct_Parse, pTrigger *struct_Trigger, pTab *struct_Table, regIn int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var db *struct_sqlite3 = pParse.db
	var pNew *struct_ExprList
	var pReturning *struct_Returning
	var sSelect struct_Select
	var sFrom struct_SrcList
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pReturning = pParse.u1.pReturning
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&sSelect), 0, 128, __builtin_object_size(unsafe.Pointer(&sSelect), 0))
	__builtin___memset_chk(unsafe.Pointer(&sFrom), 0, 120, __builtin_object_size(unsafe.Pointer(&sFrom), 0))
	sSelect.pEList = sqlite3ExprListDup(db, pReturning.pReturnEL, 0)
	sSelect.pSrc = &sFrom
	sFrom.nSrc = int32(1)
	(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&sFrom.a)))) + uintptr(0)*112))).pTab = pTab
	(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&sFrom.a)))) + uintptr(0)*112))).iCursor = int32(-1)
	sqlite3SelectPrep(pParse, &sSelect, nil)
	if pParse.nErr == 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3GenerateColumnNames(pParse, &sSelect)
	}
	sqlite3ExprListDelete(db, sSelect.pEList)
	pNew = sqlite3ExpandReturning(pParse, pReturning.pReturnEL, pTab)
	if !(db.mallocFailed != 0) {
		var sNC struct_NameContext
		__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
		if pReturning.nRetCol == 0 {
			pReturning.nRetCol = pNew.nExpr
			pReturning.iRetCur = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
		}
		sNC.pParse = pParse
		*(*int32)(unsafe.Pointer(&sNC.uNC)) = regIn
		sNC.ncFlags = int32(1024)
		pParse.eTriggerOp = pTrigger.op
		pParse.pTriggerTab = pTab
		if sqlite3ResolveExprListNames(&sNC, pNew) == 0 && !(db.mallocFailed != 0) {
			var i int32
			var nCol int32 = pNew.nExpr
			var reg int32 = pParse.nMem + 1
			pParse.nMem += nCol + 2
			pReturning.iRetReg = reg
			for i = int32(0); i < nCol; i++ {
				var pCol *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pNew.a)))) + uintptr(i)*28))).pExpr
				func() int {
					_ = 0
					return 0
				}()
				sqlite3ExprCodeFactorable(pParse, pCol, reg+i)
				if int32(sqlite3ExprAffinity(pCol)) == 69 {
					sqlite3VdbeAddOp1(v, 86, reg+i)
				}
			}
			sqlite3VdbeAddOp3(v, 96, reg, i, reg+i)
			sqlite3VdbeAddOp2(v, 126, pReturning.iRetCur, reg+i+1)
			sqlite3VdbeAddOp3(v, 127, pReturning.iRetCur, reg+i, reg+i+1)
		}
	}
	sqlite3ExprListDelete(db, pNew)
	pParse.eTriggerOp = uint8(0)
	pParse.pTriggerTab = (*struct_Table)(nil)
}
func codeTriggerProgram(pParse *struct_Parse, pStepList *struct_TriggerStep, orconf int32) int32 {
	var pStep *struct_TriggerStep
	var v *struct_Vdbe = pParse.pVdbe
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for pStep = pStepList; pStep != nil; pStep = pStep.pNext {
		pParse.eOrconf = uint8(func() int32 {
			if orconf == 11 {
				return int32(pStep.orconf)
			} else {
				return int32(uint8(orconf))
			}
		}())
		func() int {
			_ = 0
			return 0
		}()
		if pStep.zSpan != nil {
			sqlite3VdbeAddOp4(v, 179, 2147483647, 1, 0, sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[6]int8{'-', '-', ' ', '%', 's', '\x00'})), pStep.zSpan), -7)
		}
		switch int32(pStep.op) {
		case 129:
			{
				sqlite3Update(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprListDup(db, pStep.pExprList, 0), sqlite3ExprDup(db, pStep.pWhere, 0), int32(pParse.eOrconf), nil, nil, nil)
				sqlite3VdbeAddOp0(v, 130)
				break
			}
		case 127:
			{
				sqlite3Insert(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3SelectDup(db, pStep.pSelect, 0), sqlite3IdListDup(db, pStep.pIdList), int32(pParse.eOrconf), sqlite3UpsertDup(db, pStep.pUpsert))
				sqlite3VdbeAddOp0(v, 130)
				break
			}
		case 128:
			{
				sqlite3DeleteFrom(pParse, sqlite3TriggerStepSrc(pParse, pStep), sqlite3ExprDup(db, pStep.pWhere, 0), nil, nil)
				sqlite3VdbeAddOp0(v, 130)
				break
			}
		default:
			func() int {
				_ = 0
				return 0
			}()
			{
				var sDest struct_SelectDest
				var pSelect *struct_Select = sqlite3SelectDup(db, pStep.pSelect, 0)
				sqlite3SelectDestInit(&sDest, 4, 0)
				sqlite3Select(pParse, pSelect, &sDest)
				sqlite3SelectDelete(db, pSelect)
				break
			}
		}
	}
	return int32(0)
}
func transferParseError(pTo *struct_Parse, pFrom *struct_Parse) {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pTo.nErr == 0 {
		pTo.zErrMsg = pFrom.zErrMsg
		pTo.nErr = pFrom.nErr
		pTo.rc = pFrom.rc
	} else {
		sqlite3DbFree(pFrom.db, unsafe.Pointer(pFrom.zErrMsg))
	}
}
func codeRowTrigger(pParse *struct_Parse, pTrigger *struct_Trigger, pTab *struct_Table, orconf int32) *struct_TriggerPrg {
	var pTop *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	var db *struct_sqlite3 = pParse.db
	var pPrg *struct_TriggerPrg
	var pWhen *struct_Expr = nil
	var v *struct_Vdbe
	var sNC struct_NameContext
	var pProgram *struct_SubProgram = nil
	var iEndTrigger int32 = 0
	var sSubParse struct_Parse
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pPrg = (*struct_TriggerPrg)(sqlite3DbMallocZero(db, uint64(36)))
	if !(pPrg != nil) {
		return (*struct_TriggerPrg)(nil)
	}
	pPrg.pNext = pTop.pTriggerPrg
	pTop.pTriggerPrg = pPrg
	pPrg.pProgram = func() (_cgo_ret *struct_SubProgram) {
		_cgo_addr := &pProgram
		*_cgo_addr = (*struct_SubProgram)(sqlite3DbMallocZero(db, uint64(48)))
		return *_cgo_addr
	}()
	if !(pProgram != nil) {
		return (*struct_TriggerPrg)(nil)
	}
	sqlite3VdbeLinkSubProgram(pTop.pVdbe, pProgram)
	pPrg.pTrigger = pTrigger
	pPrg.orconf = orconf
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pPrg.aColmask)))) + uintptr(0)*4)) = uint32(4294967295)
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pPrg.aColmask)))) + uintptr(1)*4)) = uint32(4294967295)
	sqlite3ParseObjectInit(&sSubParse, db)
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	sNC.pParse = &sSubParse
	sSubParse.pTriggerTab = pTab
	sSubParse.pToplevel = pTop
	sSubParse.zAuthContext = pTrigger.zName
	sSubParse.eTriggerOp = pTrigger.op
	sSubParse.nQueryLoop = pParse.nQueryLoop
	sSubParse.disableVtab = pParse.disableVtab
	v = sqlite3GetVdbe(&sSubParse)
	if v != nil {
		if pTrigger.zName != nil {
			sqlite3VdbeChangeP4(v, -1, sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[14]int8{'-', '-', ' ', 'T', 'R', 'I', 'G', 'G', 'E', 'R', ' ', '%', 's', '\x00'})), pTrigger.zName), -7)
		}
		if pTrigger.pWhen != nil {
			pWhen = sqlite3ExprDup(db, pTrigger.pWhen, 0)
			if int32(db.mallocFailed) == 0 && 0 == sqlite3ResolveExprNames(&sNC, pWhen) {
				iEndTrigger = sqlite3VdbeMakeLabel(&sSubParse)
				sqlite3ExprIfFalse(&sSubParse, pWhen, iEndTrigger, 16)
			}
			sqlite3ExprDelete(db, pWhen)
		}
		codeTriggerProgram(&sSubParse, pTrigger.step_list, orconf)
		if iEndTrigger != 0 {
			sqlite3VdbeResolveLabel(v, iEndTrigger)
		}
		sqlite3VdbeAddOp0(v, 70)
		transferParseError(pParse, &sSubParse)
		if pParse.nErr == 0 {
			func() int {
				_ = 0
				return 0
			}()
			pProgram.aOp = sqlite3VdbeTakeOpArray(v, &pProgram.nOp, &pTop.nMaxArg)
		}
		pProgram.nMem = sSubParse.nMem
		pProgram.nCsr = sSubParse.nTab
		pProgram.token = unsafe.Pointer(pTrigger)
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pPrg.aColmask)))) + uintptr(0)*4)) = sSubParse.oldmask
		*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pPrg.aColmask)))) + uintptr(1)*4)) = sSubParse.newmask
		sqlite3VdbeDelete(v)
	} else {
		transferParseError(pParse, &sSubParse)
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ParseObjectReset(&sSubParse)
	return pPrg
}
func getRowTrigger(pParse *struct_Parse, pTrigger *struct_Trigger, pTab *struct_Table, orconf int32) *struct_TriggerPrg {
	var pRoot *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	var pPrg *struct_TriggerPrg
	func() int {
		_ = 0
		return 0
	}()
	for pPrg = pRoot.pTriggerPrg; pPrg != nil && (uintptr(unsafe.Pointer(pPrg.pTrigger)) != uintptr(unsafe.Pointer(pTrigger)) || pPrg.orconf != orconf); pPrg = pPrg.pNext {
	}
	if !(pPrg != nil) {
		pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf)
		pParse.db.errByteOffset = int32(-1)
	}
	return pPrg
}
func sqlite3CodeRowTriggerDirect(pParse *struct_Parse, p *struct_Trigger, pTab *struct_Table, reg int32, orconf int32, ignoreJump int32) {
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var pPrg *struct_TriggerPrg
	pPrg = getRowTrigger(pParse, p, pTab, orconf)
	func() int {
		_ = 0
		return 0
	}()
	if pPrg != nil {
		var bRecursive int32 = func() int32 {
			if p.zName != nil && uint64(0) == pParse.db.flags&uint64(8192) {
				return 1
			} else {
				return 0
			}
		}()
		sqlite3VdbeAddOp4(v, 47, reg, ignoreJump, func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}(), (*int8)(unsafe.Pointer(pPrg.pProgram)), -4)
		sqlite3VdbeChangeP5(v, uint16(uint8(bRecursive)))
	}
}
func sqlite3CodeRowTrigger(pParse *struct_Parse, pTrigger *struct_Trigger, op int32, pChanges *struct_ExprList, tr_tm int32, pTab *struct_Table, reg int32, orconf int32, ignoreJump int32) {
	var p *struct_Trigger
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for p = pTrigger; p != nil; p = p.pNext {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if (int32(p.op) == op || int32(p.bReturning) != 0 && int32(p.op) == 127 && op == 129) && int32(p.tr_tm) == tr_tm && checkColumnOverlap(p.pColumns, pChanges) != 0 {
			if !(p.bReturning != 0) {
				sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump)
			} else if uintptr(unsafe.Pointer(pParse.pToplevel)) == uintptr(unsafe.Pointer(nil)) {
				codeReturningTrigger(pParse, p, pTab, reg)
			}
		}
	}
}
func sqlite3TriggerColmask(pParse *struct_Parse, pTrigger *struct_Trigger, pChanges *struct_ExprList, isNew int32, tr_tm int32, pTab *struct_Table, orconf int32) uint32 {
	var op int32 = func() int32 {
		if pChanges != nil {
			return 129
		} else {
			return 128
		}
	}()
	var mask uint32 = uint32(0)
	var p *struct_Trigger
	func() int {
		_ = 0
		return 0
	}()
	for p = pTrigger; p != nil; p = p.pNext {
		if int32(p.op) == op && tr_tm&int32(p.tr_tm) != 0 && checkColumnOverlap(p.pColumns, pChanges) != 0 {
			if p.bReturning != 0 {
				mask = uint32(4294967295)
			} else {
				var pPrg *struct_TriggerPrg
				pPrg = getRowTrigger(pParse, p, pTab, orconf)
				if pPrg != nil {
					mask |= *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint32)(unsafe.Pointer(&pPrg.aColmask)))) + uintptr(isNew)*4))
				}
			}
		}
	}
	return mask
}
func sqlite3ColumnDefault(v *struct_Vdbe, pTab *struct_Table, i int32, iReg int32) {
	func() int {
		_ = 0
		return 0
	}()
	if !(int32(pTab.eTabType) == 2) {
		var pValue *struct_sqlite3_value = nil
		var enc uint8 = sqlite3VdbeDb(v).enc
		var pCol *struct_Column = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))
		func() int {
			_ = 0
			return 0
		}()
		sqlite3ValueFromExpr(sqlite3VdbeDb(v), sqlite3ColumnExpr(pTab, pCol), enc, uint8(pCol.affinity), &pValue)
		if pValue != nil {
			sqlite3VdbeAppendP4(v, unsafe.Pointer(pValue), -11)
		}
	}
	if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).affinity) == 69 && !(int32(pTab.eTabType) == 1) {
		sqlite3VdbeAddOp1(v, 86, iReg)
	}
}
func indexColumnIsBeingUpdated(pIdx *struct_Index, iCol int32, aXRef *int32, chngRowid int32) int32 {
	var iIdxCol int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(iCol)*2))
	func() int {
		_ = 0
		return 0
	}()
	if int32(iIdxCol) >= 0 {
		return func() int32 {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(iIdxCol)*4)) >= 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return sqlite3ExprReferencesUpdatedColumn((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(iCol)*28))).pExpr, aXRef, chngRowid)
}
func indexWhereClauseMightChange(pIdx *struct_Index, aXRef *int32, chngRowid int32) int32 {
	if uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	return sqlite3ExprReferencesUpdatedColumn(pIdx.pPartIdxWhere, aXRef, chngRowid)
}
func exprRowColumn(pParse *struct_Parse, iCol int32) *struct_Expr {
	var pRet *struct_Expr = sqlite3PExpr(pParse, 75, nil, nil)
	if pRet != nil {
		pRet.iColumn = int16(iCol + 1)
	}
	return pRet
}
func updateFromSelect(pParse *struct_Parse, iEph int32, pPk *struct_Index, pChanges *struct_ExprList, pTabList *struct_SrcList, pWhere *struct_Expr, pOrderBy *struct_ExprList, pLimit *struct_Expr) {
	var i int32
	var dest struct_SelectDest
	var pSelect *struct_Select = nil
	var pList *struct_ExprList = nil
	var pGrp *struct_ExprList = nil
	var pLimit2 *struct_Expr = nil
	var pOrderBy2 *struct_ExprList = nil
	var db *struct_sqlite3 = pParse.db
	var pTab *struct_Table = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).pTab
	var pSrc *struct_SrcList
	var pWhere2 *struct_Expr
	var eDest int32
	func() int {
		_ = pOrderBy
		return 0
	}()
	func() int {
		_ = pLimit
		return 0
	}()
	pSrc = sqlite3SrcListDup(db, pTabList, 0)
	pWhere2 = sqlite3ExprDup(db, pWhere, 0)
	func() int {
		_ = 0
		return 0
	}()
	if pSrc != nil {
		{
			_autoGo_83 := &(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).fg.Xbf_0
			*_autoGo_83 = *_autoGo_83&^256 | uint32(1)&1<<8
		}
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).iCursor = int32(-1)
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).pTab.nTabRef--
		(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).pTab = (*struct_Table)(nil)
	}
	if pPk != nil {
		for i = int32(0); i < int32(pPk.nKeyCol); i++ {
			var pNew *struct_Expr = exprRowColumn(pParse, int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))))
			pList = sqlite3ExprListAppend(pParse, pList, pNew)
		}
		eDest = func() int32 {
			if int32(pTab.eTabType) == 1 {
				return 14
			} else {
				return 15
			}
		}()
	} else if int32(pTab.eTabType) == 2 {
		for i = int32(0); i < int32(pTab.nCol); i++ {
			pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i))
		}
		eDest = int32(14)
	} else {
		eDest = func() int32 {
			if int32(pTab.eTabType) == 1 {
				return 14
			} else {
				return 15
			}
		}()
		pList = sqlite3ExprListAppend(pParse, nil, sqlite3PExpr(pParse, 75, nil, nil))
	}
	func() int {
		_ = 0
		return 0
	}()
	if pChanges != nil {
		for i = int32(0); i < pChanges.nExpr; i++ {
			pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).pExpr, 0))
		}
	}
	pSelect = sqlite3SelectNew(pParse, pList, pSrc, pWhere2, pGrp, nil, pOrderBy2, uint32(8388608|131072), pLimit2)
	if pSelect != nil {
		pSelect.selFlags |= uint32(134217728)
	}
	sqlite3SelectDestInit(&dest, eDest, iEph)
	dest.iSDParm2 = func() int32 {
		if pPk != nil {
			return int32(pPk.nKeyCol)
		} else {
			return -1
		}
	}()
	sqlite3Select(pParse, pSelect, &dest)
	sqlite3SelectDelete(db, pSelect)
}
func sqlite3Update(pParse *struct_Parse, pTabList *struct_SrcList, pChanges *struct_ExprList, pWhere *struct_Expr, onError int32, pOrderBy *struct_ExprList, pLimit *struct_Expr, pUpsert *struct_Upsert) {
	var i int32
	var j int32
	var k int32
	var pTab *struct_Table
	var addrTop int32 = 0
	var pWInfo *struct_WhereInfo = nil
	var v *struct_Vdbe
	var pIdx *struct_Index
	var pPk *struct_Index
	var nIdx int32
	var nAllIdx int32
	var iBaseCur int32
	var iDataCur int32
	var iIdxCur int32
	var db *struct_sqlite3
	var aRegIdx *int32 = nil
	var aXRef *int32 = nil
	var aToOpen *uint8
	var chngPk uint8
	var chngRowid uint8
	var chngKey uint8
	var pRowidExpr *struct_Expr = nil
	var iRowidExpr int32 = -1
	var sContext struct_AuthContext
	var sNC struct_NameContext
	var iDb int32
	var eOnePass int32
	var hasFK int32
	var labelBreak int32
	var labelContinue int32
	var flags int32
	var isView int32
	var pTrigger *struct_Trigger
	var tmask int32
	var newmask int32
	var iEph int32 = 0
	var nKey int32 = 0
	var aiCurOnePass [2]int32
	var addrOpen int32 = 0
	var iPk int32 = 0
	var nPk int16 = int16(0)
	var bReplace int32 = 0
	var bFinishSeek int32 = 1
	var nChangeFrom int32 = 0
	var regRowCount int32 = 0
	var regOldRowid int32 = 0
	var regNewRowid int32 = 0
	var regNew int32 = 0
	var regOld int32 = 0
	var regRowSet int32 = 0
	var regKey int32 = 0
	__builtin___memset_chk(unsafe.Pointer(&sContext), 0, 16, __builtin_object_size(unsafe.Pointer(&sContext), 0))
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pParse.nErr != 0 {
		goto update_cleanup
	}
	func() int {
		_ = 0
		return 0
	}()
	pTab = sqlite3SrcListLookup(pParse, pTabList)
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		goto update_cleanup
	}
	iDb = sqlite3SchemaToIndex(pParse.db, pTab.pSchema)
	pTrigger = sqlite3TriggersExist(pParse, pTab, 129, pChanges, &tmask)
	isView = func() int32 {
		if int32(pTab.eTabType) == 2 {
			return 1
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	nChangeFrom = func() int32 {
		if pTabList.nSrc > 1 {
			return pChanges.nExpr
		} else {
			return 0
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3ViewGetColumnNames(pParse, pTab) != 0 {
		goto update_cleanup
	}
	if sqlite3IsReadOnly(pParse, pTab, tmask) != 0 {
		goto update_cleanup
	}
	iBaseCur = func() (_cgo_ret int32) {
		_cgo_addr := &iDataCur
		*_cgo_addr = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		return *_cgo_addr
	}()
	iIdxCur = iDataCur + 1
	pPk = func() *struct_Index {
		if pTab.tabFlags&uint32(128) == uint32(0) {
			return nil
		} else {
			return sqlite3PrimaryKeyIndex(pTab)
		}
	}()
	for func() *struct_Index {
		nIdx = int32(0)
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pTab.pIndex
			return *_cgo_addr
		}()
	}(); pIdx != nil; func() int32 {
		pIdx = pIdx.pNext
		return func() (_cgo_ret int32) {
			_cgo_addr := &nIdx
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		if uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(pIdx)) {
			iDataCur = pParse.nTab
		}
		pParse.nTab++
	}
	if pUpsert != nil {
		iDataCur = pUpsert.iDataCur
		iIdxCur = pUpsert.iIdxCur
		pParse.nTab = iBaseCur
	}
	(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).iCursor = iDataCur
	aXRef = (*int32)(sqlite3DbMallocRawNN(db, uint64(4*uint(int32(pTab.nCol)+nIdx+1)+uint(nIdx)+uint(2))))
	if uintptr(unsafe.Pointer(aXRef)) == uintptr(unsafe.Pointer(nil)) {
		goto update_cleanup
	}
	aRegIdx = (*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(int32(pTab.nCol))*4))
	aToOpen = (*uint8)(unsafe.Pointer((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx))+uintptr(nIdx)*4)))) + uintptr(1)*4))))
	__builtin___memset_chk(unsafe.Pointer(aToOpen), 1, uint(nIdx+1), __builtin_object_size(unsafe.Pointer(aToOpen), 0))
	*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(nIdx+1))) = uint8(0)
	for i = int32(0); i < int32(pTab.nCol); i++ {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)) = int32(-1)
	}
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	sNC.pParse = pParse
	sNC.pSrcList = pTabList
	*(**struct_Upsert)(unsafe.Pointer(&sNC.uNC)) = pUpsert
	sNC.ncFlags = int32(512)
	v = sqlite3GetVdbe(pParse)
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		goto update_cleanup
	}
	chngRowid = func() (_cgo_ret uint8) {
		_cgo_addr := &chngPk
		*_cgo_addr = uint8(0)
		return *_cgo_addr
	}()
	for i = int32(0); i < pChanges.nExpr; i++ {
		var hCol uint8 = sqlite3StrIHash((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).zEName)
		if nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).pExpr) != 0 {
			goto update_cleanup
		}
		for j = int32(0); j < int32(pTab.nCol); j++ {
			if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).hName) == int32(hCol) && sqlite3StrICmp((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).zEName) == 0 {
				if j == int32(pTab.iPKey) {
					chngRowid = uint8(1)
					pRowidExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).pExpr
					iRowidExpr = i
				} else if pPk != nil && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).colFlags)&1 != 0 {
					chngPk = uint8(1)
				} else if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).colFlags)&96 != 0 {
					sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[36]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'U', 'P', 'D', 'A', 'T', 'E', ' ', 'g', 'e', 'n', 'e', 'r', 'a', 't', 'e', 'd', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', '"', '%', 's', '"', '\x00'})), (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName)
					goto update_cleanup
				}
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(j)*4)) = i
				break
			}
		}
		if j >= int32(pTab.nCol) {
			if uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(nil)) && sqlite3IsRowid((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).zEName) != 0 {
				j = int32(-1)
				chngRowid = uint8(1)
				pRowidExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).pExpr
				iRowidExpr = i
			} else {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[19]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ':', ' ', '%', 's', '\x00'})), (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(i)*28))).zEName)
				pParse.checkSchema = uint8(1)
				goto update_cleanup
			}
		}
		{
			var rc int32
			rc = sqlite3AuthCheck(pParse, 23, pTab.zName, func() *int8 {
				if j < 0 {
					return (*int8)(unsafe.Pointer(&[6]int8{'R', 'O', 'W', 'I', 'D', '\x00'}))
				} else {
					return (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(j)*20))).zCnName
				}
			}(), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName)
			if rc == 1 {
				goto update_cleanup
			} else if rc == 2 {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(j)*4)) = int32(-1)
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	chngKey = uint8(int32(chngRowid) + int32(chngPk))
	if pTab.tabFlags&uint32(96) != 0 {
		var bProgress int32
		for {
			bProgress = int32(0)
			for i = int32(0); i < int32(pTab.nCol); i++ {
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)) >= 0 {
					continue
				}
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&96 == 0 {
					continue
				}
				if sqlite3ExprReferencesUpdatedColumn(sqlite3ColumnExpr(pTab, &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))), aXRef, int32(chngRowid)) != 0 {
					*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)) = int32(99999)
					bProgress = int32(1)
				}
			}
			if !(bProgress != 0) {
				break
			}
		}
	}
	(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).colUsed = func() uint64 {
		if int32(pTab.eTabType) == 1 {
			return uint64(18446744073709551615)
		} else {
			return uint64(0)
		}
	}()
	hasFK = sqlite3FkRequired(pParse, pTab, aXRef, int32(chngKey))
	if onError == 5 {
		bReplace = int32(1)
	}
	for func() *struct_Index {
		nAllIdx = int32(0)
		return func() (_cgo_ret *struct_Index) {
			_cgo_addr := &pIdx
			*_cgo_addr = pTab.pIndex
			return *_cgo_addr
		}()
	}(); pIdx != nil; func() int32 {
		pIdx = pIdx.pNext
		return func() (_cgo_ret int32) {
			_cgo_addr := &nAllIdx
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		var reg int32
		if int32(chngKey) != 0 || hasFK > 1 || uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(pPk)) || indexWhereClauseMightChange(pIdx, aXRef, int32(chngRowid)) != 0 {
			reg = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			pParse.nMem += int32(pIdx.nColumn)
		} else {
			reg = int32(0)
			for i = int32(0); i < int32(pIdx.nKeyCol); i++ {
				if indexColumnIsBeingUpdated(pIdx, i, aXRef, int32(chngRowid)) != 0 {
					reg = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nMem
						*_cgo_addr++
						return *_cgo_addr
					}()
					pParse.nMem += int32(pIdx.nColumn)
					if onError == 11 && int32(pIdx.onError) == 5 {
						bReplace = int32(1)
					}
					break
				}
			}
		}
		if reg == 0 {
			*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(nAllIdx+1))) = uint8(0)
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(nAllIdx)*4)) = reg
	}
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(nAllIdx)*4)) = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	if bReplace != 0 {
		__builtin___memset_chk(unsafe.Pointer(aToOpen), 1, uint(nIdx+1), __builtin_object_size(unsafe.Pointer(aToOpen), 0))
	}
	if int32(pParse.nested) == 0 {
		sqlite3VdbeCountChanges(v)
	}
	sqlite3BeginWriteOperation(pParse, func() int32 {
		if pTrigger != nil || hasFK != 0 {
			return 1
		} else {
			return 0
		}
	}(), iDb)
	if !(int32(pTab.eTabType) == 1) {
		func() int {
			_ = 0
			return 0
		}()
		regRowSet = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(nAllIdx)*4))
		regOldRowid = func() (_cgo_ret int32) {
			_cgo_addr := &regNewRowid
			*_cgo_addr = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			return *_cgo_addr
		}()
		if int32(chngPk) != 0 || pTrigger != nil || hasFK != 0 {
			regOld = pParse.nMem + 1
			pParse.nMem += int32(pTab.nCol)
		}
		if int32(chngKey) != 0 || pTrigger != nil || hasFK != 0 {
			regNewRowid = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
		}
		regNew = pParse.nMem + 1
		pParse.nMem += int32(pTab.nCol)
	}
	if isView != 0 {
		sqlite3AuthContextPush(pParse, &sContext, pTab.zName)
	}
	if nChangeFrom == 0 && isView != 0 {
		sqlite3MaterializeView(pParse, pTab, pWhere, pOrderBy, pLimit, iDataCur)
		pOrderBy = (*struct_ExprList)(nil)
		pLimit = (*struct_Expr)(nil)
	}
	if nChangeFrom == 0 && sqlite3ResolveExprNames(&sNC, pWhere) != 0 {
		goto update_cleanup
	}
	if int32(pTab.eTabType) == 1 {
		updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef, pWhere, onError)
		goto update_cleanup
	}
	labelContinue = func() (_cgo_ret int32) {
		_cgo_addr := &labelBreak
		*_cgo_addr = sqlite3VdbeMakeLabel(pParse)
		return *_cgo_addr
	}()
	if db.flags&(uint64(1)<<32) != uint64(0) && !(pParse.pTriggerTab != nil) && !(pParse.nested != 0) && !(pParse.bReturning != 0) && uintptr(unsafe.Pointer(pUpsert)) == uintptr(unsafe.Pointer(nil)) {
		regRowCount = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 71, 0, regRowCount)
	}
	if nChangeFrom == 0 && pTab.tabFlags&uint32(128) == uint32(0) {
		sqlite3VdbeAddOp3(v, 74, 0, regRowSet, regOldRowid)
		iEph = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		addrOpen = sqlite3VdbeAddOp3(v, 116, iEph, 0, regRowSet)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		nPk = int16(func() int32 {
			if pPk != nil {
				return int32(pPk.nKeyCol)
			} else {
				return 0
			}
		}())
		iPk = pParse.nMem + 1
		pParse.nMem += int32(nPk)
		pParse.nMem += nChangeFrom
		regKey = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		if uintptr(unsafe.Pointer(pUpsert)) == uintptr(unsafe.Pointer(nil)) {
			var nEphCol int32 = int32(nPk) + nChangeFrom + func() int32 {
				if isView != 0 {
					return int32(pTab.nCol)
				} else {
					return 0
				}
			}()
			iEph = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			if pPk != nil {
				sqlite3VdbeAddOp3(v, 74, 0, iPk, iPk+int32(nPk)-1)
			}
			addrOpen = sqlite3VdbeAddOp2(v, 116, iEph, nEphCol)
			if pPk != nil {
				var pKeyInfo *struct_KeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk)
				if pKeyInfo != nil {
					pKeyInfo.nAllField = uint16(nEphCol)
					sqlite3VdbeAppendP4(v, unsafe.Pointer(pKeyInfo), -9)
				}
			}
			if nChangeFrom != 0 {
				updateFromSelect(pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit)
				if isView != 0 {
					iDataCur = iEph
				}
			}
		}
	}
	if nChangeFrom != 0 {
		sqlite3MultiWrite(pParse)
		eOnePass = int32(0)
		nKey = int32(nPk)
		regKey = iPk
	} else {
		if pUpsert != nil {
			pWInfo = (*struct_WhereInfo)(nil)
			eOnePass = int32(1)
			sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 16)
			bFinishSeek = int32(0)
		} else {
			flags = int32(4)
			if !(pParse.nested != 0) && !(pTrigger != nil) && !(hasFK != 0) && !(chngKey != 0) && !(bReplace != 0) {
				flags |= int32(8)
			}
			pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, nil, nil, nil, uint16(flags), iIdxCur)
			if uintptr(unsafe.Pointer(pWInfo)) == uintptr(unsafe.Pointer(nil)) {
				goto update_cleanup
			}
			eOnePass = sqlite3WhereOkOnePass(pWInfo, (*int32)(unsafe.Pointer(&aiCurOnePass)))
			bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo)
			if eOnePass != 1 {
				sqlite3MultiWrite(pParse)
				if eOnePass == 2 {
					var iCur int32 = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4))
					if iCur >= 0 && iCur != iDataCur && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(iCur-iBaseCur)))) != 0 {
						eOnePass = int32(0)
					}
					func() int {
						_ = 0
						return 0
					}()
				}
			}
		}
		if pTab.tabFlags&uint32(128) == uint32(0) {
			sqlite3VdbeAddOp2(v, 134, iDataCur, regOldRowid)
			if eOnePass == 0 {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aRegIdx)) + uintptr(nAllIdx)*4)) = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
				sqlite3VdbeAddOp3(v, 127, iEph, regRowSet, regOldRowid)
			} else if addrOpen != 0 {
				sqlite3VdbeChangeToNoop(v, addrOpen)
			}
		} else {
			for i = int32(0); i < int32(nPk); i++ {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))), iPk+i)
			}
			if eOnePass != 0 {
				if addrOpen != 0 {
					sqlite3VdbeChangeToNoop(v, addrOpen)
				}
				nKey = int32(nPk)
				regKey = iPk
			} else {
				sqlite3VdbeAddOp4(v, 96, iPk, int32(nPk), regKey, sqlite3IndexAffinityStr(db, pPk), int32(nPk))
				sqlite3VdbeAddOp4Int(v, 137, iEph, regKey, iPk, int32(nPk))
			}
		}
	}
	if uintptr(unsafe.Pointer(pUpsert)) == uintptr(unsafe.Pointer(nil)) {
		if nChangeFrom == 0 && eOnePass != 2 {
			sqlite3WhereEnd(pWInfo)
		}
		if !(isView != 0) {
			var addrOnce int32 = 0
			if eOnePass != 0 {
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(0)*4)) >= 0 {
					*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(0)*4))-iBaseCur))) = uint8(0)
				}
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4)) >= 0 {
					*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(aToOpen)) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4))-iBaseCur))) = uint8(0)
				}
			}
			if eOnePass == 2 && nIdx-func() int32 {
				if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4)) >= 0 {
					return 1
				} else {
					return 0
				}
			}() > 0 {
				addrOnce = sqlite3VdbeAddOp0(v, 17)
			}
			sqlite3OpenTableAndIndices(pParse, pTab, 112, uint8(0), iBaseCur, aToOpen, nil, nil)
			if addrOnce != 0 {
				sqlite3VdbeJumpHereOrPopInst(v, addrOnce)
			}
		}
		if eOnePass != 0 {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(0)*4)) != iDataCur && *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurOnePass)))) + uintptr(1)*4)) != iDataCur {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp4Int(v, 30, iDataCur, labelBreak, regKey, nKey)
			}
			if eOnePass != 1 {
				labelContinue = sqlite3VdbeMakeLabel(pParse)
			}
			sqlite3VdbeAddOp2(v, 50, func() int32 {
				if pPk != nil {
					return regKey
				} else {
					return regOldRowid
				}
			}(), labelBreak)
		} else if pPk != nil || nChangeFrom != 0 {
			labelContinue = sqlite3VdbeMakeLabel(pParse)
			sqlite3VdbeAddOp2(v, 38, iEph, labelBreak)
			addrTop = sqlite3VdbeCurrentAddr(v)
			if nChangeFrom != 0 {
				if !(isView != 0) {
					if pPk != nil {
						for i = int32(0); i < int32(nPk); i++ {
							sqlite3VdbeAddOp3(v, 93, iEph, i, iPk+i)
						}
						sqlite3VdbeAddOp4Int(v, 30, iDataCur, labelContinue, iPk, int32(nPk))
					} else {
						sqlite3VdbeAddOp2(v, 134, iEph, regOldRowid)
						sqlite3VdbeAddOp3(v, 33, iDataCur, labelContinue, regOldRowid)
					}
				}
			} else {
				sqlite3VdbeAddOp2(v, 133, iEph, regKey)
				sqlite3VdbeAddOp4Int(v, 30, iDataCur, labelContinue, regKey, 0)
			}
		} else {
			sqlite3VdbeAddOp2(v, 38, iEph, labelBreak)
			labelContinue = sqlite3VdbeMakeLabel(pParse)
			addrTop = sqlite3VdbeAddOp2(v, 134, iEph, regOldRowid)
			sqlite3VdbeAddOp3(v, 33, iDataCur, labelContinue, regOldRowid)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if chngRowid != 0 {
		func() int {
			_ = 0
			return 0
		}()
		if nChangeFrom == 0 {
			sqlite3ExprCode(pParse, pRowidExpr, regNewRowid)
		} else {
			sqlite3VdbeAddOp3(v, 93, iEph, iRowidExpr, regNewRowid)
		}
		sqlite3VdbeAddOp1(v, 15, regNewRowid)
	}
	if int32(chngPk) != 0 || hasFK != 0 || pTrigger != nil {
		var oldmask uint32 = func() uint32 {
			if hasFK != 0 {
				return sqlite3FkOldmask(pParse, pTab)
			} else {
				return uint32(0)
			}
		}()
		oldmask |= sqlite3TriggerColmask(pParse, pTrigger, pChanges, 0, 1|2, pTab, onError)
		for i = int32(0); i < int32(pTab.nCol); i++ {
			var colFlags uint32 = uint32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)
			k = int32(sqlite3TableColumnToStorage(pTab, int16(i))) + regOld
			if oldmask == 4294967295 || i < 32 && oldmask&(uint32(1)<<i) != uint32(0) || colFlags&uint32(1) != uint32(0) {
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k)
			} else {
				sqlite3VdbeAddOp2(v, 74, 0, k)
			}
		}
		if int32(chngRowid) == 0 && uintptr(unsafe.Pointer(pPk)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3VdbeAddOp2(v, 79, regOldRowid, regNewRowid)
		}
	}
	newmask = int32(sqlite3TriggerColmask(pParse, pTrigger, pChanges, 1, 1, pTab, onError))
	for func() int32 {
		i = int32(0)
		return func() (_cgo_ret int32) {
			_cgo_addr := &k
			*_cgo_addr = regNew
			return *_cgo_addr
		}()
	}(); i < int32(pTab.nCol); func() int32 {
		i++
		return func() (_cgo_ret int32) {
			_cgo_addr := &k
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		if i == int32(pTab.iPKey) {
			sqlite3VdbeAddOp2(v, 74, 0, k)
		} else if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&96 != 0 {
			if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 != 0 {
				k--
			}
		} else {
			j = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4))
			if j >= 0 {
				if nChangeFrom != 0 {
					var nOff int32 = func() int32 {
						if isView != 0 {
							return int32(pTab.nCol)
						} else {
							return int32(nPk)
						}
					}()
					func() int {
						_ = 0
						return 0
					}()
					sqlite3VdbeAddOp3(v, 93, iEph, nOff+j, k)
				} else {
					sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(j)*28))).pExpr, k)
				}
			} else if 0 == tmask&1 || i > 31 || uint32(newmask)&(uint32(1)<<i) != 0 {
				sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k)
				bFinishSeek = int32(0)
			} else {
				sqlite3VdbeAddOp2(v, 74, 0, k)
			}
		}
	}
	if pTab.tabFlags&uint32(96) != 0 {
		sqlite3ComputeGeneratedColumns(pParse, regNew, pTab)
	}
	if tmask&1 != 0 {
		sqlite3TableAffinity(v, pTab, regNew)
		sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 1, pTab, regOldRowid, onError, labelContinue)
		if !(isView != 0) {
			if pPk != nil {
				sqlite3VdbeAddOp4Int(v, 30, iDataCur, labelContinue, regKey, nKey)
			} else {
				sqlite3VdbeAddOp3(v, 33, iDataCur, labelContinue, regOldRowid)
			}
			for func() int32 {
				i = int32(0)
				return func() (_cgo_ret int32) {
					_cgo_addr := &k
					*_cgo_addr = regNew
					return *_cgo_addr
				}()
			}(); i < int32(pTab.nCol); func() int32 {
				i++
				return func() (_cgo_ret int32) {
					_cgo_addr := &k
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
			}() {
				if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&96 != 0 {
					if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).colFlags)&32 != 0 {
						k--
					}
				} else if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)) < 0 && i != int32(pTab.iPKey) {
					sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k)
				}
			}
			if pTab.tabFlags&uint32(96) != 0 {
				sqlite3ComputeGeneratedColumns(pParse, regNew, pTab)
			}
		}
	}
	if !(isView != 0) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur, regNewRowid, regOldRowid, chngKey, uint8(onError), labelContinue, &bReplace, aXRef, nil)
		if bReplace != 0 || int32(chngKey) != 0 {
			if pPk != nil {
				sqlite3VdbeAddOp4Int(v, 30, iDataCur, labelContinue, regKey, nKey)
			} else {
				sqlite3VdbeAddOp3(v, 33, iDataCur, labelContinue, regOldRowid)
			}
		}
		if hasFK != 0 {
			sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, int32(chngKey))
		}
		sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1)
		if bFinishSeek != 0 {
			sqlite3VdbeAddOp1(v, 142, iDataCur)
		}
		func() int {
			_ = 0
			return 0
		}()
		if hasFK > 1 || int32(chngKey) != 0 {
			sqlite3VdbeAddOp2(v, 129, iDataCur, 0)
		}
		if hasFK != 0 {
			sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, int32(chngKey))
		}
		sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx, 4|func() int32 {
			if eOnePass == 2 {
				return 2
			} else {
				return 0
			}
		}(), 0, 0)
		if hasFK != 0 {
			sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, int32(chngKey))
		}
	}
	if regRowCount != 0 {
		sqlite3VdbeAddOp2(v, 85, regRowCount, 1)
	}
	sqlite3CodeRowTrigger(pParse, pTrigger, 129, pChanges, 2, pTab, regOldRowid, onError, labelContinue)
	if eOnePass == 1 {
	} else if eOnePass == 2 {
		sqlite3VdbeResolveLabel(v, labelContinue)
		sqlite3WhereEnd(pWInfo)
	} else {
		sqlite3VdbeResolveLabel(v, labelContinue)
		sqlite3VdbeAddOp2(v, 5, iEph, addrTop)
	}
	sqlite3VdbeResolveLabel(v, labelBreak)
	if int32(pParse.nested) == 0 && uintptr(unsafe.Pointer(pParse.pTriggerTab)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pUpsert)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3AutoincrementEnd(pParse)
	}
	if regRowCount != 0 {
		sqlite3CodeChangeCount(v, regRowCount, (*int8)(unsafe.Pointer(&[13]int8{'r', 'o', 'w', 's', ' ', 'u', 'p', 'd', 'a', 't', 'e', 'd', '\x00'})))
	}
update_cleanup:
	sqlite3AuthContextPop(&sContext)
	sqlite3DbFree(db, unsafe.Pointer(aXRef))
	sqlite3SrcListDelete(db, pTabList)
	sqlite3ExprListDelete(db, pChanges)
	sqlite3ExprDelete(db, pWhere)
	return
}
func updateVirtualTable(pParse *struct_Parse, pSrc *struct_SrcList, pTab *struct_Table, pChanges *struct_ExprList, pRowid *struct_Expr, aXRef *int32, pWhere *struct_Expr, onError int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var ephemTab int32
	var i int32
	var db *struct_sqlite3 = pParse.db
	var pVTab *int8 = (*int8)(unsafe.Pointer(sqlite3GetVTable(db, pTab)))
	var pWInfo *struct_WhereInfo = nil
	var nArg int32 = 2 + int32(pTab.nCol)
	var regArg int32
	var regRec int32
	var regRowid int32
	var iCsr int32 = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(0)*112))).iCursor
	var aDummy [2]int32
	var eOnePass int32
	var addr int32
	func() int {
		_ = 0
		return 0
	}()
	ephemTab = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	addr = sqlite3VdbeAddOp2(v, 116, ephemTab, nArg)
	regArg = pParse.nMem + 1
	pParse.nMem += nArg
	if pSrc.nSrc > 1 {
		var pPk *struct_Index = nil
		var pRow *struct_Expr
		var pList *struct_ExprList
		if pTab.tabFlags&uint32(128) == uint32(0) {
			if pRowid != nil {
				pRow = sqlite3ExprDup(db, pRowid, 0)
			} else {
				pRow = sqlite3PExpr(pParse, 75, nil, nil)
			}
		} else {
			var iPk int16
			pPk = sqlite3PrimaryKeyIndex(pTab)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			iPk = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(0)*2))
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(iPk)*4)) >= 0 {
				pRow = sqlite3ExprDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(iPk)*4)))*28))).pExpr, 0)
			} else {
				pRow = exprRowColumn(pParse, int32(iPk))
			}
		}
		pList = sqlite3ExprListAppend(pParse, nil, pRow)
		for i = int32(0); i < int32(pTab.nCol); i++ {
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)) >= 0 {
				pList = sqlite3ExprListAppend(pParse, pList, sqlite3ExprDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)))*28))).pExpr, 0))
			} else {
				pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i))
			}
		}
		updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, nil, nil)
		sqlite3ExprListDelete(db, pList)
		eOnePass = int32(0)
	} else {
		regRec = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		regRowid = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, nil, nil, nil, uint16(4), 0)
		if uintptr(unsafe.Pointer(pWInfo)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		for i = int32(0); i < int32(pTab.nCol); i++ {
			func() int {
				_ = 0
				return 0
			}()
			if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)) >= 0 {
				sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pChanges.a)))) + uintptr(*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aXRef)) + uintptr(i)*4)))*28))).pExpr, regArg+2+i)
			} else {
				sqlite3VdbeAddOp3(v, 174, iCsr, i, regArg+2+i)
				sqlite3VdbeChangeP5(v, uint16(1))
			}
		}
		if pTab.tabFlags&uint32(128) == uint32(0) {
			sqlite3VdbeAddOp2(v, 134, iCsr, regArg)
			if pRowid != nil {
				sqlite3ExprCode(pParse, pRowid, regArg+1)
			} else {
				sqlite3VdbeAddOp2(v, 134, iCsr, regArg+1)
			}
		} else {
			var pPk *struct_Index
			var iPk int16
			pPk = sqlite3PrimaryKeyIndex(pTab)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			iPk = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(0)*2))
			sqlite3VdbeAddOp3(v, 174, iCsr, int32(iPk), regArg)
			sqlite3VdbeAddOp2(v, 80, regArg+2+int32(iPk), regArg+1)
		}
		eOnePass = sqlite3WhereOkOnePass(pWInfo, (*int32)(unsafe.Pointer(&aDummy)))
		func() int {
			_ = 0
			return 0
		}()
		if eOnePass != 0 {
			sqlite3VdbeChangeToNoop(v, addr)
			sqlite3VdbeAddOp1(v, 121, iCsr)
		} else {
			sqlite3MultiWrite(pParse)
			sqlite3VdbeAddOp3(v, 96, regArg, nArg, regRec)
			sqlite3VdbeAddOp2(v, 126, ephemTab, regRowid)
			sqlite3VdbeAddOp3(v, 127, ephemTab, regRec, regRowid)
		}
	}
	if eOnePass == 0 {
		if pSrc.nSrc == 1 {
			sqlite3WhereEnd(pWInfo)
		}
		addr = sqlite3VdbeAddOp1(v, 38, ephemTab)
		for i = int32(0); i < nArg; i++ {
			sqlite3VdbeAddOp3(v, 93, ephemTab, i, regArg+i)
		}
	}
	sqlite3VtabMakeWritable(pParse, pTab)
	sqlite3VdbeAddOp4(v, 10, 0, nArg, regArg, pVTab, -12)
	sqlite3VdbeChangeP5(v, uint16(func() int32 {
		if onError == 11 {
			return 2
		} else {
			return onError
		}
	}()))
	sqlite3MayAbort(pParse)
	if eOnePass == 0 {
		sqlite3VdbeAddOp2(v, 5, ephemTab, addr+1)
		sqlite3VdbeJumpHere(v, addr)
		sqlite3VdbeAddOp2(v, 121, ephemTab, 0)
	} else {
		sqlite3WhereEnd(pWInfo)
	}
}
func upsertDelete(db *struct_sqlite3, p *struct_Upsert) {
	for {
		var pNext *struct_Upsert = p.pNextUpsert
		sqlite3ExprListDelete(db, p.pUpsertTarget)
		sqlite3ExprDelete(db, p.pUpsertTargetWhere)
		sqlite3ExprListDelete(db, p.pUpsertSet)
		sqlite3ExprDelete(db, p.pUpsertWhere)
		sqlite3DbFree(db, p.pToFree)
		sqlite3DbFree(db, unsafe.Pointer(p))
		p = pNext
		if !(p != nil) {
			break
		}
	}
}
func sqlite3UpsertDelete(db *struct_sqlite3, p *struct_Upsert) {
	if p != nil {
		upsertDelete(db, p)
	}
}
func sqlite3UpsertDup(db *struct_sqlite3, p *struct_Upsert) *struct_Upsert {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_Upsert)(nil)
	}
	return sqlite3UpsertNew(db, sqlite3ExprListDup(db, p.pUpsertTarget, 0), sqlite3ExprDup(db, p.pUpsertTargetWhere, 0), sqlite3ExprListDup(db, p.pUpsertSet, 0), sqlite3ExprDup(db, p.pUpsertWhere, 0), sqlite3UpsertDup(db, p.pNextUpsert))
}
func sqlite3UpsertNew(db *struct_sqlite3, pTarget *struct_ExprList, pTargetWhere *struct_Expr, pSet *struct_ExprList, pWhere *struct_Expr, pNext *struct_Upsert) *struct_Upsert {
	var pNew *struct_Upsert
	pNew = (*struct_Upsert)(sqlite3DbMallocZero(db, uint64(84)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ExprListDelete(db, pTarget)
		sqlite3ExprDelete(db, pTargetWhere)
		sqlite3ExprListDelete(db, pSet)
		sqlite3ExprDelete(db, pWhere)
		sqlite3UpsertDelete(db, pNext)
		return (*struct_Upsert)(nil)
	} else {
		pNew.pUpsertTarget = pTarget
		pNew.pUpsertTargetWhere = pTargetWhere
		pNew.pUpsertSet = pSet
		pNew.pUpsertWhere = pWhere
		pNew.isDoUpdate = func() uint8 {
			if uintptr(unsafe.Pointer(pSet)) != uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}()
		pNew.pNextUpsert = pNext
	}
	return pNew
}
func sqlite3UpsertAnalyzeTarget(pParse *struct_Parse, pTabList *struct_SrcList, pUpsert *struct_Upsert) int32 {
	var pTab *struct_Table
	var rc int32
	var iCursor int32
	var pIdx *struct_Index
	var pTarget *struct_ExprList
	var pTerm *struct_Expr
	var sNC struct_NameContext
	var sCol [2]struct_Expr
	var nClause int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&sNC), 0, 56, __builtin_object_size(unsafe.Pointer(&sNC), 0))
	sNC.pParse = pParse
	sNC.pSrcList = pTabList
	for ; pUpsert != nil && pUpsert.pUpsertTarget != nil; func() int32 {
		pUpsert = pUpsert.pNextUpsert
		return func() (_cgo_ret int32) {
			_cgo_addr := &nClause
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		rc = sqlite3ResolveExprListNames(&sNC, pUpsert.pUpsertTarget)
		if rc != 0 {
			return rc
		}
		rc = sqlite3ResolveExprNames(&sNC, pUpsert.pUpsertTargetWhere)
		if rc != 0 {
			return rc
		}
		pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).pTab
		pTarget = pUpsert.pUpsertTarget
		iCursor = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).iCursor
		if pTab.tabFlags&uint32(128) == uint32(0) && pTarget.nExpr == 1 && int32(func() (_cgo_ret *struct_Expr) {
			_cgo_addr := &pTerm
			*_cgo_addr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pTarget.a)))) + uintptr(0)*28))).pExpr
			return *_cgo_addr
		}().op) == 167 && int32(pTerm.iColumn) == -1 {
			func() int {
				_ = 0
				return 0
			}()
			continue
		}
		__builtin___memset_chk(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol))), 0, 144, __builtin_object_size(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol))), 0))
		(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))).op = uint8(113)
		(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))).pLeft = &*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(1)*72))
		(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(1)*72))).op = uint8(167)
		(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(1)*72))).iTable = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).iCursor
		for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			var ii int32
			var jj int32
			var nn int32
			if !(int32(pIdx.onError) != 0) {
				continue
			}
			if pTarget.nExpr != int32(pIdx.nKeyCol) {
				continue
			}
			if pIdx.pPartIdxWhere != nil {
				if uintptr(unsafe.Pointer(pUpsert.pUpsertTargetWhere)) == uintptr(unsafe.Pointer(nil)) {
					continue
				}
				if sqlite3ExprCompare(pParse, pUpsert.pUpsertTargetWhere, pIdx.pPartIdxWhere, iCursor) != 0 {
					continue
				}
			}
			nn = int32(pIdx.nKeyCol)
			for ii = int32(0); ii < nn; ii++ {
				var pExpr *struct_Expr
				(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))).u.zToken = (*int8)(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(ii)*8))))
				if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(ii)*2))) == -2 {
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					pExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(ii)*28))).pExpr
					if int32(pExpr.op) != 113 {
						(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))).pLeft = pExpr
						pExpr = &*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))
					}
				} else {
					(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))).pLeft = &*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(1)*72))
					(*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(1)*72))).iColumn = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(ii)*2))
					pExpr = &*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Expr)(unsafe.Pointer(&sCol)))) + uintptr(0)*72))
				}
				for jj = int32(0); jj < nn; jj++ {
					if sqlite3ExprCompare(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pTarget.a)))) + uintptr(jj)*28))).pExpr, pExpr, iCursor) < 2 {
						break
					}
				}
				if jj >= nn {
					break
				}
			}
			if ii < nn {
				continue
			}
			pUpsert.pUpsertIdx = pIdx
			break
		}
		if uintptr(unsafe.Pointer(pUpsert.pUpsertIdx)) == uintptr(unsafe.Pointer(nil)) {
			var zWhich [16]int8
			if nClause == 0 && uintptr(unsafe.Pointer(pUpsert.pNextUpsert)) == uintptr(unsafe.Pointer(nil)) {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zWhich)))) + uintptr(0))) = int8(0)
			} else {
				sqlite3_snprintf(int32(16), (*int8)(unsafe.Pointer(&zWhich)), (*int8)(unsafe.Pointer(&[4]int8{'%', 'r', ' ', '\x00'})), nClause+1)
			}
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[73]int8{'%', 's', 'O', 'N', ' ', 'C', 'O', 'N', 'F', 'L', 'I', 'C', 'T', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'd', 'o', 'e', 's', ' ', 'n', 'o', 't', ' ', 'm', 'a', 't', 'c', 'h', ' ', 'a', 'n', 'y', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', ' ', 'o', 'r', ' ', 'U', 'N', 'I', 'Q', 'U', 'E', ' ', 'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', '\x00'})), (*int8)(unsafe.Pointer(&zWhich)))
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3UpsertNextIsIPK(pUpsert *struct_Upsert) int32 {
	var pNext *struct_Upsert
	if uintptr(unsafe.Pointer(pUpsert)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	pNext = pUpsert.pNextUpsert
	if uintptr(unsafe.Pointer(pNext)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	if uintptr(unsafe.Pointer(pNext.pUpsertTarget)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	if uintptr(unsafe.Pointer(pNext.pUpsertIdx)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	return int32(0)
}
func sqlite3UpsertOfIndex(pUpsert *struct_Upsert, pIdx *struct_Index) *struct_Upsert {
	for pUpsert != nil && uintptr(unsafe.Pointer(pUpsert.pUpsertTarget)) != uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pUpsert.pUpsertIdx)) != uintptr(unsafe.Pointer(pIdx)) {
		pUpsert = pUpsert.pNextUpsert
	}
	return pUpsert
}
func sqlite3UpsertDoUpdate(pParse *struct_Parse, pUpsert *struct_Upsert, pTab *struct_Table, pIdx *struct_Index, iCur int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var db *struct_sqlite3 = pParse.db
	var pSrc *struct_SrcList
	var iDataCur int32
	var i int32
	var pTop *struct_Upsert = pUpsert
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	iDataCur = pUpsert.iDataCur
	pUpsert = sqlite3UpsertOfIndex(pTop, pIdx)
	if pIdx != nil && iCur != iDataCur {
		if pTab.tabFlags&uint32(128) == uint32(0) {
			var regRowid int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp2(v, 141, iCur, regRowid)
			sqlite3VdbeAddOp3(v, 32, iDataCur, 0, regRowid)
			sqlite3ReleaseTempReg(pParse, regRowid)
		} else {
			var pPk *struct_Index = sqlite3PrimaryKeyIndex(pTab)
			var nPk int32 = int32(pPk.nKeyCol)
			var iPk int32 = pParse.nMem + 1
			pParse.nMem += nPk
			for i = int32(0); i < nPk; i++ {
				var k int32
				func() int {
					_ = 0
					return 0
				}()
				k = int32(sqlite3TableColumnToIndex(pIdx, *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(i)*2))))
				sqlite3VdbeAddOp3(v, 93, iCur, k, iPk+i)
			}
			i = sqlite3VdbeAddOp4Int(v, 31, iDataCur, 0, iPk, nPk)
			sqlite3VdbeAddOp4(v, 70, 11, 2, 0, (*int8)(unsafe.Pointer(&[17]int8{'c', 'o', 'r', 'r', 'u', 'p', 't', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})), -1)
			sqlite3MayAbort(pParse)
			sqlite3VdbeJumpHere(v, i)
		}
	}
	pSrc = sqlite3SrcListDup(db, pTop.pUpsertSrc, 0)
	for i = int32(0); i < int32(pTab.nCol); i++ {
		if int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(i)*20))).affinity) == 69 {
			sqlite3VdbeAddOp1(v, 86, pTop.regData+i)
		}
	}
	sqlite3Update(pParse, pSrc, sqlite3ExprListDup(db, pUpsert.pUpsertSet, 0), sqlite3ExprDup(db, pUpsert.pUpsertWhere, 0), 2, nil, nil, pUpsert)
}
func execSql(db *struct_sqlite3, pzErrMsg **int8, zSql *int8) int32 {
	var pStmt *struct_sqlite3_stmt
	var rc int32
	rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, nil)
	if rc != 0 {
		return rc
	}
	for 100 == func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = sqlite3_step(pStmt)
		return *_cgo_addr
	}() {
		var zSubSql *int8 = (*int8)(unsafe.Pointer(sqlite3_column_text(pStmt, 0)))
		func() int {
			_ = 0
			return 0
		}()
		if zSubSql != nil && (strncmp(zSubSql, (*int8)(unsafe.Pointer(&[4]int8{'C', 'R', 'E', '\x00'})), uint(3)) == 0 || strncmp(zSubSql, (*int8)(unsafe.Pointer(&[4]int8{'I', 'N', 'S', '\x00'})), uint(3)) == 0) {
			rc = execSql(db, pzErrMsg, zSubSql)
			if rc != 0 {
				break
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if rc == 101 {
		rc = int32(0)
	}
	if rc != 0 {
		sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db))
	}
	func() int {
		_ = sqlite3_finalize(pStmt)
		return 0
	}()
	return rc
}
func execSqlF(db *struct_sqlite3, pzErrMsg **int8, zSql *int8, __cgo_args ...interface {
}) int32 {
	var z *int8
	var rc int32
	z = sqlite3VMPrintf(db, zSql, __cgo_args...)
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	rc = execSql(db, pzErrMsg, z)
	sqlite3DbFree(db, unsafe.Pointer(z))
	return rc
}
func sqlite3Vacuum(pParse *struct_Parse, pNm *struct_Token, pInto *struct_Expr) {
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var iDb int32 = 0
	if uintptr(unsafe.Pointer(v)) == uintptr(unsafe.Pointer(nil)) {
		goto build_vacuum_end
	}
	if pParse.nErr != 0 {
		goto build_vacuum_end
	}
	if pNm != nil {
		iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm)
		if iDb < 0 {
			goto build_vacuum_end
		}
	}
	if iDb != 1 {
		var iIntoReg int32 = 0
		if pInto != nil && sqlite3ResolveSelfReference(pParse, nil, 0, pInto, nil) == 0 {
			iIntoReg = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3ExprCode(pParse, pInto, iIntoReg)
		}
		sqlite3VdbeAddOp2(v, 8, iDb, iIntoReg)
		sqlite3VdbeUsesBtree(v, iDb)
	}
build_vacuum_end:
	sqlite3ExprDelete(pParse.db, pInto)
	return
}
func sqlite3RunVacuum(pzErrMsg **int8, db *struct_sqlite3, iDb int32, pOut *struct_sqlite3_value) int32 {
	var rc int32 = 0
	var pMain *struct_Btree
	var pTemp *struct_Btree
	var saved_mDbFlags uint32
	var saved_flags uint64
	var saved_nChange int64
	var saved_nTotalChange int64
	var saved_openFlags uint32
	var saved_mTrace uint8
	var pDb *struct_Db = nil
	var isMemDb int32
	var nRes int32
	var nDb int32
	var zDbMain *int8
	var zOut *int8
	if !(db.autoCommit != 0) {
		sqlite3SetString(pzErrMsg, db, (*int8)(unsafe.Pointer(&[40]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'V', 'A', 'C', 'U', 'U', 'M', ' ', 'f', 'r', 'o', 'm', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 'a', ' ', 't', 'r', 'a', 'n', 's', 'a', 'c', 't', 'i', 'o', 'n', '\x00'})))
		return int32(1)
	}
	if db.nVdbeActive > 1 {
		sqlite3SetString(pzErrMsg, db, (*int8)(unsafe.Pointer(&[43]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'V', 'A', 'C', 'U', 'U', 'M', ' ', '-', ' ', 'S', 'Q', 'L', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'i', 'n', ' ', 'p', 'r', 'o', 'g', 'r', 'e', 's', 's', '\x00'})))
		return int32(1)
	}
	saved_openFlags = db.openFlags
	if pOut != nil {
		if sqlite3_value_type(pOut) != 3 {
			sqlite3SetString(pzErrMsg, db, (*int8)(unsafe.Pointer(&[18]int8{'n', 'o', 'n', '-', 't', 'e', 'x', 't', ' ', 'f', 'i', 'l', 'e', 'n', 'a', 'm', 'e', '\x00'})))
			return int32(1)
		}
		zOut = (*int8)(unsafe.Pointer(sqlite3_value_text(pOut)))
		db.openFlags &= uint32(4294967294)
		db.openFlags |= uint32(4 | 2)
	} else {
		zOut = (*int8)(unsafe.Pointer(&[1]int8{'\x00'}))
	}
	saved_flags = db.flags
	saved_mDbFlags = db.mDbFlags
	saved_nChange = db.nChange
	saved_nTotalChange = db.nTotalChange
	saved_mTrace = db.mTrace
	db.flags |= uint64(1 | 512)
	db.mDbFlags |= uint32(2 | 4)
	db.flags &= ^uint64(uint64(16384|4096|268435456) | uint64(1)<<32)
	db.mTrace = uint8(0)
	zDbMain = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	pMain = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt
	isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain))
	nDb = db.nDb
	rc = execSqlF(db, pzErrMsg, (*int8)(unsafe.Pointer(&[23]int8{'A', 'T', 'T', 'A', 'C', 'H', ' ', '%', 'Q', ' ', 'A', 'S', ' ', 'v', 'a', 'c', 'u', 'u', 'm', '_', 'd', 'b', '\x00'})), zOut)
	db.openFlags = saved_openFlags
	if rc != 0 {
		goto end_of_vacuum
	}
	func() int {
		_ = 0
		return 0
	}()
	pDb = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(nDb)*32))
	func() int {
		_ = 0
		return 0
	}()
	pTemp = pDb.pBt
	if pOut != nil {
		var id *struct_sqlite3_file = sqlite3PagerFile(sqlite3BtreePager(pTemp))
		var sz int64 = int64(0)
		if uintptr(unsafe.Pointer(id.pMethods)) != uintptr(unsafe.Pointer(nil)) && (sqlite3OsFileSize(id, &sz) != 0 || sz > int64(0)) {
			rc = int32(1)
			sqlite3SetString(pzErrMsg, db, (*int8)(unsafe.Pointer(&[27]int8{'o', 'u', 't', 'p', 'u', 't', ' ', 'f', 'i', 'l', 'e', ' ', 'a', 'l', 'r', 'e', 'a', 'd', 'y', ' ', 'e', 'x', 'i', 's', 't', 's', '\x00'})))
			goto end_of_vacuum
		}
		db.mDbFlags |= uint32(8)
	}
	nRes = sqlite3BtreeGetRequestedReserve(pMain)
	sqlite3BtreeSetCacheSize(pTemp, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pSchema.cache_size)
	sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain, 0))
	sqlite3BtreeSetPagerFlags(pTemp, uint32(1|32))
	rc = execSql(db, pzErrMsg, (*int8)(unsafe.Pointer(&[6]int8{'B', 'E', 'G', 'I', 'N', '\x00'})))
	if rc != 0 {
		goto end_of_vacuum
	}
	rc = sqlite3BtreeBeginTrans(pMain, func() int32 {
		if uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(nil)) {
			return 2
		} else {
			return 0
		}
	}(), nil)
	if rc != 0 {
		goto end_of_vacuum
	}
	if sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain)) == 5 && uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(nil)) {
		db.nextPagesize = int32(0)
	}
	if sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0) != 0 || !(isMemDb != 0) && sqlite3BtreeSetPageSize(pTemp, db.nextPagesize, nRes, 0) != 0 || int32(db.mallocFailed) != 0 {
		rc = int32(7)
		goto end_of_vacuum
	}
	sqlite3BtreeSetAutoVacuum(pTemp, func() int32 {
		if int32(db.nextAutovac) >= 0 {
			return int32(db.nextAutovac)
		} else {
			return sqlite3BtreeGetAutoVacuum(pMain)
		}
	}())
	db.init.iDb = uint8(nDb)
	rc = execSqlF(db, pzErrMsg, (*int8)(unsafe.Pointer(&[108]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', 's', 'q', 'l', ' ', 'F', 'R', 'O', 'M', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', 'A', 'N', 'D', ' ', 'n', 'a', 'm', 'e', '<', '>', '\'', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', '\'', ' ', 'A', 'N', 'D', ' ', 'c', 'o', 'a', 'l', 'e', 's', 'c', 'e', '(', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', ',', '1', ')', '>', '0', '\x00'})), zDbMain)
	if rc != 0 {
		goto end_of_vacuum
	}
	rc = execSqlF(db, pzErrMsg, (*int8)(unsafe.Pointer(&[54]int8{'S', 'E', 'L', 'E', 'C', 'T', ' ', 's', 'q', 'l', ' ', 'F', 'R', 'O', 'M', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', '=', '\'', 'i', 'n', 'd', 'e', 'x', '\'', '\x00'})), zDbMain)
	if rc != 0 {
		goto end_of_vacuum
	}
	db.init.iDb = uint8(0)
	rc = execSqlF(db, pzErrMsg, (*int8)(unsafe.Pointer(&[151]int8{'S', 'E', 'L', 'E', 'C', 'T', '\'', 'I', 'N', 'S', 'E', 'R', 'T', ' ', 'I', 'N', 'T', 'O', ' ', 'v', 'a', 'c', 'u', 'u', 'm', '_', 'd', 'b', '.', '\'', '|', '|', 'q', 'u', 'o', 't', 'e', '(', 'n', 'a', 'm', 'e', ')', '|', '|', '\'', ' ', 'S', 'E', 'L', 'E', 'C', 'T', '*', 'F', 'R', 'O', 'M', '"', '%', 'w', '"', '.', '\'', '|', '|', 'q', 'u', 'o', 't', 'e', '(', 'n', 'a', 'm', 'e', ')', 'F', 'R', 'O', 'M', ' ', 'v', 'a', 'c', 'u', 'u', 'm', '_', 'd', 'b', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', 'A', 'N', 'D', ' ', 'c', 'o', 'a', 'l', 'e', 's', 'c', 'e', '(', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', ',', '1', ')', '>', '0', '\x00'})), zDbMain)
	func() int {
		_ = 0
		return 0
	}()
	db.mDbFlags &= uint32(4294967291)
	if rc != 0 {
		goto end_of_vacuum
	}
	rc = execSqlF(db, pzErrMsg, (*int8)(unsafe.Pointer(&[130]int8{'I', 'N', 'S', 'E', 'R', 'T', ' ', 'I', 'N', 'T', 'O', ' ', 'v', 'a', 'c', 'u', 'u', 'm', '_', 'd', 'b', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'S', 'E', 'L', 'E', 'C', 'T', '*', 'F', 'R', 'O', 'M', ' ', '"', '%', 'w', '"', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 't', 'y', 'p', 'e', ' ', 'I', 'N', '(', '\'', 'v', 'i', 'e', 'w', '\'', ',', '\'', 't', 'r', 'i', 'g', 'g', 'e', 'r', '\'', ')', ' ', 'O', 'R', '(', 't', 'y', 'p', 'e', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', 'A', 'N', 'D', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '=', '0', ')', '\x00'})), zDbMain)
	if rc != 0 {
		goto end_of_vacuum
	}
	{
		var meta uint32
		var i int32
		var aCopy [10]uint8 = [10]uint8{uint8(1), uint8(1), uint8(3), uint8(0), uint8(5), uint8(0), uint8(6), uint8(0), uint8(8), uint8(0)}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		for i = int32(0); i < int32(10/1); i += int32(2) {
			sqlite3BtreeGetMeta(pMain, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCopy)))) + uintptr(i)))), &meta)
			rc = sqlite3BtreeUpdateMeta(pTemp, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCopy)))) + uintptr(i)))), meta+uint32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aCopy)))) + uintptr(i+1)))))
			if rc != 0 {
				goto end_of_vacuum
			}
		}
		if uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(nil)) {
			rc = sqlite3BtreeCopyFile(pMain, pTemp)
		}
		if rc != 0 {
			goto end_of_vacuum
		}
		rc = sqlite3BtreeCommit(pTemp)
		if rc != 0 {
			goto end_of_vacuum
		}
		if uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp))
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pOut)) == uintptr(unsafe.Pointer(nil)) {
		rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes, 1)
	}
end_of_vacuum:
	db.init.iDb = uint8(0)
	db.mDbFlags = saved_mDbFlags
	db.flags = saved_flags
	db.nChange = saved_nChange
	db.nTotalChange = saved_nTotalChange
	db.mTrace = saved_mTrace
	sqlite3BtreeSetPageSize(pMain, -1, 0, 1)
	db.autoCommit = uint8(1)
	if pDb != nil {
		sqlite3BtreeClose(pDb.pBt)
		pDb.pBt = (*struct_Btree)(nil)
		pDb.pSchema = (*struct_Schema)(nil)
	}
	sqlite3ResetAllSchemasOfConnection(db)
	return rc
}

type struct_VtabCtx struct {
	pVTable   *struct_VTable
	pTab      *struct_Table
	pPrior    *struct_VtabCtx
	bDeclared int32
}

func sqlite3VtabCreateModule(db *struct_sqlite3, zName *int8, pModule *struct_sqlite3_module, pAux unsafe.Pointer, xDestroy func(unsafe.Pointer)) *struct_Module {
	var pMod *struct_Module
	var pDel *struct_Module
	var zCopy *int8
	if uintptr(unsafe.Pointer(pModule)) == uintptr(unsafe.Pointer(nil)) {
		zCopy = (*int8)(unsafe.Pointer(zName))
		pMod = (*struct_Module)(nil)
	} else {
		var nName int32 = sqlite3Strlen30(zName)
		pMod = (*struct_Module)(sqlite3Malloc(uint64(48 + uint(nName) + uint(1))))
		if uintptr(unsafe.Pointer(pMod)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3OomFault(db)
			return (*struct_Module)(nil)
		}
		zCopy = (*int8)(unsafe.Pointer(&*(*struct_Module)(unsafe.Pointer(uintptr(unsafe.Pointer(pMod)) + uintptr(1)*48))))
		__builtin___memcpy_chk(unsafe.Pointer(zCopy), unsafe.Pointer(zName), uint(nName+1), __builtin_object_size(unsafe.Pointer(zCopy), 0))
		pMod.zName = zCopy
		pMod.pModule = pModule
		pMod.pAux = pAux
		pMod.xDestroy = xDestroy
		pMod.pEpoTab = (*struct_Table)(nil)
		pMod.nRefModule = int32(1)
	}
	pDel = (*struct_Module)(sqlite3HashInsert(&db.aModule, zCopy, unsafe.Pointer(pMod)))
	if pDel != nil {
		if uintptr(unsafe.Pointer(pDel)) == uintptr(unsafe.Pointer(pMod)) {
			sqlite3OomFault(db)
			sqlite3DbFree(db, unsafe.Pointer(pDel))
			pMod = (*struct_Module)(nil)
		} else {
			sqlite3VtabEponymousTableClear(db, pDel)
			sqlite3VtabModuleUnref(db, pDel)
		}
	}
	return pMod
}
func createModule(db *struct_sqlite3, zName *int8, pModule *struct_sqlite3_module, pAux unsafe.Pointer, xDestroy func(unsafe.Pointer)) int32 {
	var rc int32 = 0
	sqlite3_mutex_enter(db.mutex)
	func() int {
		_ = sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy)
		return 0
	}()
	rc = sqlite3ApiExit(db, rc)
	if rc != 0 && xDestroy != nil {
		xDestroy(pAux)
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_create_module(db *struct_sqlite3, zName *int8, pModule *struct_sqlite3_module, pAux unsafe.Pointer) int32 {
	return createModule(db, zName, pModule, pAux, nil)
}
func sqlite3_create_module_v2(db *struct_sqlite3, zName *int8, pModule *struct_sqlite3_module, pAux unsafe.Pointer, xDestroy func(unsafe.Pointer)) int32 {
	return createModule(db, zName, pModule, pAux, xDestroy)
}
func sqlite3_drop_modules(db *struct_sqlite3, azNames **int8) int32 {
	var pThis *struct_HashElem
	var pNext *struct_HashElem
	for pThis = (&db.aModule).first; pThis != nil; pThis = pNext {
		var pMod *struct_Module = (*struct_Module)(pThis.data)
		pNext = pThis.next
		if azNames != nil {
			var ii int32
			for ii = int32(0); uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azNames)) + uintptr(ii)*8)))) != uintptr(unsafe.Pointer(nil)) && strcmp(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azNames)) + uintptr(ii)*8)), pMod.zName) != 0; ii++ {
			}
			if uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azNames)) + uintptr(ii)*8)))) != uintptr(unsafe.Pointer(nil)) {
				continue
			}
		}
		createModule(db, pMod.zName, nil, nil, nil)
	}
	return int32(0)
}
func sqlite3VtabModuleUnref(db *struct_sqlite3, pMod *struct_Module) {
	func() int {
		_ = 0
		return 0
	}()
	pMod.nRefModule--
	if pMod.nRefModule == 0 {
		if pMod.xDestroy != nil {
			pMod.xDestroy(pMod.pAux)
		}
		func() int {
			_ = 0
			return 0
		}()
		sqlite3DbFree(db, unsafe.Pointer(pMod))
	}
}
func sqlite3VtabLock(pVTab *struct_VTable) {
	pVTab.nRef++
}
func sqlite3GetVTable(db *struct_sqlite3, pTab *struct_Table) *struct_VTable {
	var pVtab *struct_VTable
	func() int {
		_ = 0
		return 0
	}()
	for pVtab = (*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p; pVtab != nil && uintptr(unsafe.Pointer(pVtab.db)) != uintptr(unsafe.Pointer(db)); pVtab = pVtab.pNext {
	}
	return pVtab
}
func sqlite3VtabUnlock(pVTab *struct_VTable) {
	var db *struct_sqlite3 = pVTab.db
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pVTab.nRef--
	if pVTab.nRef == 0 {
		var p *struct_sqlite3_vtab = pVTab.pVtab
		sqlite3VtabModuleUnref(pVTab.db, pVTab.pMod)
		if p != nil {
			p.pModule.xDisconnect(p)
		}
		sqlite3DbFree(db, unsafe.Pointer(pVTab))
	}
}
func vtabDisconnectAll(db *struct_sqlite3, p *struct_Table) *struct_VTable {
	var pRet *struct_VTable = nil
	var pVTable *struct_VTable
	func() int {
		_ = 0
		return 0
	}()
	pVTable = (*(*_cgoa_13)(unsafe.Pointer(&p.u))).p
	(*(*_cgoa_13)(unsafe.Pointer(&p.u))).p = (*struct_VTable)(nil)
	func() int {
		_ = 0
		return 0
	}()
	for pVTable != nil {
		var db2 *struct_sqlite3 = pVTable.db
		var pNext *struct_VTable = pVTable.pNext
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(db2)) == uintptr(unsafe.Pointer(db)) {
			pRet = pVTable
			(*(*_cgoa_13)(unsafe.Pointer(&p.u))).p = pRet
			pRet.pNext = (*struct_VTable)(nil)
		} else {
			pVTable.pNext = db2.pDisconnect
			db2.pDisconnect = pVTable
		}
		pVTable = pNext
	}
	func() int {
		_ = 0
		return 0
	}()
	return pRet
}
func sqlite3VtabDisconnect(db *struct_sqlite3, p *struct_Table) {
	var ppVTab **struct_VTable
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for ppVTab = &(*(*_cgoa_13)(unsafe.Pointer(&p.u))).p; *ppVTab != nil; ppVTab = &(*ppVTab).pNext {
		if uintptr(unsafe.Pointer((*ppVTab).db)) == uintptr(unsafe.Pointer(db)) {
			var pVTab *struct_VTable = *ppVTab
			*ppVTab = pVTab.pNext
			sqlite3VtabUnlock(pVTab)
			break
		}
	}
}
func sqlite3VtabUnlockList(db *struct_sqlite3) {
	var p *struct_VTable = db.pDisconnect
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p != nil {
		db.pDisconnect = (*struct_VTable)(nil)
		sqlite3ExpirePreparedStatements(db, 0)
		for {
			var pNext *struct_VTable = p.pNext
			sqlite3VtabUnlock(p)
			p = pNext
			if !(p != nil) {
				break
			}
		}
	}
}
func sqlite3VtabClear(db *struct_sqlite3, p *struct_Table) {
	func() int {
		_ = 0
		return 0
	}()
	if !(db != nil) || uintptr(unsafe.Pointer(db.pnBytesFreed)) == uintptr(unsafe.Pointer(nil)) {
		vtabDisconnectAll(nil, p)
	}
	if (*(*_cgoa_13)(unsafe.Pointer(&p.u))).azArg != nil {
		var i int32
		for i = int32(0); i < (*(*_cgoa_13)(unsafe.Pointer(&p.u))).nArg; i++ {
			if i != 1 {
				sqlite3DbFree(db, unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&p.u))).azArg)) + uintptr(i)*8))))
			}
		}
		sqlite3DbFree(db, unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&p.u))).azArg))
	}
}
func addModuleArgument(pParse *struct_Parse, pTable *struct_Table, zArg *int8) {
	var nBytes int64
	var azModuleArg **int8
	var db *struct_sqlite3 = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	nBytes = int64(8 * uint(2+(*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).nArg))
	if (*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).nArg+3 >= *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(2)*4)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[23]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'c', 'o', 'l', 'u', 'm', 'n', 's', ' ', 'o', 'n', ' ', '%', 's', '\x00'})), pTable.zName)
	}
	azModuleArg = (**int8)(sqlite3DbRealloc(db, unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).azArg), uint64(nBytes)))
	if uintptr(unsafe.Pointer(azModuleArg)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3DbFree(db, unsafe.Pointer(zArg))
	} else {
		var i int32 = func() (_cgo_ret int32) {
			_cgo_addr := &(*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).nArg
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azModuleArg)) + uintptr(i)*8)) = zArg
		*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azModuleArg)) + uintptr(i+1)*8)) = (*int8)(nil)
		(*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).azArg = azModuleArg
	}
}
func sqlite3VtabBeginParse(pParse *struct_Parse, pName1 *struct_Token, pName2 *struct_Token, pModuleName *struct_Token, ifNotExists int32) {
	var pTable *struct_Table
	var db *struct_sqlite3
	sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists)
	pTable = pParse.pNewTable
	if uintptr(unsafe.Pointer(pTable)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	pTable.eTabType = uint8(1)
	db = pParse.db
	func() int {
		_ = 0
		return 0
	}()
	addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName))
	addModuleArgument(pParse, pTable, nil)
	addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable.zName))
	func() int {
		_ = 0
		return 0
	}()
	pParse.sNameToken.n = uint32(int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pModuleName.z)) + uintptr(pModuleName.n))))) - uintptr(unsafe.Pointer(pParse.sNameToken.z))))
	if (*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).azArg != nil {
		var iDb int32 = sqlite3SchemaToIndex(db, pTable.pSchema)
		func() int {
			_ = 0
			return 0
		}()
		sqlite3AuthCheck(pParse, 29, pTable.zName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTable.u))).azArg)) + uintptr(0)*8)), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.db.aDb)) + uintptr(iDb)*32))).zDbSName)
	}
}
func addArgumentToVtab(pParse *struct_Parse) {
	if pParse.sArg.z != nil && pParse.pNewTable != nil {
		var z *int8 = (*int8)(unsafe.Pointer(pParse.sArg.z))
		var n int32 = int32(pParse.sArg.n)
		var db *struct_sqlite3 = pParse.db
		addModuleArgument(pParse, pParse.pNewTable, sqlite3DbStrNDup(db, z, uint64(n)))
	}
}
func sqlite3VtabFinishParse(pParse *struct_Parse, pEnd *struct_Token) {
	var pTab *struct_Table = pParse.pNewTable
	var db *struct_sqlite3 = pParse.db
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	addArgumentToVtab(pParse)
	pParse.sArg.z = (*int8)(nil)
	if (*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).nArg < 1 {
		return
	}
	if !(db.init.busy != 0) {
		var zStmt *int8
		var zWhere *int8
		var iDb int32
		var iReg int32
		var v *struct_Vdbe
		sqlite3MayAbort(pParse)
		if pEnd != nil {
			pParse.sNameToken.n = uint32(int32(uintptr(unsafe.Pointer(pEnd.z))-uintptr(unsafe.Pointer(pParse.sNameToken.z)))) + pEnd.n
		}
		zStmt = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[24]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'V', 'I', 'R', 'T', 'U', 'A', 'L', ' ', 'T', 'A', 'B', 'L', 'E', ' ', '%', 'T', '\x00'})), &pParse.sNameToken)
		iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
		sqlite3NestedParse(pParse, (*int8)(unsafe.Pointer(&[99]int8{'U', 'P', 'D', 'A', 'T', 'E', ' ', '%', 'Q', '.', 's', 'q', 'l', 'i', 't', 'e', '_', 'm', 'a', 's', 't', 'e', 'r', ' ', 'S', 'E', 'T', ' ', 't', 'y', 'p', 'e', '=', '\'', 't', 'a', 'b', 'l', 'e', '\'', ',', ' ', 'n', 'a', 'm', 'e', '=', '%', 'Q', ',', ' ', 't', 'b', 'l', '_', 'n', 'a', 'm', 'e', '=', '%', 'Q', ',', ' ', 'r', 'o', 'o', 't', 'p', 'a', 'g', 'e', '=', '0', ',', ' ', 's', 'q', 'l', '=', '%', 'Q', ' ', 'W', 'H', 'E', 'R', 'E', ' ', 'r', 'o', 'w', 'i', 'd', '=', '#', '%', 'd', '\x00'})), (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName, pTab.zName, pTab.zName, zStmt, pParse.regRowid)
		v = sqlite3GetVdbe(pParse)
		sqlite3ChangeCookie(pParse, iDb)
		sqlite3VdbeAddOp0(v, 165)
		zWhere = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[19]int8{'n', 'a', 'm', 'e', '=', '%', 'Q', ' ', 'A', 'N', 'D', ' ', 's', 'q', 'l', '=', '%', 'Q', '\x00'})), pTab.zName, zStmt)
		sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere, uint16(0))
		sqlite3DbFree(db, unsafe.Pointer(zStmt))
		iReg = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeLoadString(v, iReg, pTab.zName)
		sqlite3VdbeAddOp2(v, 170, iDb, iReg)
	} else {
		var pOld *struct_Table
		var pSchema *struct_Schema = pTab.pSchema
		var zName *int8 = pTab.zName
		func() int {
			_ = 0
			return 0
		}()
		sqlite3MarkAllShadowTablesOf(db, pTab)
		pOld = (*struct_Table)(sqlite3HashInsert(&pSchema.tblHash, zName, unsafe.Pointer(pTab)))
		if pOld != nil {
			sqlite3OomFault(db)
			func() int {
				_ = 0
				return 0
			}()
			return
		}
		pParse.pNewTable = (*struct_Table)(nil)
	}
}
func sqlite3VtabArgInit(pParse *struct_Parse) {
	addArgumentToVtab(pParse)
	pParse.sArg.z = (*int8)(nil)
	pParse.sArg.n = uint32(0)
}
func sqlite3VtabArgExtend(pParse *struct_Parse, p *struct_Token) {
	var pArg *struct_Token = &pParse.sArg
	if uintptr(unsafe.Pointer(pArg.z)) == uintptr(unsafe.Pointer(nil)) {
		pArg.z = p.z
		pArg.n = p.n
	} else {
		func() int {
			_ = 0
			return 0
		}()
		pArg.n = uint32(int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.z)) + uintptr(p.n))))) - uintptr(unsafe.Pointer(pArg.z))))
	}
}
func vtabCallConstructor(db *struct_sqlite3, pTab *struct_Table, pMod *struct_Module, xConstruct func(*struct_sqlite3, unsafe.Pointer, int32, **int8, **struct_sqlite3_vtab, **int8) int32, pzErr **int8) int32 {
	var sCtx struct_VtabCtx
	var pVTable *struct_VTable
	var rc int32
	var azArg **int8
	var nArg int32 = (*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).nArg
	var zErr *int8 = nil
	var zModuleName *int8
	var iDb int32
	var pCtx *struct_VtabCtx
	func() int {
		_ = 0
		return 0
	}()
	azArg = (**int8)(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg))
	for pCtx = db.pVtabCtx; pCtx != nil; pCtx = pCtx.pPrior {
		if uintptr(unsafe.Pointer(pCtx.pTab)) == uintptr(unsafe.Pointer(pTab)) {
			*pzErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[42]int8{'v', 't', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 'c', 'a', 'l', 'l', 'e', 'd', ' ', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 'l', 'y', ':', ' ', '%', 's', '\x00'})), pTab.zName)
			return int32(6)
		}
	}
	zModuleName = sqlite3DbStrDup(db, pTab.zName)
	if !(zModuleName != nil) {
		return int32(7)
	}
	pVTable = (*struct_VTable)(sqlite3MallocZero(uint64(48)))
	if !(pVTable != nil) {
		sqlite3OomFault(db)
		sqlite3DbFree(db, unsafe.Pointer(zModuleName))
		return int32(7)
	}
	pVTable.db = db
	pVTable.pMod = pMod
	pVTable.eVtabRisk = uint8(1)
	iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg)) + uintptr(1)*8)) = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	sCtx.pTab = pTab
	sCtx.pVTable = pVTable
	sCtx.pPrior = db.pVtabCtx
	sCtx.bDeclared = int32(0)
	db.pVtabCtx = &sCtx
	rc = xConstruct(db, pMod.pAux, nArg, azArg, &pVTable.pVtab, &zErr)
	db.pVtabCtx = sCtx.pPrior
	if rc == 7 {
		sqlite3OomFault(db)
	}
	func() int {
		_ = 0
		return 0
	}()
	if 0 != rc {
		if uintptr(unsafe.Pointer(zErr)) == uintptr(unsafe.Pointer(nil)) {
			*pzErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[30]int8{'v', 't', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 'f', 'a', 'i', 'l', 'e', 'd', ':', ' ', '%', 's', '\x00'})), zModuleName)
		} else {
			*pzErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zErr)
			sqlite3_free(unsafe.Pointer(zErr))
		}
		sqlite3DbFree(db, unsafe.Pointer(pVTable))
	} else if pVTable.pVtab != nil {
		__builtin___memset_chk(unsafe.Pointer(pVTable.pVtab), 0, 24, __builtin_object_size(unsafe.Pointer(pVTable.pVtab), 0))
		pVTable.pVtab.pModule = pMod.pModule
		pMod.nRefModule++
		pVTable.nRef = int32(1)
		if sCtx.bDeclared == 0 {
			var zFormat *int8 = (*int8)(unsafe.Pointer(&[46]int8{'v', 't', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'n', 's', 't', 'r', 'u', 'c', 't', 'o', 'r', ' ', 'd', 'i', 'd', ' ', 'n', 'o', 't', ' ', 'd', 'e', 'c', 'l', 'a', 'r', 'e', ' ', 's', 'c', 'h', 'e', 'm', 'a', ':', ' ', '%', 's', '\x00'}))
			*pzErr = sqlite3MPrintf(db, zFormat, pTab.zName)
			sqlite3VtabUnlock(pVTable)
			rc = int32(1)
		} else {
			var iCol int32
			var oooHidden uint16 = uint16(0)
			pVTable.pNext = (*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p
			(*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p = pVTable
			for iCol = int32(0); iCol < int32(pTab.nCol); iCol++ {
				var zType *int8 = sqlite3ColumnType(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20)), (*int8)(unsafe.Pointer(&[1]int8{'\x00'})))
				var nType int32
				var i int32 = 0
				nType = sqlite3Strlen30(zType)
				for i = int32(0); i < nType; i++ {
					if 0 == sqlite3_strnicmp((*int8)(unsafe.Pointer(&[7]int8{'h', 'i', 'd', 'd', 'e', 'n', '\x00'})), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i))), 6) && (i == 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i-1)))) == ' ') && (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i+6)))) == '\x00' || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i+6)))) == ' ') {
						break
					}
				}
				if i < nType {
					var j int32
					var nDel int32 = 6 + func() int32 {
						if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i+6)))) != 0 {
							return 1
						} else {
							return 0
						}
					}()
					for j = i; j+nDel <= nType; j++ {
						*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(j))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(j+nDel)))
					}
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i)))) == '\x00' && i > 0 {
						func() int {
							_ = 0
							return 0
						}()
						*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zType)) + uintptr(i-1))) = int8('\x00')
					}
					(*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))).colFlags |= uint16(2)
					pTab.tabFlags |= uint32(2)
					oooHidden = uint16(1024)
				} else {
					pTab.tabFlags |= uint32(oooHidden)
				}
			}
		}
	}
	sqlite3DbFree(db, unsafe.Pointer(zModuleName))
	return rc
}
func sqlite3VtabCallConnect(pParse *struct_Parse, pTab *struct_Table) int32 {
	var db *struct_sqlite3 = pParse.db
	var zMod *int8
	var pMod *struct_Module
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3GetVTable(db, pTab) != nil {
		return int32(0)
	}
	zMod = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg)) + uintptr(0)*8))
	pMod = (*struct_Module)(sqlite3HashFind(&db.aModule, zMod))
	if !(pMod != nil) {
		var zModule *int8 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg)) + uintptr(0)*8))
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[19]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'm', 'o', 'd', 'u', 'l', 'e', ':', ' ', '%', 's', '\x00'})), zModule)
		rc = int32(1)
	} else {
		var zErr *int8 = nil
		rc = vtabCallConstructor(db, pTab, pMod, pMod.pModule.xConnect, &zErr)
		if rc != 0 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zErr)
			pParse.rc = rc
		}
		sqlite3DbFree(db, unsafe.Pointer(zErr))
	}
	return rc
}
func growVTrans(db *struct_sqlite3) int32 {
	const ARRAY_INCR int32 = 5
	if db.nVTrans%ARRAY_INCR == 0 {
		var aVTrans **struct_VTable
		var nBytes int64 = int64(uint64(8) * uint64(int64(db.nVTrans)+int64(ARRAY_INCR)))
		aVTrans = (**struct_VTable)(sqlite3DbRealloc(db, unsafe.Pointer(db.aVTrans), uint64(nBytes)))
		if !(aVTrans != nil) {
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(&*(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(aVTrans)) + uintptr(db.nVTrans)*8))), 0, 8*uint(ARRAY_INCR), __builtin_object_size(unsafe.Pointer(&*(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(aVTrans)) + uintptr(db.nVTrans)*8))), 0))
		db.aVTrans = aVTrans
	}
	return int32(0)
}
func addToVTrans(db *struct_sqlite3, pVTab *struct_VTable) {
	*(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aVTrans)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &db.nVTrans
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*8)) = pVTab
	sqlite3VtabLock(pVTab)
}
func sqlite3VtabCallCreate(db *struct_sqlite3, iDb int32, zTab *int8, pzErr **int8) int32 {
	var rc int32 = 0
	var pTab *struct_Table
	var pMod *struct_Module
	var zMod *int8
	pTab = sqlite3FindTable(db, zTab, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName)
	func() int {
		_ = 0
		return 0
	}()
	zMod = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).azArg)) + uintptr(0)*8))
	pMod = (*struct_Module)(sqlite3HashFind(&db.aModule, zMod))
	if uintptr(unsafe.Pointer(pMod)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pMod.pModule.xCreate)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(pMod.pModule.xDestroy)) == uintptr(unsafe.Pointer(nil)) {
		*pzErr = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[19]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'm', 'o', 'd', 'u', 'l', 'e', ':', ' ', '%', 's', '\x00'})), zMod)
		rc = int32(1)
	} else {
		rc = vtabCallConstructor(db, pTab, pMod, pMod.pModule.xCreate, pzErr)
	}
	if rc == 0 && sqlite3GetVTable(db, pTab) != nil {
		rc = growVTrans(db)
		if rc == 0 {
			addToVTrans(db, sqlite3GetVTable(db, pTab))
		}
	}
	return rc
}
func sqlite3_declare_vtab(db *struct_sqlite3, zCreateTable *int8) int32 {
	var pCtx *struct_VtabCtx
	var rc int32 = 0
	var pTab *struct_Table
	var sParse struct_Parse
	var initBusy int32
	sqlite3_mutex_enter(db.mutex)
	pCtx = db.pVtabCtx
	if !(pCtx != nil) || pCtx.bDeclared != 0 {
		sqlite3Error(db, 21)
		sqlite3_mutex_leave(db.mutex)
		return sqlite3MisuseError(146294)
	}
	pTab = pCtx.pTab
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ParseObjectInit(&sParse, db)
	sParse.eParseMode = uint8(1)
	sParse.disableTriggers = uint8(1)
	func() int {
		_ = 0
		return 0
	}()
	initBusy = int32(db.init.busy)
	db.init.busy = uint8(0)
	sParse.nQueryLoop = uint32(1)
	if 0 == sqlite3RunParser(&sParse, zCreateTable) && uintptr(unsafe.Pointer(sParse.pNewTable)) != uintptr(unsafe.Pointer(nil)) && !(db.mallocFailed != 0) && int32(sParse.pNewTable.eTabType) == 0 {
		func() int {
			_ = 0
			return 0
		}()
		if !(pTab.aCol != nil) {
			var pNew *struct_Table = sParse.pNewTable
			var pIdx *struct_Index
			pTab.aCol = pNew.aCol
			sqlite3ExprListDelete(db, pNew.u.tab.pDfltList)
			pTab.nNVCol = func() (_cgo_ret int16) {
				_cgo_addr := &pTab.nCol
				*_cgo_addr = pNew.nCol
				return *_cgo_addr
			}()
			pTab.tabFlags |= pNew.tabFlags & uint32(128|512)
			pNew.nCol = int16(0)
			pNew.aCol = (*struct_Column)(nil)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if !(pNew.tabFlags&uint32(128) == uint32(0)) && uintptr(unsafe.Pointer(pCtx.pVTable.pMod.pModule.xUpdate)) != uintptr(unsafe.Pointer(nil)) && int32(sqlite3PrimaryKeyIndex(pNew).nKeyCol) != 1 {
				rc = int32(1)
			}
			pIdx = pNew.pIndex
			if pIdx != nil {
				func() int {
					_ = 0
					return 0
				}()
				pTab.pIndex = pIdx
				pNew.pIndex = (*struct_Index)(nil)
				pIdx.pTable = pTab
			}
		}
		pCtx.bDeclared = int32(1)
	} else {
		sqlite3ErrorWithMsg(db, 1, func() *int8 {
			if sParse.zErrMsg != nil {
				return (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'}))
			} else {
				return nil
			}
		}(), sParse.zErrMsg)
		sqlite3DbFree(db, unsafe.Pointer(sParse.zErrMsg))
		rc = int32(1)
	}
	sParse.eParseMode = uint8(0)
	if sParse.pVdbe != nil {
		sqlite3VdbeFinalize(sParse.pVdbe)
	}
	sqlite3DeleteTable(db, sParse.pNewTable)
	sqlite3ParseObjectReset(&sParse)
	db.init.busy = uint8(initBusy)
	func() int {
		_ = 0
		return 0
	}()
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3VtabCallDestroy(db *struct_sqlite3, iDb int32, zTab *int8) int32 {
	var rc int32 = 0
	var pTab *struct_Table
	pTab = sqlite3FindTable(db, zTab, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).zDbSName)
	if uintptr(unsafe.Pointer(pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pTab.eTabType) == 1 && uintptr(unsafe.Pointer((*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p)) != uintptr(unsafe.Pointer(nil)) {
		var p *struct_VTable
		var xDestroy func(*struct_sqlite3_vtab) int32
		for p = (*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p; p != nil; p = p.pNext {
			func() int {
				_ = 0
				return 0
			}()
			if p.pVtab.nRef > 0 {
				return int32(6)
			}
		}
		p = vtabDisconnectAll(db, pTab)
		xDestroy = p.pMod.pModule.xDestroy
		if uintptr(unsafe.Pointer(xDestroy)) == uintptr(unsafe.Pointer(nil)) {
			xDestroy = p.pMod.pModule.xDisconnect
		}
		func() int {
			_ = 0
			return 0
		}()
		pTab.nTabRef++
		rc = xDestroy(p.pVtab)
		if rc == 0 {
			func() int {
				_ = 0
				return 0
			}()
			p.pVtab = (*struct_sqlite3_vtab)(nil)
			(*(*_cgoa_13)(unsafe.Pointer(&pTab.u))).p = (*struct_VTable)(nil)
			sqlite3VtabUnlock(p)
		}
		sqlite3DeleteTable(db, pTab)
	}
	return rc
}
func callFinaliser(db *struct_sqlite3, offset int32) {
	var i int32
	if db.aVTrans != nil {
		var aVTrans **struct_VTable = db.aVTrans
		db.aVTrans = (**struct_VTable)(nil)
		for i = int32(0); i < db.nVTrans; i++ {
			var pVTab *struct_VTable = *(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(aVTrans)) + uintptr(i)*8))
			var p *struct_sqlite3_vtab = pVTab.pVtab
			if p != nil {
				var x func(*struct_sqlite3_vtab) int32
				x = *(*func(*struct_sqlite3_vtab) int32)(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(p.pModule)))) + uintptr(offset)))))
				if x != nil {
					x(p)
				}
			}
			pVTab.iSavepoint = int32(0)
			sqlite3VtabUnlock(pVTab)
		}
		sqlite3DbFree(db, unsafe.Pointer(aVTrans))
		db.nVTrans = int32(0)
	}
}
func sqlite3VtabSync(db *struct_sqlite3, p *struct_Vdbe) int32 {
	var i int32
	var rc int32 = 0
	var aVTrans **struct_VTable = db.aVTrans
	db.aVTrans = (**struct_VTable)(nil)
	for i = int32(0); rc == 0 && i < db.nVTrans; i++ {
		var x func(*struct_sqlite3_vtab) int32
		var pVtab *struct_sqlite3_vtab = (*(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(aVTrans)) + uintptr(i)*8))).pVtab
		if pVtab != nil && uintptr(unsafe.Pointer(func() (_cgo_ret func(*struct_sqlite3_vtab) int32) {
			_cgo_addr := &x
			*_cgo_addr = pVtab.pModule.xSync
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			rc = x(pVtab)
			sqlite3VtabImportErrmsg(p, pVtab)
		}
	}
	db.aVTrans = aVTrans
	return rc
}
func sqlite3VtabRollback(db *struct_sqlite3) int32 {
	callFinaliser(db, int32(136))
	return int32(0)
}
func sqlite3VtabCommit(db *struct_sqlite3) int32 {
	callFinaliser(db, int32(128))
	return int32(0)
}
func sqlite3VtabBegin(db *struct_sqlite3, pVTab *struct_VTable) int32 {
	var rc int32 = 0
	var pModule *struct_sqlite3_module
	if db.nVTrans > 0 && uintptr(unsafe.Pointer(db.aVTrans)) == uintptr(unsafe.Pointer(nil)) {
		return int32(6)
	}
	if !(pVTab != nil) {
		return int32(0)
	}
	pModule = pVTab.pVtab.pModule
	if pModule.xBegin != nil {
		var i int32
		for i = int32(0); i < db.nVTrans; i++ {
			if uintptr(unsafe.Pointer(*(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aVTrans)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(pVTab)) {
				return int32(0)
			}
		}
		rc = growVTrans(db)
		if rc == 0 {
			rc = pModule.xBegin(pVTab.pVtab)
			if rc == 0 {
				var iSvpt int32 = db.nStatement + db.nSavepoint
				addToVTrans(db, pVTab)
				if iSvpt != 0 && pModule.xSavepoint != nil {
					pVTab.iSavepoint = iSvpt
					rc = pModule.xSavepoint(pVTab.pVtab, iSvpt-1)
				}
			}
		}
	}
	return rc
}
func sqlite3VtabSavepoint(db *struct_sqlite3, op int32, iSavepoint int32) int32 {
	var rc int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if db.aVTrans != nil {
		var i int32
		for i = int32(0); rc == 0 && i < db.nVTrans; i++ {
			var pVTab *struct_VTable = *(**struct_VTable)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aVTrans)) + uintptr(i)*8))
			var pMod *struct_sqlite3_module = pVTab.pMod.pModule
			if pVTab.pVtab != nil && pMod.iVersion >= 2 {
				var xMethod func(*struct_sqlite3_vtab, int32) int32
				sqlite3VtabLock(pVTab)
				switch op {
				case 0:
					xMethod = pMod.xSavepoint
					pVTab.iSavepoint = iSavepoint + 1
					break
				case 2:
					xMethod = pMod.xRollbackTo
					break
				default:
					xMethod = pMod.xRelease
					break
				}
				if xMethod != nil && pVTab.iSavepoint > iSavepoint {
					rc = xMethod(pVTab.pVtab, iSavepoint)
				}
				sqlite3VtabUnlock(pVTab)
			}
		}
	}
	return rc
}
func sqlite3VtabOverloadFunction(db *struct_sqlite3, pDef *struct_FuncDef, nArg int32, pExpr *struct_Expr) *struct_FuncDef {
	var pTab *struct_Table
	var pVtab *struct_sqlite3_vtab
	var pMod *struct_sqlite3_module
	var xSFunc func(*struct_sqlite3_context, int32, **struct_sqlite3_value) = nil
	var pArg unsafe.Pointer = nil
	var pNew *struct_FuncDef
	var rc int32 = 0
	if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
		return pDef
	}
	if int32(pExpr.op) != 167 {
		return pDef
	}
	func() int {
		_ = 0
		return 0
	}()
	pTab = pExpr.y.pTab
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return pDef
	}
	if !(int32(pTab.eTabType) == 1) {
		return pDef
	}
	pVtab = sqlite3GetVTable(db, pTab).pVtab
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pMod = (*struct_sqlite3_module)(unsafe.Pointer(pVtab.pModule))
	if uintptr(unsafe.Pointer(pMod.xFindFunction)) == uintptr(unsafe.Pointer(nil)) {
		return pDef
	}
	rc = pMod.xFindFunction(pVtab, nArg, pDef.zName, &xSFunc, &pArg)
	if rc == 0 {
		return pDef
	}
	pNew = (*struct_FuncDef)(sqlite3DbMallocZero(db, uint64(72+uint(sqlite3Strlen30(pDef.zName))+uint(1))))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return pDef
	}
	*pNew = *pDef
	pNew.zName = (*int8)(unsafe.Pointer(&*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew)) + uintptr(1)*72))))
	__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(&*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew)) + uintptr(1)*72))))), unsafe.Pointer(pDef.zName), uint(sqlite3Strlen30(pDef.zName)+1), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(&*(*struct_FuncDef)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew)) + uintptr(1)*72))))), 0))
	pNew.xSFunc = xSFunc
	pNew.pUserData = pArg
	pNew.funcFlags |= uint32(16)
	return pNew
}
func sqlite3VtabMakeWritable(pParse *struct_Parse, pTab *struct_Table) {
	var pToplevel *struct_Parse = func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}()
	var i int32
	var n int32
	var apVtabLock **struct_Table
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < pToplevel.nVtabLock; i++ {
		if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(*(**struct_Table)(unsafe.Pointer(uintptr(unsafe.Pointer(pToplevel.apVtabLock)) + uintptr(i)*8)))) {
			return
		}
	}
	n = int32(uint(pToplevel.nVtabLock+1) * 8)
	apVtabLock = (**struct_Table)(sqlite3Realloc(unsafe.Pointer(pToplevel.apVtabLock), uint64(n)))
	if apVtabLock != nil {
		pToplevel.apVtabLock = apVtabLock
		*(**struct_Table)(unsafe.Pointer(uintptr(unsafe.Pointer(pToplevel.apVtabLock)) + uintptr(func() (_cgo_ret int32) {
			_cgo_addr := &pToplevel.nVtabLock
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*8)) = pTab
	} else {
		sqlite3OomFault(pToplevel.db)
	}
}
func sqlite3VtabEponymousTableInit(pParse *struct_Parse, pMod *struct_Module) int32 {
	var pModule *struct_sqlite3_module = pMod.pModule
	var pTab *struct_Table
	var zErr *int8 = nil
	var rc int32
	var db *struct_sqlite3 = pParse.db
	if pMod.pEpoTab != nil {
		return int32(1)
	}
	if uintptr(unsafe.Pointer(pModule.xCreate)) != uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(pModule.xCreate)) != uintptr(unsafe.Pointer(pModule.xConnect)) {
		return int32(0)
	}
	pTab = (*struct_Table)(sqlite3DbMallocZero(db, uint64(104)))
	if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	pTab.zName = sqlite3DbStrDup(db, pMod.zName)
	if uintptr(unsafe.Pointer(pTab.zName)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3DbFree(db, unsafe.Pointer(pTab))
		return int32(0)
	}
	pMod.pEpoTab = pTab
	pTab.nTabRef = uint32(1)
	pTab.eTabType = uint8(1)
	pTab.pSchema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema
	func() int {
		_ = 0
		return 0
	}()
	pTab.iPKey = int16(-1)
	pTab.tabFlags |= uint32(32768)
	addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName))
	addModuleArgument(pParse, pTab, nil)
	addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab.zName))
	rc = vtabCallConstructor(db, pTab, pMod, pModule.xConnect, &zErr)
	if rc != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), zErr)
		sqlite3DbFree(db, unsafe.Pointer(zErr))
		sqlite3VtabEponymousTableClear(db, pMod)
	}
	return int32(1)
}
func sqlite3VtabEponymousTableClear(db *struct_sqlite3, pMod *struct_Module) {
	var pTab *struct_Table = pMod.pEpoTab
	if uintptr(unsafe.Pointer(pTab)) != uintptr(unsafe.Pointer(nil)) {
		pTab.tabFlags |= uint32(16384)
		sqlite3DeleteTable(db, pTab)
		pMod.pEpoTab = (*struct_Table)(nil)
	}
}
func sqlite3_vtab_on_conflict(db *struct_sqlite3) int32 {
	var aMap [5]uint8 = [5]uint8{uint8(1), uint8(4), uint8(3), uint8(2), uint8(5)}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMap)))) + uintptr(int32(db.vtabOnConflict)-1))))
}
func sqlite3_vtab_config(db *struct_sqlite3, op int32, __cgo_args ...interface {
}) int32 {
	var rc int32 = 0
	var p *struct_VtabCtx
	sqlite3_mutex_enter(db.mutex)
	p = db.pVtabCtx
	if !(p != nil) {
		rc = sqlite3MisuseError(146785)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		switch op {
		case 1:
			{
				p.pVTable.bConstraint = uint8(func() (_cgo_ret int32) {
					_cgo_ret = __cgo_args[0].(int32)
					__cgo_args = __cgo_args[1:]
					return
				}())
				break
			}
		case 2:
			{
				p.pVTable.eVtabRisk = uint8(0)
				break
			}
		case 3:
			{
				p.pVTable.eVtabRisk = uint8(2)
				break
			}
		default:
			{
				rc = sqlite3MisuseError(146803)
				break
			}
		}
	}
	if rc != 0 {
		sqlite3Error(db, rc)
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}

type WhereClause = struct_WhereClause
type WhereMaskSet = struct_WhereMaskSet
type WhereOrInfo = struct_WhereOrInfo
type WhereAndInfo = struct_WhereAndInfo
type WhereLevel = struct_WhereLevel
type WhereLoop = struct_WhereLoop
type WherePath = struct_WherePath
type WhereTerm = struct_WhereTerm
type WhereLoopBuilder = struct_WhereLoopBuilder
type WhereScan = struct_WhereScan
type WhereOrCost = struct_WhereOrCost
type WhereOrSet = struct_WhereOrSet
type struct_InLoop struct {
	iCur       int32
	addrInTop  int32
	iBase      int32
	nPrefix    int32
	eEndLoopOp uint8
}
type _cgoa_82 struct {
	nIn     int32
	aInLoop *struct_InLoop
}
type _cgoa_81 struct {
	in _cgoa_82
}
type struct_WhereLevel struct {
	iLeftJoin    int32
	iTabCur      int32
	iIdxCur      int32
	addrBrk      int32
	addrNxt      int32
	addrSkip     int32
	addrCont     int32
	addrFirst    int32
	addrBody     int32
	regBignull   int32
	addrBignull  int32
	iLikeRepCntr uint32
	addrLikeRep  int32
	regFilter    int32
	iFrom        uint8
	op           uint8
	p3           uint8
	p5           uint8
	p1           int32
	p2           int32
	u            _cgoa_81
	pWLoop       *struct_WhereLoop
	notReady     uint64
}
type _cgoa_84 struct {
	nEq          uint16
	nBtm         uint16
	nTop         uint16
	nDistinctCol uint16
	pIndex       *struct_Index
}
type _cgoa_85 struct {
	idxNum    int32
	Xbf_0     uint32
	isOrdered int8
	omitMask  uint16
	idxStr    *int8
	mHandleIn uint32
}
type _cgoa_83 struct {
	vtab _cgoa_85
}
type struct_WhereLoop struct {
	prereq      uint64
	maskSelf    uint64
	iTab        uint8
	iSortIdx    uint8
	rSetup      int16
	rRun        int16
	nOut        int16
	u           _cgoa_83
	wsFlags     uint32
	nLTerm      uint16
	nSkip       uint16
	nLSlot      uint16
	aLTerm      **struct_WhereTerm
	pNextLoop   *struct_WhereLoop
	aLTermSpace [3]*struct_WhereTerm
}
type struct_WhereOrCost struct {
	prereq uint64
	rRun   int16
	nOut   int16
}
type struct_WhereOrSet struct {
	n uint16
	a [3]struct_WhereOrCost
}
type struct_WherePath struct {
	maskLoop  uint64
	revLoop   uint64
	nRow      int16
	rCost     int16
	rUnsorted int16
	isOrdered int8
	aLoop     **struct_WhereLoop
}
type _cgoa_87 struct {
	leftColumn int32
	iField     int32
}
type _cgoa_86 struct {
	x _cgoa_87
}
type struct_WhereTerm struct {
	pExpr       *struct_Expr
	pWC         *struct_WhereClause
	truthProb   int16
	wtFlags     uint16
	eOperator   uint16
	nChild      uint8
	eMatchOp    uint8
	iParent     int32
	leftCursor  int32
	u           _cgoa_86
	prereqRight uint64
	prereqAll   uint64
}
type struct_WhereScan struct {
	pOrigWC   *struct_WhereClause
	pWC       *struct_WhereClause
	zCollName *int8
	pIdxExpr  *struct_Expr
	k         int32
	opMask    uint32
	idxaff    int8
	iEquiv    uint8
	nEquiv    uint8
	aiCur     [11]int32
	aiColumn  [11]int16
}
type struct_WhereClause struct {
	pWInfo  *struct_WhereInfo
	pOuter  *struct_WhereClause
	op      uint8
	hasOr   uint8
	nTerm   int32
	nSlot   int32
	nBase   int32
	a       *struct_WhereTerm
	aStatic [8]struct_WhereTerm
}
type struct_WhereOrInfo struct {
	wc        struct_WhereClause
	indexable uint64
}
type struct_WhereAndInfo struct {
	wc struct_WhereClause
}
type struct_WhereMaskSet struct {
	bVarSelect int32
	n          int32
	ix         [64]int32
}
type struct_WhereLoopBuilder struct {
	pWInfo     *struct_WhereInfo
	pWC        *struct_WhereClause
	pNew       *struct_WhereLoop
	pOrSet     *struct_WhereOrSet
	bldFlags1  uint8
	bldFlags2  uint8
	iPlanLimit uint32
}
type WhereExprMod = struct_WhereExprMod
type struct_WhereExprMod struct {
	pNext *struct_WhereExprMod
	pExpr *struct_Expr
	orig  struct_Expr
}
type struct_WhereInfo struct {
	pParse          *struct_Parse
	pTabList        *struct_SrcList
	pOrderBy        *struct_ExprList
	pResultSet      *struct_ExprList
	pWhere          *struct_Expr
	pLimit          *struct_Select
	aiCurOnePass    [2]int32
	iContinue       int32
	iBreak          int32
	savedNQueryLoop int32
	wctrlFlags      uint16
	iLimit          int16
	nLevel          uint8
	nOBSat          int8
	eOnePass        uint8
	eDistinct       uint8
	Xbf_0           uint32
	nRowOut         int16
	iTop            int32
	iEndWhere       int32
	pLoops          *struct_WhereLoop
	pExprMods       *struct_WhereExprMod
	revMask         uint64
	sWC             struct_WhereClause
	sMaskSet        struct_WhereMaskSet
	a               [1]struct_WhereLevel
}

func explainIndexColumnName(pIdx *struct_Index, i int32) *int8 {
	i = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
	if i == -2 {
		return (*int8)(unsafe.Pointer(&[7]int8{'<', 'e', 'x', 'p', 'r', '>', '\x00'}))
	}
	if i == -1 {
		return (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'w', 'i', 'd', '\x00'}))
	}
	return (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.pTable.aCol)) + uintptr(i)*20))).zCnName
}
func explainAppendTerm(pStr *struct_sqlite3_str, pIdx *struct_Index, nTerm int32, iTerm int32, bAnd int32, zOp *int8) {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	if bAnd != 0 {
		sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[6]int8{' ', 'A', 'N', 'D', ' ', '\x00'})), 5)
	}
	if nTerm > 1 {
		sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{'(', '\x00'})), 1)
	}
	for i = int32(0); i < nTerm; i++ {
		if i != 0 {
			sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{',', '\x00'})), 1)
		}
		sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, iTerm+i))
	}
	if nTerm > 1 {
		sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'})), 1)
	}
	sqlite3_str_append(pStr, zOp, 1)
	if nTerm > 1 {
		sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{'(', '\x00'})), 1)
	}
	for i = int32(0); i < nTerm; i++ {
		if i != 0 {
			sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{',', '\x00'})), 1)
		}
		sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{'?', '\x00'})), 1)
	}
	if nTerm > 1 {
		sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'})), 1)
	}
}
func explainIndexRange(pStr *struct_sqlite3_str, pLoop *struct_WhereLoop) {
	var pIndex *struct_Index = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
	var nEq uint16 = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq
	var nSkip uint16 = pLoop.nSkip
	var i int32
	var j int32
	if int32(nEq) == 0 && pLoop.wsFlags&uint32(32|16) == uint32(0) {
		return
	}
	sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[3]int8{' ', '(', '\x00'})), 2)
	for i = int32(0); i < int32(nEq); i++ {
		var z *int8 = explainIndexColumnName(pIndex, i)
		if i != 0 {
			sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[6]int8{' ', 'A', 'N', 'D', ' ', '\x00'})), 5)
		}
		sqlite3_str_appendf(pStr, func() *int8 {
			if i >= int32(nSkip) {
				return (*int8)(unsafe.Pointer(&[5]int8{'%', 's', '=', '?', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[8]int8{'A', 'N', 'Y', '(', '%', 's', ')', '\x00'}))
			}
		}(), z)
	}
	j = i
	if pLoop.wsFlags&uint32(32) != 0 {
		explainAppendTerm(pStr, pIndex, int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nBtm), j, i, (*int8)(unsafe.Pointer(&[2]int8{'>', '\x00'})))
		i = int32(1)
	}
	if pLoop.wsFlags&uint32(16) != 0 {
		explainAppendTerm(pStr, pIndex, int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nTop), j, i, (*int8)(unsafe.Pointer(&[2]int8{'<', '\x00'})))
	}
	sqlite3_str_append(pStr, (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'})), 1)
}
func sqlite3WhereExplainOneScan(pParse *struct_Parse, pTabList *struct_SrcList, pLevel *struct_WhereLevel, wctrlFlags uint16) int32 {
	var ret int32 = 0
	if int32(func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}().explain) == 2 {
		var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(pLevel.iFrom)*112))
		var v *struct_Vdbe = pParse.pVdbe
		var db *struct_sqlite3 = pParse.db
		var isSearch int32
		var pLoop *struct_WhereLoop
		var flags uint32
		var zMsg *int8
		var str struct_sqlite3_str
		var zBuf [100]int8
		pLoop = pLevel.pWLoop
		flags = pLoop.wsFlags
		if flags&uint32(8192) != 0 || int32(wctrlFlags)&32 != 0 {
			return int32(0)
		}
		isSearch = func() int32 {
			if flags&uint32(32|16) != uint32(0) || flags&uint32(1024) == uint32(0) && int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq) > 0 || int32(wctrlFlags)&(1|2) != 0 {
				return 1
			} else {
				return 0
			}
		}()
		sqlite3StrAccumInit(&str, db, (*int8)(unsafe.Pointer(&zBuf)), int32(100), 1000000000)
		str.printfFlags = uint8(1)
		sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[6]int8{'%', 's', ' ', '%', 'S', '\x00'})), func() *int8 {
			if isSearch != 0 {
				return (*int8)(unsafe.Pointer(&[7]int8{'S', 'E', 'A', 'R', 'C', 'H', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[5]int8{'S', 'C', 'A', 'N', '\x00'}))
			}
		}(), pItem)
		if flags&uint32(256|1024) == uint32(0) {
			var zFmt *int8 = nil
			var pIdx *struct_Index
			func() int {
				_ = 0
				return 0
			}()
			pIdx = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
			func() int {
				_ = 0
				return 0
			}()
			if !(pItem.pTab.tabFlags&uint32(128) == uint32(0)) && int32(pIdx.Xbf_0&3) == 2 {
				if isSearch != 0 {
					zFmt = (*int8)(unsafe.Pointer(&[12]int8{'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', '\x00'}))
				}
			} else if flags&uint32(131072) != 0 {
				zFmt = (*int8)(unsafe.Pointer(&[33]int8{'A', 'U', 'T', 'O', 'M', 'A', 'T', 'I', 'C', ' ', 'P', 'A', 'R', 'T', 'I', 'A', 'L', ' ', 'C', 'O', 'V', 'E', 'R', 'I', 'N', 'G', ' ', 'I', 'N', 'D', 'E', 'X', '\x00'}))
			} else if flags&uint32(16384) != 0 {
				zFmt = (*int8)(unsafe.Pointer(&[25]int8{'A', 'U', 'T', 'O', 'M', 'A', 'T', 'I', 'C', ' ', 'C', 'O', 'V', 'E', 'R', 'I', 'N', 'G', ' ', 'I', 'N', 'D', 'E', 'X', '\x00'}))
			} else if flags&uint32(64) != 0 {
				zFmt = (*int8)(unsafe.Pointer(&[18]int8{'C', 'O', 'V', 'E', 'R', 'I', 'N', 'G', ' ', 'I', 'N', 'D', 'E', 'X', ' ', '%', 's', '\x00'}))
			} else {
				zFmt = (*int8)(unsafe.Pointer(&[9]int8{'I', 'N', 'D', 'E', 'X', ' ', '%', 's', '\x00'}))
			}
			if zFmt != nil {
				sqlite3_str_append(&str, (*int8)(unsafe.Pointer(&[8]int8{' ', 'U', 'S', 'I', 'N', 'G', ' ', '\x00'})), 7)
				sqlite3_str_appendf(&str, zFmt, pIdx.zName)
				explainIndexRange(&str, pLoop)
			}
		} else if flags&uint32(256) != uint32(0) && flags&uint32(15) != uint32(0) {
			var cRangeOp int8
			var zRowid *int8 = (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'w', 'i', 'd', '\x00'}))
			sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[31]int8{' ', 'U', 'S', 'I', 'N', 'G', ' ', 'I', 'N', 'T', 'E', 'G', 'E', 'R', ' ', 'P', 'R', 'I', 'M', 'A', 'R', 'Y', ' ', 'K', 'E', 'Y', ' ', '(', '%', 's', '\x00'})), zRowid)
			if flags&uint32(1|4) != 0 {
				cRangeOp = int8('=')
			} else if flags&uint32(48) == uint32(48) {
				sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[10]int8{'>', '?', ' ', 'A', 'N', 'D', ' ', '%', 's', '\x00'})), zRowid)
				cRangeOp = int8('<')
			} else if flags&uint32(32) != 0 {
				cRangeOp = int8('>')
			} else {
				func() int {
					_ = 0
					return 0
				}()
				cRangeOp = int8('<')
			}
			sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[5]int8{'%', 'c', '?', ')', '\x00'})), int32(cRangeOp))
		} else if flags&uint32(1024) != uint32(0) {
			sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[27]int8{' ', 'V', 'I', 'R', 'T', 'U', 'A', 'L', ' ', 'T', 'A', 'B', 'L', 'E', ' ', 'I', 'N', 'D', 'E', 'X', ' ', '%', 'd', ':', '%', 's', '\x00'})), pLoop.u.vtab.idxNum, pLoop.u.vtab.idxStr)
		}
		zMsg = sqlite3StrAccumFinish(&str)
		ret = sqlite3VdbeAddOp4(v, 183, sqlite3VdbeCurrentAddr(v), pParse.addrExplain, 0, zMsg, -7)
	}
	return ret
}
func sqlite3WhereExplainBloomFilter(pParse *struct_Parse, pWInfo *struct_WhereInfo, pLevel *struct_WhereLevel) int32 {
	var ret int32 = 0
	var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLevel.iFrom)*112))
	var v *struct_Vdbe = pParse.pVdbe
	var db *struct_sqlite3 = pParse.db
	var zMsg *int8
	var i int32
	var pLoop *struct_WhereLoop
	var str struct_sqlite3_str
	var zBuf [100]int8
	sqlite3StrAccumInit(&str, db, (*int8)(unsafe.Pointer(&zBuf)), int32(100), 1000000000)
	str.printfFlags = uint8(1)
	sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[21]int8{'B', 'L', 'O', 'O', 'M', ' ', 'F', 'I', 'L', 'T', 'E', 'R', ' ', 'O', 'N', ' ', '%', 'S', ' ', '(', '\x00'})), pItem)
	pLoop = pLevel.pWLoop
	if pLoop.wsFlags&uint32(256) != 0 {
		var pTab *struct_Table = pItem.pTab
		if int32(pTab.iPKey) >= 0 {
			sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[5]int8{'%', 's', '=', '?', '\x00'})), (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(pTab.iPKey)*20))).zCnName)
		} else {
			sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[8]int8{'r', 'o', 'w', 'i', 'd', '=', '?', '\x00'})))
		}
	} else {
		for i = int32(pLoop.nSkip); i < int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq); i++ {
			var z *int8 = explainIndexColumnName((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex, i)
			if i > int32(pLoop.nSkip) {
				sqlite3_str_append(&str, (*int8)(unsafe.Pointer(&[6]int8{' ', 'A', 'N', 'D', ' ', '\x00'})), 5)
			}
			sqlite3_str_appendf(&str, (*int8)(unsafe.Pointer(&[5]int8{'%', 's', '=', '?', '\x00'})), z)
		}
	}
	sqlite3_str_append(&str, (*int8)(unsafe.Pointer(&[2]int8{')', '\x00'})), 1)
	zMsg = sqlite3StrAccumFinish(&str)
	ret = sqlite3VdbeAddOp4(v, 183, sqlite3VdbeCurrentAddr(v), pParse.addrExplain, 0, zMsg, -7)
	return ret
}
func disableTerm(pLevel *struct_WhereLevel, pTerm *struct_WhereTerm) {
	var nLoop int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	for int32(pTerm.wtFlags)&4 == 0 && (pLevel.iLeftJoin == 0 || pTerm.pExpr.flags&uint32(1) != uint32(0)) && pLevel.notReady&pTerm.prereqAll == uint64(0) {
		if nLoop != 0 && int32(pTerm.wtFlags)&1024 != 0 {
			pTerm.wtFlags |= uint16(512)
		} else {
			pTerm.wtFlags |= uint16(4)
		}
		if pTerm.iParent < 0 {
			break
		}
		pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pTerm.pWC.a)) + uintptr(pTerm.iParent)*56))
		func() int {
			_ = 0
			return 0
		}()
		pTerm.nChild--
		if int32(pTerm.nChild) != 0 {
			break
		}
		nLoop++
	}
}
func codeApplyAffinity(pParse *struct_Parse, base int32, n int32, zAff *int8) {
	var v *struct_Vdbe = pParse.pVdbe
	if uintptr(unsafe.Pointer(zAff)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for n > 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(0)))) <= 65 {
		n--
		base++
		*(*uintptr)(unsafe.Pointer(&zAff))++
	}
	for n > 1 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(n-1)))) <= 65 {
		n--
	}
	if n > 0 {
		sqlite3VdbeAddOp4(v, 95, base, n, 0, zAff, n)
	}
}
func updateRangeAffinityStr(pRight *struct_Expr, n int32, zAff *int8) {
	var i int32
	for i = int32(0); i < n; i++ {
		var p *struct_Expr = sqlite3VectorFieldSubexpr(pRight, i)
		if int32(sqlite3CompareAffinity(p, *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(i))))) == 65 || sqlite3ExprNeedsNoAffinityChange(p, *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(i)))) != 0 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(i))) = int8(65)
		}
	}
}
func removeUnindexableInClauseTerms(pParse *struct_Parse, iEq int32, pLoop *struct_WhereLoop, pX *struct_Expr) *struct_Expr {
	var db *struct_sqlite3 = pParse.db
	var pNew *struct_Expr
	pNew = sqlite3ExprDup(db, pX, 0)
	if int32(db.mallocFailed) == 0 {
		var pOrigRhs *struct_ExprList
		var pOrigLhs *struct_ExprList
		var pRhs *struct_ExprList = nil
		var pLhs *struct_ExprList = nil
		var i int32
		var pSelect *struct_Select
		func() int {
			_ = 0
			return 0
		}()
		pOrigRhs = (*(**struct_Select)(unsafe.Pointer(&pNew.x))).pEList
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pOrigLhs = pNew.pLeft.x.pList
		for i = iEq; i < int32(pLoop.nLTerm); i++ {
			if uintptr(unsafe.Pointer((*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8))).pExpr)) == uintptr(unsafe.Pointer(pX)) {
				var iField int32
				func() int {
					_ = 0
					return 0
				}()
				iField = (*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8))).u.x.iField - 1
				if uintptr(unsafe.Pointer((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrigRhs.a)))) + uintptr(iField)*28))).pExpr)) == uintptr(unsafe.Pointer(nil)) {
					continue
				}
				pRhs = sqlite3ExprListAppend(pParse, pRhs, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrigRhs.a)))) + uintptr(iField)*28))).pExpr)
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrigRhs.a)))) + uintptr(iField)*28))).pExpr = (*struct_Expr)(nil)
				func() int {
					_ = 0
					return 0
				}()
				pLhs = sqlite3ExprListAppend(pParse, pLhs, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrigLhs.a)))) + uintptr(iField)*28))).pExpr)
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrigLhs.a)))) + uintptr(iField)*28))).pExpr = (*struct_Expr)(nil)
			}
		}
		sqlite3ExprListDelete(db, pOrigRhs)
		sqlite3ExprListDelete(db, pOrigLhs)
		pNew.pLeft.x.pList = pLhs
		(*(**struct_Select)(unsafe.Pointer(&pNew.x))).pEList = pRhs
		if pLhs != nil && pLhs.nExpr == 1 {
			var p *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pLhs.a)))) + uintptr(0)*28))).pExpr
			(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pLhs.a)))) + uintptr(0)*28))).pExpr = (*struct_Expr)(nil)
			sqlite3ExprDelete(db, pNew.pLeft)
			pNew.pLeft = p
		}
		pSelect = *(**struct_Select)(unsafe.Pointer(&pNew.x))
		if pSelect.pOrderBy != nil {
			var pOrderBy *struct_ExprList = pSelect.pOrderBy
			for i = int32(0); i < pOrderBy.nExpr; i++ {
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).u.x.iOrderByCol = uint16(0)
			}
		}
	}
	return pNew
}
func codeEqualityTerm(pParse *struct_Parse, pTerm *struct_WhereTerm, pLevel *struct_WhereLevel, iEq int32, bRev int32, iTarget int32) int32 {
	var pX *struct_Expr = pTerm.pExpr
	var v *struct_Vdbe = pParse.pVdbe
	var iReg int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pX.op) == 53 || int32(pX.op) == 45 {
		iReg = sqlite3ExprCodeTarget(pParse, pX.pRight, iTarget)
	} else if int32(pX.op) == 50 {
		iReg = iTarget
		sqlite3VdbeAddOp2(v, 74, 0, iReg)
	} else {
		var eType int32 = 5
		var iTab int32
		var pIn *struct_InLoop
		var pLoop *struct_WhereLoop = pLevel.pWLoop
		var i int32
		var nEq int32 = 0
		var aiMap *int32 = nil
		if pLoop.wsFlags&uint32(1024) == uint32(0) && uintptr(unsafe.Pointer((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex)) != uintptr(unsafe.Pointer(nil)) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex.aSortOrder)) + uintptr(iEq)))) != 0 {
			bRev = func() int32 {
				if !(bRev != 0) {
					return 1
				} else {
					return 0
				}
			}()
		}
		func() int {
			_ = 0
			return 0
		}()
		iReg = iTarget
		for i = int32(0); i < iEq; i++ {
			if *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8)) != nil && uintptr(unsafe.Pointer((*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8))).pExpr)) == uintptr(unsafe.Pointer(pX)) {
				disableTerm(pLevel, pTerm)
				return iTarget
			}
		}
		for i = iEq; i < int32(pLoop.nLTerm); i++ {
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer((*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8))).pExpr)) == uintptr(unsafe.Pointer(pX)) {
				nEq++
			}
		}
		iTab = int32(0)
		if !(pX.flags&uint32(2048) != uint32(0)) || (*(**struct_Select)(unsafe.Pointer(&pX.x))).pEList.nExpr == 1 {
			eType = sqlite3FindInIndex(pParse, pX, uint32(4), nil, nil, &iTab)
		} else {
			var db *struct_sqlite3 = pParse.db
			pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX)
			if !(db.mallocFailed != 0) {
				aiMap = (*int32)(sqlite3DbMallocZero(pParse.db, uint64(4*uint(nEq))))
				eType = sqlite3FindInIndex(pParse, pX, uint32(4), nil, aiMap, &iTab)
				pTerm.pExpr.iTable = iTab
			}
			sqlite3ExprDelete(db, pX)
			pX = pTerm.pExpr
		}
		if eType == 4 {
			bRev = func() int32 {
				if !(bRev != 0) {
					return 1
				} else {
					return 0
				}
			}()
		}
		sqlite3VdbeAddOp2(v, func() int32 {
			if bRev != 0 {
				return 34
			} else {
				return 38
			}
		}(), iTab, 0)
		func() int {
			_ = 0
			return 0
		}()
		pLoop.wsFlags |= uint32(2048)
		if pLevel.u.in.nIn == 0 {
			pLevel.addrNxt = sqlite3VdbeMakeLabel(pParse)
		}
		if iEq > 0 && pLoop.wsFlags&uint32(1048576) == uint32(0) {
			pLoop.wsFlags |= uint32(262144)
		}
		i = pLevel.u.in.nIn
		pLevel.u.in.nIn += nEq
		pLevel.u.in.aInLoop = (*struct_InLoop)(sqlite3DbReallocOrFree(pParse.db, unsafe.Pointer(pLevel.u.in.aInLoop), uint64(17*uint(pLevel.u.in.nIn))))
		pIn = pLevel.u.in.aInLoop
		if pIn != nil {
			var iMap int32 = 0
			*(*uintptr)(unsafe.Pointer(&pIn)) += uintptr(i) * 17
			for i = iEq; i < int32(pLoop.nLTerm); i++ {
				if uintptr(unsafe.Pointer((*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8))).pExpr)) == uintptr(unsafe.Pointer(pX)) {
					var iOut int32 = iReg + i - iEq
					if eType == 1 {
						pIn.addrInTop = sqlite3VdbeAddOp2(v, 134, iTab, iOut)
					} else {
						var iCol int32 = func() int32 {
							if aiMap != nil {
								return *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiMap)) + uintptr(func() (_cgo_ret int32) {
									_cgo_addr := &iMap
									_cgo_ret = *_cgo_addr
									*_cgo_addr++
									return
								}())*4))
							} else {
								return 0
							}
						}()
						pIn.addrInTop = sqlite3VdbeAddOp3(v, 93, iTab, iCol, iOut)
					}
					sqlite3VdbeAddOp1(v, 50, iOut)
					if i == iEq {
						pIn.iCur = iTab
						pIn.eEndLoopOp = uint8(func() int32 {
							if bRev != 0 {
								return 4
							} else {
								return 5
							}
						}())
						if iEq > 0 {
							pIn.iBase = iReg - i
							pIn.nPrefix = i
						} else {
							pIn.nPrefix = int32(0)
						}
					} else {
						pIn.eEndLoopOp = uint8(182)
					}
					*(*uintptr)(unsafe.Pointer(&pIn)) += 17
				}
			}
			if iEq > 0 && pLoop.wsFlags&uint32(1048576|1024) == uint32(0) {
				sqlite3VdbeAddOp3(v, 124, pLevel.iIdxCur, 0, iEq)
			}
		} else {
			pLevel.u.in.nIn = int32(0)
		}
		sqlite3DbFree(pParse.db, unsafe.Pointer(aiMap))
	}
	if pLevel.pWLoop.wsFlags&uint32(2097152) == uint32(0) || int32(pTerm.eOperator)&2048 == 0 {
		disableTerm(pLevel, pTerm)
	}
	return iReg
}
func codeAllEqualityTerms(pParse *struct_Parse, pLevel *struct_WhereLevel, bRev int32, nExtraReg int32, pzAff **int8) int32 {
	var nEq uint16
	var nSkip uint16
	var v *struct_Vdbe = pParse.pVdbe
	var pIdx *struct_Index
	var pTerm *struct_WhereTerm
	var pLoop *struct_WhereLoop
	var j int32
	var regBase int32
	var nReg int32
	var zAff *int8
	pLoop = pLevel.pWLoop
	func() int {
		_ = 0
		return 0
	}()
	nEq = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq
	nSkip = pLoop.nSkip
	pIdx = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
	func() int {
		_ = 0
		return 0
	}()
	regBase = pParse.nMem + 1
	nReg = int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq) + nExtraReg
	pParse.nMem += nReg
	zAff = sqlite3DbStrDup(pParse.db, sqlite3IndexAffinityStr(pParse.db, pIdx))
	func() int {
		_ = 0
		return 0
	}()
	if nSkip != 0 {
		var iIdxCur int32 = pLevel.iIdxCur
		sqlite3VdbeAddOp3(v, 74, 0, regBase, regBase+int32(nSkip)-1)
		sqlite3VdbeAddOp1(v, func() int32 {
			if bRev != 0 {
				return 34
			} else {
				return 38
			}
		}(), iIdxCur)
		j = sqlite3VdbeAddOp0(v, 11)
		func() int {
			_ = 0
			return 0
		}()
		pLevel.addrSkip = sqlite3VdbeAddOp4Int(v, func() int32 {
			if bRev != 0 {
				return 23
			} else {
				return 26
			}
		}(), iIdxCur, 0, regBase, int32(nSkip))
		sqlite3VdbeJumpHere(v, j)
		for j = int32(0); j < int32(nSkip); j++ {
			sqlite3VdbeAddOp3(v, 93, iIdxCur, j, regBase+j)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	for j = int32(nSkip); j < int32(nEq); j++ {
		var r1 int32
		pTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))
		func() int {
			_ = 0
			return 0
		}()
		r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase+j)
		if r1 != regBase+j {
			if nReg == 1 {
				sqlite3ReleaseTempReg(pParse, regBase)
				regBase = r1
			} else {
				sqlite3VdbeAddOp2(v, 79, r1, regBase+j)
			}
		}
	}
	for j = int32(nSkip); j < int32(nEq); j++ {
		pTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))
		if int32(pTerm.eOperator)&1 != 0 {
			if pTerm.pExpr.flags&uint32(2048) != 0 {
				if zAff != nil {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(j))) = int8(65)
				}
			}
		} else if int32(pTerm.eOperator)&256 == 0 {
			var pRight *struct_Expr = pTerm.pExpr.pRight
			if int32(pTerm.wtFlags)&2048 == 0 && sqlite3ExprCanBeNull(pRight) != 0 {
				sqlite3VdbeAddOp2(v, 50, regBase+j, pLevel.addrBrk)
			}
			if pParse.nErr == 0 {
				func() int {
					_ = 0
					return 0
				}()
				if int32(sqlite3CompareAffinity(pRight, *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(j))))) == 65 {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(j))) = int8(65)
				}
				if sqlite3ExprNeedsNoAffinityChange(pRight, *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(j)))) != 0 {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zAff)) + uintptr(j))) = int8(65)
				}
			}
		}
	}
	*pzAff = zAff
	return regBase
}
func whereLikeOptimizationStringFixup(v *struct_Vdbe, pLevel *struct_WhereLevel, pTerm *struct_WhereTerm) {
	if int32(pTerm.wtFlags)&256 != 0 {
		var pOp *struct_VdbeOp
		func() int {
			_ = 0
			return 0
		}()
		pOp = sqlite3VdbeGetOp(v, -1)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pOp.p3 = int32(pLevel.iLikeRepCntr >> 1)
		pOp.p5 = uint16(uint8(pLevel.iLikeRepCntr & uint32(1)))
	}
}
func codeDeferredSeek(pWInfo *struct_WhereInfo, pIdx *struct_Index, iCur int32, iIdxCur int32) {
	var pParse *struct_Parse = pWInfo.pParse
	var v *struct_Vdbe = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	{
		_autoGo_84 := &pWInfo.Xbf_0
		*_autoGo_84 = *_autoGo_84&^1 | uint32(1)&1
	}
	sqlite3VdbeAddOp3(v, 140, iIdxCur, 0, iCur)
	if int32(pWInfo.wctrlFlags)&32 != 0 && func() *struct_Parse {
		if pParse.pToplevel != nil {
			return pParse.pToplevel
		} else {
			return pParse
		}
	}().writeMask == uint32(0) {
		var i int32
		var pTab *struct_Table = pIdx.pTable
		var ai *uint32 = (*uint32)(sqlite3DbMallocZero(pParse.db, uint64(4*uint(int32(pTab.nCol)+1))))
		if ai != nil {
			*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(ai)) + uintptr(0)*4)) = uint32(pTab.nCol)
			for i = int32(0); i < int32(pIdx.nColumn)-1; i++ {
				var x1 int32
				var x2 int32
				func() int {
					_ = 0
					return 0
				}()
				x1 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2)))
				x2 = int32(sqlite3TableColumnToStorage(pTab, int16(x1)))
				if x1 >= 0 {
					*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(ai)) + uintptr(x2+1)*4)) = uint32(i + 1)
				}
			}
			sqlite3VdbeChangeP4(v, -1, (*int8)(unsafe.Pointer(ai)), -15)
		}
	}
}
func codeExprOrVector(pParse *struct_Parse, p *struct_Expr, iReg int32, nReg int32) {
	func() int {
		_ = 0
		return 0
	}()
	if p != nil && sqlite3ExprIsVector(p) != 0 {
		if p.flags&uint32(2048) != uint32(0) {
			var v *struct_Vdbe = pParse.pVdbe
			var iSelect int32
			func() int {
				_ = 0
				return 0
			}()
			iSelect = sqlite3CodeSubselect(pParse, p)
			sqlite3VdbeAddOp3(v, 79, iSelect, iReg, nReg-1)
		} else {
			var i int32
			var pList *struct_ExprList
			func() int {
				_ = 0
				return 0
			}()
			pList = p.x.pList
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < nReg; i++ {
				sqlite3ExprCode(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr, iReg+i)
			}
		}
	} else {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3ExprCode(pParse, p, iReg)
	}
}

type struct_IdxExprTrans struct {
	pIdxExpr *struct_Expr
	iTabCur  int32
	iIdxCur  int32
	iIdxCol  int32
	iTabCol  int32
	pWInfo   *struct_WhereInfo
	db       *struct_sqlite3
}
type IdxExprTrans = struct_IdxExprTrans

func preserveExpr(pTrans *struct_IdxExprTrans, pExpr *struct_Expr) {
	var pNew *struct_WhereExprMod
	pNew = (*struct_WhereExprMod)(sqlite3DbMallocRaw(pTrans.db, uint64(88)))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	pNew.pNext = pTrans.pWInfo.pExprMods
	pTrans.pWInfo.pExprMods = pNew
	pNew.pExpr = pExpr
	__builtin___memcpy_chk(unsafe.Pointer(&pNew.orig), unsafe.Pointer(pExpr), 72, __builtin_object_size(unsafe.Pointer(&pNew.orig), 0))
}
func whereIndexExprTransNode(p *struct_Walker, pExpr *struct_Expr) int32 {
	var pX *struct_IdxExprTrans = *(**struct_IdxExprTrans)(unsafe.Pointer(&p.u))
	if sqlite3ExprCompare(nil, pExpr, pX.pIdxExpr, pX.iTabCur) == 0 {
		preserveExpr(pX, pExpr)
		pExpr.affExpr = sqlite3ExprAffinity(pExpr)
		pExpr.op = uint8(167)
		pExpr.iTable = pX.iIdxCur
		pExpr.iColumn = int16(pX.iIdxCol)
		pExpr.flags &= uint32(4244369407)
		pExpr.y.pTab = (*struct_Table)(nil)
		return int32(1)
	} else {
		return int32(0)
	}
}
func whereIndexExprTransColumn(p *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 167 {
		var pX *struct_IdxExprTrans = *(**struct_IdxExprTrans)(unsafe.Pointer(&p.u))
		if pExpr.iTable == pX.iTabCur && int32(pExpr.iColumn) == pX.iTabCol {
			func() int {
				_ = 0
				return 0
			}()
			preserveExpr(pX, pExpr)
			pExpr.affExpr = sqlite3TableColumnAffinity(pExpr.y.pTab, int32(pExpr.iColumn))
			pExpr.iTable = pX.iIdxCur
			pExpr.iColumn = int16(pX.iIdxCol)
			pExpr.y.pTab = (*struct_Table)(nil)
		}
	}
	return int32(0)
}
func whereIndexExprTrans(pIdx *struct_Index, iTabCur int32, iIdxCur int32, pWInfo *struct_WhereInfo) {
	var iIdxCol int32
	var aColExpr *struct_ExprList
	var pTab *struct_Table
	var w struct_Walker
	var x struct_IdxExprTrans
	aColExpr = pIdx.aColExpr
	if uintptr(unsafe.Pointer(aColExpr)) == uintptr(unsafe.Pointer(nil)) && !(pIdx.Xbf_0>>10&1 != 0) {
		return
	}
	pTab = pIdx.pTable
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	*(**struct_IdxExprTrans)(unsafe.Pointer(&w.u)) = &x
	x.iTabCur = iTabCur
	x.iIdxCur = iIdxCur
	x.pWInfo = pWInfo
	x.db = pWInfo.pParse.db
	for iIdxCol = int32(0); iIdxCol < int32(pIdx.nColumn); iIdxCol++ {
		var iRef int16 = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(iIdxCol)*2))
		if int32(iRef) == -2 {
			func() int {
				_ = 0
				return 0
			}()
			x.pIdxExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&aColExpr.a)))) + uintptr(iIdxCol)*28))).pExpr
			if sqlite3ExprIsConstant(x.pIdxExpr) != 0 {
				continue
			}
			w.xExprCallback = whereIndexExprTransNode
		} else if int32(iRef) >= 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iRef)*20))).colFlags)&32 != 0 && (int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iRef)*20))).colFlags)&512 == 0 || sqlite3StrICmp(sqlite3ColumnColl(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iRef)*20))), (*int8)(unsafe.Pointer(&sqlite3StrBINARY))) == 0) {
			x.iTabCol = int32(iRef)
			w.xExprCallback = whereIndexExprTransColumn
		} else {
			continue
		}
		x.iIdxCol = iIdxCol
		sqlite3WalkExpr(&w, pWInfo.pWhere)
		sqlite3WalkExprList(&w, pWInfo.pOrderBy)
		sqlite3WalkExprList(&w, pWInfo.pResultSet)
	}
}
func whereApplyPartialIndexConstraints(pTruth *struct_Expr, iTabCur int32, pWC *struct_WhereClause) {
	var i int32
	var pTerm *struct_WhereTerm
	for int32(pTruth.op) == 44 {
		whereApplyPartialIndexConstraints(pTruth.pLeft, iTabCur, pWC)
		pTruth = pTruth.pRight
	}
	for func() *struct_WhereTerm {
		i = int32(0)
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			*_cgo_addr = pWC.a
			return *_cgo_addr
		}()
	}(); i < pWC.nTerm; func() *struct_WhereTerm {
		i++
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		var pExpr *struct_Expr
		if int32(pTerm.wtFlags)&4 != 0 {
			continue
		}
		pExpr = pTerm.pExpr
		if sqlite3ExprCompare(nil, pExpr, pTruth, iTabCur) == 0 {
			pTerm.wtFlags |= uint16(4)
		}
	}
}
func filterPullDown(pParse *struct_Parse, pWInfo *struct_WhereInfo, iLevel int32, addrNxt int32, notReady uint64) {
	for func() (_cgo_ret int32) {
		_cgo_addr := &iLevel
		*_cgo_addr++
		return *_cgo_addr
	}() < int32(pWInfo.nLevel) {
		var pLevel *struct_WhereLevel = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(iLevel)*104))
		var pLoop *struct_WhereLoop = pLevel.pWLoop
		if pLevel.regFilter == 0 {
			continue
		}
		if pLevel.pWLoop.nSkip != 0 {
			continue
		}
		if pLoop.prereq&notReady != 0 {
			continue
		}
		if pLoop.wsFlags&uint32(256) != 0 {
			var pTerm *struct_WhereTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(0)*8))
			var regRowid int32
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			regRowid = sqlite3GetTempReg(pParse)
			regRowid = codeEqualityTerm(pParse, pTerm, pLevel, 0, 0, regRowid)
			sqlite3VdbeAddOp4Int(pParse.pVdbe, 63, pLevel.regFilter, addrNxt, regRowid, 1)
		} else {
			var nEq uint16 = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq
			var r1 int32
			var zStartAff *int8
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			r1 = codeAllEqualityTerms(pParse, pLevel, 0, 0, &zStartAff)
			codeApplyAffinity(pParse, r1, int32(nEq), zStartAff)
			sqlite3DbFree(pParse.db, unsafe.Pointer(zStartAff))
			sqlite3VdbeAddOp4Int(pParse.pVdbe, 63, pLevel.regFilter, addrNxt, r1, int32(nEq))
		}
		pLevel.regFilter = int32(0)
	}
}
func sqlite3WhereCodeOneLoopStart(pParse *struct_Parse, v *struct_Vdbe, pWInfo *struct_WhereInfo, iLevel int32, pLevel *struct_WhereLevel, notReady uint64) uint64 {
	var j int32
	var k int32
	var iCur int32
	var addrNxt int32
	var bRev int32
	var pLoop *struct_WhereLoop
	var pWC *struct_WhereClause
	var pTerm *struct_WhereTerm
	var db *struct_sqlite3
	var pTabItem *struct_SrcItem
	var addrBrk int32
	var addrHalt int32
	var addrCont int32
	var iRowidReg int32 = 0
	var iReleaseReg int32 = 0
	var pIdx *struct_Index = nil
	var iLoop int32
	pWC = &pWInfo.sWC
	db = pParse.db
	pLoop = pLevel.pWLoop
	pTabItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLevel.iFrom)*112))
	iCur = pTabItem.iCursor
	pLevel.notReady = notReady & ^sqlite3WhereGetMask(&pWInfo.sMaskSet, iCur)
	bRev = int32(pWInfo.revMask >> iLevel & uint64(1))
	addrBrk = func() (_cgo_ret int32) {
		_cgo_addr := &pLevel.addrBrk
		*_cgo_addr = func() (_cgo_ret int32) {
			_cgo_addr := &pLevel.addrNxt
			*_cgo_addr = sqlite3VdbeMakeLabel(pParse)
			return *_cgo_addr
		}()
		return *_cgo_addr
	}()
	addrCont = func() (_cgo_ret int32) {
		_cgo_addr := &pLevel.addrCont
		*_cgo_addr = sqlite3VdbeMakeLabel(pParse)
		return *_cgo_addr
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pLevel.iFrom) > 0 && int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer(pTabItem)) + uintptr(0)*112))).fg.jointype)&8 != 0 {
		pLevel.iLeftJoin = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 71, 0, pLevel.iLeftJoin)
	}
	for j = iLevel; j > 0 && (*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(j)*104))).iLeftJoin == 0; j-- {
	}
	addrHalt = (*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(j)*104))).addrBrk
	if pTabItem.fg.Xbf_0>>4&1 != 0 {
		var regYield int32 = pTabItem.regReturn
		sqlite3VdbeAddOp3(v, 13, regYield, 0, pTabItem.addrFillSub)
		pLevel.p2 = sqlite3VdbeAddOp2(v, 14, regYield, addrBrk)
		pLevel.op = uint8(11)
	} else if pLoop.wsFlags&uint32(1024) != uint32(0) {
		var iReg int32
		var addrNotFound int32
		var nConstraint int32 = int32(pLoop.nLTerm)
		iReg = sqlite3GetTempRange(pParse, nConstraint+2)
		addrNotFound = pLevel.addrBrk
		for j = int32(0); j < nConstraint; j++ {
			var iTarget int32 = iReg + j + 2
			pTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))
			if uintptr(unsafe.Pointer(pTerm)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			if int32(pTerm.eOperator)&1 != 0 {
				if func() uint32 {
					if j <= 31 {
						return uint32(1) << j
					} else {
						return uint32(0)
					}
				}()&pLoop.u.vtab.mHandleIn != 0 {
					var iTab int32 = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nTab
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
					var iCache int32 = func() (_cgo_ret int32) {
						_cgo_addr := &pParse.nMem
						*_cgo_addr++
						return *_cgo_addr
					}()
					sqlite3CodeRhsOfIN(pParse, pTerm.pExpr, iTab)
					sqlite3VdbeAddOp3(v, 173, iTab, iTarget, iCache)
				} else {
					codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget)
					addrNotFound = pLevel.addrNxt
				}
			} else {
				var pRight *struct_Expr = pTerm.pExpr.pRight
				codeExprOrVector(pParse, pRight, iTarget, 1)
				if int32(pTerm.eMatchOp) == 74 && int32(pLoop.u.vtab.Xbf_0>>1&1) != 0 {
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					func() int {
						_ = 0
						return 0
					}()
					sqlite3VdbeAddOp2(v, 71, 0, pWInfo.pLimit.iOffset)
				}
			}
		}
		sqlite3VdbeAddOp2(v, 71, pLoop.u.vtab.idxNum, iReg)
		sqlite3VdbeAddOp2(v, 71, nConstraint, iReg+1)
		sqlite3VdbeAddOp4(v, 9, iCur, addrNotFound, iReg, pLoop.u.vtab.idxStr, func() int32 {
			if int32(pLoop.u.vtab.Xbf_0&1) != 0 {
				return -7
			} else {
				return -1
			}
		}())
		{
			_autoGo_85 := &pLoop.u.vtab.Xbf_0
			*_autoGo_85 = *_autoGo_85&^1 | uint32(0)&1
		}
		if db.mallocFailed != 0 {
			pLoop.u.vtab.idxStr = (*int8)(nil)
		}
		pLevel.p1 = iCur
		pLevel.op = uint8(func() int32 {
			if int32(pWInfo.eOnePass) != 0 {
				return 182
			} else {
				return 62
			}
		}())
		pLevel.p2 = sqlite3VdbeCurrentAddr(v)
		func() int {
			_ = 0
			return 0
		}()
		for j = int32(0); j < nConstraint; j++ {
			pTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))
			if j < 16 && int32(pLoop.u.vtab.omitMask)>>j&1 != 0 {
				disableTerm(pLevel, pTerm)
				continue
			}
			if int32(pTerm.eOperator)&1 != 0 && func() uint32 {
				if j <= 31 {
					return uint32(1) << j
				} else {
					return uint32(0)
				}
			}()&pLoop.u.vtab.mHandleIn == uint32(0) && !(db.mallocFailed != 0) {
				var pCompare *struct_Expr
				var pRight *struct_Expr
				var pOp *struct_VdbeOp
				var iIn int32
				for iIn = int32(0); iIn < pLevel.u.in.nIn; iIn++ {
					pOp = sqlite3VdbeGetOp(v, (*(*struct_InLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pLevel.u.in.aInLoop)) + uintptr(iIn)*17))).addrInTop)
					if int32(pOp.opcode) == 93 && pOp.p3 == iReg+j+2 || int32(pOp.opcode) == 134 && pOp.p2 == iReg+j+2 {
						sqlite3VdbeAddOp3(v, int32(pOp.opcode), pOp.p1, pOp.p2, pOp.p3)
						break
					}
				}
				pCompare = sqlite3PExpr(pParse, 53, nil, nil)
				if !(db.mallocFailed != 0) {
					var iFld int32 = pTerm.u.x.iField
					var pLeft *struct_Expr = pTerm.pExpr.pLeft
					func() int {
						_ = 0
						return 0
					}()
					if iFld > 0 {
						func() int {
							_ = 0
							return 0
						}()
						func() int {
							_ = 0
							return 0
						}()
						func() int {
							_ = 0
							return 0
						}()
						pCompare.pLeft = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pLeft.x.pList.a)))) + uintptr(iFld-1)*28))).pExpr
					} else {
						pCompare.pLeft = pLeft
					}
					pCompare.pRight = func() (_cgo_ret *struct_Expr) {
						_cgo_addr := &pRight
						*_cgo_addr = sqlite3Expr(db, 176, nil)
						return *_cgo_addr
					}()
					if pRight != nil {
						pRight.iTable = iReg + j + 2
						sqlite3ExprIfFalse(pParse, pCompare, pLevel.addrCont, 16)
					}
					pCompare.pLeft = (*struct_Expr)(nil)
				}
				sqlite3ExprDelete(db, pCompare)
			}
		}
	} else if pLoop.wsFlags&uint32(256) != uint32(0) && pLoop.wsFlags&uint32(4|1) != uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		pTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(0)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		iReleaseReg = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg)
		if iRowidReg != iReleaseReg {
			sqlite3ReleaseTempReg(pParse, iReleaseReg)
		}
		addrNxt = pLevel.addrNxt
		if pLevel.regFilter != 0 {
			sqlite3VdbeAddOp4Int(v, 63, pLevel.regFilter, addrNxt, iRowidReg, 1)
			filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady)
		}
		sqlite3VdbeAddOp3(v, 32, iCur, addrNxt, iRowidReg)
		pLevel.op = uint8(182)
	} else if pLoop.wsFlags&uint32(256) != uint32(0) && pLoop.wsFlags&uint32(2) != uint32(0) {
		var testOp int32 = 182
		var start int32
		var memEndValue int32 = 0
		var pStart *struct_WhereTerm
		var pEnd *struct_WhereTerm
		j = int32(0)
		pStart = func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pEnd
			*_cgo_addr = (*struct_WhereTerm)(nil)
			return *_cgo_addr
		}()
		if pLoop.wsFlags&uint32(32) != 0 {
			pStart = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8))
		}
		if pLoop.wsFlags&uint32(16) != 0 {
			pEnd = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8))
		}
		func() int {
			_ = 0
			return 0
		}()
		if bRev != 0 {
			pTerm = pStart
			pStart = pEnd
			pEnd = pTerm
		}
		if pStart != nil {
			var pX *struct_Expr
			var r1 int32
			var rTemp int32
			var op int32
			var aMoveOp [4]uint8 = [4]uint8{uint8(26), uint8(24), uint8(23), uint8(25)}
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pX = pStart.pExpr
			func() int {
				_ = 0
				return 0
			}()
			if sqlite3ExprIsVector(pX.pRight) != 0 {
				r1 = func() (_cgo_ret int32) {
					_cgo_addr := &rTemp
					*_cgo_addr = sqlite3GetTempReg(pParse)
					return *_cgo_addr
				}()
				codeExprOrVector(pParse, pX.pRight, r1, 1)
				op = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMoveOp)))) + uintptr((int32(pX.op)-54-1)&3|1))))
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
			} else {
				r1 = sqlite3ExprCodeTemp(pParse, pX.pRight, &rTemp)
				disableTerm(pLevel, pStart)
				op = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aMoveOp)))) + uintptr(int32(pX.op)-54))))
			}
			sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1)
			sqlite3ReleaseTempReg(pParse, rTemp)
		} else {
			sqlite3VdbeAddOp2(v, func() int32 {
				if bRev != 0 {
					return 34
				} else {
					return 38
				}
			}(), iCur, addrHalt)
		}
		if pEnd != nil {
			var pX *struct_Expr
			pX = pEnd.pExpr
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			memEndValue = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			codeExprOrVector(pParse, pX.pRight, memEndValue, 1)
			if 0 == sqlite3ExprIsVector(pX.pRight) && (int32(pX.op) == 56 || int32(pX.op) == 54) {
				testOp = func() int32 {
					if bRev != 0 {
						return 55
					} else {
						return 57
					}
				}()
			} else {
				testOp = func() int32 {
					if bRev != 0 {
						return 56
					} else {
						return 54
					}
				}()
			}
			if 0 == sqlite3ExprIsVector(pX.pRight) {
				disableTerm(pLevel, pEnd)
			}
		}
		start = sqlite3VdbeCurrentAddr(v)
		pLevel.op = uint8(func() int32 {
			if bRev != 0 {
				return 4
			} else {
				return 5
			}
		}())
		pLevel.p1 = iCur
		pLevel.p2 = start
		func() int {
			_ = 0
			return 0
		}()
		if testOp != 182 {
			iRowidReg = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3VdbeAddOp2(v, 134, iCur, iRowidReg)
			sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg)
			sqlite3VdbeChangeP5(v, uint16(67|16))
		}
	} else if pLoop.wsFlags&uint32(512) != 0 {
		var aStartOp [8]uint8 = [8]uint8{uint8(0), uint8(0), uint8(38), uint8(34), uint8(26), uint8(23), uint8(25), uint8(24)}
		var aEndOp [4]uint8 = [4]uint8{uint8(42), uint8(40), uint8(39), uint8(41)}
		var nEq uint16 = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq
		var nBtm uint16 = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nBtm
		var nTop uint16 = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nTop
		var regBase int32
		var pRangeStart *struct_WhereTerm = nil
		var pRangeEnd *struct_WhereTerm = nil
		var startEq int32
		var endEq int32
		var start_constraints int32
		var nConstraint int32
		var iIdxCur int32
		var nExtraReg int32 = 0
		var op int32
		var zStartAff *int8
		var zEndAff *int8 = nil
		var bSeekPastNull uint8 = uint8(0)
		var bStopAtNull uint8 = uint8(0)
		var omitTable int32
		var regBignull int32 = 0
		var addrSeekScan int32 = 0
		pIdx = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
		iIdxCur = pLevel.iIdxCur
		func() int {
			_ = 0
			return 0
		}()
		j = int32(nEq)
		if pLoop.wsFlags&uint32(32) != 0 {
			pRangeStart = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8))
			nExtraReg = func() int32 {
				if nExtraReg > int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nBtm) {
					return nExtraReg
				} else {
					return int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nBtm)
				}
			}()
			func() int {
				_ = 0
				return 0
			}()
		}
		if pLoop.wsFlags&uint32(16) != 0 {
			pRangeEnd = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &j
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())*8))
			nExtraReg = func() int32 {
				if nExtraReg > int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nTop) {
					return nExtraReg
				} else {
					return int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nTop)
				}
			}()
			if int32(pRangeEnd.wtFlags)&256 != 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pLevel.iLikeRepCntr = uint32(func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}())
				sqlite3VdbeAddOp2(v, 71, 1, int32(pLevel.iLikeRepCntr))
				pLevel.addrLikeRep = sqlite3VdbeCurrentAddr(v)
				func() int {
					_ = 0
					return 0
				}()
				pLevel.iLikeRepCntr <<= 1
				pLevel.iLikeRepCntr |= uint32(bRev ^ func() int32 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(nEq)))) == 1 {
						return 1
					} else {
						return 0
					}
				}())
			}
			if uintptr(unsafe.Pointer(pRangeStart)) == uintptr(unsafe.Pointer(nil)) {
				j = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(nEq)*2)))
				if j >= 0 && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.pTable.aCol)) + uintptr(j)*20))).Xbf_0&15) == 0 || j == -2 {
					bSeekPastNull = uint8(1)
				}
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		if pLoop.wsFlags&uint32(16|32) == uint32(0) && pLoop.wsFlags&uint32(524288) != uint32(0) {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			nExtraReg = int32(1)
			bSeekPastNull = uint8(1)
			pLevel.regBignull = func() (_cgo_ret int32) {
				_cgo_addr := &regBignull
				*_cgo_addr = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
				return *_cgo_addr
			}()
			if pLevel.iLeftJoin != 0 {
				sqlite3VdbeAddOp2(v, 71, 0, regBignull)
			}
			pLevel.addrBignull = sqlite3VdbeMakeLabel(pParse)
		}
		if int32(nEq) < int32(pIdx.nColumn) && bRev == func() int32 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(nEq)))) == 0 {
				return 1
			} else {
				return 0
			}
		}() {
			{
				var t *struct_WhereTerm = pRangeEnd
				pRangeEnd = pRangeStart
				pRangeStart = t
			}
			{
				var t uint8 = bSeekPastNull
				bSeekPastNull = bStopAtNull
				bStopAtNull = t
			}
			{
				var t uint8 = uint8(nBtm)
				nBtm = nTop
				nTop = uint16(t)
			}
		}
		if iLevel > 0 && pLoop.wsFlags&uint32(1048576) != uint32(0) {
			sqlite3VdbeAddOp1(v, 135, iIdxCur)
		}
		regBase = codeAllEqualityTerms(pParse, pLevel, bRev, nExtraReg, &zStartAff)
		func() int {
			_ = 0
			return 0
		}()
		if zStartAff != nil && int32(nTop) != 0 {
			zEndAff = sqlite3DbStrDup(db, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStartAff)) + uintptr(nEq))))
		}
		addrNxt = func() int32 {
			if regBignull != 0 {
				return pLevel.addrBignull
			} else {
				return pLevel.addrNxt
			}
		}()
		startEq = func() int32 {
			if !(pRangeStart != nil) || int32(pRangeStart.eOperator)&(2<<(55-53)|2<<(57-53)) != 0 {
				return 1
			} else {
				return 0
			}
		}()
		endEq = func() int32 {
			if !(pRangeEnd != nil) || int32(pRangeEnd.eOperator)&(2<<(55-53)|2<<(57-53)) != 0 {
				return 1
			} else {
				return 0
			}
		}()
		start_constraints = func() int32 {
			if pRangeStart != nil || int32(nEq) > 0 {
				return 1
			} else {
				return 0
			}
		}()
		nConstraint = int32(nEq)
		if pRangeStart != nil {
			var pRight *struct_Expr = pRangeStart.pExpr.pRight
			codeExprOrVector(pParse, pRight, regBase+int32(nEq), int32(nBtm))
			whereLikeOptimizationStringFixup(v, pLevel, pRangeStart)
			if int32(pRangeStart.wtFlags)&128 == 0 && sqlite3ExprCanBeNull(pRight) != 0 {
				sqlite3VdbeAddOp2(v, 50, regBase+int32(nEq), addrNxt)
			}
			if zStartAff != nil {
				updateRangeAffinityStr(pRight, int32(nBtm), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zStartAff)) + uintptr(nEq))))
			}
			nConstraint += int32(nBtm)
			if sqlite3ExprIsVector(pRight) == 0 {
				disableTerm(pLevel, pRangeStart)
			} else {
				startEq = int32(1)
			}
			bSeekPastNull = uint8(0)
		} else if bSeekPastNull != 0 {
			startEq = int32(0)
			sqlite3VdbeAddOp2(v, 74, 0, regBase+int32(nEq))
			start_constraints = int32(1)
			nConstraint++
		} else if regBignull != 0 {
			sqlite3VdbeAddOp2(v, 74, 0, regBase+int32(nEq))
			start_constraints = int32(1)
			nConstraint++
		}
		codeApplyAffinity(pParse, regBase, nConstraint-int32(bSeekPastNull), zStartAff)
		if int32(pLoop.nSkip) > 0 && nConstraint == int32(pLoop.nSkip) {
		} else {
			if regBignull != 0 {
				sqlite3VdbeAddOp2(v, 71, 1, regBignull)
			}
			if pLevel.regFilter != 0 {
				sqlite3VdbeAddOp4Int(v, 63, pLevel.regFilter, addrNxt, regBase, int32(nEq))
				filterPullDown(pParse, pWInfo, iLevel, addrNxt, notReady)
			}
			op = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aStartOp)))) + uintptr(start_constraints<<2+startEq<<1+bRev))))
			func() int {
				_ = 0
				return 0
			}()
			if pLoop.wsFlags&uint32(1048576) != uint32(0) && op == 25 {
				func() int {
					_ = 0
					return 0
				}()
				addrSeekScan = sqlite3VdbeAddOp1(v, 123, (int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiRowLogEst)) + uintptr(0)*2)))+9)/10)
			}
			sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint)
			func() int {
				_ = 0
				return 0
			}()
			if regBignull != 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp2(v, 11, 0, sqlite3VdbeCurrentAddr(v)+2)
				op = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aStartOp)))) + uintptr(func() int32 {
					if nConstraint > 1 {
						return 1
					} else {
						return 0
					}
				}()*4+2+bRev))))
				sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint-startEq)
				func() int {
					_ = 0
					return 0
				}()
			}
		}
		nConstraint = int32(nEq)
		func() int {
			_ = 0
			return 0
		}()
		if pRangeEnd != nil {
			var pRight *struct_Expr = pRangeEnd.pExpr.pRight
			if addrSeekScan != 0 {
				pLevel.p2 = sqlite3VdbeCurrentAddr(v)
			}
			codeExprOrVector(pParse, pRight, regBase+int32(nEq), int32(nTop))
			whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd)
			if int32(pRangeEnd.wtFlags)&128 == 0 && sqlite3ExprCanBeNull(pRight) != 0 {
				sqlite3VdbeAddOp2(v, 50, regBase+int32(nEq), addrNxt)
			}
			if zEndAff != nil {
				updateRangeAffinityStr(pRight, int32(nTop), zEndAff)
				codeApplyAffinity(pParse, regBase+int32(nEq), int32(nTop), zEndAff)
			} else {
				func() int {
					_ = 0
					return 0
				}()
			}
			nConstraint += int32(nTop)
			if sqlite3ExprIsVector(pRight) == 0 {
				disableTerm(pLevel, pRangeEnd)
			} else {
				endEq = int32(1)
			}
		} else if bStopAtNull != 0 {
			if regBignull == 0 {
				sqlite3VdbeAddOp2(v, 74, 0, regBase+int32(nEq))
				endEq = int32(0)
			}
			nConstraint++
		}
		sqlite3DbFree(db, unsafe.Pointer(zStartAff))
		sqlite3DbFree(db, unsafe.Pointer(zEndAff))
		if pLevel.p2 == 0 {
			pLevel.p2 = sqlite3VdbeCurrentAddr(v)
		}
		if nConstraint != 0 {
			if regBignull != 0 {
				sqlite3VdbeAddOp2(v, 20, regBignull, sqlite3VdbeCurrentAddr(v)+3)
			}
			op = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aEndOp)))) + uintptr(bRev*2+endEq))))
			sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint)
			if addrSeekScan != 0 {
				sqlite3VdbeJumpHere(v, addrSeekScan)
			}
		}
		if regBignull != 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 18, regBignull, sqlite3VdbeCurrentAddr(v)+2)
			op = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aEndOp)))) + uintptr(bRev*2+int32(bSeekPastNull)))))
			sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint+int32(bSeekPastNull))
		}
		if pLoop.wsFlags&uint32(262144) != uint32(0) {
			sqlite3VdbeAddOp3(v, 124, iIdxCur, int32(nEq), int32(nEq))
		}
		omitTable = func() int32 {
			if pLoop.wsFlags&uint32(64) != uint32(0) && int32(pWInfo.wctrlFlags)&32 == 0 {
				return 1
			} else {
				return 0
			}
		}()
		if omitTable != 0 {
		} else if pIdx.pTable.tabFlags&uint32(128) == uint32(0) {
			codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur)
		} else if iCur != iIdxCur {
			var pPk *struct_Index = sqlite3PrimaryKeyIndex(pIdx.pTable)
			iRowidReg = sqlite3GetTempRange(pParse, int32(pPk.nKeyCol))
			for j = int32(0); j < int32(pPk.nKeyCol); j++ {
				k = int32(sqlite3TableColumnToIndex(pIdx, *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(j)*2))))
				sqlite3VdbeAddOp3(v, 93, iIdxCur, k, iRowidReg+j)
			}
			sqlite3VdbeAddOp4Int(v, 30, iCur, addrCont, iRowidReg, int32(pPk.nKeyCol))
		}
		if pLevel.iLeftJoin == 0 {
			if int32(pWInfo.wctrlFlags)&32 == 0 {
				whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo)
			}
			if pIdx.pPartIdxWhere != nil {
				whereApplyPartialIndexConstraints(pIdx.pPartIdxWhere, iCur, pWC)
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
		}
		if pLoop.wsFlags&uint32(4096) != 0 {
			pLevel.op = uint8(182)
		} else if bRev != 0 {
			pLevel.op = uint8(4)
		} else {
			pLevel.op = uint8(5)
		}
		pLevel.p1 = iIdxCur
		pLevel.p3 = uint8(func() int32 {
			if pLoop.wsFlags&uint32(65536) != uint32(0) {
				return 1
			} else {
				return 0
			}
		}())
		if pLoop.wsFlags&uint32(15) == uint32(0) {
			pLevel.p5 = uint8(1)
		} else {
			func() int {
				_ = 0
				return 0
			}()
		}
		if omitTable != 0 {
			pIdx = (*struct_Index)(nil)
		}
	} else if pLoop.wsFlags&uint32(8192) != 0 {
		var pOrWc *struct_WhereClause
		var pOrTab *struct_SrcList
		var pCov *struct_Index = nil
		var iCovCur int32 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		var regReturn int32 = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		var regRowset int32 = 0
		var regRowid int32 = 0
		var iLoopBody int32 = sqlite3VdbeMakeLabel(pParse)
		var iRetInit int32
		var untestedTerms int32 = 0
		var ii int32
		var pAndExpr *struct_Expr = nil
		var pTab *struct_Table = pTabItem.pTab
		pTerm = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(0)*8))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pOrWc = &(*(**struct_WhereOrInfo)(unsafe.Pointer(&pTerm.u))).wc
		pLevel.op = uint8(67)
		pLevel.p1 = regReturn
		if int32(pWInfo.nLevel) > 1 {
			var nNotReady int32
			var origSrc *struct_SrcItem
			nNotReady = int32(pWInfo.nLevel) - iLevel - 1
			pOrTab = (*struct_SrcList)(sqlite3DbMallocRaw(db, uint64(120+uint(nNotReady)*112)))
			if uintptr(unsafe.Pointer(pOrTab)) == uintptr(unsafe.Pointer(nil)) {
				return notReady
			}
			pOrTab.nAlloc = uint32(uint8(nNotReady + 1))
			pOrTab.nSrc = int32(pOrTab.nAlloc)
			__builtin___memcpy_chk(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pOrTab.a))), unsafe.Pointer(pTabItem), 112, __builtin_object_size(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pOrTab.a))), 0))
			origSrc = (*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a))
			for k = int32(1); k <= nNotReady; k++ {
				__builtin___memcpy_chk(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pOrTab.a)))) + uintptr(k)*112))), unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer(origSrc)) + uintptr((*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer(pLevel)) + uintptr(k)*104))).iFrom)*112))), 112, __builtin_object_size(unsafe.Pointer(&*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pOrTab.a)))) + uintptr(k)*112))), 0))
			}
		} else {
			pOrTab = pWInfo.pTabList
		}
		if int32(pWInfo.wctrlFlags)&16 == 0 {
			if pTab.tabFlags&uint32(128) == uint32(0) {
				regRowset = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nMem
					*_cgo_addr++
					return *_cgo_addr
				}()
				sqlite3VdbeAddOp2(v, 74, 0, regRowset)
			} else {
				var pPk *struct_Index = sqlite3PrimaryKeyIndex(pTab)
				regRowset = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nTab
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
				sqlite3VdbeAddOp2(v, 116, regRowset, int32(pPk.nKeyCol))
				sqlite3VdbeSetP4KeyInfo(pParse, pPk)
			}
			regRowid = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
		}
		iRetInit = sqlite3VdbeAddOp2(v, 71, 0, regReturn)
		if pWC.nTerm > 1 {
			var iTerm int32
			for iTerm = int32(0); iTerm < pWC.nTerm; iTerm++ {
				var pExpr *struct_Expr = (*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iTerm)*56))).pExpr
				if uintptr(unsafe.Pointer(&*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iTerm)*56)))) == uintptr(unsafe.Pointer(pTerm)) {
					continue
				}
				if int32((*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iTerm)*56))).wtFlags)&(2|4|32768) != 0 {
					continue
				}
				if int32((*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iTerm)*56))).eOperator)&8191 == 0 {
					continue
				}
				if pExpr.flags&uint32(2097152) != uint32(0) {
					continue
				}
				pExpr = sqlite3ExprDup(db, pExpr, 0)
				pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr)
			}
			if pAndExpr != nil {
				pAndExpr = sqlite3PExpr(pParse, 44|65536, nil, pAndExpr)
			}
		}
		sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[15]int8{'M', 'U', 'L', 'T', 'I', '-', 'I', 'N', 'D', 'E', 'X', ' ', 'O', 'R', '\x00'})))
		for ii = int32(0); ii < pOrWc.nTerm; ii++ {
			var pOrTerm *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pOrWc.a)) + uintptr(ii)*56))
			if pOrTerm.leftCursor == iCur || int32(pOrTerm.eOperator)&1024 != 0 {
				var pSubWInfo *struct_WhereInfo
				var pOrExpr *struct_Expr = pOrTerm.pExpr
				var pDelete *struct_Expr
				var jmp1 int32 = 0
				pDelete = func() (_cgo_ret *struct_Expr) {
					_cgo_addr := &pOrExpr
					*_cgo_addr = sqlite3ExprDup(db, pOrExpr, 0)
					return *_cgo_addr
				}()
				if db.mallocFailed != 0 {
					sqlite3ExprDelete(db, pDelete)
					continue
				}
				if pAndExpr != nil {
					pAndExpr.pLeft = pOrExpr
					pOrExpr = pAndExpr
				}
				sqlite3VdbeExplain(pParse, uint8(1), (*int8)(unsafe.Pointer(&[9]int8{'I', 'N', 'D', 'E', 'X', ' ', '%', 'd', '\x00'})), ii+1)
				pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, nil, nil, nil, uint16(32), iCovCur)
				func() int {
					_ = 0
					return 0
				}()
				if pSubWInfo != nil {
					var pSubLoop *struct_WhereLoop
					var addrExplain int32 = sqlite3WhereExplainOneScan(pParse, pOrTab, &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pSubWInfo.a)))) + uintptr(0)*104)), uint16(0))
					func() int {
						_ = addrExplain
						return 0
					}()
					if int32(pWInfo.wctrlFlags)&16 == 0 {
						var iSet int32 = func() int32 {
							if ii == pOrWc.nTerm-1 {
								return -1
							} else {
								return ii
							}
						}()
						if pTab.tabFlags&uint32(128) == uint32(0) {
							sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid)
							jmp1 = sqlite3VdbeAddOp4Int(v, 46, regRowset, 0, regRowid, iSet)
						} else {
							var pPk *struct_Index = sqlite3PrimaryKeyIndex(pTab)
							var nPk int32 = int32(pPk.nKeyCol)
							var iPk int32
							var r int32
							r = sqlite3GetTempRange(pParse, nPk)
							for iPk = int32(0); iPk < nPk; iPk++ {
								var iCol int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(iPk)*2)))
								sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r+iPk)
							}
							if iSet != 0 {
								jmp1 = sqlite3VdbeAddOp4Int(v, 31, regRowset, 0, r, nPk)
							}
							if iSet >= 0 {
								sqlite3VdbeAddOp3(v, 96, r, nPk, regRowid)
								sqlite3VdbeAddOp4Int(v, 137, regRowset, regRowid, r, nPk)
								if iSet != 0 {
									sqlite3VdbeChangeP5(v, uint16(16))
								}
							}
							sqlite3ReleaseTempRange(pParse, r, nPk)
						}
					}
					sqlite3VdbeAddOp2(v, 12, regReturn, iLoopBody)
					if jmp1 != 0 {
						sqlite3VdbeJumpHere(v, jmp1)
					}
					if pSubWInfo.Xbf_0>>1&1 != 0 {
						untestedTerms = int32(1)
					}
					pSubLoop = (*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pSubWInfo.a)))) + uintptr(0)*104))).pWLoop
					func() int {
						_ = 0
						return 0
					}()
					if pSubLoop.wsFlags&uint32(512) != uint32(0) && (ii == 0 || uintptr(unsafe.Pointer((*(*_cgoa_84)(unsafe.Pointer(&pSubLoop.u))).pIndex)) == uintptr(unsafe.Pointer(pCov))) && (pTab.tabFlags&uint32(128) == uint32(0) || !(int32((*(*_cgoa_84)(unsafe.Pointer(&pSubLoop.u))).pIndex.Xbf_0&3) == 2)) {
						func() int {
							_ = 0
							return 0
						}()
						pCov = (*(*_cgoa_84)(unsafe.Pointer(&pSubLoop.u))).pIndex
					} else {
						pCov = (*struct_Index)(nil)
					}
					if sqlite3WhereUsesDeferredSeek(pSubWInfo) != 0 {
						{
							_autoGo_86 := &pWInfo.Xbf_0
							*_autoGo_86 = *_autoGo_86&^1 | uint32(1)&1
						}
					}
					sqlite3WhereEnd(pSubWInfo)
					sqlite3VdbeExplainPop(pParse)
				}
				sqlite3ExprDelete(db, pDelete)
			}
		}
		sqlite3VdbeExplainPop(pParse)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		*(**struct_Index)(unsafe.Pointer(&pLevel.u)) = pCov
		if pCov != nil {
			pLevel.iIdxCur = iCovCur
		}
		if pAndExpr != nil {
			pAndExpr.pLeft = (*struct_Expr)(nil)
			sqlite3ExprDelete(db, pAndExpr)
		}
		sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v))
		sqlite3VdbeGoto(v, pLevel.addrBrk)
		sqlite3VdbeResolveLabel(v, iLoopBody)
		if int32(pWInfo.nLevel) > 1 {
			sqlite3DbFree(db, unsafe.Pointer(pOrTab))
		}
		if !(untestedTerms != 0) {
			disableTerm(pLevel, pTerm)
		}
	} else {
		var aStep [2]uint8 = [2]uint8{uint8(5), uint8(4)}
		var aStart [2]uint8 = [2]uint8{uint8(38), uint8(34)}
		func() int {
			_ = 0
			return 0
		}()
		if pTabItem.fg.Xbf_0>>5&1 != 0 {
			pLevel.op = uint8(182)
		} else {
			pLevel.op = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aStep)))) + uintptr(bRev)))
			pLevel.p1 = iCur
			pLevel.p2 = 1 + sqlite3VdbeAddOp2(v, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aStart)))) + uintptr(bRev)))), iCur, addrHalt)
			pLevel.p5 = uint8(1)
		}
	}
	iLoop = func() int32 {
		if pIdx != nil {
			return 1
		} else {
			return 2
		}
	}()
	for {
		var iNext int32 = 0
		for func() int32 {
			pTerm = pWC.a
			return func() (_cgo_ret int32) {
				_cgo_addr := &j
				*_cgo_addr = pWC.nTerm
				return *_cgo_addr
			}()
		}(); j > 0; func() *struct_WhereTerm {
			j--
			return func() (_cgo_ret *struct_WhereTerm) {
				_cgo_addr := &pTerm
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
				return
			}()
		}() {
			var pE *struct_Expr
			var skipLikeAddr int32 = 0
			if int32(pTerm.wtFlags)&(2|4) != 0 {
				continue
			}
			if pTerm.prereqAll&pLevel.notReady != uint64(0) {
				{
					_autoGo_87 := &pWInfo.Xbf_0
					*_autoGo_87 = *_autoGo_87&^2 | uint32(1)&1<<1
				}
				continue
			}
			pE = pTerm.pExpr
			func() int {
				_ = 0
				return 0
			}()
			if int32(pTabItem.fg.jointype)&8 != 0 && !(pE.flags&uint32(1) != uint32(0)) {
				continue
			}
			if iLoop == 1 && !(sqlite3ExprCoveredByIndex(pE, pLevel.iTabCur, pIdx) != 0) {
				iNext = int32(2)
				continue
			}
			if iLoop < 3 && int32(pTerm.wtFlags)&4096 != 0 {
				if iNext == 0 {
					iNext = int32(3)
				}
				continue
			}
			if int32(pTerm.wtFlags)&512 != 0 {
				var x uint32 = pLevel.iLikeRepCntr
				if x > uint32(0) {
					skipLikeAddr = sqlite3VdbeAddOp1(v, func() int32 {
						if x&uint32(1) != 0 {
							return 20
						} else {
							return 18
						}
					}(), int32(x>>1))
				}
			}
			sqlite3ExprIfFalse(pParse, pE, addrCont, 16)
			if skipLikeAddr != 0 {
				sqlite3VdbeJumpHere(v, skipLikeAddr)
			}
			pTerm.wtFlags |= uint16(4)
		}
		iLoop = iNext
		if !(iLoop > 0) {
			break
		}
	}
	for func() int32 {
		pTerm = pWC.a
		return func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = pWC.nBase
			return *_cgo_addr
		}()
	}(); j > 0; func() *struct_WhereTerm {
		j--
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		var pE *struct_Expr
		var sEAlt struct_Expr
		var pAlt *struct_WhereTerm
		if int32(pTerm.wtFlags)&(2|4) != 0 {
			continue
		}
		if int32(pTerm.eOperator)&(2|128) == 0 {
			continue
		}
		if int32(pTerm.eOperator)&2048 == 0 {
			continue
		}
		if pTerm.leftCursor != iCur {
			continue
		}
		if int32(pTabItem.fg.jointype)&8 != 0 {
			continue
		}
		pE = pTerm.pExpr
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm.u.x.leftColumn, notReady, uint32(2|1|128), nil)
		if uintptr(unsafe.Pointer(pAlt)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if int32(pAlt.wtFlags)&4 != 0 {
			continue
		}
		if int32(pAlt.eOperator)&1 != 0 && pAlt.pExpr.flags&uint32(2048) != uint32(0) && (*(**struct_Select)(unsafe.Pointer(&pAlt.pExpr.x))).pEList.nExpr > 1 {
			continue
		}
		sEAlt = *pAlt.pExpr
		sEAlt.pLeft = pE.pLeft
		sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, 16)
		pAlt.wtFlags |= uint16(4)
	}
	if pLevel.iLeftJoin != 0 {
		pLevel.addrFirst = sqlite3VdbeCurrentAddr(v)
		sqlite3VdbeAddOp2(v, 71, 1, pLevel.iLeftJoin)
		for func() int32 {
			pTerm = pWC.a
			return func() (_cgo_ret int32) {
				_cgo_addr := &j
				*_cgo_addr = int32(0)
				return *_cgo_addr
			}()
		}(); j < pWC.nBase; func() *struct_WhereTerm {
			j++
			return func() (_cgo_ret *struct_WhereTerm) {
				_cgo_addr := &pTerm
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
				return
			}()
		}() {
			if int32(pTerm.wtFlags)&(2|4) != 0 {
				continue
			}
			if pTerm.prereqAll&pLevel.notReady != uint64(0) {
				func() int {
					_ = 0
					return 0
				}()
				continue
			}
			func() int {
				_ = 0
				return 0
			}()
			sqlite3ExprIfFalse(pParse, pTerm.pExpr, addrCont, 16)
			pTerm.wtFlags |= uint16(4)
		}
	}
	return pLevel.notReady
}
func whereOrInfoDelete(db *struct_sqlite3, p *struct_WhereOrInfo) {
	sqlite3WhereClauseClear(&p.wc)
	sqlite3DbFree(db, unsafe.Pointer(p))
}
func whereAndInfoDelete(db *struct_sqlite3, p *struct_WhereAndInfo) {
	sqlite3WhereClauseClear(&p.wc)
	sqlite3DbFree(db, unsafe.Pointer(p))
}
func whereClauseInsert(pWC *struct_WhereClause, p *struct_Expr, wtFlags uint16) int32 {
	var pTerm *struct_WhereTerm
	var idx int32
	if pWC.nTerm >= pWC.nSlot {
		var pOld *struct_WhereTerm = pWC.a
		var db *struct_sqlite3 = pWC.pWInfo.pParse.db
		pWC.a = (*struct_WhereTerm)(sqlite3DbMallocRawNN(db, uint64(56*uint(pWC.nSlot)*uint(2))))
		if uintptr(unsafe.Pointer(pWC.a)) == uintptr(unsafe.Pointer(nil)) {
			if int32(wtFlags)&1 != 0 {
				sqlite3ExprDelete(db, p)
			}
			pWC.a = pOld
			return int32(0)
		}
		__builtin___memcpy_chk(unsafe.Pointer(pWC.a), unsafe.Pointer(pOld), 56*uint(pWC.nTerm), __builtin_object_size(unsafe.Pointer(pWC.a), 0))
		if uintptr(unsafe.Pointer(pOld)) != uintptr(unsafe.Pointer((*struct_WhereTerm)(unsafe.Pointer(&pWC.aStatic)))) {
			sqlite3DbFree(db, unsafe.Pointer(pOld))
		}
		pWC.nSlot = int32(uint(sqlite3DbMallocSize(db, unsafe.Pointer(pWC.a))) / 56)
	}
	pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &idx
		*_cgo_addr = func() (_cgo_ret int32) {
			_cgo_addr := &pWC.nTerm
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		return *_cgo_addr
	}())*56))
	if int32(wtFlags)&2 == 0 {
		pWC.nBase = pWC.nTerm
	}
	if p != nil && p.flags&uint32(262144) != uint32(0) {
		pTerm.truthProb = int16(int32(sqlite3LogEst(uint64(p.iTable))) - 270)
	} else {
		pTerm.truthProb = int16(1)
	}
	pTerm.pExpr = sqlite3ExprSkipCollateAndLikely(p)
	pTerm.wtFlags = wtFlags
	pTerm.pWC = pWC
	pTerm.iParent = int32(-1)
	__builtin___memset_chk(unsafe.Pointer(&pTerm.eOperator), 0, 56-20, __builtin_object_size(unsafe.Pointer(&pTerm.eOperator), 0))
	return idx
}
func allowedOp(op int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if op == 49 || op >= 53 && op <= 57 || op == 50 || op == 45 {
			return 1
		} else {
			return 0
		}
	}()
}
func exprCommute(pParse *struct_Parse, pExpr *struct_Expr) uint16 {
	if int32(pExpr.pLeft.op) == 177 || int32(pExpr.pRight.op) == 177 || uintptr(unsafe.Pointer(sqlite3BinaryCompareCollSeq(pParse, pExpr.pLeft, pExpr.pRight))) != uintptr(unsafe.Pointer(sqlite3BinaryCompareCollSeq(pParse, pExpr.pRight, pExpr.pLeft))) {
		pExpr.flags ^= uint32(512)
	}
	{
		var t *struct_Expr = pExpr.pRight
		pExpr.pRight = pExpr.pLeft
		pExpr.pLeft = t
	}
	if int32(pExpr.op) >= 54 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		pExpr.op = uint8(int32(pExpr.op) - 54 ^ 2 + 54)
	}
	return uint16(0)
}
func operatorMask(op int32) uint16 {
	var c uint16
	func() int {
		_ = 0
		return 0
	}()
	if op == 49 {
		c = uint16(1)
	} else if op == 50 {
		c = uint16(256)
	} else if op == 45 {
		c = uint16(128)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		c = uint16(2 << (op - 53))
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return c
}
func isLikeOrGlob(pParse *struct_Parse, pExpr *struct_Expr, ppPrefix **struct_Expr, pisComplete *int32, pnoCase *int32) int32 {
	var z *uint8 = nil
	var pRight *struct_Expr
	var pLeft *struct_Expr
	var pList *struct_ExprList
	var c uint8
	var cnt int32
	var wc [4]uint8
	var db *struct_sqlite3 = pParse.db
	var pVal *struct_sqlite3_value = nil
	var op int32
	var rc int32
	if !(sqlite3IsLikeFunction(db, pExpr, pnoCase, (*int8)(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc))))) != 0) {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	pList = pExpr.x.pList
	pLeft = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(1)*28))).pExpr
	pRight = sqlite3ExprSkipCollate((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr)
	op = int32(pRight.op)
	if op == 156 && db.flags&uint64(8388608) == uint64(0) {
		var pReprepare *struct_Vdbe = pParse.pReprepare
		var iCol int32 = int32(pRight.iColumn)
		pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, uint8(65))
		if pVal != nil && sqlite3_value_type(pVal) == 3 {
			z = sqlite3_value_text(pVal)
		}
		sqlite3VdbeSetVarmask(pParse.pVdbe, iCol)
		func() int {
			_ = 0
			return 0
		}()
	} else if op == 117 {
		func() int {
			_ = 0
			return 0
		}()
		z = (*uint8)(unsafe.Pointer(pRight.u.zToken))
	}
	if z != nil {
		cnt = int32(0)
		for int32(func() (_cgo_ret uint8) {
			_cgo_addr := &c
			*_cgo_addr = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(cnt)))
			return *_cgo_addr
		}()) != 0 && int32(c) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(0)))) && int32(c) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(1)))) && int32(c) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(2)))) {
			cnt++
			if int32(c) == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(3)))) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(cnt)))) != 0 {
				cnt++
			}
		}
		if cnt != 0 && 255 != int32(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(cnt-1))))) && (cnt > 1 || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(3))))) {
			var pPrefix *struct_Expr
			*pisComplete = func() int32 {
				if int32(c) == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(0)))) && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(cnt+1)))) == 0 {
					return 1
				} else {
					return 0
				}
			}()
			pPrefix = sqlite3Expr(db, 117, (*int8)(unsafe.Pointer(z)))
			if pPrefix != nil {
				var iFrom int32
				var iTo int32
				var zNew *int8
				func() int {
					_ = 0
					return 0
				}()
				zNew = pPrefix.u.zToken
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(cnt))) = int8(0)
				for iFrom = func() (_cgo_ret int32) {
					_cgo_addr := &iTo
					*_cgo_addr = int32(0)
					return *_cgo_addr
				}(); iFrom < cnt; iFrom++ {
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(iFrom)))) == int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&wc)))) + uintptr(3)))) {
						iFrom++
					}
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &iTo
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()))) = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(iFrom)))
				}
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(iTo))) = int8(0)
				func() int {
					_ = 0
					return 0
				}()
				if int32(pLeft.op) != 167 || int32(sqlite3ExprAffinity(pLeft)) != 66 || pLeft.flags&uint32(16777216|33554432) == uint32(0) && pLeft.y.pTab != nil && int32(pLeft.y.pTab.eTabType) == 1 {
					var isNum int32
					var rDummy float64
					isNum = sqlite3AtoF(zNew, &rDummy, iTo, uint8(1))
					if isNum <= 0 {
						if iTo == 1 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(0)))) == '-' {
							isNum = int32(1)
						} else {
							*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(iTo-1)))++
							isNum = sqlite3AtoF(zNew, &rDummy, iTo, uint8(1))
							*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zNew)) + uintptr(iTo-1)))--
						}
					}
					if isNum > 0 {
						sqlite3ExprDelete(db, pPrefix)
						sqlite3ValueFree(pVal)
						return int32(0)
					}
				}
			}
			*ppPrefix = pPrefix
			if op == 156 {
				var v *struct_Vdbe = pParse.pVdbe
				sqlite3VdbeSetVarmask(v, int32(pRight.iColumn))
				func() int {
					_ = 0
					return 0
				}()
				if *pisComplete != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pRight.u.zToken)) + uintptr(1)))) != 0 {
					var r1 int32 = sqlite3GetTempReg(pParse)
					sqlite3ExprCodeTarget(pParse, pRight, r1)
					sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0)
					sqlite3ReleaseTempReg(pParse, r1)
				}
			}
		} else {
			z = (*uint8)(nil)
		}
	}
	rc = func() int32 {
		if uintptr(unsafe.Pointer(z)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	sqlite3ValueFree(pVal)
	return rc
}
func isAuxiliaryVtabOperator(db *struct_sqlite3, pExpr *struct_Expr, peOp2 *uint8, ppLeft **struct_Expr, ppRight **struct_Expr) int32 {
	if int32(pExpr.op) == 172 {
		type struct_Op2 struct {
			zOp  *int8
			eOp2 uint8
		}
		var aOp [4]struct_Op2 = [4]struct_Op2{struct_Op2{(*int8)(unsafe.Pointer(&[6]int8{'m', 'a', 't', 'c', 'h', '\x00'})), uint8(64)}, struct_Op2{(*int8)(unsafe.Pointer(&[5]int8{'g', 'l', 'o', 'b', '\x00'})), uint8(66)}, struct_Op2{(*int8)(unsafe.Pointer(&[5]int8{'l', 'i', 'k', 'e', '\x00'})), uint8(65)}, struct_Op2{(*int8)(unsafe.Pointer(&[7]int8{'r', 'e', 'g', 'e', 'x', 'p', '\x00'})), uint8(67)}}
		var pList *struct_ExprList
		var pCol *struct_Expr
		var i int32
		func() int {
			_ = 0
			return 0
		}()
		pList = pExpr.x.pList
		if uintptr(unsafe.Pointer(pList)) == uintptr(unsafe.Pointer(nil)) || pList.nExpr != 2 {
			return int32(0)
		}
		pCol = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(1)*28))).pExpr
		func() int {
			_ = 0
			return 0
		}()
		if int32(pCol.op) == 167 && uintptr(unsafe.Pointer(pCol.y.pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pCol.y.pTab.eTabType) == 1 {
			for i = int32(0); i < int32(57/9); i++ {
				func() int {
					_ = 0
					return 0
				}()
				if sqlite3StrICmp(pExpr.u.zToken, (*(*struct_Op2)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Op2)(unsafe.Pointer(&aOp)))) + uintptr(i)*9))).zOp) == 0 {
					*peOp2 = (*(*struct_Op2)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_Op2)(unsafe.Pointer(&aOp)))) + uintptr(i)*9))).eOp2
					*ppRight = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr
					*ppLeft = pCol
					return int32(1)
				}
			}
		}
		pCol = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr
		func() int {
			_ = 0
			return 0
		}()
		if int32(pCol.op) == 167 && uintptr(unsafe.Pointer(pCol.y.pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pCol.y.pTab.eTabType) == 1 {
			var pVtab *struct_sqlite3_vtab
			var pMod *struct_sqlite3_module
			var xNotUsed func(*struct_sqlite3_context, int32, **struct_sqlite3_value)
			var pNotUsed unsafe.Pointer
			pVtab = sqlite3GetVTable(db, pCol.y.pTab).pVtab
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pMod = (*struct_sqlite3_module)(unsafe.Pointer(pVtab.pModule))
			if uintptr(unsafe.Pointer(pMod.xFindFunction)) != uintptr(unsafe.Pointer(nil)) {
				i = pMod.xFindFunction(pVtab, 2, pExpr.u.zToken, &xNotUsed, &pNotUsed)
				if i >= 150 {
					*peOp2 = uint8(i)
					*ppRight = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(1)*28))).pExpr
					*ppLeft = pCol
					return int32(1)
				}
			}
		}
	} else if int32(pExpr.op) == 52 || int32(pExpr.op) == 171 || int32(pExpr.op) == 51 {
		var res int32 = 0
		var pLeft *struct_Expr = pExpr.pLeft
		var pRight *struct_Expr = pExpr.pRight
		func() int {
			_ = 0
			return 0
		}()
		if int32(pLeft.op) == 167 && uintptr(unsafe.Pointer(pLeft.y.pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pLeft.y.pTab.eTabType) == 1 {
			res++
		}
		func() int {
			_ = 0
			return 0
		}()
		if pRight != nil && (int32(pRight.op) == 167 && uintptr(unsafe.Pointer(pRight.y.pTab)) != uintptr(unsafe.Pointer(nil)) && int32(pRight.y.pTab.eTabType) == 1) {
			res++
			{
				var t *struct_Expr = pLeft
				pLeft = pRight
				pRight = t
			}
		}
		*ppLeft = pLeft
		*ppRight = pRight
		if int32(pExpr.op) == 52 {
			*peOp2 = uint8(68)
		}
		if int32(pExpr.op) == 171 {
			*peOp2 = uint8(69)
		}
		if int32(pExpr.op) == 51 {
			*peOp2 = uint8(70)
		}
		return res
	}
	return int32(0)
}
func transferJoinMarkings(pDerived *struct_Expr, pBase *struct_Expr) {
	if pDerived != nil {
		pDerived.flags |= pBase.flags & uint32(1)
		pDerived.w.iRightJoinTable = pBase.w.iRightJoinTable
	}
}
func markTermAsChild(pWC *struct_WhereClause, iChild int32, iParent int32) {
	(*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iChild)*56))).iParent = iParent
	(*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iChild)*56))).truthProb = (*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iParent)*56))).truthProb
	(*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(iParent)*56))).nChild++
}
func whereNthSubterm(pTerm *struct_WhereTerm, N int32) *struct_WhereTerm {
	if int32(pTerm.eOperator) != 1024 {
		return func() *struct_WhereTerm {
			if N == 0 {
				return pTerm
			} else {
				return nil
			}
		}()
	}
	if N < (*(**struct_WhereAndInfo)(unsafe.Pointer(&pTerm.u))).wc.nTerm {
		return &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer((*(**struct_WhereAndInfo)(unsafe.Pointer(&pTerm.u))).wc.a)) + uintptr(N)*56))
	}
	return (*struct_WhereTerm)(nil)
}
func whereCombineDisjuncts(pSrc *struct_SrcList, pWC *struct_WhereClause, pOne *struct_WhereTerm, pTwo *struct_WhereTerm) {
	var eOp uint16 = uint16(int32(pOne.eOperator) | int32(pTwo.eOperator))
	var db *struct_sqlite3
	var pNew *struct_Expr
	var op int32
	var idxNew int32
	if (int32(pOne.wtFlags)|int32(pTwo.wtFlags))&128 != 0 {
		return
	}
	if int32(pOne.eOperator)&(2|2<<(56-53)|2<<(55-53)|2<<(54-53)|2<<(57-53)) == 0 {
		return
	}
	if int32(pTwo.eOperator)&(2|2<<(56-53)|2<<(55-53)|2<<(54-53)|2<<(57-53)) == 0 {
		return
	}
	if int32(eOp)&(2|2<<(56-53)|2<<(55-53)) != int32(eOp) && int32(eOp)&(2|2<<(54-53)|2<<(57-53)) != int32(eOp) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3ExprCompare(nil, pOne.pExpr.pLeft, pTwo.pExpr.pLeft, -1) != 0 {
		return
	}
	if sqlite3ExprCompare(nil, pOne.pExpr.pRight, pTwo.pExpr.pRight, -1) != 0 {
		return
	}
	if int32(eOp)&(int32(eOp)-1) != 0 {
		if int32(eOp)&(2<<(56-53)|2<<(55-53)) != 0 {
			eOp = uint16(2 << (55 - 53))
		} else {
			func() int {
				_ = 0
				return 0
			}()
			eOp = uint16(2 << (57 - 53))
		}
	}
	db = pWC.pWInfo.pParse.db
	pNew = sqlite3ExprDup(db, pOne.pExpr, 0)
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	for op = int32(53); int(int32(eOp)) != 2<<(op-53); op++ {
		func() int {
			_ = 0
			return 0
		}()
	}
	pNew.op = uint8(op)
	idxNew = whereClauseInsert(pWC, pNew, uint16(2|1))
	exprAnalyze(pSrc, pWC, idxNew)
}
func exprAnalyzeOrTerm(pSrc *struct_SrcList, pWC *struct_WhereClause, idxTerm int32) {
	var pWInfo *struct_WhereInfo = pWC.pWInfo
	var pParse *struct_Parse = pWInfo.pParse
	var db *struct_sqlite3 = pParse.db
	var pTerm *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
	var pExpr *struct_Expr = pTerm.pExpr
	var i int32
	var pOrWc *struct_WhereClause
	var pOrTerm *struct_WhereTerm
	var pOrInfo *struct_WhereOrInfo
	var chngToIN uint64
	var indexable uint64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*(**struct_WhereOrInfo)(unsafe.Pointer(&pTerm.u)) = func() (_cgo_ret *struct_WhereOrInfo) {
		_cgo_addr := &pOrInfo
		*_cgo_addr = (*struct_WhereOrInfo)(sqlite3DbMallocZero(db, uint64(496)))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(pOrInfo)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	pTerm.wtFlags |= uint16(16)
	pOrWc = &pOrInfo.wc
	__builtin___memset_chk(unsafe.Pointer((*struct_WhereTerm)(unsafe.Pointer(&pOrWc.aStatic))), 0, 448, __builtin_object_size(unsafe.Pointer((*struct_WhereTerm)(unsafe.Pointer(&pOrWc.aStatic))), 0))
	sqlite3WhereClauseInit(pOrWc, pWInfo)
	sqlite3WhereSplit(pOrWc, pExpr, uint8(43))
	sqlite3WhereExprAnalyze(pSrc, pOrWc)
	if db.mallocFailed != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	indexable = ^uint64(0)
	chngToIN = ^uint64(0)
	for func() *struct_WhereTerm {
		i = pOrWc.nTerm - 1
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pOrTerm
			*_cgo_addr = pOrWc.a
			return *_cgo_addr
		}()
	}(); i >= 0 && indexable != 0; func() *struct_WhereTerm {
		i--
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pOrTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		if int32(pOrTerm.eOperator)&511 == 0 {
			var pAndInfo *struct_WhereAndInfo
			func() int {
				_ = 0
				return 0
			}()
			chngToIN = uint64(0)
			pAndInfo = (*struct_WhereAndInfo)(sqlite3DbMallocRawNN(db, uint64(488)))
			if pAndInfo != nil {
				var pAndWC *struct_WhereClause
				var pAndTerm *struct_WhereTerm
				var j int32
				var b uint64 = uint64(0)
				*(**struct_WhereAndInfo)(unsafe.Pointer(&pOrTerm.u)) = pAndInfo
				pOrTerm.wtFlags |= uint16(32)
				pOrTerm.eOperator = uint16(1024)
				pOrTerm.leftCursor = int32(-1)
				pAndWC = &pAndInfo.wc
				__builtin___memset_chk(unsafe.Pointer((*struct_WhereTerm)(unsafe.Pointer(&pAndWC.aStatic))), 0, 448, __builtin_object_size(unsafe.Pointer((*struct_WhereTerm)(unsafe.Pointer(&pAndWC.aStatic))), 0))
				sqlite3WhereClauseInit(pAndWC, pWC.pWInfo)
				sqlite3WhereSplit(pAndWC, pOrTerm.pExpr, uint8(44))
				sqlite3WhereExprAnalyze(pSrc, pAndWC)
				pAndWC.pOuter = pWC
				if !(db.mallocFailed != 0) {
					for func() *struct_WhereTerm {
						j = int32(0)
						return func() (_cgo_ret *struct_WhereTerm) {
							_cgo_addr := &pAndTerm
							*_cgo_addr = pAndWC.a
							return *_cgo_addr
						}()
					}(); j < pAndWC.nTerm; func() *struct_WhereTerm {
						j++
						return func() (_cgo_ret *struct_WhereTerm) {
							_cgo_addr := &pAndTerm
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
							return
						}()
					}() {
						func() int {
							_ = 0
							return 0
						}()
						if allowedOp(int32(pAndTerm.pExpr.op)) != 0 || int32(pAndTerm.eOperator) == 64 {
							b |= sqlite3WhereGetMask(&pWInfo.sMaskSet, pAndTerm.leftCursor)
						}
					}
				}
				indexable &= b
			}
		} else if int32(pOrTerm.wtFlags)&8 != 0 {
		} else {
			var b uint64
			b = sqlite3WhereGetMask(&pWInfo.sMaskSet, pOrTerm.leftCursor)
			if int32(pOrTerm.wtFlags)&2 != 0 {
				var pOther *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pOrWc.a)) + uintptr(pOrTerm.iParent)*56))
				b |= sqlite3WhereGetMask(&pWInfo.sMaskSet, pOther.leftCursor)
			}
			indexable &= b
			if int32(pOrTerm.eOperator)&2 == 0 {
				chngToIN = uint64(0)
			} else {
				chngToIN &= b
			}
		}
	}
	pOrInfo.indexable = indexable
	pTerm.eOperator = uint16(512)
	pTerm.leftCursor = int32(-1)
	if indexable != 0 {
		pWC.hasOr = uint8(1)
	}
	if indexable != 0 && pOrWc.nTerm == 2 {
		var iOne int32 = 0
		var pOne *struct_WhereTerm
		for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pOne
			*_cgo_addr = whereNthSubterm(&*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pOrWc.a)) + uintptr(0)*56)), func() (_cgo_ret int32) {
				_cgo_addr := &iOne
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}())
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			var iTwo int32 = 0
			var pTwo *struct_WhereTerm
			for uintptr(unsafe.Pointer(func() (_cgo_ret *struct_WhereTerm) {
				_cgo_addr := &pTwo
				*_cgo_addr = whereNthSubterm(&*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pOrWc.a)) + uintptr(1)*56)), func() (_cgo_ret int32) {
					_cgo_addr := &iTwo
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())
				return *_cgo_addr
			}())) != uintptr(unsafe.Pointer(nil)) {
				whereCombineDisjuncts(pSrc, pWC, pOne, pTwo)
			}
		}
	}
	if chngToIN != 0 {
		var okToChngToIN int32 = 0
		var iColumn int32 = -1
		var iCursor int32 = -1
		var j int32 = 0
		for j = int32(0); j < 2 && !(okToChngToIN != 0); j++ {
			var pLeft *struct_Expr = nil
			pOrTerm = pOrWc.a
			for i = pOrWc.nTerm - 1; i >= 0; func() *struct_WhereTerm {
				i--
				return func() (_cgo_ret *struct_WhereTerm) {
					_cgo_addr := &pOrTerm
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return
				}()
			}() {
				func() int {
					_ = 0
					return 0
				}()
				pOrTerm.wtFlags &= uint16(^64)
				if pOrTerm.leftCursor == iCursor {
					func() int {
						_ = 0
						return 0
					}()
					continue
				}
				if chngToIN&sqlite3WhereGetMask(&pWInfo.sMaskSet, pOrTerm.leftCursor) == uint64(0) {
					func() int {
						_ = 0
						return 0
					}()
					continue
				}
				func() int {
					_ = 0
					return 0
				}()
				iColumn = pOrTerm.u.x.leftColumn
				iCursor = pOrTerm.leftCursor
				pLeft = pOrTerm.pExpr.pLeft
				break
			}
			if i < 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				break
			}
			okToChngToIN = int32(1)
			for ; i >= 0 && okToChngToIN != 0; func() *struct_WhereTerm {
				i--
				return func() (_cgo_ret *struct_WhereTerm) {
					_cgo_addr := &pOrTerm
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return
				}()
			}() {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if pOrTerm.leftCursor != iCursor {
					pOrTerm.wtFlags &= uint16(^64)
				} else if pOrTerm.u.x.leftColumn != iColumn || iColumn == -2 && sqlite3ExprCompare(pParse, pOrTerm.pExpr.pLeft, pLeft, -1) != 0 {
					okToChngToIN = int32(0)
				} else {
					var affLeft int32
					var affRight int32
					affRight = int32(sqlite3ExprAffinity(pOrTerm.pExpr.pRight))
					affLeft = int32(sqlite3ExprAffinity(pOrTerm.pExpr.pLeft))
					if affRight != 0 && affRight != affLeft {
						okToChngToIN = int32(0)
					} else {
						pOrTerm.wtFlags |= uint16(64)
					}
				}
			}
		}
		if okToChngToIN != 0 {
			var pDup *struct_Expr
			var pList *struct_ExprList = nil
			var pLeft *struct_Expr = nil
			var pNew *struct_Expr
			for func() *struct_WhereTerm {
				i = pOrWc.nTerm - 1
				return func() (_cgo_ret *struct_WhereTerm) {
					_cgo_addr := &pOrTerm
					*_cgo_addr = pOrWc.a
					return *_cgo_addr
				}()
			}(); i >= 0; func() *struct_WhereTerm {
				i--
				return func() (_cgo_ret *struct_WhereTerm) {
					_cgo_addr := &pOrTerm
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return
				}()
			}() {
				if int32(pOrTerm.wtFlags)&64 == 0 {
					continue
				}
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pDup = sqlite3ExprDup(db, pOrTerm.pExpr.pRight, 0)
				pList = sqlite3ExprListAppend(pWInfo.pParse, pList, pDup)
				pLeft = pOrTerm.pExpr.pLeft
			}
			func() int {
				_ = 0
				return 0
			}()
			pDup = sqlite3ExprDup(db, pLeft, 0)
			pNew = sqlite3PExpr(pParse, 49, pDup, nil)
			if pNew != nil {
				var idxNew int32
				transferJoinMarkings(pNew, pExpr)
				func() int {
					_ = 0
					return 0
				}()
				pNew.x.pList = pList
				idxNew = whereClauseInsert(pWC, pNew, uint16(2|1))
				exprAnalyze(pSrc, pWC, idxNew)
				markTermAsChild(pWC, idxNew, idxTerm)
			} else {
				sqlite3ExprListDelete(db, pList)
			}
		}
	}
}
func termIsEquivalence(pParse *struct_Parse, pExpr *struct_Expr) int32 {
	var aff1 int8
	var aff2 int8
	var pColl *struct_CollSeq
	if !(pParse.db.dbOptFlags&uint32(128) == uint32(0)) {
		return int32(0)
	}
	if int32(pExpr.op) != 53 && int32(pExpr.op) != 45 {
		return int32(0)
	}
	if pExpr.flags&uint32(1) != uint32(0) {
		return int32(0)
	}
	aff1 = sqlite3ExprAffinity(pExpr.pLeft)
	aff2 = sqlite3ExprAffinity(pExpr.pRight)
	if int32(aff1) != int32(aff2) && (!(int32(aff1) >= 67) || !(int32(aff2) >= 67)) {
		return int32(0)
	}
	pColl = sqlite3ExprCompareCollSeq(pParse, pExpr)
	if sqlite3IsBinary(pColl) != 0 {
		return int32(1)
	}
	return sqlite3ExprCollSeqMatch(pParse, pExpr.pLeft, pExpr.pRight)
}
func exprSelectUsage(pMaskSet *struct_WhereMaskSet, pS *struct_Select) uint64 {
	var mask uint64 = uint64(0)
	for pS != nil {
		var pSrc *struct_SrcList = pS.pSrc
		mask |= sqlite3WhereExprListUsage(pMaskSet, pS.pEList)
		mask |= sqlite3WhereExprListUsage(pMaskSet, pS.pGroupBy)
		mask |= sqlite3WhereExprListUsage(pMaskSet, pS.pOrderBy)
		mask |= sqlite3WhereExprUsage(pMaskSet, pS.pWhere)
		mask |= sqlite3WhereExprUsage(pMaskSet, pS.pHaving)
		if uintptr(unsafe.Pointer(pSrc)) != uintptr(unsafe.Pointer(nil)) {
			var i int32
			for i = int32(0); i < pSrc.nSrc; i++ {
				mask |= exprSelectUsage(pMaskSet, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).pSelect)
				mask |= sqlite3WhereExprUsage(pMaskSet, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).pOn)
				if (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).fg.Xbf_0>>2&1 != 0 {
					mask |= sqlite3WhereExprListUsage(pMaskSet, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSrc.a)))) + uintptr(i)*112))).u1)))
				}
			}
		}
		pS = pS.pPrior
	}
	return mask
}
func exprMightBeIndexed2(pFrom *struct_SrcList, mPrereq uint64, aiCurCol *int32, pExpr *struct_Expr) int32 {
	var pIdx *struct_Index
	var i int32
	var iCur int32
	for i = int32(0); mPrereq > uint64(1); func() uint64 {
		i++
		return func() (_cgo_ret uint64) {
			_cgo_addr := &mPrereq
			*_cgo_addr >>= 1
			return *_cgo_addr
		}()
	}() {
	}
	iCur = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pFrom.a)))) + uintptr(i)*112))).iCursor
	for pIdx = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pFrom.a)))) + uintptr(i)*112))).pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
		if uintptr(unsafe.Pointer(pIdx.aColExpr)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		for i = int32(0); i < int32(pIdx.nKeyCol); i++ {
			if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i)*2))) != -2 {
				continue
			}
			if sqlite3ExprCompareSkip(pExpr, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(i)*28))).pExpr, iCur) == 0 {
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCurCol)) + uintptr(0)*4)) = iCur
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCurCol)) + uintptr(1)*4)) = int32(-2)
				return int32(1)
			}
		}
	}
	return int32(0)
}
func exprMightBeIndexed(pFrom *struct_SrcList, mPrereq uint64, aiCurCol *int32, pExpr *struct_Expr, op int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32(pExpr.op) == 177 && (op >= 54 && op <= 57) {
		func() int {
			_ = 0
			return 0
		}()
		pExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(0)*28))).pExpr
	}
	if int32(pExpr.op) == 167 {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCurCol)) + uintptr(0)*4)) = pExpr.iTable
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(aiCurCol)) + uintptr(1)*4)) = int32(pExpr.iColumn)
		return int32(1)
	}
	if mPrereq == uint64(0) {
		return int32(0)
	}
	if mPrereq&(mPrereq-uint64(1)) != uint64(0) {
		return int32(0)
	}
	return exprMightBeIndexed2(pFrom, mPrereq, aiCurCol, pExpr)
}
func exprAnalyze(pSrc *struct_SrcList, pWC *struct_WhereClause, idxTerm int32) {
	var pWInfo *struct_WhereInfo = pWC.pWInfo
	var pTerm *struct_WhereTerm
	var pMaskSet *struct_WhereMaskSet
	var pExpr *struct_Expr
	var prereqLeft uint64
	var prereqAll uint64
	var extraRight uint64 = uint64(0)
	var pStr1 *struct_Expr = nil
	var isComplete int32 = 0
	var noCase int32 = 0
	var op int32
	var pParse *struct_Parse = pWInfo.pParse
	var db *struct_sqlite3 = pParse.db
	var eOp2 uint8 = uint8(0)
	var nLeft int32
	if db.mallocFailed != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
	pMaskSet = &pWInfo.sMaskSet
	pExpr = pTerm.pExpr
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pMaskSet.bVarSelect = int32(0)
	prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr.pLeft)
	op = int32(pExpr.op)
	if op == 49 {
		func() int {
			_ = 0
			return 0
		}()
		if sqlite3ExprCheckIN(pParse, pExpr) != 0 {
			return
		}
		if pExpr.flags&uint32(2048) != uint32(0) {
			pTerm.prereqRight = exprSelectUsage(pMaskSet, *(**struct_Select)(unsafe.Pointer(&pExpr.x)))
		} else {
			pTerm.prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr.x.pList)
		}
		prereqAll = prereqLeft | pTerm.prereqRight
	} else {
		pTerm.prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr.pRight)
		if uintptr(unsafe.Pointer(pExpr.pLeft)) == uintptr(unsafe.Pointer(nil)) || pExpr.flags&uint32(2048|131072) != uint32(0) || uintptr(unsafe.Pointer(pExpr.x.pList)) != uintptr(unsafe.Pointer(nil)) {
			prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr)
		} else {
			prereqAll = prereqLeft | pTerm.prereqRight
		}
	}
	if pMaskSet.bVarSelect != 0 {
		pTerm.wtFlags |= uint16(4096)
	}
	if pExpr.flags&uint32(1) != uint32(0) {
		var x uint64 = sqlite3WhereGetMask(pMaskSet, pExpr.w.iRightJoinTable)
		prereqAll |= x
		extraRight = x - uint64(1)
		if prereqAll>>1 >= x {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[41]int8{'O', 'N', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'r', 'e', 'f', 'e', 'r', 'e', 'n', 'c', 'e', 's', ' ', 't', 'a', 'b', 'l', 'e', 's', ' ', 't', 'o', ' ', 'i', 't', 's', ' ', 'r', 'i', 'g', 'h', 't', '\x00'})))
			return
		}
	}
	pTerm.prereqAll = prereqAll
	pTerm.leftCursor = int32(-1)
	pTerm.iParent = int32(-1)
	pTerm.eOperator = uint16(0)
	if allowedOp(op) != 0 {
		var aiCurCol [2]int32
		var pLeft *struct_Expr = sqlite3ExprSkipCollate(pExpr.pLeft)
		var pRight *struct_Expr = sqlite3ExprSkipCollate(pExpr.pRight)
		var opMask uint16 = uint16(func() int32 {
			if pTerm.prereqRight&prereqLeft == uint64(0) {
				return 8191
			} else {
				return 2048
			}
		}())
		if pTerm.u.x.iField > 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pLeft = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pLeft.x.pList.a)))) + uintptr(pTerm.u.x.iField-1)*28))).pExpr
		}
		if exprMightBeIndexed(pSrc, prereqLeft, (*int32)(unsafe.Pointer(&aiCurCol)), pLeft, op) != 0 {
			pTerm.leftCursor = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurCol)))) + uintptr(0)*4))
			func() int {
				_ = 0
				return 0
			}()
			pTerm.u.x.leftColumn = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurCol)))) + uintptr(1)*4))
			pTerm.eOperator = uint16(int32(operatorMask(op)) & int32(opMask))
		}
		if op == 45 {
			pTerm.wtFlags |= uint16(2048)
		}
		if pRight != nil && exprMightBeIndexed(pSrc, pTerm.prereqRight, (*int32)(unsafe.Pointer(&aiCurCol)), pRight, op) != 0 && !(pRight.flags&uint32(8) != uint32(0)) {
			var pNew *struct_WhereTerm
			var pDup *struct_Expr
			var eExtraOp uint16 = uint16(0)
			func() int {
				_ = 0
				return 0
			}()
			if pTerm.leftCursor >= 0 {
				var idxNew int32
				pDup = sqlite3ExprDup(db, pExpr, 0)
				if db.mallocFailed != 0 {
					sqlite3ExprDelete(db, pDup)
					return
				}
				idxNew = whereClauseInsert(pWC, pDup, uint16(2|1))
				if idxNew == 0 {
					return
				}
				pNew = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxNew)*56))
				markTermAsChild(pWC, idxNew, idxTerm)
				if op == 45 {
					pNew.wtFlags |= uint16(2048)
				}
				pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
				pTerm.wtFlags |= uint16(8)
				if termIsEquivalence(pParse, pDup) != 0 {
					pTerm.eOperator |= uint16(2048)
					eExtraOp = uint16(2048)
				}
			} else {
				pDup = pExpr
				pNew = pTerm
			}
			pNew.wtFlags |= uint16(int32(exprCommute(pParse, pDup)))
			pNew.leftCursor = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurCol)))) + uintptr(0)*4))
			func() int {
				_ = 0
				return 0
			}()
			pNew.u.x.leftColumn = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aiCurCol)))) + uintptr(1)*4))
			pNew.prereqRight = prereqLeft | extraRight
			pNew.prereqAll = prereqAll
			pNew.eOperator = uint16((int32(operatorMask(int32(pDup.op))) + int32(eExtraOp)) & int32(opMask))
		} else if op == 50 && !(pExpr.flags&uint32(1) != uint32(0)) && 0 == sqlite3ExprCanBeNull(pLeft) {
			func() int {
				_ = 0
				return 0
			}()
			pExpr.op = uint8(170)
			pExpr.u.zToken = (*int8)(unsafe.Pointer(&[6]int8{'f', 'a', 'l', 's', 'e', '\x00'}))
			pExpr.flags |= uint32(536870912)
			pTerm.prereqAll = uint64(0)
			pTerm.eOperator = uint16(0)
		}
	} else if int32(pExpr.op) == 48 && int32(pWC.op) == 44 {
		var pList *struct_ExprList
		var i int32
		var ops [2]uint8 = [2]uint8{uint8(57), uint8(55)}
		func() int {
			_ = 0
			return 0
		}()
		pList = pExpr.x.pList
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		for i = int32(0); i < 2; i++ {
			var pNewExpr *struct_Expr
			var idxNew int32
			pNewExpr = sqlite3PExpr(pParse, int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&ops)))) + uintptr(i)))), sqlite3ExprDup(db, pExpr.pLeft, 0), sqlite3ExprDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr, 0))
			transferJoinMarkings(pNewExpr, pExpr)
			idxNew = whereClauseInsert(pWC, pNewExpr, uint16(2|1))
			exprAnalyze(pSrc, pWC, idxNew)
			pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
			markTermAsChild(pWC, idxNew, idxTerm)
		}
	} else if int32(pExpr.op) == 43 {
		func() int {
			_ = 0
			return 0
		}()
		exprAnalyzeOrTerm(pSrc, pWC, idxTerm)
		pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
	} else if int32(pExpr.op) == 51 {
		if int32(pExpr.pLeft.op) == 167 && int32(pExpr.pLeft.iColumn) >= 0 && !(pExpr.flags&uint32(1) != uint32(0)) {
			var pNewExpr *struct_Expr
			var pLeft *struct_Expr = pExpr.pLeft
			var idxNew int32
			var pNewTerm *struct_WhereTerm
			pNewExpr = sqlite3PExpr(pParse, 54, sqlite3ExprDup(db, pLeft, 0), sqlite3ExprAlloc(db, 121, nil, 0))
			idxNew = whereClauseInsert(pWC, pNewExpr, uint16(2|1|128))
			if idxNew != 0 {
				pNewTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxNew)*56))
				pNewTerm.prereqRight = uint64(0)
				pNewTerm.leftCursor = pLeft.iTable
				pNewTerm.u.x.leftColumn = int32(pLeft.iColumn)
				pNewTerm.eOperator = uint16(2 << (54 - 53))
				markTermAsChild(pWC, idxNew, idxTerm)
				pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
				pTerm.wtFlags |= uint16(8)
				pNewTerm.prereqAll = pTerm.prereqAll
			}
		}
	} else if int32(pExpr.op) == 172 && int32(pWC.op) == 44 && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase) != 0 {
		var pLeft *struct_Expr
		var pStr2 *struct_Expr
		var pNewExpr1 *struct_Expr
		var pNewExpr2 *struct_Expr
		var idxNew1 int32
		var idxNew2 int32
		var zCollSeqName *int8
		var wtFlags uint16 = uint16(256 | 2 | 1)
		func() int {
			_ = 0
			return 0
		}()
		pLeft = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pExpr.x.pList.a)))) + uintptr(1)*28))).pExpr
		pStr2 = sqlite3ExprDup(db, pStr1, 0)
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if noCase != 0 && !(pParse.db.mallocFailed != 0) {
			var i int32
			var c int8
			pTerm.wtFlags |= uint16(1024)
			for i = int32(0); int32(func() (_cgo_ret int8) {
				_cgo_addr := &c
				*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pStr1.u.zToken)) + uintptr(i)))
				return *_cgo_addr
			}()) != 0; i++ {
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pStr1.u.zToken)) + uintptr(i))) = int8(int32(c) & ^(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(c))))) & 32))
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pStr2.u.zToken)) + uintptr(i))) = int8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(c)))))
			}
		}
		if !(db.mallocFailed != 0) {
			var c uint8
			var pC *uint8
			pC = (*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pStr2.u.zToken)) + uintptr(sqlite3Strlen30(pStr2.u.zToken)-1)))))
			c = *pC
			if noCase != 0 {
				if int32(c) == 'A'-1 {
					isComplete = int32(0)
				}
				c = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(c)))
			}
			*pC = uint8(int32(c) + 1)
		}
		zCollSeqName = func() *int8 {
			if noCase != 0 {
				return (*int8)(unsafe.Pointer((*int8)(unsafe.Pointer(&[7]int8{'N', 'O', 'C', 'A', 'S', 'E', '\x00'}))))
			} else {
				return (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
			}
		}()
		pNewExpr1 = sqlite3ExprDup(db, pLeft, 0)
		pNewExpr1 = sqlite3PExpr(pParse, 57, sqlite3ExprAddCollateString(pParse, pNewExpr1, zCollSeqName), pStr1)
		transferJoinMarkings(pNewExpr1, pExpr)
		idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags)
		exprAnalyze(pSrc, pWC, idxNew1)
		pNewExpr2 = sqlite3ExprDup(db, pLeft, 0)
		pNewExpr2 = sqlite3PExpr(pParse, 56, sqlite3ExprAddCollateString(pParse, pNewExpr2, zCollSeqName), pStr2)
		transferJoinMarkings(pNewExpr2, pExpr)
		idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags)
		exprAnalyze(pSrc, pWC, idxNew2)
		pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
		if isComplete != 0 {
			markTermAsChild(pWC, idxNew1, idxTerm)
			markTermAsChild(pWC, idxNew2, idxTerm)
		}
	}
	if (int32(pExpr.op) == 53 || int32(pExpr.op) == 45) && func() (_cgo_ret int32) {
		_cgo_addr := &nLeft
		*_cgo_addr = sqlite3ExprVectorSize(pExpr.pLeft)
		return *_cgo_addr
	}() > 1 && sqlite3ExprVectorSize(pExpr.pRight) == nLeft && (pExpr.pLeft.flags&uint32(2048) == uint32(0) || pExpr.pRight.flags&uint32(2048) == uint32(0)) && int32(pWC.op) == 44 {
		var i int32
		for i = int32(0); i < nLeft; i++ {
			var idxNew int32
			var pNew *struct_Expr
			var pLeft *struct_Expr = sqlite3ExprForVectorField(pParse, pExpr.pLeft, i, nLeft)
			var pRight *struct_Expr = sqlite3ExprForVectorField(pParse, pExpr.pRight, i, nLeft)
			pNew = sqlite3PExpr(pParse, int32(pExpr.op), pLeft, pRight)
			transferJoinMarkings(pNew, pExpr)
			idxNew = whereClauseInsert(pWC, pNew, uint16(1|32768))
			exprAnalyze(pSrc, pWC, idxNew)
		}
		pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
		pTerm.wtFlags |= uint16(4 | 2)
		pTerm.eOperator = uint16(0)
	} else if int32(pExpr.op) == 49 && pTerm.u.x.iField == 0 && int32(pExpr.pLeft.op) == 177 && pExpr.flags&uint32(2048) != uint32(0) && uintptr(unsafe.Pointer((*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pPrior)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer((*(**struct_Select)(unsafe.Pointer(&pExpr.x))).pWin)) == uintptr(unsafe.Pointer(nil)) && int32(pWC.op) == 44 {
		var i int32
		for i = int32(0); i < sqlite3ExprVectorSize(pExpr.pLeft); i++ {
			var idxNew int32
			idxNew = whereClauseInsert(pWC, pExpr, uint16(2|32768))
			(*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxNew)*56))).u.x.iField = i + 1
			exprAnalyze(pSrc, pWC, idxNew)
			markTermAsChild(pWC, idxNew, idxTerm)
		}
	} else if int32(pWC.op) == 44 {
		var pRight *struct_Expr = nil
		var pLeft *struct_Expr = nil
		var res int32 = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight)
		for func() (_cgo_ret int32) {
			_cgo_addr := &res
			_cgo_ret = *_cgo_addr
			*_cgo_addr--
			return
		}() > 0 {
			var idxNew int32
			var pNewTerm *struct_WhereTerm
			var prereqColumn uint64
			var prereqExpr uint64
			prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight)
			prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft)
			if prereqExpr&prereqColumn == uint64(0) {
				var pNewExpr *struct_Expr
				pNewExpr = sqlite3PExpr(pParse, 46, nil, sqlite3ExprDup(db, pRight, 0))
				if pExpr.flags&uint32(1) != uint32(0) && pNewExpr != nil {
					pNewExpr.flags |= uint32(1)
					pNewExpr.w.iRightJoinTable = pExpr.w.iRightJoinTable
				}
				idxNew = whereClauseInsert(pWC, pNewExpr, uint16(2|1))
				pNewTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxNew)*56))
				pNewTerm.prereqRight = prereqExpr
				pNewTerm.leftCursor = pLeft.iTable
				pNewTerm.u.x.leftColumn = int32(pLeft.iColumn)
				pNewTerm.eOperator = uint16(64)
				pNewTerm.eMatchOp = eOp2
				markTermAsChild(pWC, idxNew, idxTerm)
				pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
				pTerm.wtFlags |= uint16(8)
				pNewTerm.prereqAll = pTerm.prereqAll
			}
			{
				var t *struct_Expr = pLeft
				pLeft = pRight
				pRight = t
			}
		}
	}
	pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idxTerm)*56))
	pTerm.prereqRight |= extraRight
}
func sqlite3WhereSplit(pWC *struct_WhereClause, pExpr *struct_Expr, op uint8) {
	var pE2 *struct_Expr = sqlite3ExprSkipCollateAndLikely(pExpr)
	pWC.op = op
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pE2)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if int32(pE2.op) != int32(op) {
		whereClauseInsert(pWC, pExpr, uint16(0))
	} else {
		sqlite3WhereSplit(pWC, pE2.pLeft, op)
		sqlite3WhereSplit(pWC, pE2.pRight, op)
	}
}
func whereAddLimitExpr(pWC *struct_WhereClause, iReg int32, pExpr *struct_Expr, iCsr int32, eMatchOp int32) {
	var pParse *struct_Parse = pWC.pWInfo.pParse
	var db *struct_sqlite3 = pParse.db
	var pNew *struct_Expr
	var iVal int32 = 0
	if sqlite3ExprIsInteger(pExpr, &iVal) != 0 && iVal >= 0 {
		var pVal *struct_Expr = sqlite3Expr(db, 155, nil)
		if uintptr(unsafe.Pointer(pVal)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		pVal.flags |= uint32(1024)
		*(*int32)(unsafe.Pointer(&pVal.u)) = iVal
		pNew = sqlite3PExpr(pParse, 46, nil, pVal)
	} else {
		var pVal *struct_Expr = sqlite3Expr(db, 176, nil)
		if uintptr(unsafe.Pointer(pVal)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		pVal.iTable = iReg
		pNew = sqlite3PExpr(pParse, 46, nil, pVal)
	}
	if pNew != nil {
		var pTerm *struct_WhereTerm
		var idx int32
		idx = whereClauseInsert(pWC, pNew, uint16(1|2))
		pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(idx)*56))
		pTerm.leftCursor = iCsr
		pTerm.eOperator = uint16(64)
		pTerm.eMatchOp = uint8(eMatchOp)
	}
}
func sqlite3WhereAddLimit(pWC *struct_WhereClause, p *struct_Select) {
	func() int {
		_ = 0
		return 0
	}()
	if p != nil && p.pLimit != nil && p.selFlags&uint32(1|8) == uint32(0) && (p.pSrc.nSrc == 1 && int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pTab.eTabType) == 1) {
		var pOrderBy *struct_ExprList = p.pOrderBy
		var iCsr int32 = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).iCursor
		var ii int32
		for ii = int32(0); ii < pWC.nTerm; ii++ {
			if int32((*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(ii)*56))).wtFlags)&4 != 0 {
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				continue
			}
			if (*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(ii)*56))).leftCursor != iCsr {
				return
			}
		}
		if pOrderBy != nil {
			for ii = int32(0); ii < pOrderBy.nExpr; ii++ {
				var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(ii)*28))).pExpr
				if int32(pExpr.op) != 167 {
					return
				}
				if pExpr.iTable != iCsr {
					return
				}
				if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(ii)*28))).sortFlags)&2 != 0 {
					return
				}
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		whereAddLimitExpr(pWC, p.iLimit, p.pLimit.pLeft, iCsr, 73)
		if p.iOffset > 0 {
			whereAddLimitExpr(pWC, p.iOffset, p.pLimit.pRight, iCsr, 74)
		}
	}
}
func sqlite3WhereClauseInit(pWC *struct_WhereClause, pWInfo *struct_WhereInfo) {
	pWC.pWInfo = pWInfo
	pWC.hasOr = uint8(0)
	pWC.pOuter = (*struct_WhereClause)(nil)
	pWC.nTerm = int32(0)
	pWC.nBase = int32(0)
	pWC.nSlot = int32(448 / 56)
	pWC.a = (*struct_WhereTerm)(unsafe.Pointer(&pWC.aStatic))
}
func sqlite3WhereClauseClear(pWC *struct_WhereClause) {
	var db *struct_sqlite3 = pWC.pWInfo.pParse.db
	func() int {
		_ = 0
		return 0
	}()
	if pWC.nTerm > 0 {
		var a *struct_WhereTerm = pWC.a
		var aLast *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(pWC.nTerm-1)*56))
		for 1 != 0 {
			func() int {
				_ = 0
				return 0
			}()
			if int32(a.wtFlags)&1 != 0 {
				sqlite3ExprDelete(db, a.pExpr)
			}
			if int32(a.wtFlags)&(16|32) != 0 {
				if int32(a.wtFlags)&16 != 0 {
					func() int {
						_ = 0
						return 0
					}()
					whereOrInfoDelete(db, *(**struct_WhereOrInfo)(unsafe.Pointer(&a.u)))
				} else {
					func() int {
						_ = 0
						return 0
					}()
					whereAndInfoDelete(db, *(**struct_WhereAndInfo)(unsafe.Pointer(&a.u)))
				}
			}
			if uintptr(unsafe.Pointer(a)) == uintptr(unsafe.Pointer(aLast)) {
				break
			}
			*(*uintptr)(unsafe.Pointer(&a)) += 56
		}
	}
	if uintptr(unsafe.Pointer(pWC.a)) != uintptr(unsafe.Pointer((*struct_WhereTerm)(unsafe.Pointer(&pWC.aStatic)))) {
		sqlite3DbFree(db, unsafe.Pointer(pWC.a))
	}
}
func sqlite3WhereExprUsageFull(pMaskSet *struct_WhereMaskSet, p *struct_Expr) uint64 {
	var mask uint64
	mask = func() uint64 {
		if int32(p.op) == 179 {
			return sqlite3WhereGetMask(pMaskSet, p.iTable)
		} else {
			return uint64(0)
		}
	}()
	if p.pLeft != nil {
		mask |= sqlite3WhereExprUsageNN(pMaskSet, p.pLeft)
	}
	if p.pRight != nil {
		mask |= sqlite3WhereExprUsageNN(pMaskSet, p.pRight)
		func() int {
			_ = 0
			return 0
		}()
	} else if p.flags&uint32(2048) != uint32(0) {
		if p.flags&uint32(32) != uint32(0) {
			pMaskSet.bVarSelect = int32(1)
		}
		mask |= exprSelectUsage(pMaskSet, *(**struct_Select)(unsafe.Pointer(&p.x)))
	} else if p.x.pList != nil {
		mask |= sqlite3WhereExprListUsage(pMaskSet, p.x.pList)
	}
	if (int32(p.op) == 172 || int32(p.op) == 168) && p.flags&uint32(16777216) != uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		mask |= sqlite3WhereExprListUsage(pMaskSet, (*(**struct_Window)(unsafe.Pointer(&p.y))).pPartition)
		mask |= sqlite3WhereExprListUsage(pMaskSet, (*(**struct_Window)(unsafe.Pointer(&p.y))).pOrderBy)
		mask |= sqlite3WhereExprUsage(pMaskSet, (*(**struct_Window)(unsafe.Pointer(&p.y))).pFilter)
	}
	return mask
}
func sqlite3WhereExprUsageNN(pMaskSet *struct_WhereMaskSet, p *struct_Expr) uint64 {
	if int32(p.op) == 167 && !(p.flags&uint32(8) != uint32(0)) {
		return sqlite3WhereGetMask(pMaskSet, p.iTable)
	} else if p.flags&uint32(16384|8388608) != uint32(0) {
		func() int {
			_ = 0
			return 0
		}()
		return uint64(0)
	}
	return sqlite3WhereExprUsageFull(pMaskSet, p)
}
func sqlite3WhereExprUsage(pMaskSet *struct_WhereMaskSet, p *struct_Expr) uint64 {
	return func() uint64 {
		if p != nil {
			return sqlite3WhereExprUsageNN(pMaskSet, p)
		} else {
			return uint64(0)
		}
	}()
}
func sqlite3WhereExprListUsage(pMaskSet *struct_WhereMaskSet, pList *struct_ExprList) uint64 {
	var i int32
	var mask uint64 = uint64(0)
	if pList != nil {
		for i = int32(0); i < pList.nExpr; i++ {
			mask |= sqlite3WhereExprUsage(pMaskSet, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr)
		}
	}
	return mask
}
func sqlite3WhereExprAnalyze(pTabList *struct_SrcList, pWC *struct_WhereClause) {
	var i int32
	for i = pWC.nTerm - 1; i >= 0; i-- {
		exprAnalyze(pTabList, pWC, i)
	}
}
func sqlite3WhereTabFuncArgs(pParse *struct_Parse, pItem *struct_SrcItem, pWC *struct_WhereClause) {
	var pTab *struct_Table
	var j int32
	var k int32
	var pArgs *struct_ExprList
	var pColRef *struct_Expr
	var pTerm *struct_Expr
	if int32(pItem.fg.Xbf_0>>2&1) == 0 {
		return
	}
	pTab = pItem.pTab
	func() int {
		_ = 0
		return 0
	}()
	pArgs = *(**struct_ExprList)(unsafe.Pointer(&pItem.u1))
	if uintptr(unsafe.Pointer(pArgs)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	for j = func() (_cgo_ret int32) {
		_cgo_addr := &k
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}(); j < pArgs.nExpr; j++ {
		var pRhs *struct_Expr
		for k < int32(pTab.nCol) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(k)*20))).colFlags)&2 == 0 {
			k++
		}
		if k >= int32(pTab.nCol) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[36]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', ' ', 'o', 'n', ' ', '%', 's', '(', ')', ' ', '-', ' ', 'm', 'a', 'x', ' ', '%', 'd', '\x00'})), pTab.zName, j)
			return
		}
		pColRef = sqlite3ExprAlloc(pParse.db, 167, nil, 0)
		if uintptr(unsafe.Pointer(pColRef)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		pColRef.iTable = pItem.iCursor
		pColRef.iColumn = int16(func() (_cgo_ret int32) {
			_cgo_addr := &k
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())
		func() int {
			_ = 0
			return 0
		}()
		pColRef.y.pTab = pTab
		pItem.colUsed |= sqlite3ExprColUsed(pColRef)
		pRhs = sqlite3PExpr(pParse, 174, sqlite3ExprDup(pParse.db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pArgs.a)))) + uintptr(j)*28))).pExpr, 0), nil)
		pTerm = sqlite3PExpr(pParse, 53, pColRef, pRhs)
		if int32(pItem.fg.jointype)&8 != 0 {
			sqlite3SetJoinExpr(pTerm, pItem.iCursor)
		}
		whereClauseInsert(pWC, pTerm, uint16(1))
	}
}

type HiddenIndexInfo = struct_HiddenIndexInfo
type struct_HiddenIndexInfo struct {
	pWC       *struct_WhereClause
	pParse    *struct_Parse
	eDistinct int32
	mIn       uint32
	mHandleIn uint32
	aRhs      [1]*struct_sqlite3_value
}

func sqlite3WhereOutputRowCount(pWInfo *struct_WhereInfo) int16 {
	return pWInfo.nRowOut
}
func sqlite3WhereIsDistinct(pWInfo *struct_WhereInfo) int32 {
	return int32(pWInfo.eDistinct)
}
func sqlite3WhereIsOrdered(pWInfo *struct_WhereInfo) int32 {
	return int32(pWInfo.nOBSat)
}
func sqlite3WhereOrderByLimitOptLabel(pWInfo *struct_WhereInfo) int32 {
	var pInner *struct_WhereLevel
	if !(pWInfo.Xbf_0>>2&1 != 0) {
		return pWInfo.iContinue
	}
	pInner = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(int32(pWInfo.nLevel)-1)*104))
	func() int {
		_ = 0
		return 0
	}()
	return pInner.addrNxt
}
func sqlite3WhereMinMaxOptEarlyOut(v *struct_Vdbe, pWInfo *struct_WhereInfo) {
	var pInner *struct_WhereLevel
	var i int32
	if !(pWInfo.Xbf_0>>2&1 != 0) {
		return
	}
	if int32(pWInfo.nOBSat) == 0 {
		return
	}
	for i = int32(pWInfo.nLevel) - 1; i >= 0; i-- {
		pInner = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))
		if pInner.pWLoop.wsFlags&uint32(4) != uint32(0) {
			sqlite3VdbeGoto(v, pInner.addrNxt)
			return
		}
	}
	sqlite3VdbeGoto(v, pWInfo.iBreak)
}
func sqlite3WhereContinueLabel(pWInfo *struct_WhereInfo) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return pWInfo.iContinue
}
func sqlite3WhereBreakLabel(pWInfo *struct_WhereInfo) int32 {
	return pWInfo.iBreak
}
func sqlite3WhereOkOnePass(pWInfo *struct_WhereInfo, aiCur *int32) int32 {
	__builtin___memcpy_chk(unsafe.Pointer(aiCur), unsafe.Pointer((*int32)(unsafe.Pointer(&pWInfo.aiCurOnePass))), 4*uint(2), __builtin_object_size(unsafe.Pointer(aiCur), 0))
	return int32(pWInfo.eOnePass)
}
func sqlite3WhereUsesDeferredSeek(pWInfo *struct_WhereInfo) int32 {
	return int32(pWInfo.Xbf_0 & 1)
}
func whereOrMove(pDest *struct_WhereOrSet, pSrc *struct_WhereOrSet) {
	pDest.n = pSrc.n
	__builtin___memcpy_chk(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&pDest.a))), unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&pSrc.a))), uint(pDest.n)*12, __builtin_object_size(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&pDest.a))), 0))
}
func whereOrInsert(pSet *struct_WhereOrSet, prereq uint64, rRun int16, nOut int16) int32 {
	var i uint16
	var p *struct_WhereOrCost
	for func() *struct_WhereOrCost {
		i = pSet.n
		return func() (_cgo_ret *struct_WhereOrCost) {
			_cgo_addr := &p
			*_cgo_addr = (*struct_WhereOrCost)(unsafe.Pointer(&pSet.a))
			return *_cgo_addr
		}()
	}(); int32(i) > 0; func() *struct_WhereOrCost {
		i--
		return func() (_cgo_ret *struct_WhereOrCost) {
			_cgo_addr := &p
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 12
			return
		}()
	}() {
		if int32(rRun) <= int32(p.rRun) && prereq&p.prereq == prereq {
			goto whereOrInsert_done
		}
		if int32(p.rRun) <= int32(rRun) && p.prereq&prereq == p.prereq {
			return int32(0)
		}
	}
	if int32(pSet.n) < 3 {
		p = &*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&pSet.a)))) + uintptr(func() (_cgo_ret uint16) {
			_cgo_addr := &pSet.n
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*12))
		p.nOut = nOut
	} else {
		p = (*struct_WhereOrCost)(unsafe.Pointer(&pSet.a))
		for i = uint16(1); int32(i) < int32(pSet.n); i++ {
			if int32(p.rRun) > int32((*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&pSet.a)))) + uintptr(i)*12))).rRun) {
				p = (*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&pSet.a)))) + uintptr(int32(i))*12))
			}
		}
		if int32(p.rRun) <= int32(rRun) {
			return int32(0)
		}
	}
whereOrInsert_done:
	p.prereq = prereq
	p.rRun = rRun
	if int32(p.nOut) > int32(nOut) {
		p.nOut = nOut
	}
	return int32(1)
}
func sqlite3WhereGetMask(pMaskSet *struct_WhereMaskSet, iCursor int32) uint64 {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pMaskSet.ix)))) + uintptr(0)*4)) == iCursor {
		return uint64(1)
	}
	for i = int32(1); i < pMaskSet.n; i++ {
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pMaskSet.ix)))) + uintptr(i)*4)) == iCursor {
			return uint64(1) << i
		}
	}
	return uint64(0)
}
func createMask(pMaskSet *struct_WhereMaskSet, iCursor int32) {
	func() int {
		_ = 0
		return 0
	}()
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pMaskSet.ix)))) + uintptr(func() (_cgo_ret int32) {
		_cgo_addr := &pMaskSet.n
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())*4)) = iCursor
}
func whereRightSubexprIsColumn(p *struct_Expr) *struct_Expr {
	p = sqlite3ExprSkipCollateAndLikely(p.pRight)
	if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) && int32(p.op) == 167 && !(p.flags&uint32(8) != uint32(0)) {
		return p
	}
	return (*struct_Expr)(nil)
}
func whereScanNext(pScan *struct_WhereScan) *struct_WhereTerm {
	var iCur int32
	var iColumn int16
	var pX *struct_Expr
	var pWC *struct_WhereClause
	var pTerm *struct_WhereTerm
	var k int32 = pScan.k
	func() int {
		_ = 0
		return 0
	}()
	pWC = pScan.pWC
	for 1 != 0 {
		iColumn = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&pScan.aiColumn)))) + uintptr(int32(pScan.iEquiv)-1)*2))
		iCur = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pScan.aiCur)))) + uintptr(int32(pScan.iEquiv)-1)*4))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		for {
			for pTerm = (*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(k)*56)); k < pWC.nTerm; func() *struct_WhereTerm {
				k++
				return func() (_cgo_ret *struct_WhereTerm) {
					_cgo_addr := &pTerm
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
					return
				}()
			}() {
				func() int {
					_ = 0
					return 0
				}()
				if pTerm.leftCursor == iCur && pTerm.u.x.leftColumn == int32(iColumn) && (int32(iColumn) != -2 || sqlite3ExprCompareSkip(pTerm.pExpr.pLeft, pScan.pIdxExpr, iCur) == 0) && (int32(pScan.iEquiv) <= 1 || !(pTerm.pExpr.flags&uint32(1) != uint32(0))) {
					if int32(pTerm.eOperator)&2048 != 0 && int32(pScan.nEquiv) < int32(44/4) && uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Expr) {
						_cgo_addr := &pX
						*_cgo_addr = whereRightSubexprIsColumn(pTerm.pExpr)
						return *_cgo_addr
					}())) != uintptr(unsafe.Pointer(nil)) {
						var j int32
						for j = int32(0); j < int32(pScan.nEquiv); j++ {
							if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pScan.aiCur)))) + uintptr(j)*4)) == pX.iTable && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&pScan.aiColumn)))) + uintptr(j)*2))) == int32(pX.iColumn) {
								break
							}
						}
						if j == int32(pScan.nEquiv) {
							*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pScan.aiCur)))) + uintptr(j)*4)) = pX.iTable
							*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&pScan.aiColumn)))) + uintptr(j)*2)) = pX.iColumn
							pScan.nEquiv++
						}
					}
					if uint32(pTerm.eOperator)&pScan.opMask != uint32(0) {
						if pScan.zCollName != nil && int32(pTerm.eOperator)&256 == 0 {
							var pColl *struct_CollSeq
							var pParse *struct_Parse = pWC.pWInfo.pParse
							pX = pTerm.pExpr
							if !(sqlite3IndexAffinityOk(pX, pScan.idxaff) != 0) {
								continue
							}
							func() int {
								_ = 0
								return 0
							}()
							pColl = sqlite3ExprCompareCollSeq(pParse, pX)
							if uintptr(unsafe.Pointer(pColl)) == uintptr(unsafe.Pointer(nil)) {
								pColl = pParse.db.pDfltColl
							}
							if sqlite3StrICmp(pColl.zName, pScan.zCollName) != 0 {
								continue
							}
						}
						if int32(pTerm.eOperator)&(2|128) != 0 && func() bool {
							pX = pTerm.pExpr.pRight
							return uintptr(unsafe.Pointer(pX)) != uintptr(unsafe.Pointer(nil))
						}() && int32(pX.op) == 167 && pX.iTable == *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pScan.aiCur)))) + uintptr(0)*4)) && int32(pX.iColumn) == int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&pScan.aiColumn)))) + uintptr(0)*2))) {
							continue
						}
						pScan.pWC = pWC
						pScan.k = k + 1
						return pTerm
					}
				}
			}
			pWC = pWC.pOuter
			k = int32(0)
			if !(uintptr(unsafe.Pointer(pWC)) != uintptr(unsafe.Pointer(nil))) {
				break
			}
		}
		if int32(pScan.iEquiv) >= int32(pScan.nEquiv) {
			break
		}
		pWC = pScan.pOrigWC
		k = int32(0)
		pScan.iEquiv++
	}
	return (*struct_WhereTerm)(nil)
}
func whereScanInitIndexExpr(pScan *struct_WhereScan) *struct_WhereTerm {
	pScan.idxaff = sqlite3ExprAffinity(pScan.pIdxExpr)
	return whereScanNext(pScan)
}
func whereScanInit(pScan *struct_WhereScan, pWC *struct_WhereClause, iCur int32, iColumn int32, opMask uint32, pIdx *struct_Index) *struct_WhereTerm {
	pScan.pOrigWC = pWC
	pScan.pWC = pWC
	pScan.pIdxExpr = (*struct_Expr)(nil)
	pScan.idxaff = int8(0)
	pScan.zCollName = (*int8)(nil)
	pScan.opMask = opMask
	pScan.k = int32(0)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pScan.aiCur)))) + uintptr(0)*4)) = iCur
	pScan.nEquiv = uint8(1)
	pScan.iEquiv = uint8(1)
	if pIdx != nil {
		var j int32 = iColumn
		iColumn = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(j)*2)))
		if iColumn == int32(pIdx.pTable.iPKey) {
			iColumn = int32(-1)
		} else if iColumn >= 0 {
			pScan.idxaff = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.pTable.aCol)) + uintptr(iColumn)*20))).affinity
			pScan.zCollName = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(j)*8))
		} else if iColumn == -2 {
			pScan.pIdxExpr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIdx.aColExpr.a)))) + uintptr(j)*28))).pExpr
			pScan.zCollName = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(j)*8))
			*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&pScan.aiColumn)))) + uintptr(0)*2)) = int16(-2)
			return whereScanInitIndexExpr(pScan)
		}
	} else if iColumn == -2 {
		return (*struct_WhereTerm)(nil)
	}
	*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&pScan.aiColumn)))) + uintptr(0)*2)) = int16(iColumn)
	return whereScanNext(pScan)
}
func sqlite3WhereFindTerm(pWC *struct_WhereClause, iCur int32, iColumn int32, notReady uint64, op uint32, pIdx *struct_Index) *struct_WhereTerm {
	var pResult *struct_WhereTerm = nil
	var p *struct_WhereTerm
	var scan struct_WhereScan
	p = whereScanInit(&scan, pWC, iCur, iColumn, op, pIdx)
	op &= uint32(2 | 128)
	for p != nil {
		if p.prereqRight&notReady == uint64(0) {
			if p.prereqRight == uint64(0) && uint32(p.eOperator)&op != uint32(0) {
				return p
			}
			if uintptr(unsafe.Pointer(pResult)) == uintptr(unsafe.Pointer(nil)) {
				pResult = p
			}
		}
		p = whereScanNext(&scan)
	}
	return pResult
}
func findIndexCol(pParse *struct_Parse, pList *struct_ExprList, iBase int32, pIdx *struct_Index, iCol int32) int32 {
	var i int32
	var zColl *int8 = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(iCol)*8))
	for i = int32(0); i < pList.nExpr; i++ {
		var p *struct_Expr = sqlite3ExprSkipCollateAndLikely((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr)
		if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) && (int32(p.op) == 167 || int32(p.op) == 169) && int32(p.iColumn) == int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(iCol)*2))) && p.iTable == iBase {
			var pColl *struct_CollSeq = sqlite3ExprNNCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(i)*28))).pExpr)
			if 0 == sqlite3StrICmp(pColl.zName, zColl) {
				return i
			}
		}
	}
	return int32(-1)
}
func indexColumnNotNull(pIdx *struct_Index, iCol int32) int32 {
	var j int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	j = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(iCol)*2)))
	if j >= 0 {
		return int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.pTable.aCol)) + uintptr(j)*20))).Xbf_0 & 15)
	} else if j == -1 {
		return int32(1)
	} else {
		func() int {
			_ = 0
			return 0
		}()
		return int32(0)
	}
}
func isDistinctRedundant(pParse *struct_Parse, pTabList *struct_SrcList, pWC *struct_WhereClause, pDistinct *struct_ExprList) int32 {
	var pTab *struct_Table
	var pIdx *struct_Index
	var i int32
	var iBase int32
	if pTabList.nSrc != 1 {
		return int32(0)
	}
	iBase = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).iCursor
	pTab = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).pTab
	for i = int32(0); i < pDistinct.nExpr; i++ {
		var p *struct_Expr = sqlite3ExprSkipCollateAndLikely((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pDistinct.a)))) + uintptr(i)*28))).pExpr)
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if int32(p.op) != 167 && int32(p.op) != 169 {
			continue
		}
		if p.iTable == iBase && int32(p.iColumn) < 0 {
			return int32(1)
		}
	}
	for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
		if !(int32(pIdx.onError) != 0) {
			continue
		}
		if pIdx.pPartIdxWhere != nil {
			continue
		}
		for i = int32(0); i < int32(pIdx.nKeyCol); i++ {
			if nil == sqlite3WhereFindTerm(pWC, iBase, i, ^uint64(0), uint32(2), pIdx) {
				if findIndexCol(pParse, pDistinct, iBase, pIdx, i) < 0 {
					break
				}
				if indexColumnNotNull(pIdx, i) == 0 {
					break
				}
			}
		}
		if i == int32(pIdx.nKeyCol) {
			return int32(1)
		}
	}
	return int32(0)
}
func estLog(N int16) int16 {
	return int16(func() int32 {
		if int32(N) <= 10 {
			return 0
		} else {
			return int32(sqlite3LogEst(uint64(N))) - 33
		}
	}())
}
func translateColumnToCopy(pParse *struct_Parse, iStart int32, iTabCur int32, iRegister int32, iAutoidxCur int32) {
	var v *struct_Vdbe = pParse.pVdbe
	var pOp *struct_VdbeOp = sqlite3VdbeGetOp(v, iStart)
	var iEnd int32 = sqlite3VdbeCurrentAddr(v)
	if pParse.db.mallocFailed != 0 {
		return
	}
	for ; iStart < iEnd; func() *struct_VdbeOp {
		iStart++
		return func() (_cgo_ret *struct_VdbeOp) {
			_cgo_addr := &pOp
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 24
			return
		}()
	}() {
		if pOp.p1 != iTabCur {
			continue
		}
		if int32(pOp.opcode) == 93 {
			pOp.opcode = uint8(79)
			pOp.p1 = pOp.p2 + iRegister
			pOp.p2 = pOp.p3
			pOp.p3 = int32(0)
		} else if int32(pOp.opcode) == 134 {
			pOp.opcode = uint8(125)
			pOp.p1 = iAutoidxCur
		}
	}
}
func termCanDriveIndex(pTerm *struct_WhereTerm, pSrc *struct_SrcItem, notReady uint64) int32 {
	var aff int8
	if pTerm.leftCursor != pSrc.iCursor {
		return int32(0)
	}
	if int32(pTerm.eOperator)&(2|128) == 0 {
		return int32(0)
	}
	if int32(pSrc.fg.jointype)&8 != 0 && !(pTerm.pExpr.flags&uint32(1) != uint32(0)) && int32(pTerm.eOperator)&128 != 0 {
		return int32(0)
	}
	if pTerm.prereqRight&notReady != uint64(0) {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	if pTerm.u.x.leftColumn < 0 {
		return int32(0)
	}
	aff = (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pSrc.pTab.aCol)) + uintptr(pTerm.u.x.leftColumn)*20))).affinity
	if !(sqlite3IndexAffinityOk(pTerm.pExpr, aff) != 0) {
		return int32(0)
	}
	return int32(1)
}
func constructAutomaticIndex(pParse *struct_Parse, pWC *struct_WhereClause, pSrc *struct_SrcItem, notReady uint64, pLevel *struct_WhereLevel) {
	var nKeyCol int32
	var pTerm *struct_WhereTerm
	var pWCEnd *struct_WhereTerm
	var pIdx *struct_Index
	var v *struct_Vdbe
	var addrInit int32
	var pTable *struct_Table
	var addrTop int32
	var regRecord int32
	var n int32
	var i int32
	var mxBitCol int32
	var pColl *struct_CollSeq
	var pLoop *struct_WhereLoop
	var zNotUsed *int8
	var idxCols uint64
	var extraCols uint64
	var sentWarning uint8 = uint8(0)
	var pPartial *struct_Expr = nil
	var iContinue int32 = 0
	var pTabItem *struct_SrcItem
	var addrCounter int32 = 0
	var regBase int32
	v = pParse.pVdbe
	func() int {
		_ = 0
		return 0
	}()
	addrInit = sqlite3VdbeAddOp0(v, 17)
	nKeyCol = int32(0)
	pTable = pSrc.pTab
	pWCEnd = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(pWC.nTerm)*56))
	pLoop = pLevel.pWLoop
	idxCols = uint64(0)
	for pTerm = pWC.a; uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pWCEnd)); *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
		var pExpr *struct_Expr = pTerm.pExpr
		if int32(pTerm.wtFlags)&2 == 0 && (int32(pSrc.fg.jointype)&8 == 0 || pExpr.flags&uint32(1) != uint32(0)) && sqlite3ExprIsTableConstant(pExpr, pSrc.iCursor) != 0 {
			pPartial = sqlite3ExprAnd(pParse, pPartial, sqlite3ExprDup(pParse.db, pExpr, 0))
		}
		if termCanDriveIndex(pTerm, pSrc, notReady) != 0 {
			var iCol int32
			var cMask uint64
			func() int {
				_ = 0
				return 0
			}()
			iCol = pTerm.u.x.leftColumn
			cMask = func() uint64 {
				if iCol >= int32(8*uint(8)) {
					return uint64(1) << (int32(8*uint(8)) - 1)
				} else {
					return uint64(1) << iCol
				}
			}()
			if !(sentWarning != 0) {
				sqlite3_log(28|1<<8, (*int8)(unsafe.Pointer(&[26]int8{'a', 'u', 't', 'o', 'm', 'a', 't', 'i', 'c', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'n', ' ', '%', 's', '(', '%', 's', ')', '\x00'})), pTable.zName, (*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTable.aCol)) + uintptr(iCol)*20))).zCnName)
				sentWarning = uint8(1)
			}
			if idxCols&cMask == uint64(0) {
				if whereLoopResize(pParse.db, pLoop, nKeyCol+1) != 0 {
					goto end_auto_index_create
				}
				*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &nKeyCol
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())*8)) = pTerm
				idxCols |= cMask
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq = func() (_cgo_ret uint16) {
		_cgo_addr := &pLoop.nLTerm
		*_cgo_addr = uint16(nKeyCol)
		return *_cgo_addr
	}()
	pLoop.wsFlags = uint32(1 | 64 | 512 | 16384)
	extraCols = pSrc.colUsed & (^idxCols | uint64(1)<<(int32(8*uint(8))-1))
	mxBitCol = func() int32 {
		if int32(8*uint(8))-1 < int32(pTable.nCol) {
			return int32(8*uint(8)) - 1
		} else {
			return int32(pTable.nCol)
		}
	}()
	for i = int32(0); i < mxBitCol; i++ {
		if extraCols&(uint64(1)<<i) != 0 {
			nKeyCol++
		}
	}
	if pSrc.colUsed&(uint64(1)<<(int32(8*uint(8))-1)) != 0 {
		nKeyCol += int32(pTable.nCol) - int32(8*uint(8)) + 1
	}
	pIdx = sqlite3AllocateIndexObject(pParse.db, int16(nKeyCol+1), 0, &zNotUsed)
	if uintptr(unsafe.Pointer(pIdx)) == uintptr(unsafe.Pointer(nil)) {
		goto end_auto_index_create
	}
	(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex = pIdx
	pIdx.zName = (*int8)(unsafe.Pointer(&[11]int8{'a', 'u', 't', 'o', '-', 'i', 'n', 'd', 'e', 'x', '\x00'}))
	pIdx.pTable = pTable
	n = int32(0)
	idxCols = uint64(0)
	for pTerm = pWC.a; uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pWCEnd)); *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
		if termCanDriveIndex(pTerm, pSrc, notReady) != 0 {
			var iCol int32
			var cMask uint64
			func() int {
				_ = 0
				return 0
			}()
			iCol = pTerm.u.x.leftColumn
			cMask = func() uint64 {
				if iCol >= int32(8*uint(8)) {
					return uint64(1) << (int32(8*uint(8)) - 1)
				} else {
					return uint64(1) << iCol
				}
			}()
			if idxCols&cMask == uint64(0) {
				var pX *struct_Expr = pTerm.pExpr
				idxCols |= cMask
				*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(n)*2)) = int16(pTerm.u.x.leftColumn)
				pColl = sqlite3ExprCompareCollSeq(pParse, pX)
				func() int {
					_ = 0
					return 0
				}()
				*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(n)*8)) = func() *int8 {
					if pColl != nil {
						return (*int8)(unsafe.Pointer(pColl.zName))
					} else {
						return (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
					}
				}()
				n++
			}
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < mxBitCol; i++ {
		if extraCols&(uint64(1)<<i) != 0 {
			*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(n)*2)) = int16(i)
			*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(n)*8)) = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
			n++
		}
	}
	if pSrc.colUsed&(uint64(1)<<(int32(8*uint(8))-1)) != 0 {
		for i = int32(8*uint(8)) - 1; i < int32(pTable.nCol); i++ {
			*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(n)*2)) = int16(i)
			*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(n)*8)) = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
			n++
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(n)*2)) = int16(-1)
	*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(n)*8)) = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
	func() int {
		_ = 0
		return 0
	}()
	pLevel.iIdxCur = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nTab
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()
	sqlite3VdbeAddOp2(v, 115, pLevel.iIdxCur, nKeyCol+1)
	sqlite3VdbeSetP4KeyInfo(pParse, pIdx)
	if pParse.db.dbOptFlags&uint32(524288) == uint32(0) {
		pLevel.regFilter = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		sqlite3VdbeAddOp2(v, 76, 10000, pLevel.regFilter)
	}
	pTabItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWC.pWInfo.pTabList.a)))) + uintptr(pLevel.iFrom)*112))
	if pTabItem.fg.Xbf_0>>4&1 != 0 {
		var regYield int32 = pTabItem.regReturn
		addrCounter = sqlite3VdbeAddOp2(v, 71, 0, 0)
		sqlite3VdbeAddOp3(v, 13, regYield, 0, pTabItem.addrFillSub)
		addrTop = sqlite3VdbeAddOp1(v, 14, regYield)
	} else {
		addrTop = sqlite3VdbeAddOp1(v, 38, pLevel.iTabCur)
	}
	if pPartial != nil {
		iContinue = sqlite3VdbeMakeLabel(pParse)
		sqlite3ExprIfFalse(pParse, pPartial, iContinue, 16)
		pLoop.wsFlags |= uint32(131072)
	}
	regRecord = sqlite3GetTempReg(pParse)
	regBase = sqlite3GenerateIndexKey(pParse, pIdx, pLevel.iTabCur, regRecord, 0, nil, nil, 0)
	if pLevel.regFilter != 0 {
		sqlite3VdbeAddOp4Int(v, 178, pLevel.regFilter, 0, regBase, int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq))
	}
	sqlite3VdbeAddOp2(v, 137, pLevel.iIdxCur, regRecord)
	sqlite3VdbeChangeP5(v, uint16(16))
	if pPartial != nil {
		sqlite3VdbeResolveLabel(v, iContinue)
	}
	if pTabItem.fg.Xbf_0>>4&1 != 0 {
		sqlite3VdbeChangeP2(v, addrCounter, regBase+n)
		func() int {
			_ = 0
			return 0
		}()
		translateColumnToCopy(pParse, addrTop, pLevel.iTabCur, pTabItem.regResult, pLevel.iIdxCur)
		sqlite3VdbeGoto(v, addrTop)
		{
			_autoGo_88 := &pTabItem.fg.Xbf_0
			*_autoGo_88 = *_autoGo_88&^16 | uint32(0)&1<<4
		}
	} else {
		sqlite3VdbeAddOp2(v, 5, pLevel.iTabCur, addrTop+1)
		sqlite3VdbeChangeP5(v, uint16(3))
	}
	sqlite3VdbeJumpHere(v, addrTop)
	sqlite3ReleaseTempReg(pParse, regRecord)
	sqlite3VdbeJumpHere(v, addrInit)
end_auto_index_create:
	sqlite3ExprDelete(pParse.db, pPartial)
}
func sqlite3ConstructBloomFilter(pWInfo *struct_WhereInfo, iLevel int32, pLevel *struct_WhereLevel, notReady uint64) {
	var addrOnce int32
	var addrTop int32
	var addrCont int32
	var pTerm *struct_WhereTerm
	var pWCEnd *struct_WhereTerm
	var pParse *struct_Parse = pWInfo.pParse
	var v *struct_Vdbe = pParse.pVdbe
	var pLoop *struct_WhereLoop = pLevel.pWLoop
	var iCur int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	addrOnce = sqlite3VdbeAddOp0(v, 17)
	for {
		var pItem *struct_SrcItem
		var pTab *struct_Table
		var sz uint64
		sqlite3WhereExplainBloomFilter(pParse, pWInfo, pLevel)
		addrCont = sqlite3VdbeMakeLabel(pParse)
		iCur = pLevel.iTabCur
		pLevel.regFilter = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		pItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLevel.iFrom)*112))
		func() int {
			_ = 0
			return 0
		}()
		pTab = pItem.pTab
		func() int {
			_ = 0
			return 0
		}()
		sz = sqlite3LogEstToInt(pTab.nRowLogEst)
		if sz < uint64(10000) {
			sz = uint64(10000)
		} else if sz > uint64(10000000) {
			sz = uint64(10000000)
		}
		sqlite3VdbeAddOp2(v, 76, int32(sz), pLevel.regFilter)
		addrTop = sqlite3VdbeAddOp1(v, 38, iCur)
		pWCEnd = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWInfo.sWC.a)) + uintptr(pWInfo.sWC.nTerm)*56))
		for pTerm = pWInfo.sWC.a; uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pWCEnd)); *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
			var pExpr *struct_Expr = pTerm.pExpr
			if int32(pTerm.wtFlags)&2 == 0 && sqlite3ExprIsTableConstant(pExpr, iCur) != 0 {
				sqlite3ExprIfFalse(pParse, pTerm.pExpr, addrCont, 16)
			}
		}
		if pLoop.wsFlags&uint32(256) != 0 {
			var r1 int32 = sqlite3GetTempReg(pParse)
			sqlite3VdbeAddOp2(v, 134, iCur, r1)
			sqlite3VdbeAddOp4Int(v, 178, pLevel.regFilter, 0, r1, 1)
			sqlite3ReleaseTempReg(pParse, r1)
		} else {
			var pIdx *struct_Index = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
			var n int32 = int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq)
			var r1 int32 = sqlite3GetTempRange(pParse, n)
			var jj int32
			for jj = int32(0); jj < n; jj++ {
				var iCol int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(jj)*2)))
				func() int {
					_ = 0
					return 0
				}()
				sqlite3ExprCodeGetColumnOfTable(v, pIdx.pTable, iCur, iCol, r1+jj)
			}
			sqlite3VdbeAddOp4Int(v, 178, pLevel.regFilter, 0, r1, n)
			sqlite3ReleaseTempRange(pParse, r1, n)
		}
		sqlite3VdbeResolveLabel(v, addrCont)
		sqlite3VdbeAddOp2(v, 5, pLevel.iTabCur, addrTop+1)
		sqlite3VdbeJumpHere(v, addrTop)
		pLoop.wsFlags &= uint32(4290772991)
		if pParse.db.dbOptFlags&uint32(1048576) != uint32(0) {
			break
		}
		for func() (_cgo_ret int32) {
			_cgo_addr := &iLevel
			*_cgo_addr++
			return *_cgo_addr
		}() < int32(pWInfo.nLevel) {
			var pTabItem *struct_SrcItem
			pLevel = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(iLevel)*104))
			pTabItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLevel.iFrom)*112))
			if int32(pTabItem.fg.jointype)&8 != 0 {
				continue
			}
			pLoop = pLevel.pWLoop
			if uintptr(unsafe.Pointer(pLoop)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			if pLoop.prereq&notReady != 0 {
				continue
			}
			if pLoop.wsFlags&uint32(4194304|4) == uint32(4194304) {
				break
			}
		}
		if !(iLevel < int32(pWInfo.nLevel)) {
			break
		}
	}
	sqlite3VdbeJumpHere(v, addrOnce)
}
func allocateIndexInfo(pWInfo *struct_WhereInfo, pWC *struct_WhereClause, mUnusable uint64, pSrc *struct_SrcItem, pmNoOmit *uint16) *struct_sqlite3_index_info {
	var i int32
	var j int32
	var nTerm int32
	var pParse *struct_Parse = pWInfo.pParse
	var pIdxCons *struct_sqlite3_index_constraint
	var pIdxOrderBy *struct_sqlite3_index_orderby
	var pUsage *struct_sqlite3_index_constraint_usage
	var pHidden *struct_HiddenIndexInfo
	var pTerm *struct_WhereTerm
	var nOrderBy int32
	var pIdxInfo *struct_sqlite3_index_info
	var mNoOmit uint16 = uint16(0)
	var pTab *struct_Table
	var eDistinct int32 = 0
	var pOrderBy *struct_ExprList = pWInfo.pOrderBy
	func() int {
		_ = 0
		return 0
	}()
	pTab = pSrc.pTab
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for func() *struct_WhereTerm {
		i = func() (_cgo_ret int32) {
			_cgo_addr := &nTerm
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			*_cgo_addr = pWC.a
			return *_cgo_addr
		}()
	}(); i < pWC.nTerm; func() *struct_WhereTerm {
		i++
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		pTerm.wtFlags &= uint16(^64)
		if pTerm.leftCursor != pSrc.iCursor {
			continue
		}
		if pTerm.prereqRight&mUnusable != 0 {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		if int32(pTerm.eOperator) & ^2048 == 0 {
			continue
		}
		if int32(pTerm.wtFlags)&128 != 0 {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if int32(pSrc.fg.jointype)&8 != 0 && !(pTerm.pExpr.flags&uint32(1) != uint32(0)) {
			continue
		}
		nTerm++
		pTerm.wtFlags |= uint16(64)
	}
	nOrderBy = int32(0)
	if pOrderBy != nil {
		var n int32 = pOrderBy.nExpr
		for i = int32(0); i < n; i++ {
			var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr
			var pE2 *struct_Expr
			if sqlite3ExprIsConstant(pExpr) != 0 {
				continue
			}
			if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).sortFlags)&2 != 0 {
				break
			}
			if int32(pExpr.op) == 167 && pExpr.iTable == pSrc.iCursor {
				func() int {
					_ = 0
					return 0
				}()
				continue
			}
			if int32(pExpr.op) == 113 && int32(func() (_cgo_ret *struct_Expr) {
				_cgo_addr := &pE2
				*_cgo_addr = pExpr.pLeft
				return *_cgo_addr
			}().op) == 167 && pE2.iTable == pSrc.iCursor {
				var zColl *int8
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pExpr.iColumn = pE2.iColumn
				if int32(pE2.iColumn) < 0 {
					continue
				}
				zColl = sqlite3ColumnColl(&*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(pE2.iColumn)*20)))
				if uintptr(unsafe.Pointer(zColl)) == uintptr(unsafe.Pointer(nil)) {
					zColl = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
				}
				if sqlite3_stricmp(pExpr.u.zToken, zColl) == 0 {
					continue
				}
			}
			break
		}
		if i == n {
			nOrderBy = n
			if int32(pWInfo.wctrlFlags)&(64|128) != 0 {
				eDistinct = 1 + func() int32 {
					if int32(pWInfo.wctrlFlags)&128 != 0 {
						return 1
					} else {
						return 0
					}
				}()
			}
		}
	}
	pIdxInfo = (*struct_sqlite3_index_info)(sqlite3DbMallocZero(pParse.db, uint64(96+(12+5)*uint(nTerm)+5*uint(nOrderBy)+40+8*uint(nTerm))))
	if uintptr(unsafe.Pointer(pIdxInfo)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})))
		return (*struct_sqlite3_index_info)(nil)
	}
	pHidden = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	pIdxCons = (*struct_sqlite3_index_constraint)(unsafe.Pointer(&*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pHidden.aRhs)))) + uintptr(nTerm)*8))))
	pIdxOrderBy = (*struct_sqlite3_index_orderby)(unsafe.Pointer(&*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(nTerm)*12))))
	pUsage = (*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(&*(*struct_sqlite3_index_orderby)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxOrderBy)) + uintptr(nOrderBy)*5))))
	pIdxInfo.aConstraint = pIdxCons
	pIdxInfo.aOrderBy = pIdxOrderBy
	pIdxInfo.aConstraintUsage = pUsage
	pHidden.pWC = pWC
	pHidden.pParse = pParse
	pHidden.eDistinct = eDistinct
	pHidden.mIn = uint32(0)
	for func() *struct_WhereTerm {
		i = func() (_cgo_ret int32) {
			_cgo_addr := &j
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			*_cgo_addr = pWC.a
			return *_cgo_addr
		}()
	}(); i < pWC.nTerm; func() *struct_WhereTerm {
		i++
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		var op uint16
		if int32(pTerm.wtFlags)&64 == 0 {
			continue
		}
		(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).iColumn = pTerm.u.x.leftColumn
		(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).iTermOffset = i
		op = uint16(int32(pTerm.eOperator) & 8191)
		if int32(op) == 1 {
			if int32(pTerm.wtFlags)&32768 == 0 {
				pHidden.mIn |= func() uint32 {
					if j <= 31 {
						return uint32(1) << j
					} else {
						return uint32(0)
					}
				}()
			}
			op = uint16(2)
		}
		if int32(op) == 64 {
			(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).op = pTerm.eMatchOp
		} else if int32(op)&(256|128) != 0 {
			if int32(op) == 256 {
				(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).op = uint8(71)
			} else {
				(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).op = uint8(72)
			}
		} else {
			(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).op = uint8(op)
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(op)&(2<<(56-53)|2<<(55-53)|2<<(54-53)|2<<(57-53)) != 0 && sqlite3ExprIsVector(pTerm.pExpr.pRight) != 0 {
				if j < 16 {
					mNoOmit |= uint16(1 << j)
				}
				if int32(op) == 2<<(56-53) {
					(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).op = uint8(2 << (55 - 53))
				}
				if int32(op) == 2<<(54-53) {
					(*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxCons)) + uintptr(j)*12))).op = uint8(2 << (57 - 53))
				}
			}
		}
		j++
	}
	func() int {
		_ = 0
		return 0
	}()
	pIdxInfo.nConstraint = j
	for i = func() (_cgo_ret int32) {
		_cgo_addr := &j
		*_cgo_addr = int32(0)
		return *_cgo_addr
	}(); i < nOrderBy; i++ {
		var pExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr
		if sqlite3ExprIsConstant(pExpr) != 0 {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		(*(*struct_sqlite3_index_orderby)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxOrderBy)) + uintptr(j)*5))).iColumn = int32(pExpr.iColumn)
		(*(*struct_sqlite3_index_orderby)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxOrderBy)) + uintptr(j)*5))).desc = uint8(int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).sortFlags) & 1)
		j++
	}
	pIdxInfo.nOrderBy = j
	*pmNoOmit = mNoOmit
	return pIdxInfo
}
func freeIndexInfo(db *struct_sqlite3, pIdxInfo *struct_sqlite3_index_info) {
	var pHidden *struct_HiddenIndexInfo
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	pHidden = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < pIdxInfo.nConstraint; i++ {
		sqlite3ValueFree(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pHidden.aRhs)))) + uintptr(i)*8)))
		*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pHidden.aRhs)))) + uintptr(i)*8)) = (*struct_sqlite3_value)(nil)
	}
	sqlite3DbFree(db, unsafe.Pointer(pIdxInfo))
}
func vtabBestIndex(pParse *struct_Parse, pTab *struct_Table, p *struct_sqlite3_index_info) int32 {
	var pVtab *struct_sqlite3_vtab = sqlite3GetVTable(pParse.db, pTab).pVtab
	var rc int32
	pParse.db.nSchemaLock++
	rc = pVtab.pModule.xBestIndex(pVtab, p)
	pParse.db.nSchemaLock--
	if rc != 0 && rc != 19 {
		if rc == 7 {
			sqlite3OomFault(pParse.db)
		} else if !(pVtab.zErrMsg != nil) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3ErrStr(rc))
		} else {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), pVtab.zErrMsg)
		}
	}
	sqlite3_free(unsafe.Pointer(pVtab.zErrMsg))
	pVtab.zErrMsg = (*int8)(nil)
	return rc
}
func whereRangeAdjust(pTerm *struct_WhereTerm, nNew int16) int16 {
	var nRet int16 = nNew
	if pTerm != nil {
		if int32(pTerm.truthProb) <= 0 {
			nRet += int16(int32(pTerm.truthProb))
		} else if int32(pTerm.wtFlags)&128 == 0 {
			nRet -= int16(20)
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	return nRet
}
func whereRangeScanEst(pParse *struct_Parse, pBuilder *struct_WhereLoopBuilder, pLower *struct_WhereTerm, pUpper *struct_WhereTerm, pLoop *struct_WhereLoop) int32 {
	var rc int32 = 0
	var nOut int32 = int32(pLoop.nOut)
	var nNew int16
	func() int {
		_ = pParse
		return 0
	}()
	func() int {
		_ = pBuilder
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nNew = whereRangeAdjust(pLower, int16(nOut))
	nNew = whereRangeAdjust(pUpper, nNew)
	if pLower != nil && int32(pLower.truthProb) > 0 && pUpper != nil && int32(pUpper.truthProb) > 0 {
		nNew -= int16(20)
	}
	nOut -= func() int32 {
		if uintptr(unsafe.Pointer(pLower)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}() + func() int32 {
		if uintptr(unsafe.Pointer(pUpper)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	if int32(nNew) < 10 {
		nNew = int16(10)
	}
	if int32(nNew) < nOut {
		nOut = int32(nNew)
	}
	pLoop.nOut = int16(nOut)
	return rc
}
func whereLoopInit(p *struct_WhereLoop) {
	p.aLTerm = (**struct_WhereTerm)(unsafe.Pointer(&p.aLTermSpace))
	p.nLTerm = uint16(0)
	p.nLSlot = uint16(int32(24 / 8))
	p.wsFlags = uint32(0)
}
func whereLoopClearUnion(db *struct_sqlite3, p *struct_WhereLoop) {
	if p.wsFlags&uint32(1024|16384) != 0 {
		if p.wsFlags&uint32(1024) != uint32(0) && int32(p.u.vtab.Xbf_0&1) != 0 {
			sqlite3_free(unsafe.Pointer(p.u.vtab.idxStr))
			{
				_autoGo_89 := &p.u.vtab.Xbf_0
				*_autoGo_89 = *_autoGo_89&^1 | uint32(0)&1
			}
			p.u.vtab.idxStr = (*int8)(nil)
		} else if p.wsFlags&uint32(16384) != uint32(0) && uintptr(unsafe.Pointer((*(*_cgoa_84)(unsafe.Pointer(&p.u))).pIndex)) != uintptr(unsafe.Pointer(nil)) {
			sqlite3DbFree(db, unsafe.Pointer((*(*_cgoa_84)(unsafe.Pointer(&p.u))).pIndex.zColAff))
			sqlite3DbFreeNN(db, unsafe.Pointer((*(*_cgoa_84)(unsafe.Pointer(&p.u))).pIndex))
			(*(*_cgoa_84)(unsafe.Pointer(&p.u))).pIndex = (*struct_Index)(nil)
		}
	}
}
func whereLoopClear(db *struct_sqlite3, p *struct_WhereLoop) {
	if uintptr(unsafe.Pointer(p.aLTerm)) != uintptr(unsafe.Pointer((**struct_WhereTerm)(unsafe.Pointer(&p.aLTermSpace)))) {
		sqlite3DbFreeNN(db, unsafe.Pointer(p.aLTerm))
	}
	whereLoopClearUnion(db, p)
	whereLoopInit(p)
}
func whereLoopResize(db *struct_sqlite3, p *struct_WhereLoop, n int32) int32 {
	var paNew **struct_WhereTerm
	if int32(p.nLSlot) >= n {
		return int32(0)
	}
	n = (n + 7) & ^7
	paNew = (**struct_WhereTerm)(sqlite3DbMallocRawNN(db, uint64(8*uint(n))))
	if uintptr(unsafe.Pointer(paNew)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memcpy_chk(unsafe.Pointer(paNew), unsafe.Pointer(p.aLTerm), 8*uint(p.nLSlot), __builtin_object_size(unsafe.Pointer(paNew), 0))
	if uintptr(unsafe.Pointer(p.aLTerm)) != uintptr(unsafe.Pointer((**struct_WhereTerm)(unsafe.Pointer(&p.aLTermSpace)))) {
		sqlite3DbFreeNN(db, unsafe.Pointer(p.aLTerm))
	}
	p.aLTerm = paNew
	p.nLSlot = uint16(n)
	return int32(0)
}
func whereLoopXfer(db *struct_sqlite3, pTo *struct_WhereLoop, pFrom *struct_WhereLoop) int32 {
	whereLoopClearUnion(db, pTo)
	if whereLoopResize(db, pTo, int32(pFrom.nLTerm)) != 0 {
		__builtin___memset_chk(unsafe.Pointer(pTo), 0, 60, __builtin_object_size(unsafe.Pointer(pTo), 0))
		return int32(7)
	}
	__builtin___memcpy_chk(unsafe.Pointer(pTo), unsafe.Pointer(pFrom), 60, __builtin_object_size(unsafe.Pointer(pTo), 0))
	__builtin___memcpy_chk(unsafe.Pointer(pTo.aLTerm), unsafe.Pointer(pFrom.aLTerm), uint(pTo.nLTerm)*8, __builtin_object_size(unsafe.Pointer(pTo.aLTerm), 0))
	if pFrom.wsFlags&uint32(1024) != 0 {
		{
			_autoGo_90 := &pFrom.u.vtab.Xbf_0
			*_autoGo_90 = *_autoGo_90&^1 | uint32(0)&1
		}
	} else if pFrom.wsFlags&uint32(16384) != uint32(0) {
		(*(*_cgoa_84)(unsafe.Pointer(&pFrom.u))).pIndex = (*struct_Index)(nil)
	}
	return int32(0)
}
func whereLoopDelete(db *struct_sqlite3, p *struct_WhereLoop) {
	whereLoopClear(db, p)
	sqlite3DbFreeNN(db, unsafe.Pointer(p))
}
func whereInfoFree(db *struct_sqlite3, pWInfo *struct_WhereInfo) {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < int32(pWInfo.nLevel); i++ {
		var pLevel *struct_WhereLevel = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))
		if pLevel.pWLoop != nil && pLevel.pWLoop.wsFlags&uint32(2048) != uint32(0) {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3DbFree(db, unsafe.Pointer(pLevel.u.in.aInLoop))
		}
	}
	sqlite3WhereClauseClear(&pWInfo.sWC)
	for pWInfo.pLoops != nil {
		var p *struct_WhereLoop = pWInfo.pLoops
		pWInfo.pLoops = p.pNextLoop
		whereLoopDelete(db, p)
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3DbFreeNN(db, unsafe.Pointer(pWInfo))
}
func whereUndoExprMods(pWInfo *struct_WhereInfo) {
	for pWInfo.pExprMods != nil {
		var p *struct_WhereExprMod = pWInfo.pExprMods
		pWInfo.pExprMods = p.pNext
		__builtin___memcpy_chk(unsafe.Pointer(p.pExpr), unsafe.Pointer(&p.orig), 72, __builtin_object_size(unsafe.Pointer(p.pExpr), 0))
		sqlite3DbFree(pWInfo.pParse.db, unsafe.Pointer(p))
	}
}
func whereLoopCheaperProperSubset(pX *struct_WhereLoop, pY *struct_WhereLoop) int32 {
	var i int32
	var j int32
	if int32(pX.nLTerm)-int32(pX.nSkip) >= int32(pY.nLTerm)-int32(pY.nSkip) {
		return int32(0)
	}
	if int32(pX.rRun) > int32(pY.rRun) && int32(pX.nOut) > int32(pY.nOut) {
		return int32(0)
	}
	if int32(pY.nSkip) > int32(pX.nSkip) {
		return int32(0)
	}
	for i = int32(pX.nLTerm) - 1; i >= 0; i-- {
		if uintptr(unsafe.Pointer(*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pX.aLTerm)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		for j = int32(pY.nLTerm) - 1; j >= 0; j-- {
			if uintptr(unsafe.Pointer(*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pY.aLTerm)) + uintptr(j)*8)))) == uintptr(unsafe.Pointer(*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pX.aLTerm)) + uintptr(i)*8)))) {
				break
			}
		}
		if j < 0 {
			return int32(0)
		}
	}
	if pX.wsFlags&uint32(64) != uint32(0) && pY.wsFlags&uint32(64) == uint32(0) {
		return int32(0)
	}
	return int32(1)
}
func whereLoopAdjustCost(p *struct_WhereLoop, pTemplate *struct_WhereLoop) {
	if pTemplate.wsFlags&uint32(512) == uint32(0) {
		return
	}
	for ; p != nil; p = p.pNextLoop {
		if int32(p.iTab) != int32(pTemplate.iTab) {
			continue
		}
		if p.wsFlags&uint32(512) == uint32(0) {
			continue
		}
		if whereLoopCheaperProperSubset(p, pTemplate) != 0 {
			pTemplate.rRun = int16(func() int32 {
				if int32(p.rRun) < int32(pTemplate.rRun) {
					return int32(p.rRun)
				} else {
					return int32(pTemplate.rRun)
				}
			}())
			pTemplate.nOut = int16(func() int32 {
				if int32(p.nOut)-1 < int32(pTemplate.nOut) {
					return int32(p.nOut) - 1
				} else {
					return int32(pTemplate.nOut)
				}
			}())
		} else if whereLoopCheaperProperSubset(pTemplate, p) != 0 {
			pTemplate.rRun = int16(func() int32 {
				if int32(p.rRun) > int32(pTemplate.rRun) {
					return int32(p.rRun)
				} else {
					return int32(pTemplate.rRun)
				}
			}())
			pTemplate.nOut = int16(func() int32 {
				if int32(p.nOut)+1 > int32(pTemplate.nOut) {
					return int32(p.nOut) + 1
				} else {
					return int32(pTemplate.nOut)
				}
			}())
		}
	}
}
func whereLoopFindLesser(ppPrev **struct_WhereLoop, pTemplate *struct_WhereLoop) **struct_WhereLoop {
	var p *struct_WhereLoop
	for p = *ppPrev; p != nil; func() *struct_WhereLoop {
		ppPrev = &p.pNextLoop
		return func() (_cgo_ret *struct_WhereLoop) {
			_cgo_addr := &p
			*_cgo_addr = *ppPrev
			return *_cgo_addr
		}()
	}() {
		if int32(p.iTab) != int32(pTemplate.iTab) || int32(p.iSortIdx) != int32(pTemplate.iSortIdx) {
			continue
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if p.wsFlags&uint32(16384) != uint32(0) && int32(pTemplate.nSkip) == 0 && pTemplate.wsFlags&uint32(512) != uint32(0) && pTemplate.wsFlags&uint32(1) != uint32(0) && p.prereq&pTemplate.prereq == pTemplate.prereq {
			break
		}
		if p.prereq&pTemplate.prereq == p.prereq && int32(p.rSetup) <= int32(pTemplate.rSetup) && int32(p.rRun) <= int32(pTemplate.rRun) && int32(p.nOut) <= int32(pTemplate.nOut) {
			return (**struct_WhereLoop)(nil)
		}
		if p.prereq&pTemplate.prereq == pTemplate.prereq && int32(p.rRun) >= int32(pTemplate.rRun) && int32(p.nOut) >= int32(pTemplate.nOut) {
			func() int {
				_ = 0
				return 0
			}()
			break
		}
	}
	return ppPrev
}
func whereLoopInsert(pBuilder *struct_WhereLoopBuilder, pTemplate *struct_WhereLoop) int32 {
	var ppPrev **struct_WhereLoop
	var p *struct_WhereLoop
	var pWInfo *struct_WhereInfo = pBuilder.pWInfo
	var db *struct_sqlite3 = pWInfo.pParse.db
	var rc int32
	if pBuilder.iPlanLimit == uint32(0) {
		if pBuilder.pOrSet != nil {
			pBuilder.pOrSet.n = uint16(0)
		}
		return int32(101)
	}
	pBuilder.iPlanLimit--
	whereLoopAdjustCost(pWInfo.pLoops, pTemplate)
	if uintptr(unsafe.Pointer(pBuilder.pOrSet)) != uintptr(unsafe.Pointer(nil)) {
		if pTemplate.nLTerm != 0 {
			whereOrInsert(pBuilder.pOrSet, pTemplate.prereq, pTemplate.rRun, pTemplate.nOut)
		}
		return int32(0)
	}
	ppPrev = whereLoopFindLesser(&pWInfo.pLoops, pTemplate)
	if uintptr(unsafe.Pointer(ppPrev)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	} else {
		p = *ppPrev
	}
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		*ppPrev = func() (_cgo_ret *struct_WhereLoop) {
			_cgo_addr := &p
			*_cgo_addr = (*struct_WhereLoop)(sqlite3DbMallocRawNN(db, uint64(104)))
			return *_cgo_addr
		}()
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		whereLoopInit(p)
		p.pNextLoop = (*struct_WhereLoop)(nil)
	} else {
		var ppTail **struct_WhereLoop = &p.pNextLoop
		var pToDel *struct_WhereLoop
		for *ppTail != nil {
			ppTail = whereLoopFindLesser(ppTail, pTemplate)
			if uintptr(unsafe.Pointer(ppTail)) == uintptr(unsafe.Pointer(nil)) {
				break
			}
			pToDel = *ppTail
			if uintptr(unsafe.Pointer(pToDel)) == uintptr(unsafe.Pointer(nil)) {
				break
			}
			*ppTail = pToDel.pNextLoop
			whereLoopDelete(db, pToDel)
		}
	}
	rc = whereLoopXfer(db, p, pTemplate)
	if p.wsFlags&uint32(1024) == uint32(0) {
		var pIndex *struct_Index = (*(*_cgoa_84)(unsafe.Pointer(&p.u))).pIndex
		if pIndex != nil && int32(pIndex.Xbf_0&3) == 3 {
			(*(*_cgoa_84)(unsafe.Pointer(&p.u))).pIndex = (*struct_Index)(nil)
		}
	}
	return rc
}
func whereLoopOutputAdjust(pWC *struct_WhereClause, pLoop *struct_WhereLoop, nRow int16) {
	var pTerm *struct_WhereTerm
	var pX *struct_WhereTerm
	var notAllowed uint64 = ^(pLoop.prereq | pLoop.maskSelf)
	var i int32
	var j int32
	var iReduce int16 = int16(0)
	func() int {
		_ = 0
		return 0
	}()
	for func() *struct_WhereTerm {
		i = pWC.nBase
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			*_cgo_addr = pWC.a
			return *_cgo_addr
		}()
	}(); i > 0; func() *struct_WhereTerm {
		i--
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		func() int {
			_ = 0
			return 0
		}()
		if pTerm.prereqAll&notAllowed != uint64(0) {
			continue
		}
		if pTerm.prereqAll&pLoop.maskSelf == uint64(0) {
			continue
		}
		if int32(pTerm.wtFlags)&2 != 0 {
			continue
		}
		for j = int32(pLoop.nLTerm) - 1; j >= 0; j-- {
			pX = *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))
			if uintptr(unsafe.Pointer(pX)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			if uintptr(unsafe.Pointer(pX)) == uintptr(unsafe.Pointer(pTerm)) {
				break
			}
			if pX.iParent >= 0 && uintptr(unsafe.Pointer(&*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(pX.iParent)*56)))) == uintptr(unsafe.Pointer(pTerm)) {
				break
			}
		}
		if j < 0 {
			if pLoop.maskSelf == pTerm.prereqAll {
				if int32(pTerm.eOperator)&63 != 0 || int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWC.pWInfo.pTabList.a)))) + uintptr(pLoop.iTab)*112))).fg.jointype)&8 == 0 {
					pLoop.wsFlags |= uint32(8388608)
				}
			}
			if int32(pTerm.truthProb) <= 0 {
				pLoop.nOut += int16(int32(pTerm.truthProb))
			} else {
				pLoop.nOut--
				if int32(pTerm.eOperator)&(2|128) != 0 && int32(pTerm.wtFlags)&0 == 0 {
					var pRight *struct_Expr = pTerm.pExpr.pRight
					var k int32 = 0
					if sqlite3ExprIsInteger(pRight, &k) != 0 && k >= -1 && k <= 1 {
						k = int32(10)
					} else {
						k = int32(20)
					}
					if int32(iReduce) < k {
						pTerm.wtFlags |= uint16(8192)
						iReduce = int16(k)
					}
				}
			}
		}
	}
	if int32(pLoop.nOut) > int32(nRow)-int32(iReduce) {
		pLoop.nOut = int16(int32(nRow) - int32(iReduce))
	}
}
func whereRangeVectorLen(pParse *struct_Parse, iCur int32, pIdx *struct_Index, nEq int32, pTerm *struct_WhereTerm) int32 {
	var nCmp int32 = sqlite3ExprVectorSize(pTerm.pExpr.pLeft)
	var i int32
	nCmp = func() int32 {
		if nCmp < int32(pIdx.nColumn)-nEq {
			return nCmp
		} else {
			return int32(pIdx.nColumn) - nEq
		}
	}()
	for i = int32(1); i < nCmp; i++ {
		var aff int8
		var idxaff int8 = int8(0)
		var pColl *struct_CollSeq
		var pLhs *struct_Expr
		var pRhs *struct_Expr
		func() int {
			_ = 0
			return 0
		}()
		pLhs = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pTerm.pExpr.pLeft.x.pList.a)))) + uintptr(i)*28))).pExpr
		pRhs = pTerm.pExpr.pRight
		if pRhs.flags&uint32(2048) != uint32(0) {
			pRhs = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_Select)(unsafe.Pointer(&pRhs.x))).pEList.a)))) + uintptr(i)*28))).pExpr
		} else {
			pRhs = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pRhs.x.pList.a)))) + uintptr(i)*28))).pExpr
		}
		if int32(pLhs.op) != 167 || pLhs.iTable != iCur || int32(pLhs.iColumn) != int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiColumn)) + uintptr(i+nEq)*2))) || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(i+nEq)))) != int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aSortOrder)) + uintptr(nEq)))) {
			break
		}
		aff = sqlite3CompareAffinity(pRhs, sqlite3ExprAffinity(pLhs))
		idxaff = sqlite3TableColumnAffinity(pIdx.pTable, int32(pLhs.iColumn))
		if int32(aff) != int32(idxaff) {
			break
		}
		pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs)
		if uintptr(unsafe.Pointer(pColl)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		if sqlite3StrICmp(pColl.zName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.azColl)) + uintptr(i+nEq)*8))) != 0 {
			break
		}
	}
	return i
}
func whereLoopAddBtreeIndex(pBuilder *struct_WhereLoopBuilder, pSrc *struct_SrcItem, pProbe *struct_Index, nInMul int16) int32 {
	var pWInfo *struct_WhereInfo = pBuilder.pWInfo
	var pParse *struct_Parse = pWInfo.pParse
	var db *struct_sqlite3 = pParse.db
	var pNew *struct_WhereLoop
	var pTerm *struct_WhereTerm
	var opMask int32
	var scan struct_WhereScan
	var saved_prereq uint64
	var saved_nLTerm uint16
	var saved_nEq uint16
	var saved_nBtm uint16
	var saved_nTop uint16
	var saved_nSkip uint16
	var saved_wsFlags uint32
	var saved_nOut int16
	var rc int32 = 0
	var rSize int16
	var rLogSize int16
	var pTop *struct_WhereTerm = nil
	var pBtm *struct_WhereTerm = nil
	pNew = pBuilder.pNew
	if db.mallocFailed != 0 {
		return int32(7)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if pNew.wsFlags&uint32(32) != 0 {
		opMask = int32(2<<(56-53) | 2<<(55-53))
	} else {
		func() int {
			_ = 0
			return 0
		}()
		opMask = int32(2 | 1 | 2<<(54-53) | 2<<(57-53) | 2<<(56-53) | 2<<(55-53) | 256 | 128)
	}
	if pProbe.Xbf_0>>2&1 != 0 {
		opMask &= int32(^(2<<(54-53) | 2<<(57-53) | 2<<(56-53) | 2<<(55-53)))
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	saved_nEq = (*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq
	saved_nBtm = (*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nBtm
	saved_nTop = (*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nTop
	saved_nSkip = pNew.nSkip
	saved_nLTerm = pNew.nLTerm
	saved_wsFlags = pNew.wsFlags
	saved_prereq = pNew.prereq
	saved_nOut = pNew.nOut
	pTerm = whereScanInit(&scan, pBuilder.pWC, pSrc.iCursor, int32(saved_nEq), uint32(opMask), pProbe)
	pNew.rSetup = int16(0)
	rSize = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(0)*2))
	rLogSize = estLog(rSize)
	for ; rc == 0 && uintptr(unsafe.Pointer(pTerm)) != uintptr(unsafe.Pointer(nil)); pTerm = whereScanNext(&scan) {
		var eOp uint16 = pTerm.eOperator
		var rCostIdx int16
		var nOutUnadjusted int16
		var nIn int32 = 0
		if (int32(eOp) == 256 || int32(pTerm.wtFlags)&128 != 0) && indexColumnNotNull(pProbe, int32(saved_nEq)) != 0 {
			continue
		}
		if pTerm.prereqRight&pNew.maskSelf != 0 {
			continue
		}
		if int32(pTerm.wtFlags)&256 != 0 && int32(pTerm.eOperator) == 2<<(56-53) {
			continue
		}
		if int32(pSrc.fg.jointype)&8 != 0 && !(pTerm.pExpr.flags&uint32(1) != uint32(0)) {
			continue
		}
		if int32(pProbe.onError) != 0 && int32(saved_nEq) == int32(pProbe.nKeyCol)-1 {
			pBuilder.bldFlags1 |= uint8(2)
		} else {
			pBuilder.bldFlags1 |= uint8(1)
		}
		pNew.wsFlags = saved_wsFlags
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq = saved_nEq
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nBtm = saved_nBtm
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nTop = saved_nTop
		pNew.nLTerm = saved_nLTerm
		if whereLoopResize(db, pNew, int32(pNew.nLTerm)+1) != 0 {
			break
		}
		*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(func() (_cgo_ret uint16) {
			_cgo_addr := &pNew.nLTerm
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*8)) = pTerm
		pNew.prereq = (saved_prereq | pTerm.prereqRight) & ^pNew.maskSelf
		func() int {
			_ = 0
			return 0
		}()
		if int32(eOp)&1 != 0 {
			var pExpr *struct_Expr = pTerm.pExpr
			if pExpr.flags&uint32(2048) != uint32(0) {
				var i int32
				nIn = int32(46)
				func() int {
					_ = 0
					return 0
				}()
				for i = int32(0); i < int32(pNew.nLTerm)-1; i++ {
					if *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(i)*8)) != nil && uintptr(unsafe.Pointer((*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(i)*8))).pExpr)) == uintptr(unsafe.Pointer(pExpr)) {
						nIn = int32(0)
					}
				}
			} else if pExpr.x.pList != nil && pExpr.x.pList.nExpr != 0 {
				nIn = int32(sqlite3LogEst(uint64(pExpr.x.pList.nExpr)))
			}
			if int32(pProbe.Xbf_0>>7&1) != 0 && int32(rLogSize) >= 10 {
				var M int16
				var logK int16
				var x int16
				M = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(saved_nEq)*2))
				logK = estLog(int16(nIn))
				x = int16(int32(M) + int32(logK) + 10 - (nIn + int32(rLogSize)))
				if int32(x) >= 0 {
				} else if int32(nInMul) < 2 && db.dbOptFlags&uint32(131072) == uint32(0) {
					pNew.wsFlags |= uint32(1048576)
				} else {
					continue
				}
			}
			pNew.wsFlags |= uint32(4)
		} else if int32(eOp)&(2|128) != 0 {
			var iCol int32 = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiColumn)) + uintptr(saved_nEq)*2)))
			pNew.wsFlags |= uint32(1)
			func() int {
				_ = 0
				return 0
			}()
			if iCol == -1 || iCol >= 0 && int32(nInMul) == 0 && int32(saved_nEq) == int32(pProbe.nKeyCol)-1 {
				if iCol == -1 || int32(pProbe.Xbf_0>>3&1) != 0 || int32(pProbe.nKeyCol) == 1 && int32(pProbe.onError) != 0 && int32(eOp) == 2 {
					pNew.wsFlags |= uint32(4096)
				} else {
					pNew.wsFlags |= uint32(65536)
				}
			}
			if int32(scan.iEquiv) > 1 {
				pNew.wsFlags |= uint32(2097152)
			}
		} else if int32(eOp)&256 != 0 {
			pNew.wsFlags |= uint32(8)
		} else if int32(eOp)&(2<<(54-53)|2<<(57-53)) != 0 {
			pNew.wsFlags |= uint32(2 | 32)
			(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nBtm = uint16(whereRangeVectorLen(pParse, pSrc.iCursor, pProbe, int32(saved_nEq), pTerm))
			pBtm = pTerm
			pTop = (*struct_WhereTerm)(nil)
			if int32(pTerm.wtFlags)&256 != 0 {
				pTop = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pTerm)) + uintptr(1)*56))
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				if whereLoopResize(db, pNew, int32(pNew.nLTerm)+1) != 0 {
					break
				}
				*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(func() (_cgo_ret uint16) {
					_cgo_addr := &pNew.nLTerm
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())*8)) = pTop
				pNew.wsFlags |= uint32(16)
				(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nTop = uint16(1)
			}
		} else {
			func() int {
				_ = 0
				return 0
			}()
			pNew.wsFlags |= uint32(2 | 16)
			(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nTop = uint16(whereRangeVectorLen(pParse, pSrc.iCursor, pProbe, int32(saved_nEq), pTerm))
			pTop = pTerm
			pBtm = func() *struct_WhereTerm {
				if pNew.wsFlags&uint32(32) != uint32(0) {
					return *(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(int32(pNew.nLTerm)-2)*8))
				} else {
					return nil
				}
			}()
		}
		func() int {
			_ = 0
			return 0
		}()
		if pNew.wsFlags&uint32(2) != 0 {
			whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew)
		} else {
			var nEq int32 = int32(func() (_cgo_ret uint16) {
				_cgo_addr := &(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq
				*_cgo_addr++
				return *_cgo_addr
			}())
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if int32(pTerm.truthProb) <= 0 && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiColumn)) + uintptr(saved_nEq)*2))) >= 0 {
				func() int {
					_ = 0
					return 0
				}()
				pNew.nOut += int16(int32(pTerm.truthProb))
				pNew.nOut -= int16(nIn)
			} else {
				{
					pNew.nOut += int16(int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(nEq)*2))) - int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(nEq-1)*2))))
					if int32(eOp)&256 != 0 {
						pNew.nOut += int16(10)
					}
				}
			}
		}
		func() int {
			_ = 0
			return 0
		}()
		rCostIdx = int16(int32(pNew.nOut) + 1 + 15*int32(pProbe.szIdxRow)/int32(pSrc.pTab.szTabRow))
		pNew.rRun = sqlite3LogEstAdd(rLogSize, rCostIdx)
		if pNew.wsFlags&uint32(64|256) == uint32(0) {
			pNew.rRun = sqlite3LogEstAdd(pNew.rRun, int16(int32(pNew.nOut)+16))
		}
		nOutUnadjusted = pNew.nOut
		pNew.rRun += int16(int32(nInMul) + nIn)
		pNew.nOut += int16(int32(nInMul) + nIn)
		whereLoopOutputAdjust(pBuilder.pWC, pNew, rSize)
		rc = whereLoopInsert(pBuilder, pNew)
		if pNew.wsFlags&uint32(2) != 0 {
			pNew.nOut = saved_nOut
		} else {
			pNew.nOut = nOutUnadjusted
		}
		if pNew.wsFlags&uint32(16) == uint32(0) && int32((*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq) < int32(pProbe.nColumn) && (int32((*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq) < int32(pProbe.nKeyCol) || int32(pProbe.Xbf_0&3) != 2) {
			whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, int16(int32(nInMul)+nIn))
		}
		pNew.nOut = saved_nOut
	}
	pNew.prereq = saved_prereq
	(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq = saved_nEq
	(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nBtm = saved_nBtm
	(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nTop = saved_nTop
	pNew.nSkip = saved_nSkip
	pNew.wsFlags = saved_wsFlags
	pNew.nOut = saved_nOut
	pNew.nLTerm = saved_nLTerm
	func() int {
		_ = 0
		return 0
	}()
	if int32(saved_nEq) == int32(saved_nSkip) && int32(saved_nEq)+1 < int32(pProbe.nKeyCol) && int32(saved_nEq) == int32(pNew.nLTerm) && int32(pProbe.Xbf_0>>6&1) == 0 && int32(pProbe.Xbf_0>>7&1) != 0 && db.dbOptFlags&uint32(16384) == uint32(0) && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(int32(saved_nEq)+1)*2))) >= 42 && func() (_cgo_ret int32) {
		_cgo_addr := &rc
		*_cgo_addr = whereLoopResize(db, pNew, int32(pNew.nLTerm)+1)
		return *_cgo_addr
	}() == 0 {
		var nIter int16
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq++
		pNew.nSkip++
		*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(func() (_cgo_ret uint16) {
			_cgo_addr := &pNew.nLTerm
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}())*8)) = (*struct_WhereTerm)(nil)
		pNew.wsFlags |= uint32(32768)
		nIter = int16(int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(saved_nEq)*2))) - int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(int32(saved_nEq)+1)*2))))
		pNew.nOut -= int16(int32(nIter))
		nIter += int16(5)
		whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, int16(int32(nIter)+int32(nInMul)))
		pNew.nOut = saved_nOut
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq = saved_nEq
		pNew.nSkip = saved_nSkip
		pNew.wsFlags = saved_wsFlags
	}
	return rc
}
func indexMightHelpWithOrderBy(pBuilder *struct_WhereLoopBuilder, pIndex *struct_Index, iCursor int32) int32 {
	var pOB *struct_ExprList
	var aColExpr *struct_ExprList
	var ii int32
	var jj int32
	if pIndex.Xbf_0>>2&1 != 0 {
		return int32(0)
	}
	if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_ExprList) {
		_cgo_addr := &pOB
		*_cgo_addr = pBuilder.pWInfo.pOrderBy
		return *_cgo_addr
	}())) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	for ii = int32(0); ii < pOB.nExpr; ii++ {
		var pExpr *struct_Expr = sqlite3ExprSkipCollateAndLikely((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOB.a)))) + uintptr(ii)*28))).pExpr)
		if uintptr(unsafe.Pointer(pExpr)) == uintptr(unsafe.Pointer(nil)) {
			continue
		}
		if int32(pExpr.op) == 167 && pExpr.iTable == iCursor {
			if int32(pExpr.iColumn) < 0 {
				return int32(1)
			}
			for jj = int32(0); jj < int32(pIndex.nKeyCol); jj++ {
				if int32(pExpr.iColumn) == int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(jj)*2))) {
					return int32(1)
				}
			}
		} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_ExprList) {
			_cgo_addr := &aColExpr
			*_cgo_addr = pIndex.aColExpr
			return *_cgo_addr
		}())) != uintptr(unsafe.Pointer(nil)) {
			for jj = int32(0); jj < int32(pIndex.nKeyCol); jj++ {
				if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(jj)*2))) != -2 {
					continue
				}
				if sqlite3ExprCompareSkip(pExpr, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&aColExpr.a)))) + uintptr(jj)*28))).pExpr, iCursor) == 0 {
					return int32(1)
				}
			}
		}
	}
	return int32(0)
}
func whereUsablePartialIndex(iTab int32, isLeft int32, pWC *struct_WhereClause, pWhere *struct_Expr) int32 {
	var i int32
	var pTerm *struct_WhereTerm
	var pParse *struct_Parse = pWC.pWInfo.pParse
	for int32(pWhere.op) == 44 {
		if !(whereUsablePartialIndex(iTab, isLeft, pWC, pWhere.pLeft) != 0) {
			return int32(0)
		}
		pWhere = pWhere.pRight
	}
	if pParse.db.flags&uint64(8388608) != 0 {
		pParse = (*struct_Parse)(nil)
	}
	for func() *struct_WhereTerm {
		i = int32(0)
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			*_cgo_addr = pWC.a
			return *_cgo_addr
		}()
	}(); i < pWC.nTerm; func() *struct_WhereTerm {
		i++
		return func() (_cgo_ret *struct_WhereTerm) {
			_cgo_addr := &pTerm
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 56
			return
		}()
	}() {
		var pExpr *struct_Expr
		pExpr = pTerm.pExpr
		if (!(pExpr.flags&uint32(1) != uint32(0)) || pExpr.w.iRightJoinTable == iTab) && (isLeft == 0 || pExpr.flags&uint32(1) != uint32(0)) && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab) != 0 && int32(pTerm.wtFlags)&128 == 0 {
			return int32(1)
		}
	}
	return int32(0)
}
func whereLoopAddBtree(pBuilder *struct_WhereLoopBuilder, mPrereq uint64) int32 {
	var pWInfo *struct_WhereInfo
	var pProbe *struct_Index
	var sPk struct_Index
	var aiRowEstPk [2]int16
	var aiColumnPk int16 = int16(-1)
	var pTabList *struct_SrcList
	var pSrc *struct_SrcItem
	var pNew *struct_WhereLoop
	var rc int32 = 0
	var iSortIdx int32 = 1
	var b int32
	var rSize int16
	var pWC *struct_WhereClause
	var pTab *struct_Table
	pNew = pBuilder.pNew
	pWInfo = pBuilder.pWInfo
	pTabList = pWInfo.pTabList
	pSrc = (*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(int32(pNew.iTab))*112))
	pTab = pSrc.pTab
	pWC = pBuilder.pWC
	func() int {
		_ = 0
		return 0
	}()
	if pSrc.fg.Xbf_0>>1&1 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		pProbe = pSrc.u2.pIBIndex
	} else if !(pTab.tabFlags&uint32(128) == uint32(0)) {
		pProbe = pTab.pIndex
	} else {
		var pFirst *struct_Index
		__builtin___memset_chk(unsafe.Pointer(&sPk), 0, 112, __builtin_object_size(unsafe.Pointer(&sPk), 0))
		sPk.nKeyCol = uint16(1)
		sPk.nColumn = uint16(1)
		sPk.aiColumn = &aiColumnPk
		sPk.aiRowLogEst = (*int16)(unsafe.Pointer(&aiRowEstPk))
		sPk.onError = uint8(5)
		sPk.pTable = pTab
		sPk.szIdxRow = pTab.szTabRow
		{
			_autoGo_91 := &sPk.Xbf_0
			*_autoGo_91 = *_autoGo_91&^3 | uint32(3)&3
		}
		*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&aiRowEstPk)))) + uintptr(0)*2)) = pTab.nRowLogEst
		*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&aiRowEstPk)))) + uintptr(1)*2)) = int16(0)
		pFirst = pSrc.pTab.pIndex
		if int32(pSrc.fg.Xbf_0&1) == 0 {
			sPk.pNext = pFirst
		}
		pProbe = &sPk
	}
	rSize = pTab.nRowLogEst
	if !(pBuilder.pOrSet != nil) && int32(pWInfo.wctrlFlags)&32 == 0 && pWInfo.pParse.db.flags&uint64(32768) != uint64(0) && !(pSrc.fg.Xbf_0>>1&1 != 0) && !(pSrc.fg.Xbf_0&1 != 0) && pTab.tabFlags&uint32(128) == uint32(0) && !(pSrc.fg.Xbf_0>>3&1 != 0) && !(pSrc.fg.Xbf_0>>5&1 != 0) {
		var rLogSize int16
		var pTerm *struct_WhereTerm
		var pWCEnd *struct_WhereTerm = (*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(pWC.nTerm)*56))
		rLogSize = estLog(rSize)
		for pTerm = pWC.a; rc == 0 && uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pWCEnd)); *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
			if pTerm.prereqRight&pNew.maskSelf != 0 {
				continue
			}
			if termCanDriveIndex(pTerm, pSrc, uint64(0)) != 0 {
				(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq = uint16(1)
				pNew.nSkip = uint16(0)
				(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).pIndex = (*struct_Index)(nil)
				pNew.nLTerm = uint16(1)
				*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(0)*8)) = pTerm
				pNew.rSetup = int16(int32(rLogSize) + int32(rSize))
				if !(int32(pTab.eTabType) == 2) && pTab.tabFlags&uint32(16384) == uint32(0) {
					pNew.rSetup += int16(28)
				} else {
					pNew.rSetup -= int16(10)
				}
				if int32(pNew.rSetup) < 0 {
					pNew.rSetup = int16(0)
				}
				pNew.nOut = int16(43)
				func() int {
					_ = 0
					return 0
				}()
				pNew.rRun = sqlite3LogEstAdd(rLogSize, pNew.nOut)
				pNew.wsFlags = uint32(16384)
				pNew.prereq = mPrereq | pTerm.prereqRight
				rc = whereLoopInsert(pBuilder, pNew)
			}
		}
	}
	for ; rc == 0 && pProbe != nil; func() int32 {
		pProbe = func() *struct_Index {
			if int32(pSrc.fg.Xbf_0>>1&1) != 0 {
				return nil
			} else {
				return pProbe.pNext
			}
		}()
		return func() (_cgo_ret int32) {
			_cgo_addr := &iSortIdx
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
	}() {
		var isLeft int32 = func() int32 {
			if int32(pSrc.fg.jointype)&32 != 0 {
				return 1
			} else {
				return 0
			}
		}()
		if uintptr(unsafe.Pointer(pProbe.pPartIdxWhere)) != uintptr(unsafe.Pointer(nil)) && !(whereUsablePartialIndex(pSrc.iCursor, isLeft, pWC, pProbe.pPartIdxWhere) != 0) {
			continue
		}
		if pProbe.Xbf_0>>8&1 != 0 {
			continue
		}
		rSize = *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pProbe.aiRowLogEst)) + uintptr(0)*2))
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nEq = uint16(0)
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nBtm = uint16(0)
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).nTop = uint16(0)
		pNew.nSkip = uint16(0)
		pNew.nLTerm = uint16(0)
		pNew.iSortIdx = uint8(0)
		pNew.rSetup = int16(0)
		pNew.prereq = mPrereq
		pNew.nOut = rSize
		(*(*_cgoa_84)(unsafe.Pointer(&pNew.u))).pIndex = pProbe
		b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc.iCursor)
		func() int {
			_ = 0
			return 0
		}()
		if int32(pProbe.Xbf_0&3) == 3 {
			pNew.wsFlags = uint32(256)
			pNew.iSortIdx = uint8(func() int32 {
				if b != 0 {
					return iSortIdx
				} else {
					return 0
				}
			}())
			pNew.rRun = int16(int32(rSize) + 16)
			whereLoopOutputAdjust(pWC, pNew, rSize)
			rc = whereLoopInsert(pBuilder, pNew)
			pNew.nOut = rSize
			if rc != 0 {
				break
			}
		} else {
			var m uint64
			if pProbe.Xbf_0>>5&1 != 0 {
				pNew.wsFlags = uint32(64 | 512)
				m = uint64(0)
			} else {
				m = pSrc.colUsed & pProbe.colNotIdxed
				pNew.wsFlags = uint32(func() int32 {
					if m == uint64(0) {
						return 64 | 512
					} else {
						return 512
					}
				}())
			}
			if b != 0 || !(pTab.tabFlags&uint32(128) == uint32(0)) || uintptr(unsafe.Pointer(pProbe.pPartIdxWhere)) != uintptr(unsafe.Pointer(nil)) || int32(pSrc.fg.Xbf_0>>1&1) != 0 || m == uint64(0) && int32(pProbe.Xbf_0>>2&1) == 0 && int32(pProbe.szIdxRow) < int32(pTab.szTabRow) && int32(pWInfo.wctrlFlags)&4 == 0 && int32(sqlite3Config.bUseCis) != 0 && pWInfo.pParse.db.dbOptFlags&uint32(32) == uint32(0) {
				pNew.iSortIdx = uint8(func() int32 {
					if b != 0 {
						return iSortIdx
					} else {
						return 0
					}
				}())
				pNew.rRun = int16(int32(rSize) + 1 + 15*int32(pProbe.szIdxRow)/int32(pTab.szTabRow))
				if m != uint64(0) {
					var nLookup int16 = int16(int32(rSize) + 16)
					var ii int32
					var iCur int32 = pSrc.iCursor
					var pWC2 *struct_WhereClause = &pWInfo.sWC
					for ii = int32(0); ii < pWC2.nTerm; ii++ {
						var pTerm *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC2.a)) + uintptr(ii)*56))
						if !(sqlite3ExprCoveredByIndex(pTerm.pExpr, iCur, pProbe) != 0) {
							break
						}
						if int32(pTerm.truthProb) <= 0 {
							nLookup += int16(int32(pTerm.truthProb))
						} else {
							nLookup--
							if int32(pTerm.eOperator)&(2|128) != 0 {
								nLookup -= int16(19)
							}
						}
					}
					pNew.rRun = sqlite3LogEstAdd(pNew.rRun, nLookup)
				}
				whereLoopOutputAdjust(pWC, pNew, rSize)
				rc = whereLoopInsert(pBuilder, pNew)
				pNew.nOut = rSize
				if rc != 0 {
					break
				}
			}
		}
		pBuilder.bldFlags1 = uint8(0)
		rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, int16(0))
		if int32(pBuilder.bldFlags1) == 1 {
			pTab.tabFlags |= uint32(256)
		}
	}
	return rc
}
func isLimitTerm(pTerm *struct_WhereTerm) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if int32(pTerm.eMatchOp) >= 73 && int32(pTerm.eMatchOp) <= 74 {
			return 1
		} else {
			return 0
		}
	}()
}
func whereLoopAddVirtualOne(pBuilder *struct_WhereLoopBuilder, mPrereq uint64, mUsable uint64, mExclude uint16, pIdxInfo *struct_sqlite3_index_info, mNoOmit uint16, pbIn *int32, pbRetryLimit *int32) int32 {
	var pWC *struct_WhereClause = pBuilder.pWC
	var pHidden *struct_HiddenIndexInfo = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	var pIdxCons *struct_sqlite3_index_constraint
	var pUsage *struct_sqlite3_index_constraint_usage = pIdxInfo.aConstraintUsage
	var i int32
	var mxTerm int32
	var rc int32 = 0
	var pNew *struct_WhereLoop = pBuilder.pNew
	var pParse *struct_Parse = pBuilder.pWInfo.pParse
	var pSrc *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pBuilder.pWInfo.pTabList.a)))) + uintptr(pNew.iTab)*112))
	var nConstraint int32 = pIdxInfo.nConstraint
	func() int {
		_ = 0
		return 0
	}()
	*pbIn = int32(0)
	pNew.prereq = mPrereq
	pIdxCons = *(**struct_sqlite3_index_constraint)(unsafe.Pointer(&pIdxInfo.aConstraint))
	for i = int32(0); i < nConstraint; func() *struct_sqlite3_index_constraint {
		i++
		return func() (_cgo_ret *struct_sqlite3_index_constraint) {
			_cgo_addr := &pIdxCons
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 12
			return
		}()
	}() {
		var pTerm *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(pIdxCons.iTermOffset)*56))
		pIdxCons.usable = uint8(0)
		if pTerm.prereqRight&mUsable == pTerm.prereqRight && int32(pTerm.eOperator)&int32(mExclude) == 0 && (pbRetryLimit != nil || !(isLimitTerm(pTerm) != 0)) {
			pIdxCons.usable = uint8(1)
		}
	}
	__builtin___memset_chk(unsafe.Pointer(pUsage), 0, 5*uint(nConstraint), __builtin_object_size(unsafe.Pointer(pUsage), 0))
	func() int {
		_ = 0
		return 0
	}()
	pIdxInfo.idxStr = (*int8)(nil)
	pIdxInfo.idxNum = int32(0)
	pIdxInfo.orderByConsumed = int32(0)
	pIdxInfo.estimatedCost = float64(9.9999999999999997e+98 / float64(2))
	pIdxInfo.estimatedRows = int64(25)
	pIdxInfo.idxFlags = int32(0)
	pIdxInfo.colUsed = uint64(int64(pSrc.colUsed))
	pHidden.mHandleIn = uint32(0)
	rc = vtabBestIndex(pParse, pSrc.pTab, pIdxInfo)
	if rc != 0 {
		if rc == 19 {
			return int32(0)
		}
		return rc
	}
	mxTerm = int32(-1)
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(pNew.aLTerm), 0, 8*uint(nConstraint), __builtin_object_size(unsafe.Pointer(pNew.aLTerm), 0))
	__builtin___memset_chk(unsafe.Pointer(&pNew.u.vtab), 0, 28, __builtin_object_size(unsafe.Pointer(&pNew.u.vtab), 0))
	pIdxCons = *(**struct_sqlite3_index_constraint)(unsafe.Pointer(&pIdxInfo.aConstraint))
	for i = int32(0); i < nConstraint; func() *struct_sqlite3_index_constraint {
		i++
		return func() (_cgo_ret *struct_sqlite3_index_constraint) {
			_cgo_addr := &pIdxCons
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 12
			return
		}()
	}() {
		var iTerm int32
		if func() (_cgo_ret int32) {
			_cgo_addr := &iTerm
			*_cgo_addr = (*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pUsage)) + uintptr(i)*5))).argvIndex - 1
			return *_cgo_addr
		}() >= 0 {
			var pTerm *struct_WhereTerm
			var j int32 = pIdxCons.iTermOffset
			if iTerm >= nConstraint || j < 0 || j >= pWC.nTerm || uintptr(unsafe.Pointer(*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(iTerm)*8)))) != uintptr(unsafe.Pointer(nil)) || int32(pIdxCons.usable) == 0 {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[26]int8{'%', 's', '.', 'x', 'B', 'e', 's', 't', 'I', 'n', 'd', 'e', 'x', ' ', 'm', 'a', 'l', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', '\x00'})), pSrc.pTab.zName)
				return int32(1)
			}
			pTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(j)*56))
			pNew.prereq |= pTerm.prereqRight
			func() int {
				_ = 0
				return 0
			}()
			*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(iTerm)*8)) = pTerm
			if iTerm > mxTerm {
				mxTerm = iTerm
			}
			if (*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pUsage)) + uintptr(i)*5))).omit != 0 {
				if i < 16 && 1<<i&int(int32(mNoOmit)) == 0 {
					pNew.u.vtab.omitMask |= uint16(1 << iTerm)
				} else {
				}
				if int32(pTerm.eMatchOp) == 74 {
					{
						_autoGo_92 := &pNew.u.vtab.Xbf_0
						*_autoGo_92 = *_autoGo_92&^2 | uint32(1)&1<<1
					}
				}
			}
			if func() uint32 {
				if i <= 31 {
					return uint32(1) << i
				} else {
					return uint32(0)
				}
			}()&pHidden.mHandleIn != 0 {
				pNew.u.vtab.mHandleIn |= uint32(1) << iTerm
			} else if int32(pTerm.eOperator)&1 != 0 {
				pIdxInfo.orderByConsumed = int32(0)
				pIdxInfo.idxFlags &= int32(^1)
				*pbIn = int32(1)
				func() int {
					_ = 0
					return 0
				}()
			}
			if isLimitTerm(pTerm) != 0 && *pbIn != 0 {
				if pIdxInfo.needToFreeIdxStr != 0 {
					sqlite3_free(unsafe.Pointer(pIdxInfo.idxStr))
					pIdxInfo.idxStr = (*int8)(nil)
					pIdxInfo.needToFreeIdxStr = int32(0)
				}
				*pbRetryLimit = int32(1)
				return int32(0)
			}
		}
	}
	pNew.nLTerm = uint16(mxTerm + 1)
	for i = int32(0); i <= mxTerm; i++ {
		if uintptr(unsafe.Pointer(*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(i)*8)))) == uintptr(unsafe.Pointer(nil)) {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[26]int8{'%', 's', '.', 'x', 'B', 'e', 's', 't', 'I', 'n', 'd', 'e', 'x', ' ', 'm', 'a', 'l', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', '\x00'})), pSrc.pTab.zName)
			return int32(1)
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	pNew.u.vtab.idxNum = pIdxInfo.idxNum
	{
		_autoGo_93 := &pNew.u.vtab.Xbf_0
		*_autoGo_93 = *_autoGo_93&^1 | uint32(pIdxInfo.needToFreeIdxStr)&1
	}
	pIdxInfo.needToFreeIdxStr = int32(0)
	pNew.u.vtab.idxStr = pIdxInfo.idxStr
	pNew.u.vtab.isOrdered = int8(func() int32 {
		if pIdxInfo.orderByConsumed != 0 {
			return pIdxInfo.nOrderBy
		} else {
			return 0
		}
	}())
	pNew.rSetup = int16(0)
	pNew.rRun = sqlite3LogEstFromDouble(pIdxInfo.estimatedCost)
	pNew.nOut = sqlite3LogEst(uint64(pIdxInfo.estimatedRows))
	if pIdxInfo.idxFlags&1 != 0 {
		pNew.wsFlags |= uint32(4096)
	} else {
		pNew.wsFlags &= uint32(4294963199)
	}
	rc = whereLoopInsert(pBuilder, pNew)
	if pNew.u.vtab.Xbf_0&1 != 0 {
		sqlite3_free(unsafe.Pointer(pNew.u.vtab.idxStr))
		{
			_autoGo_94 := &pNew.u.vtab.Xbf_0
			*_autoGo_94 = *_autoGo_94&^1 | uint32(0)&1
		}
	}
	return rc
}
func sqlite3_vtab_collation(pIdxInfo *struct_sqlite3_index_info, iCons int32) *int8 {
	var pHidden *struct_HiddenIndexInfo = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	var zRet *int8 = nil
	if iCons >= 0 && iCons < pIdxInfo.nConstraint {
		var pC *struct_CollSeq = nil
		var iTerm int32 = (*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraint)) + uintptr(iCons)*12))).iTermOffset
		var pX *struct_Expr = (*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pHidden.pWC.a)) + uintptr(iTerm)*56))).pExpr
		if pX.pLeft != nil {
			pC = sqlite3ExprCompareCollSeq(pHidden.pParse, pX)
		}
		zRet = func() *int8 {
			if pC != nil {
				return (*int8)(unsafe.Pointer(pC.zName))
			} else {
				return (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
			}
		}()
	}
	return zRet
}
func sqlite3_vtab_in(pIdxInfo *struct_sqlite3_index_info, iCons int32, bHandle int32) int32 {
	var pHidden *struct_HiddenIndexInfo = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	var m uint32 = func() uint32 {
		if iCons <= 31 {
			return uint32(1) << iCons
		} else {
			return uint32(0)
		}
	}()
	if m&pHidden.mIn != 0 {
		if bHandle == 0 {
			pHidden.mHandleIn &= ^m
		} else if bHandle > 0 {
			pHidden.mHandleIn |= m
		}
		return int32(1)
	}
	return int32(0)
}
func sqlite3_vtab_rhs_value(pIdxInfo *struct_sqlite3_index_info, iCons int32, ppVal **struct_sqlite3_value) int32 {
	var pH *struct_HiddenIndexInfo = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	var pVal *struct_sqlite3_value = nil
	var rc int32 = 0
	if iCons < 0 || iCons >= pIdxInfo.nConstraint {
		rc = int32(21)
	} else {
		if uintptr(unsafe.Pointer(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pH.aRhs)))) + uintptr(iCons)*8)))) == uintptr(unsafe.Pointer(nil)) {
			var pTerm *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pH.pWC.a)) + uintptr((*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraint)) + uintptr(iCons)*12))).iTermOffset)*56))
			rc = sqlite3ValueFromExpr(pH.pParse.db, pTerm.pExpr.pRight, pH.pParse.db.enc, uint8(65), &*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pH.aRhs)))) + uintptr(iCons)*8)))
		}
		pVal = *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer((**struct_sqlite3_value)(unsafe.Pointer(&pH.aRhs)))) + uintptr(iCons)*8))
	}
	*ppVal = pVal
	if rc == 0 && uintptr(unsafe.Pointer(pVal)) == uintptr(unsafe.Pointer(nil)) {
		rc = int32(12)
	}
	return rc
}
func sqlite3_vtab_distinct(pIdxInfo *struct_sqlite3_index_info) int32 {
	var pHidden *struct_HiddenIndexInfo = (*struct_HiddenIndexInfo)(unsafe.Pointer(&*(*struct_sqlite3_index_info)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo)) + uintptr(1)*96))))
	func() int {
		_ = 0
		return 0
	}()
	return pHidden.eDistinct
}
func whereLoopAddVirtual(pBuilder *struct_WhereLoopBuilder, mPrereq uint64, mUnusable uint64) int32 {
	var rc int32 = 0
	var pWInfo *struct_WhereInfo
	var pParse *struct_Parse
	var pWC *struct_WhereClause
	var pSrc *struct_SrcItem
	var p *struct_sqlite3_index_info
	var nConstraint int32
	var bIn int32
	var pNew *struct_WhereLoop
	var mBest uint64
	var mNoOmit uint16
	var bRetry int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	pWInfo = pBuilder.pWInfo
	pParse = pWInfo.pParse
	pWC = pBuilder.pWC
	pNew = pBuilder.pNew
	pSrc = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pNew.iTab)*112))
	func() int {
		_ = 0
		return 0
	}()
	p = allocateIndexInfo(pWInfo, pWC, mUnusable, pSrc, &mNoOmit)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	pNew.rSetup = int16(0)
	pNew.wsFlags = uint32(1024)
	pNew.nLTerm = uint16(0)
	{
		_autoGo_95 := &pNew.u.vtab.Xbf_0
		*_autoGo_95 = *_autoGo_95&^1 | uint32(0)&1
	}
	nConstraint = p.nConstraint
	if whereLoopResize(pParse.db, pNew, nConstraint) != 0 {
		freeIndexInfo(pParse.db, p)
		return int32(7)
	}
	rc = whereLoopAddVirtualOne(pBuilder, mPrereq, uint64(18446744073709551615), uint16(0), p, mNoOmit, &bIn, &bRetry)
	if bRetry != 0 {
		func() int {
			_ = 0
			return 0
		}()
		rc = whereLoopAddVirtualOne(pBuilder, mPrereq, uint64(18446744073709551615), uint16(0), p, mNoOmit, &bIn, nil)
	}
	if rc == 0 && (func() (_cgo_ret uint64) {
		_cgo_addr := &mBest
		*_cgo_addr = pNew.prereq & ^mPrereq
		return *_cgo_addr
	}() != uint64(0) || bIn != 0) {
		var seenZero int32 = 0
		var seenZeroNoIN int32 = 0
		var mPrev uint64 = uint64(0)
		var mBestNoIn uint64 = uint64(0)
		if bIn != 0 {
			rc = whereLoopAddVirtualOne(pBuilder, mPrereq, uint64(18446744073709551615), uint16(1), p, mNoOmit, &bIn, nil)
			func() int {
				_ = 0
				return 0
			}()
			mBestNoIn = pNew.prereq & ^mPrereq
			if mBestNoIn == uint64(0) {
				seenZero = int32(1)
				seenZeroNoIN = int32(1)
			}
		}
		for rc == 0 {
			var i int32
			var mNext uint64 = uint64(18446744073709551615)
			func() int {
				_ = 0
				return 0
			}()
			for i = int32(0); i < nConstraint; i++ {
				var mThis uint64 = (*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr((*(*struct_sqlite3_index_constraint)(unsafe.Pointer(uintptr(unsafe.Pointer(p.aConstraint)) + uintptr(i)*12))).iTermOffset)*56))).prereqRight & ^mPrereq
				if mThis > mPrev && mThis < mNext {
					mNext = mThis
				}
			}
			mPrev = mNext
			if mNext == uint64(18446744073709551615) {
				break
			}
			if mNext == mBest || mNext == mBestNoIn {
				continue
			}
			rc = whereLoopAddVirtualOne(pBuilder, mPrereq, mNext|mPrereq, uint16(0), p, mNoOmit, &bIn, nil)
			if pNew.prereq == mPrereq {
				seenZero = int32(1)
				if bIn == 0 {
					seenZeroNoIN = int32(1)
				}
			}
		}
		if rc == 0 && seenZero == 0 {
			rc = whereLoopAddVirtualOne(pBuilder, mPrereq, mPrereq, uint16(0), p, mNoOmit, &bIn, nil)
			if bIn == 0 {
				seenZeroNoIN = int32(1)
			}
		}
		if rc == 0 && seenZeroNoIN == 0 {
			rc = whereLoopAddVirtualOne(pBuilder, mPrereq, mPrereq, uint16(1), p, mNoOmit, &bIn, nil)
		}
	}
	if p.needToFreeIdxStr != 0 {
		sqlite3_free(unsafe.Pointer(p.idxStr))
	}
	freeIndexInfo(pParse.db, p)
	return rc
}
func whereLoopAddOr(pBuilder *struct_WhereLoopBuilder, mPrereq uint64, mUnusable uint64) int32 {
	var pWInfo *struct_WhereInfo = pBuilder.pWInfo
	var pWC *struct_WhereClause
	var pNew *struct_WhereLoop
	var pTerm *struct_WhereTerm
	var pWCEnd *struct_WhereTerm
	var rc int32 = 0
	var iCur int32
	var tempWC struct_WhereClause
	var sSubBuild struct_WhereLoopBuilder
	var sSum struct_WhereOrSet
	var sCur struct_WhereOrSet
	var pItem *struct_SrcItem
	pWC = pBuilder.pWC
	pWCEnd = (*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWC.a)) + uintptr(pWC.nTerm)*56))
	pNew = pBuilder.pNew
	__builtin___memset_chk(unsafe.Pointer(&sSum), 0, 52, __builtin_object_size(unsafe.Pointer(&sSum), 0))
	pItem = (*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(int32(pNew.iTab))*112))
	iCur = pItem.iCursor
	for pTerm = pWC.a; uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pWCEnd)) && rc == 0; *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
		if int32(pTerm.eOperator)&512 != 0 && (*(**struct_WhereOrInfo)(unsafe.Pointer(&pTerm.u))).indexable&pNew.maskSelf != uint64(0) {
			var pOrWC *struct_WhereClause = &(*(**struct_WhereOrInfo)(unsafe.Pointer(&pTerm.u))).wc
			var pOrWCEnd *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pOrWC.a)) + uintptr(pOrWC.nTerm)*56))
			var pOrTerm *struct_WhereTerm
			var once int32 = 1
			var i int32
			var j int32
			sSubBuild = *pBuilder
			sSubBuild.pOrSet = &sCur
			for pOrTerm = pOrWC.a; uintptr(unsafe.Pointer(pOrTerm)) < uintptr(unsafe.Pointer(pOrWCEnd)); *(*uintptr)(unsafe.Pointer(&pOrTerm)) += 56 {
				if int32(pOrTerm.eOperator)&1024 != 0 {
					sSubBuild.pWC = &(*(**struct_WhereAndInfo)(unsafe.Pointer(&pOrTerm.u))).wc
				} else if pOrTerm.leftCursor == iCur {
					tempWC.pWInfo = pWC.pWInfo
					tempWC.pOuter = pWC
					tempWC.op = uint8(44)
					tempWC.nTerm = int32(1)
					tempWC.nBase = int32(1)
					tempWC.a = pOrTerm
					sSubBuild.pWC = &tempWC
				} else {
					continue
				}
				sCur.n = uint16(0)
				if int32(pItem.pTab.eTabType) == 1 {
					rc = whereLoopAddVirtual(&sSubBuild, mPrereq, mUnusable)
				} else {
					rc = whereLoopAddBtree(&sSubBuild, mPrereq)
				}
				if rc == 0 {
					rc = whereLoopAddOr(&sSubBuild, mPrereq, mUnusable)
				}
				func() int {
					_ = 0
					return 0
				}()
				if int32(sCur.n) == 0 {
					sSum.n = uint16(0)
					break
				} else if once != 0 {
					whereOrMove(&sSum, &sCur)
					once = int32(0)
				} else {
					var sPrev struct_WhereOrSet
					whereOrMove(&sPrev, &sSum)
					sSum.n = uint16(0)
					for i = int32(0); i < int32(sPrev.n); i++ {
						for j = int32(0); j < int32(sCur.n); j++ {
							whereOrInsert(&sSum, (*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sPrev.a)))) + uintptr(i)*12))).prereq|(*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sCur.a)))) + uintptr(j)*12))).prereq, sqlite3LogEstAdd((*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sPrev.a)))) + uintptr(i)*12))).rRun, (*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sCur.a)))) + uintptr(j)*12))).rRun), sqlite3LogEstAdd((*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sPrev.a)))) + uintptr(i)*12))).nOut, (*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sCur.a)))) + uintptr(j)*12))).nOut))
						}
					}
				}
			}
			pNew.nLTerm = uint16(1)
			*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pNew.aLTerm)) + uintptr(0)*8)) = pTerm
			pNew.wsFlags = uint32(8192)
			pNew.rSetup = int16(0)
			pNew.iSortIdx = uint8(0)
			__builtin___memset_chk(unsafe.Pointer(&pNew.u), 0, 28, __builtin_object_size(unsafe.Pointer(&pNew.u), 0))
			for i = int32(0); rc == 0 && i < int32(sSum.n); i++ {
				pNew.rRun = int16(int32((*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sSum.a)))) + uintptr(i)*12))).rRun) + 1)
				pNew.nOut = (*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sSum.a)))) + uintptr(i)*12))).nOut
				pNew.prereq = (*(*struct_WhereOrCost)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereOrCost)(unsafe.Pointer(&sSum.a)))) + uintptr(i)*12))).prereq
				rc = whereLoopInsert(pBuilder, pNew)
			}
		}
	}
	return rc
}
func whereLoopAddAll(pBuilder *struct_WhereLoopBuilder) int32 {
	var pWInfo *struct_WhereInfo = pBuilder.pWInfo
	var mPrereq uint64 = uint64(0)
	var mPrior uint64 = uint64(0)
	var iTab int32
	var pTabList *struct_SrcList = pWInfo.pTabList
	var pItem *struct_SrcItem
	var pEnd *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(pWInfo.nLevel)*112))
	var db *struct_sqlite3 = pWInfo.pParse.db
	var rc int32 = 0
	var pNew *struct_WhereLoop
	pNew = pBuilder.pNew
	whereLoopInit(pNew)
	pBuilder.iPlanLimit = uint32(20000)
	for func() *struct_SrcItem {
		iTab = int32(0)
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			*_cgo_addr = (*struct_SrcItem)(unsafe.Pointer(&pTabList.a))
			return *_cgo_addr
		}()
	}(); uintptr(unsafe.Pointer(pItem)) < uintptr(unsafe.Pointer(pEnd)); func() *struct_SrcItem {
		iTab++
		return func() (_cgo_ret *struct_SrcItem) {
			_cgo_addr := &pItem
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 112
			return
		}()
	}() {
		var mUnusable uint64 = uint64(0)
		pNew.iTab = uint8(iTab)
		pBuilder.iPlanLimit += uint32(1000)
		pNew.maskSelf = sqlite3WhereGetMask(&pWInfo.sMaskSet, pItem.iCursor)
		if int32(pItem.fg.jointype)&(8|2) != 0 {
			mPrereq = mPrior
		} else {
			mPrereq = uint64(0)
		}
		if int32(pItem.pTab.eTabType) == 1 {
			var p *struct_SrcItem
			for p = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer(pItem)) + uintptr(1)*112)); uintptr(unsafe.Pointer(p)) < uintptr(unsafe.Pointer(pEnd)); *(*uintptr)(unsafe.Pointer(&p)) += 112 {
				if mUnusable != 0 || int32(p.fg.jointype)&(8|2) != 0 {
					mUnusable |= sqlite3WhereGetMask(&pWInfo.sMaskSet, p.iCursor)
				}
			}
			rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable)
		} else {
			rc = whereLoopAddBtree(pBuilder, mPrereq)
		}
		if rc == 0 && int32(pBuilder.pWC.hasOr) != 0 {
			rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable)
		}
		mPrior |= pNew.maskSelf
		if rc != 0 || int32(db.mallocFailed) != 0 {
			if rc == 101 {
				sqlite3_log(28, (*int8)(unsafe.Pointer(&[35]int8{'a', 'b', 'b', 'r', 'e', 'v', 'i', 'a', 't', 'e', 'd', ' ', 'q', 'u', 'e', 'r', 'y', ' ', 'a', 'l', 'g', 'o', 'r', 'i', 't', 'h', 'm', ' ', 's', 'e', 'a', 'r', 'c', 'h', '\x00'})))
				rc = int32(0)
			} else {
				break
			}
		}
	}
	whereLoopClear(db, pNew)
	return rc
}
func wherePathSatisfiesOrderBy(pWInfo *struct_WhereInfo, pOrderBy *struct_ExprList, pPath *struct_WherePath, wctrlFlags uint16, nLoop uint16, pLast *struct_WhereLoop, pRevMask *uint64) int8 {
	var revSet uint8
	var rev uint8
	var revIdx uint8
	var isOrderDistinct uint8
	var distinctColumns uint8
	var isMatch uint8
	var eqOpMask uint16
	var nKeyCol uint16
	var nColumn uint16
	var nOrderBy uint16
	var iLoop int32
	var i int32
	var j int32
	var iCur int32
	var iColumn int32
	var pLoop *struct_WhereLoop = nil
	var pTerm *struct_WhereTerm
	var pOBExpr *struct_Expr
	var pColl *struct_CollSeq
	var pIndex *struct_Index
	var db *struct_sqlite3 = pWInfo.pParse.db
	var obSat uint64 = uint64(0)
	var obDone uint64
	var orderDistinctMask uint64
	var ready uint64
	func() int {
		_ = 0
		return 0
	}()
	if int32(nLoop) != 0 && db.dbOptFlags&uint32(64) != uint32(0) {
		return int8(0)
	}
	nOrderBy = uint16(pOrderBy.nExpr)
	if int32(nOrderBy) > int32(8*uint(8))-1 {
		return int8(0)
	}
	isOrderDistinct = uint8(1)
	obDone = uint64(1)<<int32(nOrderBy) - uint64(1)
	orderDistinctMask = uint64(0)
	ready = uint64(0)
	eqOpMask = uint16(2 | 128 | 256)
	if int32(wctrlFlags)&(2048|2|1) != 0 {
		eqOpMask |= uint16(1)
	}
	for iLoop = int32(0); int32(isOrderDistinct) != 0 && obSat < obDone && iLoop <= int32(nLoop); iLoop++ {
		if iLoop > 0 {
			ready |= pLoop.maskSelf
		}
		if iLoop < int32(nLoop) {
			pLoop = *(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pPath.aLoop)) + uintptr(iLoop)*8))
			if int32(wctrlFlags)&2048 != 0 {
				continue
			}
		} else {
			pLoop = pLast
		}
		if pLoop.wsFlags&uint32(1024) != 0 {
			if int32(pLoop.u.vtab.isOrdered) != 0 && int32(wctrlFlags)&128 == 0 {
				obSat = obDone
			}
			break
		} else if int32(wctrlFlags)&128 != 0 {
			(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nDistinctCol = uint16(0)
		}
		iCur = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLoop.iTab)*112))).iCursor
		for i = int32(0); i < int32(nOrderBy); i++ {
			if uint64(1)<<i&obSat != 0 {
				continue
			}
			pOBExpr = sqlite3ExprSkipCollateAndLikely((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr)
			if uintptr(unsafe.Pointer(pOBExpr)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			if int32(pOBExpr.op) != 167 && int32(pOBExpr.op) != 169 {
				continue
			}
			if pOBExpr.iTable != iCur {
				continue
			}
			pTerm = sqlite3WhereFindTerm(&pWInfo.sWC, iCur, int32(pOBExpr.iColumn), ^ready, uint32(eqOpMask), nil)
			if uintptr(unsafe.Pointer(pTerm)) == uintptr(unsafe.Pointer(nil)) {
				continue
			}
			if int32(pTerm.eOperator) == 1 {
				func() int {
					_ = 0
					return 0
				}()
				for j = int32(0); j < int32(pLoop.nLTerm) && uintptr(unsafe.Pointer(pTerm)) != uintptr(unsafe.Pointer(*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8)))); j++ {
				}
				if j >= int32(pLoop.nLTerm) {
					continue
				}
			}
			if int32(pTerm.eOperator)&(2|128) != 0 && int32(pOBExpr.iColumn) >= 0 {
				var pParse *struct_Parse = pWInfo.pParse
				var pColl1 *struct_CollSeq = sqlite3ExprNNCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr)
				var pColl2 *struct_CollSeq = sqlite3ExprCompareCollSeq(pParse, pTerm.pExpr)
				func() int {
					_ = 0
					return 0
				}()
				if uintptr(unsafe.Pointer(pColl2)) == uintptr(unsafe.Pointer(nil)) || sqlite3StrICmp(pColl1.zName, pColl2.zName) != 0 {
					continue
				}
			}
			obSat |= uint64(1) << i
		}
		if pLoop.wsFlags&uint32(4096) == uint32(0) {
			if pLoop.wsFlags&uint32(256) != 0 {
				pIndex = (*struct_Index)(nil)
				nKeyCol = uint16(0)
				nColumn = uint16(1)
			} else if uintptr(unsafe.Pointer(func() (_cgo_ret *struct_Index) {
				_cgo_addr := &pIndex
				*_cgo_addr = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
				return *_cgo_addr
			}())) == uintptr(unsafe.Pointer(nil)) || int32(pIndex.Xbf_0>>2&1) != 0 {
				return int8(0)
			} else {
				nKeyCol = pIndex.nKeyCol
				nColumn = pIndex.nColumn
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				isOrderDistinct = func() uint8 {
					if int32(pIndex.onError) != 0 && pLoop.wsFlags&uint32(32768) == uint32(0) {
						return 1
					} else {
						return 0
					}
				}()
			}
			rev = func() (_cgo_ret uint8) {
				_cgo_addr := &revSet
				*_cgo_addr = uint8(0)
				return *_cgo_addr
			}()
			distinctColumns = uint8(0)
			for j = int32(0); j < int32(nColumn); j++ {
				var bOnce uint8 = uint8(1)
				func() int {
					_ = 0
					return 0
				}()
				if j < int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq) && j >= int32(pLoop.nSkip) {
					var eOp uint16 = (*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))).eOperator
					if int32(eOp)&int32(eqOpMask) != 0 {
						if int32(eOp)&(256|128) != 0 {
							isOrderDistinct = uint8(0)
						}
						continue
					} else if int32(eOp)&1 != 0 {
						var pX *struct_Expr = (*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8))).pExpr
						for i = j + 1; i < int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq); i++ {
							if uintptr(unsafe.Pointer((*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(i)*8))).pExpr)) == uintptr(unsafe.Pointer(pX)) {
								func() int {
									_ = 0
									return 0
								}()
								bOnce = uint8(0)
								break
							}
						}
					}
				}
				if pIndex != nil {
					iColumn = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aiColumn)) + uintptr(j)*2)))
					revIdx = uint8(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.aSortOrder)) + uintptr(j)))) & 1)
					if iColumn == int32(pIndex.pTable.iPKey) {
						iColumn = int32(-1)
					}
				} else {
					iColumn = int32(-1)
					revIdx = uint8(0)
				}
				if isOrderDistinct != 0 {
					if iColumn >= 0 && j >= int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq) && int32((*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.pTable.aCol)) + uintptr(iColumn)*20))).Xbf_0&15) == 0 {
						isOrderDistinct = uint8(0)
					}
					if iColumn == -2 {
						isOrderDistinct = uint8(0)
					}
				}
				isMatch = uint8(0)
				for i = int32(0); int32(bOnce) != 0 && i < int32(nOrderBy); i++ {
					if uint64(1)<<i&obSat != 0 {
						continue
					}
					pOBExpr = sqlite3ExprSkipCollateAndLikely((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr)
					if uintptr(unsafe.Pointer(pOBExpr)) == uintptr(unsafe.Pointer(nil)) {
						continue
					}
					if int32(wctrlFlags)&(64|128) == 0 {
						bOnce = uint8(0)
					}
					if iColumn >= -1 {
						if int32(pOBExpr.op) != 167 && int32(pOBExpr.op) != 169 {
							continue
						}
						if pOBExpr.iTable != iCur {
							continue
						}
						if int32(pOBExpr.iColumn) != iColumn {
							continue
						}
					} else {
						var pIdxExpr *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pIndex.aColExpr.a)))) + uintptr(j)*28))).pExpr
						if sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, iCur) != 0 {
							continue
						}
					}
					if iColumn != -1 {
						pColl = sqlite3ExprNNCollSeq(pWInfo.pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr)
						if sqlite3StrICmp(pColl.zName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pIndex.azColl)) + uintptr(j)*8))) != 0 {
							continue
						}
					}
					if int32(wctrlFlags)&128 != 0 {
						(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nDistinctCol = uint16(j + 1)
					}
					isMatch = uint8(1)
					break
				}
				if int32(isMatch) != 0 && int32(wctrlFlags)&64 == 0 {
					if revSet != 0 {
						if int32(rev)^int32(revIdx) != int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).sortFlags)&1 {
							isMatch = uint8(0)
						}
					} else {
						rev = uint8(int32(revIdx) ^ int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).sortFlags)&1)
						if rev != 0 {
							*pRevMask |= uint64(1) << iLoop
						}
						revSet = uint8(1)
					}
				}
				if int32(isMatch) != 0 && int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).sortFlags)&2 != 0 {
					if j == int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq) {
						pLoop.wsFlags |= uint32(524288)
					} else {
						isMatch = uint8(0)
					}
				}
				if isMatch != 0 {
					if iColumn == -1 {
						distinctColumns = uint8(1)
					}
					obSat |= uint64(1) << i
				} else {
					if j == 0 || j < int32(nKeyCol) {
						isOrderDistinct = uint8(0)
					}
					break
				}
			}
			if distinctColumns != 0 {
				isOrderDistinct = uint8(1)
			}
		}
		if isOrderDistinct != 0 {
			orderDistinctMask |= pLoop.maskSelf
			for i = int32(0); i < int32(nOrderBy); i++ {
				var p *struct_Expr
				var mTerm uint64
				if uint64(1)<<i&obSat != 0 {
					continue
				}
				p = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(i)*28))).pExpr
				mTerm = sqlite3WhereExprUsage(&pWInfo.sMaskSet, p)
				if mTerm == uint64(0) && !(sqlite3ExprIsConstant(p) != 0) {
					continue
				}
				if mTerm & ^orderDistinctMask == uint64(0) {
					obSat |= uint64(1) << i
				}
			}
		}
	}
	if obSat == obDone {
		return int8(nOrderBy)
	}
	if !(isOrderDistinct != 0) {
		for i = int32(nOrderBy) - 1; i > 0; i-- {
			var m uint64 = func() uint64 {
				if i < int32(8*uint(8)) {
					return uint64(1)<<i - uint64(1)
				} else {
					return uint64(0)
				}
			}()
			if obSat&m == m {
				return int8(i)
			}
		}
		return int8(0)
	}
	return int8(-1)
}
func sqlite3WhereIsSorted(pWInfo *struct_WhereInfo) int32 {
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return int32(pWInfo.Xbf_0 >> 3 & 1)
}
func whereSortingCost(pWInfo *struct_WhereInfo, nRow int16, nOrderBy int32, nSorted int32) int16 {
	var rScale int16
	var rSortCost int16
	func() int {
		_ = 0
		return 0
	}()
	rScale = int16(int32(sqlite3LogEst(uint64((nOrderBy-nSorted)*100/nOrderBy))) - 66)
	rSortCost = int16(int32(nRow) + int32(rScale) + 16)
	if int32(pWInfo.wctrlFlags)&16384 != 0 && int32(pWInfo.iLimit) < int32(nRow) {
		nRow = pWInfo.iLimit
	} else if int32(pWInfo.wctrlFlags)&256 != 0 {
		if int32(nRow) > 10 {
			nRow -= int16(10)
			func() int {
				_ = 0
				return 0
			}()
		}
	}
	rSortCost += int16(int32(estLog(nRow)))
	return rSortCost
}
func wherePathSolver(pWInfo *struct_WhereInfo, nRowEst int16) int32 {
	var mxChoice int32
	var nLoop int32
	var pParse *struct_Parse
	var db *struct_sqlite3
	var iLoop int32
	var ii int32
	var jj int32
	var mxI int32 = 0
	var nOrderBy int32
	var mxCost int16 = int16(0)
	var mxUnsorted int16 = int16(0)
	var nTo int32
	var nFrom int32
	var aFrom *struct_WherePath
	var aTo *struct_WherePath
	var pFrom *struct_WherePath
	var pTo *struct_WherePath
	var pWLoop *struct_WhereLoop
	var pX **struct_WhereLoop
	var aSortCost *int16 = nil
	var pSpace *int8
	var nSpace int32
	pParse = pWInfo.pParse
	db = pParse.db
	nLoop = int32(pWInfo.nLevel)
	mxChoice = func() int32 {
		if nLoop <= 1 {
			return 1
		} else {
			return func() int32 {
				if nLoop == 2 {
					return 5
				} else {
					return 10
				}
			}()
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(pWInfo.pOrderBy)) == uintptr(unsafe.Pointer(nil)) || int32(nRowEst) == 0 {
		nOrderBy = int32(0)
	} else {
		nOrderBy = pWInfo.pOrderBy.nExpr
	}
	nSpace = int32((32 + 8*uint(nLoop)) * uint(mxChoice) * uint(2))
	nSpace += int32(2 * uint(nOrderBy))
	pSpace = (*int8)(sqlite3DbMallocRawNN(db, uint64(nSpace)))
	if uintptr(unsafe.Pointer(pSpace)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	aTo = (*struct_WherePath)(unsafe.Pointer(pSpace))
	aFrom = (*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(mxChoice)*32))
	__builtin___memset_chk(unsafe.Pointer(aFrom), 0, 32, __builtin_object_size(unsafe.Pointer(aFrom), 0))
	pX = (**struct_WhereLoop)(unsafe.Pointer((*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(mxChoice)*32))))
	for func() *struct_WherePath {
		ii = mxChoice * 2
		return func() (_cgo_ret *struct_WherePath) {
			_cgo_addr := &pFrom
			*_cgo_addr = aTo
			return *_cgo_addr
		}()
	}(); ii > 0; func() **struct_WhereLoop {
		func() *struct_WherePath {
			ii--
			return func() (_cgo_ret *struct_WherePath) {
				_cgo_addr := &pFrom
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 32
				return
			}()
		}()
		return func() (_cgo_ret **struct_WhereLoop) {
			_cgo_addr := &pX
			*(*uintptr)(unsafe.Pointer(&*_cgo_addr)) += uintptr(nLoop) * 8
			return *_cgo_addr
		}()
	}() {
		pFrom.aLoop = pX
	}
	if nOrderBy != 0 {
		aSortCost = (*int16)(unsafe.Pointer(pX))
		__builtin___memset_chk(unsafe.Pointer(aSortCost), 0, 2*uint(nOrderBy), __builtin_object_size(unsafe.Pointer(aSortCost), 0))
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	(*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(0)*32))).nRow = int16(func() uint32 {
		if pParse.nQueryLoop < uint32(48) {
			return pParse.nQueryLoop
		} else {
			return uint32(48)
		}
	}())
	func() int {
		_ = 0
		return 0
	}()
	nFrom = int32(1)
	func() int {
		_ = 0
		return 0
	}()
	if nOrderBy != 0 {
		(*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(0)*32))).isOrdered = int8(func() int32 {
			if nLoop > 0 {
				return -1
			} else {
				return nOrderBy
			}
		}())
	}
	for iLoop = int32(0); iLoop < nLoop; iLoop++ {
		nTo = int32(0)
		for func() *struct_WherePath {
			ii = int32(0)
			return func() (_cgo_ret *struct_WherePath) {
				_cgo_addr := &pFrom
				*_cgo_addr = aFrom
				return *_cgo_addr
			}()
		}(); ii < nFrom; func() *struct_WherePath {
			ii++
			return func() (_cgo_ret *struct_WherePath) {
				_cgo_addr := &pFrom
				_cgo_ret = *_cgo_addr
				*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 32
				return
			}()
		}() {
			for pWLoop = pWInfo.pLoops; pWLoop != nil; pWLoop = pWLoop.pNextLoop {
				var nOut int16
				var rCost int16
				var rUnsorted int16
				var isOrdered int8 = pFrom.isOrdered
				var maskNew uint64
				var revMask uint64 = uint64(0)
				if pWLoop.prereq & ^pFrom.maskLoop != uint64(0) {
					continue
				}
				if pWLoop.maskSelf&pFrom.maskLoop != uint64(0) {
					continue
				}
				if pWLoop.wsFlags&uint32(16384) != uint32(0) && int32(pFrom.nRow) < 3 {
					func() int {
						_ = 0
						return 0
					}()
					continue
				}
				rUnsorted = sqlite3LogEstAdd(pWLoop.rSetup, int16(int32(pWLoop.rRun)+int32(pFrom.nRow)))
				rUnsorted = sqlite3LogEstAdd(rUnsorted, pFrom.rUnsorted)
				nOut = int16(int32(pFrom.nRow) + int32(pWLoop.nOut))
				maskNew = pFrom.maskLoop | pWLoop.maskSelf
				if int32(isOrdered) < 0 {
					isOrdered = wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, pWInfo.wctrlFlags, uint16(iLoop), pWLoop, &revMask)
				} else {
					revMask = pFrom.revLoop
				}
				if int32(isOrdered) >= 0 && int32(isOrdered) < nOrderBy {
					if int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(aSortCost)) + uintptr(isOrdered)*2))) == 0 {
						*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(aSortCost)) + uintptr(isOrdered)*2)) = whereSortingCost(pWInfo, nRowEst, nOrderBy, int32(isOrdered))
					}
					rCost = int16(int32(sqlite3LogEstAdd(rUnsorted, *(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(aSortCost)) + uintptr(isOrdered)*2)))) + 5)
				} else {
					rCost = rUnsorted
					rUnsorted -= int16(2)
				}
				for func() *struct_WherePath {
					jj = int32(0)
					return func() (_cgo_ret *struct_WherePath) {
						_cgo_addr := &pTo
						*_cgo_addr = aTo
						return *_cgo_addr
					}()
				}(); jj < nTo; func() *struct_WherePath {
					jj++
					return func() (_cgo_ret *struct_WherePath) {
						_cgo_addr := &pTo
						_cgo_ret = *_cgo_addr
						*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 32
						return
					}()
				}() {
					if pTo.maskLoop == maskNew && (int32(pTo.isOrdered)^int32(isOrdered))&128 == 0 {
						break
					}
				}
				if jj >= nTo {
					if nTo >= mxChoice && (int32(rCost) > int32(mxCost) || int32(rCost) == int32(mxCost) && int32(rUnsorted) >= int32(mxUnsorted)) {
						continue
					}
					if nTo < mxChoice {
						jj = func() (_cgo_ret int32) {
							_cgo_addr := &nTo
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}()
					} else {
						jj = mxI
					}
					pTo = &*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(jj)*32))
				} else if int32(pTo.rCost) < int32(rCost) || int32(pTo.rCost) == int32(rCost) && (int32(pTo.nRow) < int32(nOut) || int32(pTo.nRow) == int32(nOut) && int32(pTo.rUnsorted) <= int32(rUnsorted)) {
					continue
				}
				pTo.maskLoop = pFrom.maskLoop | pWLoop.maskSelf
				pTo.revLoop = revMask
				pTo.nRow = nOut
				pTo.rCost = rCost
				pTo.rUnsorted = rUnsorted
				pTo.isOrdered = isOrdered
				__builtin___memcpy_chk(unsafe.Pointer(pTo.aLoop), unsafe.Pointer(pFrom.aLoop), 8*uint(iLoop), __builtin_object_size(unsafe.Pointer(pTo.aLoop), 0))
				*(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pTo.aLoop)) + uintptr(iLoop)*8)) = pWLoop
				if nTo >= mxChoice {
					mxI = int32(0)
					mxCost = (*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(0)*32))).rCost
					mxUnsorted = (*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(0)*32))).nRow
					for func() *struct_WherePath {
						jj = int32(1)
						return func() (_cgo_ret *struct_WherePath) {
							_cgo_addr := &pTo
							*_cgo_addr = &*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aTo)) + uintptr(1)*32))
							return *_cgo_addr
						}()
					}(); jj < mxChoice; func() *struct_WherePath {
						jj++
						return func() (_cgo_ret *struct_WherePath) {
							_cgo_addr := &pTo
							_cgo_ret = *_cgo_addr
							*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 32
							return
						}()
					}() {
						if int32(pTo.rCost) > int32(mxCost) || int32(pTo.rCost) == int32(mxCost) && int32(pTo.rUnsorted) > int32(mxUnsorted) {
							mxCost = pTo.rCost
							mxUnsorted = pTo.rUnsorted
							mxI = jj
						}
					}
				}
			}
		}
		pFrom = aTo
		aTo = aFrom
		aFrom = pFrom
		nFrom = nTo
	}
	if nFrom == 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[18]int8{'n', 'o', ' ', 'q', 'u', 'e', 'r', 'y', ' ', 's', 'o', 'l', 'u', 't', 'i', 'o', 'n', '\x00'})))
		sqlite3DbFreeNN(db, unsafe.Pointer(pSpace))
		return int32(1)
	}
	pFrom = aFrom
	for ii = int32(1); ii < nFrom; ii++ {
		if int32(pFrom.rCost) > int32((*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(ii)*32))).rCost) {
			pFrom = &*(*struct_WherePath)(unsafe.Pointer(uintptr(unsafe.Pointer(aFrom)) + uintptr(ii)*32))
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	for iLoop = int32(0); iLoop < nLoop; iLoop++ {
		var pLevel *struct_WhereLevel = (*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(iLoop)*104))
		pLevel.pWLoop = func() (_cgo_ret *struct_WhereLoop) {
			_cgo_addr := &pWLoop
			*_cgo_addr = *(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrom.aLoop)) + uintptr(iLoop)*8))
			return *_cgo_addr
		}()
		pLevel.iFrom = pWLoop.iTab
		pLevel.iTabCur = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLevel.iFrom)*112))).iCursor
	}
	if int32(pWInfo.wctrlFlags)&256 != 0 && int32(pWInfo.wctrlFlags)&128 == 0 && int32(pWInfo.eDistinct) == 0 && int32(nRowEst) != 0 {
		var notUsed uint64
		var rc int32 = int32(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pResultSet, pFrom, uint16(128), uint16(nLoop-1), *(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrom.aLoop)) + uintptr(nLoop-1)*8)), &notUsed))
		if rc == pWInfo.pResultSet.nExpr {
			pWInfo.eDistinct = uint8(2)
		}
	}
	{
		_autoGo_96 := &pWInfo.Xbf_0
		*_autoGo_96 = *_autoGo_96&^4 | uint32(0)&1<<2
	}
	if pWInfo.pOrderBy != nil {
		if int32(pWInfo.wctrlFlags)&128 != 0 {
			if int32(pFrom.isOrdered) == pWInfo.pOrderBy.nExpr {
				pWInfo.eDistinct = uint8(2)
			}
		} else {
			pWInfo.nOBSat = pFrom.isOrdered
			pWInfo.revMask = pFrom.revLoop
			if int32(pWInfo.nOBSat) <= 0 {
				pWInfo.nOBSat = int8(0)
				if nLoop > 0 {
					var wsFlags uint32 = (*(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrom.aLoop)) + uintptr(nLoop-1)*8))).wsFlags
					if wsFlags&uint32(4096) == uint32(0) && wsFlags&uint32(256|4) != uint32(256|4) {
						var m uint64 = uint64(0)
						var rc int32 = int32(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, uint16(2048), uint16(nLoop-1), *(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrom.aLoop)) + uintptr(nLoop-1)*8)), &m))
						if rc == pWInfo.pOrderBy.nExpr {
							{
								_autoGo_97 := &pWInfo.Xbf_0
								*_autoGo_97 = *_autoGo_97&^4 | uint32(1)&1<<2
							}
							pWInfo.revMask = m
						}
					}
				}
			} else if nLoop != 0 && int32(pWInfo.nOBSat) == 1 && int32(pWInfo.wctrlFlags)&(1|2) != 0 {
				{
					_autoGo_98 := &pWInfo.Xbf_0
					*_autoGo_98 = *_autoGo_98&^4 | uint32(1)&1<<2
				}
			}
		}
		if int32(pWInfo.wctrlFlags)&512 != 0 && int32(pWInfo.nOBSat) == pWInfo.pOrderBy.nExpr && nLoop > 0 {
			var revMask uint64 = uint64(0)
			var nOrder int32 = int32(wherePathSatisfiesOrderBy(pWInfo, pWInfo.pOrderBy, pFrom, uint16(0), uint16(nLoop-1), *(**struct_WhereLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pFrom.aLoop)) + uintptr(nLoop-1)*8)), &revMask))
			func() int {
				_ = 0
				return 0
			}()
			if nOrder == pWInfo.pOrderBy.nExpr {
				{
					_autoGo_99 := &pWInfo.Xbf_0
					*_autoGo_99 = *_autoGo_99&^8 | uint32(1)&1<<3
				}
				pWInfo.revMask = revMask
			}
		}
	}
	pWInfo.nRowOut = pFrom.nRow
	sqlite3DbFreeNN(db, unsafe.Pointer(pSpace))
	return int32(0)
}
func whereShortCut(pBuilder *struct_WhereLoopBuilder) int32 {
	var pWInfo *struct_WhereInfo
	var pItem *struct_SrcItem
	var pWC *struct_WhereClause
	var pTerm *struct_WhereTerm
	var pLoop *struct_WhereLoop
	var iCur int32
	var j int32
	var pTab *struct_Table
	var pIdx *struct_Index
	var scan struct_WhereScan
	pWInfo = pBuilder.pWInfo
	if int32(pWInfo.wctrlFlags)&32 != 0 {
		return int32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	pItem = (*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a))
	pTab = pItem.pTab
	if int32(pTab.eTabType) == 1 {
		return int32(0)
	}
	if pItem.fg.Xbf_0>>1&1 != 0 {
		return int32(0)
	}
	iCur = pItem.iCursor
	pWC = &pWInfo.sWC
	pLoop = pBuilder.pNew
	pLoop.wsFlags = uint32(0)
	pLoop.nSkip = uint16(0)
	pTerm = whereScanInit(&scan, pWC, iCur, -1, uint32(2|128), nil)
	for pTerm != nil && pTerm.prereqRight != 0 {
		pTerm = whereScanNext(&scan)
	}
	if pTerm != nil {
		pLoop.wsFlags = uint32(1 | 256 | 4096)
		*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(0)*8)) = pTerm
		pLoop.nLTerm = uint16(1)
		(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq = uint16(1)
		pLoop.rRun = int16(33)
	} else {
		for pIdx = pTab.pIndex; pIdx != nil; pIdx = pIdx.pNext {
			var opMask int32
			func() int {
				_ = 0
				return 0
			}()
			if !(int32(pIdx.onError) != 0) || uintptr(unsafe.Pointer(pIdx.pPartIdxWhere)) != uintptr(unsafe.Pointer(nil)) || int32(pIdx.nKeyCol) > int32(24/8) {
				continue
			}
			opMask = func() int32 {
				if int32(pIdx.Xbf_0>>3&1) != 0 {
					return 2 | 128
				} else {
					return 2
				}
			}()
			for j = int32(0); j < int32(pIdx.nKeyCol); j++ {
				pTerm = whereScanInit(&scan, pWC, iCur, j, uint32(opMask), pIdx)
				for pTerm != nil && pTerm.prereqRight != 0 {
					pTerm = whereScanNext(&scan)
				}
				if uintptr(unsafe.Pointer(pTerm)) == uintptr(unsafe.Pointer(nil)) {
					break
				}
				*(**struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pLoop.aLTerm)) + uintptr(j)*8)) = pTerm
			}
			if j != int32(pIdx.nKeyCol) {
				continue
			}
			pLoop.wsFlags = uint32(1 | 4096 | 512)
			if int32(pIdx.Xbf_0>>5&1) != 0 || pItem.colUsed&pIdx.colNotIdxed == uint64(0) {
				pLoop.wsFlags |= uint32(64)
			}
			pLoop.nLTerm = uint16(j)
			(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nEq = uint16(j)
			(*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex = pIdx
			pLoop.rRun = int16(39)
			break
		}
	}
	if pLoop.wsFlags != 0 {
		pLoop.nOut = int16(1)
		(*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))).pWLoop = pLoop
		func() int {
			_ = 0
			return 0
		}()
		pLoop.maskSelf = uint64(1)
		(*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))).iTabCur = iCur
		pWInfo.nRowOut = int16(1)
		if pWInfo.pOrderBy != nil {
			pWInfo.nOBSat = int8(pWInfo.pOrderBy.nExpr)
		}
		if int32(pWInfo.wctrlFlags)&256 != 0 {
			pWInfo.eDistinct = uint8(1)
		}
		if int32(scan.iEquiv) > 1 {
			pLoop.wsFlags |= uint32(2097152)
		}
		return int32(1)
	}
	return int32(0)
}
func exprNodeIsDeterministic(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 172 && func() int32 {
		if pExpr.flags&uint32(524288) != uint32(0) {
			return 1
		} else {
			return 0
		}
	}() == 0 {
		pWalker.eCode = uint16(0)
		return int32(2)
	}
	return int32(0)
}
func exprIsDeterministic(p *struct_Expr) int32 {
	var w struct_Walker
	__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
	w.eCode = uint16(1)
	w.xExprCallback = exprNodeIsDeterministic
	w.xSelectCallback = sqlite3SelectWalkFail
	sqlite3WalkExpr(&w, p)
	return int32(w.eCode)
}
func whereOmitNoopJoin(pWInfo *struct_WhereInfo, notReady uint64) uint64 {
	var i int32
	var tabUsed uint64
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	tabUsed = sqlite3WhereExprListUsage(&pWInfo.sMaskSet, pWInfo.pResultSet)
	if pWInfo.pOrderBy != nil {
		tabUsed |= sqlite3WhereExprListUsage(&pWInfo.sMaskSet, pWInfo.pOrderBy)
	}
	for i = int32(pWInfo.nLevel) - 1; i >= 1; i-- {
		var pTerm *struct_WhereTerm
		var pEnd *struct_WhereTerm
		var pItem *struct_SrcItem
		var pLoop *struct_WhereLoop
		pLoop = (*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))).pWLoop
		pItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLoop.iTab)*112))
		if int32(pItem.fg.jointype)&8 == 0 {
			continue
		}
		if int32(pWInfo.wctrlFlags)&256 == 0 && pLoop.wsFlags&uint32(4096) == uint32(0) {
			continue
		}
		if tabUsed&pLoop.maskSelf != uint64(0) {
			continue
		}
		pEnd = (*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(pWInfo.sWC.a)) + uintptr(pWInfo.sWC.nTerm)*56))
		for pTerm = pWInfo.sWC.a; uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pEnd)); *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
			if pTerm.prereqAll&pLoop.maskSelf != uint64(0) {
				if !(pTerm.pExpr.flags&uint32(1) != uint32(0)) || pTerm.pExpr.w.iRightJoinTable != pItem.iCursor {
					break
				}
			}
		}
		if uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pEnd)) {
			continue
		}
		notReady &= ^pLoop.maskSelf
		for pTerm = pWInfo.sWC.a; uintptr(unsafe.Pointer(pTerm)) < uintptr(unsafe.Pointer(pEnd)); *(*uintptr)(unsafe.Pointer(&pTerm)) += 56 {
			if pTerm.prereqAll&pLoop.maskSelf != uint64(0) {
				pTerm.wtFlags |= uint16(4)
			}
		}
		if i != int32(pWInfo.nLevel)-1 {
			var nByte int32 = int32(uint(int32(pWInfo.nLevel)-1-i) * 104)
			__builtin___memmove_chk(unsafe.Pointer(&*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))), unsafe.Pointer(&*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i+1)*104))), uint(nByte), __builtin_object_size(unsafe.Pointer(&*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))), 0))
		}
		pWInfo.nLevel--
		func() int {
			_ = 0
			return 0
		}()
	}
	return notReady
}
func whereCheckIfBloomFilterIsUseful(pWInfo *struct_WhereInfo) {
	var i int32
	var nSearch int16
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	nSearch = (*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))).pWLoop.nOut
	for i = int32(1); i < int32(pWInfo.nLevel); i++ {
		var pLoop *struct_WhereLoop = (*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))).pWLoop
		var reqFlags uint32 = uint32(8388608 | 1)
		if pLoop.wsFlags&reqFlags == reqFlags && pLoop.wsFlags&uint32(256|512) != uint32(0) {
			var pItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pWInfo.pTabList.a)))) + uintptr(pLoop.iTab)*112))
			var pTab *struct_Table = pItem.pTab
			pTab.tabFlags |= uint32(256)
			if int32(nSearch) > int32(pTab.nRowLogEst) && pTab.tabFlags&uint32(16) != uint32(0) {
				pLoop.wsFlags |= uint32(4194304)
				pLoop.wsFlags &= uint32(4294967231)
			}
		}
		nSearch += int16(int32(pLoop.nOut))
	}
}
func sqlite3WhereBegin(pParse *struct_Parse, pTabList *struct_SrcList, pWhere *struct_Expr, pOrderBy *struct_ExprList, pResultSet *struct_ExprList, pLimit *struct_Select, wctrlFlags uint16, iAuxArg int32) *struct_WhereInfo {
	var nByteWInfo int32
	var nTabList int32
	var pWInfo *struct_WhereInfo
	var v *struct_Vdbe = pParse.pVdbe
	var notReady uint64
	var sWLB struct_WhereLoopBuilder
	var pMaskSet *struct_WhereMaskSet
	var pLevel *struct_WhereLevel
	var pLoop *struct_WhereLoop
	var ii int32
	var db *struct_sqlite3
	var rc int32
	var bFordelete uint8 = uint8(0)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	db = pParse.db
	__builtin___memset_chk(unsafe.Pointer(&sWLB), 0, 40, __builtin_object_size(unsafe.Pointer(&sWLB), 0))
	if pOrderBy != nil && pOrderBy.nExpr >= int32(8*uint(8)) {
		pOrderBy = (*struct_ExprList)(nil)
	}
	if pTabList.nSrc > int32(8*uint(8)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[28]int8{'a', 't', ' ', 'm', 'o', 's', 't', ' ', '%', 'd', ' ', 't', 'a', 'b', 'l', 'e', 's', ' ', 'i', 'n', ' ', 'a', ' ', 'j', 'o', 'i', 'n', '\x00'})), int32(8*uint(8)))
		return (*struct_WhereInfo)(nil)
	}
	nTabList = func() int32 {
		if int32(wctrlFlags)&32 != 0 {
			return 1
		} else {
			return pTabList.nSrc
		}
	}()
	nByteWInfo = int32((976 + uint(nTabList-1)*104 + uint(7)) & uint(18446744073709551608))
	pWInfo = (*struct_WhereInfo)(sqlite3DbMallocRawNN(db, uint64(uint(nByteWInfo)+104)))
	if db.mallocFailed != 0 {
		sqlite3DbFree(db, unsafe.Pointer(pWInfo))
		pWInfo = (*struct_WhereInfo)(nil)
		goto whereBeginError
	}
	pWInfo.pParse = pParse
	pWInfo.pTabList = pTabList
	pWInfo.pOrderBy = pOrderBy
	pWInfo.pWhere = pWhere
	pWInfo.pResultSet = pResultSet
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pWInfo.aiCurOnePass)))) + uintptr(0)*4)) = func() (_cgo_ret int32) {
		_cgo_addr := &*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pWInfo.aiCurOnePass)))) + uintptr(1)*4))
		*_cgo_addr = int32(-1)
		return *_cgo_addr
	}()
	pWInfo.nLevel = uint8(nTabList)
	pWInfo.iBreak = func() (_cgo_ret int32) {
		_cgo_addr := &pWInfo.iContinue
		*_cgo_addr = sqlite3VdbeMakeLabel(pParse)
		return *_cgo_addr
	}()
	pWInfo.wctrlFlags = wctrlFlags
	pWInfo.iLimit = int16(iAuxArg)
	pWInfo.savedNQueryLoop = int32(pParse.nQueryLoop)
	pWInfo.pLimit = pLimit
	__builtin___memset_chk(unsafe.Pointer(&pWInfo.nOBSat), 0, 120-73, __builtin_object_size(unsafe.Pointer(&pWInfo.nOBSat), 0))
	__builtin___memset_chk(unsafe.Pointer(&*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))), 0, 104+uint(nTabList)*104, __builtin_object_size(unsafe.Pointer(&*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))), 0))
	func() int {
		_ = 0
		return 0
	}()
	pMaskSet = &pWInfo.sMaskSet
	pMaskSet.n = int32(0)
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pMaskSet.ix)))) + uintptr(0)*4)) = int32(-99)
	sWLB.pWInfo = pWInfo
	sWLB.pWC = &pWInfo.sWC
	sWLB.pNew = (*struct_WhereLoop)(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(pWInfo)))) + uintptr(nByteWInfo)))))
	func() int {
		_ = 0
		return 0
	}()
	whereLoopInit(sWLB.pNew)
	sqlite3WhereClauseInit(&pWInfo.sWC, pWInfo)
	sqlite3WhereSplit(&pWInfo.sWC, pWhere, uint8(44))
	if nTabList == 0 {
		if pOrderBy != nil {
			pWInfo.nOBSat = int8(pOrderBy.nExpr)
		}
		if int32(wctrlFlags)&256 != 0 && db.dbOptFlags&uint32(16) == uint32(0) {
			pWInfo.eDistinct = uint8(1)
		}
		sqlite3VdbeExplain(pParse, uint8(0), (*int8)(unsafe.Pointer(&[18]int8{'S', 'C', 'A', 'N', ' ', 'C', 'O', 'N', 'S', 'T', 'A', 'N', 'T', ' ', 'R', 'O', 'W', '\x00'})))
	} else {
		ii = int32(0)
		for {
			createMask(pMaskSet, (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(ii)*112))).iCursor)
			sqlite3WhereTabFuncArgs(pParse, &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(ii)*112)), &pWInfo.sWC)
			if !(func() (_cgo_ret int32) {
				_cgo_addr := &ii
				*_cgo_addr++
				return *_cgo_addr
			}() < pTabList.nSrc) {
				break
			}
		}
	}
	sqlite3WhereExprAnalyze(pTabList, &pWInfo.sWC)
	sqlite3WhereAddLimit(&pWInfo.sWC, pLimit)
	if db.mallocFailed != 0 {
		goto whereBeginError
	}
	for ii = int32(0); ii < sWLB.pWC.nBase; ii++ {
		var pT *struct_WhereTerm = &*(*struct_WhereTerm)(unsafe.Pointer(uintptr(unsafe.Pointer(sWLB.pWC.a)) + uintptr(ii)*56))
		if int32(pT.wtFlags)&2 != 0 {
			continue
		}
		if pT.prereqAll == uint64(0) && (nTabList == 0 || exprIsDeterministic(pT.pExpr) != 0) {
			sqlite3ExprIfFalse(pParse, pT.pExpr, pWInfo.iBreak, 16)
			pT.wtFlags |= uint16(4)
		}
	}
	if int32(wctrlFlags)&256 != 0 {
		if db.dbOptFlags&uint32(16) != uint32(0) {
			wctrlFlags &= uint16(^256)
			pWInfo.wctrlFlags &= uint16(^256)
		} else if isDistinctRedundant(pParse, pTabList, &pWInfo.sWC, pResultSet) != 0 {
			pWInfo.eDistinct = uint8(1)
		} else if uintptr(unsafe.Pointer(pOrderBy)) == uintptr(unsafe.Pointer(nil)) {
			pWInfo.wctrlFlags |= uint16(128)
			pWInfo.pOrderBy = pResultSet
		}
	}
	if nTabList != 1 || whereShortCut(&sWLB) == 0 {
		rc = whereLoopAddAll(&sWLB)
		if rc != 0 {
			goto whereBeginError
		}
		wherePathSolver(pWInfo, int16(0))
		if db.mallocFailed != 0 {
			goto whereBeginError
		}
		if pWInfo.pOrderBy != nil {
			wherePathSolver(pWInfo, int16(int32(pWInfo.nRowOut)+1))
			if db.mallocFailed != 0 {
				goto whereBeginError
			}
		}
	}
	if uintptr(unsafe.Pointer(pWInfo.pOrderBy)) == uintptr(unsafe.Pointer(nil)) && db.flags&uint64(4096) != uint64(0) {
		pWInfo.revMask = uint64(18446744073709551615)
	}
	if pParse.nErr != 0 {
		goto whereBeginError
	}
	func() int {
		_ = 0
		return 0
	}()
	notReady = ^uint64(0)
	if int32(pWInfo.nLevel) >= 2 && uintptr(unsafe.Pointer(pResultSet)) != uintptr(unsafe.Pointer(nil)) && 0 == int32(wctrlFlags)&1024 && db.dbOptFlags&uint32(256) == uint32(0) {
		notReady = whereOmitNoopJoin(pWInfo, notReady)
		nTabList = int32(pWInfo.nLevel)
		func() int {
			_ = 0
			return 0
		}()
	}
	if int32(pWInfo.nLevel) >= 2 && db.dbOptFlags&uint32(524288) == uint32(0) {
		whereCheckIfBloomFilterIsUseful(pWInfo)
	}
	pWInfo.pParse.nQueryLoop += uint32(pWInfo.nRowOut)
	func() int {
		_ = 0
		return 0
	}()
	if int32(wctrlFlags)&4 != 0 {
		var wsFlags int32 = int32((*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))).pWLoop.wsFlags)
		var bOnerow int32 = func() int32 {
			if wsFlags&4096 != 0 {
				return 1
			} else {
				return 0
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		if bOnerow != 0 || 0 != int32(wctrlFlags)&8 && !(int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).pTab.eTabType) == 1) && (0 == wsFlags&8192 || int32(wctrlFlags)&16 != 0) {
			pWInfo.eOnePass = uint8(func() int32 {
				if bOnerow != 0 {
					return 1
				} else {
					return 2
				}
			}())
			if (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(0)*112))).pTab.tabFlags&uint32(128) == uint32(0) && wsFlags&64 != 0 {
				if int32(wctrlFlags)&8 != 0 {
					bFordelete = uint8(8)
				}
				(*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(0)*104))).pWLoop.wsFlags = uint32(wsFlags & ^64)
			}
		}
	}
	for func() *struct_WhereLevel {
		ii = int32(0)
		return func() (_cgo_ret *struct_WhereLevel) {
			_cgo_addr := &pLevel
			*_cgo_addr = (*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a))
			return *_cgo_addr
		}()
	}(); ii < nTabList; func() *struct_WhereLevel {
		ii++
		return func() (_cgo_ret *struct_WhereLevel) {
			_cgo_addr := &pLevel
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 104
			return
		}()
	}() {
		var pTab *struct_Table
		var iDb int32
		var pTabItem *struct_SrcItem
		pTabItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(pLevel.iFrom)*112))
		pTab = pTabItem.pTab
		iDb = sqlite3SchemaToIndex(db, pTab.pSchema)
		pLoop = pLevel.pWLoop
		if pTab.tabFlags&uint32(16384) != uint32(0) || int32(pTab.eTabType) == 2 {
		} else if pLoop.wsFlags&uint32(1024) != uint32(0) {
			var pVTab *int8 = (*int8)(unsafe.Pointer(sqlite3GetVTable(db, pTab)))
			var iCur int32 = pTabItem.iCursor
			sqlite3VdbeAddOp4(v, 172, iCur, 0, 0, pVTab, -12)
		} else if int32(pTab.eTabType) == 1 {
		} else if pLoop.wsFlags&uint32(64) == uint32(0) && int32(wctrlFlags)&32 == 0 {
			var op int32 = 101
			if int32(pWInfo.eOnePass) != 0 {
				op = int32(112)
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pWInfo.aiCurOnePass)))) + uintptr(0)*4)) = pTabItem.iCursor
			}
			sqlite3OpenTable(pParse, pTabItem.iCursor, iDb, pTab, op)
			func() int {
				_ = 0
				return 0
			}()
			if int32(pWInfo.eOnePass) == 0 && int32(pTab.nCol) < int32(8*uint(8)) && pTab.tabFlags&uint32(96|128) == uint32(0) && pLoop.wsFlags&uint32(16384|4194304) == uint32(0) {
				var b uint64 = pTabItem.colUsed
				var n int32 = 0
				for ; b != 0; func() int32 {
					b = b >> 1
					return func() (_cgo_ret int32) {
						_cgo_addr := &n
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()
				}() {
				}
				sqlite3VdbeChangeP4(v, -1, (*int8)(unsafe.Pointer(int(n))), -3)
				func() int {
					_ = 0
					return 0
				}()
			}
			{
				sqlite3VdbeChangeP5(v, uint16(bFordelete))
			}
		} else {
			sqlite3TableLock(pParse, iDb, pTab.tnum, uint8(0), pTab.zName)
		}
		if pLoop.wsFlags&uint32(512) != 0 {
			var pIx *struct_Index = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
			var iIndexCur int32
			var op int32 = 101
			func() int {
				_ = 0
				return 0
			}()
			if !(pTab.tabFlags&uint32(128) == uint32(0)) && int32(pIx.Xbf_0&3) == 2 && int32(wctrlFlags)&32 != 0 {
				iIndexCur = pLevel.iTabCur
				op = int32(0)
			} else if int32(pWInfo.eOnePass) != 0 {
				var pJ *struct_Index = pTabItem.pTab.pIndex
				iIndexCur = iAuxArg
				func() int {
					_ = 0
					return 0
				}()
				for pJ != nil && uintptr(unsafe.Pointer(pJ)) != uintptr(unsafe.Pointer(pIx)) {
					iIndexCur++
					pJ = pJ.pNext
				}
				op = int32(112)
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pWInfo.aiCurOnePass)))) + uintptr(1)*4)) = iIndexCur
			} else if iAuxArg != 0 && int32(wctrlFlags)&32 != 0 {
				iIndexCur = iAuxArg
				op = int32(100)
			} else {
				iIndexCur = func() (_cgo_ret int32) {
					_cgo_addr := &pParse.nTab
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()
			}
			pLevel.iIdxCur = iIndexCur
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if op != 0 {
				sqlite3VdbeAddOp3(v, op, iIndexCur, int32(pIx.tnum), iDb)
				sqlite3VdbeSetP4KeyInfo(pParse, pIx)
				if pLoop.wsFlags&uint32(15) != uint32(0) && pLoop.wsFlags&uint32(2|32768) == uint32(0) && pLoop.wsFlags&uint32(524288) == uint32(0) && pLoop.wsFlags&uint32(1048576) == uint32(0) && int32(pWInfo.wctrlFlags)&1 == 0 && int32(pWInfo.eDistinct) != 2 {
					sqlite3VdbeChangeP5(v, uint16(2))
				}
			}
		}
		if iDb >= 0 {
			sqlite3CodeVerifySchema(pParse, iDb)
		}
	}
	pWInfo.iTop = sqlite3VdbeCurrentAddr(v)
	if db.mallocFailed != 0 {
		goto whereBeginError
	}
	for ii = int32(0); ii < nTabList; ii++ {
		var addrExplain int32
		var wsFlags int32
		if pParse.nErr != 0 {
			goto whereBeginError
		}
		pLevel = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(ii)*104))
		wsFlags = int32(pLevel.pWLoop.wsFlags)
		if wsFlags&(16384|4194304) != 0 {
			if wsFlags&16384 != 0 {
				constructAutomaticIndex(pParse, &pWInfo.sWC, &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(pLevel.iFrom)*112)), notReady, pLevel)
			} else {
				sqlite3ConstructBloomFilter(pWInfo, ii, pLevel, notReady)
			}
			if db.mallocFailed != 0 {
				goto whereBeginError
			}
		}
		addrExplain = sqlite3WhereExplainOneScan(pParse, pTabList, pLevel, wctrlFlags)
		pLevel.addrBody = sqlite3VdbeCurrentAddr(v)
		notReady = sqlite3WhereCodeOneLoopStart(pParse, v, pWInfo, ii, pLevel, notReady)
		pWInfo.iContinue = pLevel.addrCont
		if wsFlags&8192 == 0 && int32(wctrlFlags)&32 == 0 {
			func() int {
				_ = addrExplain
				return 0
			}()
		}
	}
	pWInfo.iEndWhere = sqlite3VdbeCurrentAddr(v)
	return pWInfo
whereBeginError:
	if pWInfo != nil {
		whereUndoExprMods(pWInfo)
		pParse.nQueryLoop = uint32(pWInfo.savedNQueryLoop)
		whereInfoFree(db, pWInfo)
	}
	return (*struct_WhereInfo)(nil)
}
func sqlite3WhereEnd(pWInfo *struct_WhereInfo) {
	var pParse *struct_Parse = pWInfo.pParse
	var v *struct_Vdbe = pParse.pVdbe
	var i int32
	var pLevel *struct_WhereLevel
	var pLoop *struct_WhereLoop
	var pTabList *struct_SrcList = pWInfo.pTabList
	var db *struct_sqlite3 = pParse.db
	var iEnd int32 = sqlite3VdbeCurrentAddr(v)
	for i = int32(pWInfo.nLevel) - 1; i >= 0; i-- {
		var addr int32
		pLevel = &*(*struct_WhereLevel)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a)))) + uintptr(i)*104))
		pLoop = pLevel.pWLoop
		if int32(pLevel.op) != 182 {
			var addrSeek int32 = 0
			var pIdx *struct_Index
			var n int32
			if int32(pWInfo.eDistinct) == 2 && i == int32(pWInfo.nLevel)-1 && pLoop.wsFlags&uint32(512) != uint32(0) && int32(func() (_cgo_ret *struct_Index) {
				_cgo_addr := &pIdx
				*_cgo_addr = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
				return *_cgo_addr
			}().Xbf_0>>7&1) != 0 && func() (_cgo_ret int32) {
				_cgo_addr := &n
				*_cgo_addr = int32((*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).nDistinctCol)
				return *_cgo_addr
			}() > 0 && int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdx.aiRowLogEst)) + uintptr(n)*2))) >= 36 {
				var r1 int32 = pParse.nMem + 1
				var j int32
				var op int32
				for j = int32(0); j < n; j++ {
					sqlite3VdbeAddOp3(v, 93, pLevel.iIdxCur, j, r1+j)
				}
				pParse.nMem += n + 1
				op = func() int32 {
					if int32(pLevel.op) == 4 {
						return 23
					} else {
						return 26
					}
				}()
				addrSeek = sqlite3VdbeAddOp4Int(v, op, pLevel.iIdxCur, 0, r1, n)
				sqlite3VdbeAddOp2(v, 11, 1, pLevel.p2)
			}
			sqlite3VdbeResolveLabel(v, pLevel.addrCont)
			sqlite3VdbeAddOp3(v, int32(pLevel.op), pLevel.p1, pLevel.p2, int32(pLevel.p3))
			sqlite3VdbeChangeP5(v, uint16(pLevel.p5))
			if pLevel.regBignull != 0 {
				sqlite3VdbeResolveLabel(v, pLevel.addrBignull)
				sqlite3VdbeAddOp2(v, 60, pLevel.regBignull, pLevel.p2-1)
			}
			if addrSeek != 0 {
				sqlite3VdbeJumpHere(v, addrSeek)
			}
		} else {
			sqlite3VdbeResolveLabel(v, pLevel.addrCont)
		}
		if pLoop.wsFlags&uint32(2048) != uint32(0) && pLevel.u.in.nIn > 0 {
			var pIn *struct_InLoop
			var j int32
			sqlite3VdbeResolveLabel(v, pLevel.addrNxt)
			for func() *struct_InLoop {
				j = pLevel.u.in.nIn
				return func() (_cgo_ret *struct_InLoop) {
					_cgo_addr := &pIn
					*_cgo_addr = &*(*struct_InLoop)(unsafe.Pointer(uintptr(unsafe.Pointer(pLevel.u.in.aInLoop)) + uintptr(j-1)*17))
					return *_cgo_addr
				}()
			}(); j > 0; func() *struct_InLoop {
				j--
				return func() (_cgo_ret *struct_InLoop) {
					_cgo_addr := &pIn
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) -= 17
					return
				}()
			}() {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeJumpHere(v, pIn.addrInTop+1)
				if int32(pIn.eEndLoopOp) != 182 {
					if pIn.nPrefix != 0 {
						var bEarlyOut int32 = func() int32 {
							if pLoop.wsFlags&uint32(1024) == uint32(0) && pLoop.wsFlags&uint32(262144) != uint32(0) {
								return 1
							} else {
								return 0
							}
						}()
						if pLevel.iLeftJoin != 0 {
							sqlite3VdbeAddOp2(v, 27, pIn.iCur, sqlite3VdbeCurrentAddr(v)+2+bEarlyOut)
						}
						if bEarlyOut != 0 {
							sqlite3VdbeAddOp4Int(v, 28, pLevel.iIdxCur, sqlite3VdbeCurrentAddr(v)+2, pIn.iBase, pIn.nPrefix)
							sqlite3VdbeJumpHere(v, pIn.addrInTop+1)
						}
					}
					sqlite3VdbeAddOp2(v, int32(pIn.eEndLoopOp), pIn.iCur, pIn.addrInTop)
				}
				sqlite3VdbeJumpHere(v, pIn.addrInTop-1)
			}
		}
		sqlite3VdbeResolveLabel(v, pLevel.addrBrk)
		if pLevel.addrSkip != 0 {
			sqlite3VdbeGoto(v, pLevel.addrSkip)
			sqlite3VdbeJumpHere(v, pLevel.addrSkip)
			sqlite3VdbeJumpHere(v, pLevel.addrSkip-2)
		}
		if pLevel.addrLikeRep != 0 {
			sqlite3VdbeAddOp2(v, 60, int32(pLevel.iLikeRepCntr>>1), pLevel.addrLikeRep)
		}
		if pLevel.iLeftJoin != 0 {
			var ws int32 = int32(pLoop.wsFlags)
			addr = sqlite3VdbeAddOp1(v, 49, pLevel.iLeftJoin)
			func() int {
				_ = 0
				return 0
			}()
			if ws&64 == 0 {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp1(v, 135, pLevel.iTabCur)
			}
			if ws&512 != 0 || ws&8192 != 0 && *(**struct_Index)(unsafe.Pointer(&pLevel.u)) != nil {
				if ws&8192 != 0 {
					var pIx *struct_Index = *(**struct_Index)(unsafe.Pointer(&pLevel.u))
					var iDb int32 = sqlite3SchemaToIndex(db, pIx.pSchema)
					sqlite3VdbeAddOp3(v, 100, pLevel.iIdxCur, int32(pIx.tnum), iDb)
					sqlite3VdbeSetP4KeyInfo(pParse, pIx)
				}
				sqlite3VdbeAddOp1(v, 135, pLevel.iIdxCur)
			}
			if int32(pLevel.op) == 67 {
				sqlite3VdbeAddOp2(v, 12, pLevel.p1, pLevel.addrFirst)
			} else {
				sqlite3VdbeGoto(v, pLevel.addrFirst)
			}
			sqlite3VdbeJumpHere(v, addr)
		}
	}
	sqlite3VdbeResolveLabel(v, pWInfo.iBreak)
	func() int {
		_ = 0
		return 0
	}()
	for func() *struct_WhereLevel {
		i = int32(0)
		return func() (_cgo_ret *struct_WhereLevel) {
			_cgo_addr := &pLevel
			*_cgo_addr = (*struct_WhereLevel)(unsafe.Pointer(&pWInfo.a))
			return *_cgo_addr
		}()
	}(); i < int32(pWInfo.nLevel); func() *struct_WhereLevel {
		i++
		return func() (_cgo_ret *struct_WhereLevel) {
			_cgo_addr := &pLevel
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 104
			return
		}()
	}() {
		var k int32
		var last int32
		var pOp *struct_VdbeOp
		var pLastOp *struct_VdbeOp
		var pIdx *struct_Index = nil
		var pTabItem *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pTabList.a)))) + uintptr(pLevel.iFrom)*112))
		var pTab *struct_Table = pTabItem.pTab
		func() int {
			_ = 0
			return 0
		}()
		pLoop = pLevel.pWLoop
		if pTabItem.fg.Xbf_0>>4&1 != 0 {
			translateColumnToCopy(pParse, pLevel.addrBody, pLevel.iTabCur, pTabItem.regResult, 0)
			continue
		}
		if pLoop.wsFlags&uint32(512|64) != 0 {
			pIdx = (*(*_cgoa_84)(unsafe.Pointer(&pLoop.u))).pIndex
		} else if pLoop.wsFlags&uint32(8192) != 0 {
			pIdx = *(**struct_Index)(unsafe.Pointer(&pLevel.u))
		}
		if pIdx != nil && !(db.mallocFailed != 0) {
			if int32(pWInfo.eOnePass) == 0 || !(pIdx.pTable.tabFlags&uint32(128) == uint32(0)) {
				last = iEnd
			} else {
				last = pWInfo.iEndWhere
			}
			k = pLevel.addrBody + 1
			pOp = sqlite3VdbeGetOp(v, k)
			pLastOp = (*struct_VdbeOp)(unsafe.Pointer(uintptr(unsafe.Pointer(pOp)) + uintptr(last-k)*24))
			func() int {
				_ = 0
				return 0
			}()
			for {
				if pOp.p1 != pLevel.iTabCur {
				} else if int32(pOp.opcode) == 93 {
					var x int32 = pOp.p2
					func() int {
						_ = 0
						return 0
					}()
					if !(pTab.tabFlags&uint32(128) == uint32(0)) {
						var pPk *struct_Index = sqlite3PrimaryKeyIndex(pTab)
						x = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer(pPk.aiColumn)) + uintptr(x)*2)))
						func() int {
							_ = 0
							return 0
						}()
					} else {
						x = int32(sqlite3StorageColumnToTable(pTab, int16(x)))
					}
					x = int32(sqlite3TableColumnToIndex(pIdx, int16(x)))
					if x >= 0 {
						pOp.p2 = x
						pOp.p1 = pLevel.iIdxCur
					} else {
						func() int {
							_ = 0
							return 0
						}()
					}
				} else if int32(pOp.opcode) == 134 {
					pOp.p1 = pLevel.iIdxCur
					pOp.opcode = uint8(141)
				} else if int32(pOp.opcode) == 22 {
					pOp.p1 = pLevel.iIdxCur
				}
				if !(uintptr(unsafe.Pointer(func() (_cgo_ret *struct_VdbeOp) {
					_cgo_addr := &pOp
					*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 24
					return *_cgo_addr
				}())) < uintptr(unsafe.Pointer(pLastOp))) {
					break
				}
			}
		}
	}
	if pWInfo.pExprMods != nil {
		whereUndoExprMods(pWInfo)
	}
	pParse.nQueryLoop = uint32(pWInfo.savedNQueryLoop)
	whereInfoFree(db, pWInfo)
	return
}
func row_numberStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *int64 = (*int64)(sqlite3_aggregate_context(pCtx, int32(8)))
	if p != nil {
		*p++
	}
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
}
func row_numberValueFunc(pCtx *struct_sqlite3_context) {
	var p *int64 = (*int64)(sqlite3_aggregate_context(pCtx, int32(8)))
	sqlite3_result_int64(pCtx, func() int64 {
		if p != nil {
			return *p
		} else {
			return int64(0)
		}
	}())
}

type struct_CallCount struct {
	nValue int64
	nStep  int64
	nTotal int64
}

func dense_rankStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_CallCount
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		p.nStep = int64(1)
	}
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
}
func dense_rankValueFunc(pCtx *struct_sqlite3_context) {
	var p *struct_CallCount
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		if p.nStep != 0 {
			p.nValue++
			p.nStep = int64(0)
		}
		sqlite3_result_int64(pCtx, p.nValue)
	}
}

type struct_NthValueCtx struct {
	nStep  int64
	pValue *struct_sqlite3_value
}

func nth_valueStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_NthValueCtx
	p = (*struct_NthValueCtx)(sqlite3_aggregate_context(pCtx, int32(16)))
	if p != nil {
		var iVal int64
		switch sqlite3_value_numeric_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(1)*8))) {
		case 1:
			iVal = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(1)*8)))
			break
		case 2:
			{
				var fVal float64 = sqlite3_value_double(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(1)*8)))
				if float64(int64(fVal)) != fVal {
					goto error_out
				}
				iVal = int64(fVal)
				break
			}
		default:
			goto error_out
		}
		if iVal <= int64(0) {
			goto error_out
		}
		p.nStep++
		if iVal == p.nStep {
			p.pValue = sqlite3_value_dup(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(0)*8)))
			if !(p.pValue != nil) {
				sqlite3_result_error_nomem(pCtx)
			}
		}
	}
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	return
error_out:
	sqlite3_result_error(pCtx, (*int8)(unsafe.Pointer(&[56]int8{'s', 'e', 'c', 'o', 'n', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 't', 'o', ' ', 'n', 't', 'h', '_', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'p', 'o', 's', 'i', 't', 'i', 'v', 'e', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), -1)
}
func nth_valueFinalizeFunc(pCtx *struct_sqlite3_context) {
	var p *struct_NthValueCtx
	p = (*struct_NthValueCtx)(sqlite3_aggregate_context(pCtx, 0))
	if p != nil && p.pValue != nil {
		sqlite3_result_value(pCtx, p.pValue)
		sqlite3_value_free(p.pValue)
		p.pValue = (*struct_sqlite3_value)(nil)
	}
}
func first_valueStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_NthValueCtx
	p = (*struct_NthValueCtx)(sqlite3_aggregate_context(pCtx, int32(16)))
	if p != nil && uintptr(unsafe.Pointer(p.pValue)) == uintptr(unsafe.Pointer(nil)) {
		p.pValue = sqlite3_value_dup(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(0)*8)))
		if !(p.pValue != nil) {
			sqlite3_result_error_nomem(pCtx)
		}
	}
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
}
func first_valueFinalizeFunc(pCtx *struct_sqlite3_context) {
	var p *struct_NthValueCtx
	p = (*struct_NthValueCtx)(sqlite3_aggregate_context(pCtx, int32(16)))
	if p != nil && p.pValue != nil {
		sqlite3_result_value(pCtx, p.pValue)
		sqlite3_value_free(p.pValue)
		p.pValue = (*struct_sqlite3_value)(nil)
	}
}
func rankStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_CallCount
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		p.nStep++
		if p.nValue == int64(0) {
			p.nValue = p.nStep
		}
	}
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
}
func rankValueFunc(pCtx *struct_sqlite3_context) {
	var p *struct_CallCount
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		sqlite3_result_int64(pCtx, p.nValue)
		p.nValue = int64(0)
	}
}
func percent_rankStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_CallCount
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		p.nTotal++
	}
}
func percent_rankInvFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_CallCount
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	p.nStep++
}
func percent_rankValueFunc(pCtx *struct_sqlite3_context) {
	var p *struct_CallCount
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		p.nValue = p.nStep
		if p.nTotal > int64(1) {
			var r float64 = float64(p.nValue) / float64(p.nTotal-int64(1))
			sqlite3_result_double(pCtx, r)
		} else {
			sqlite3_result_double(pCtx, 0)
		}
	}
}
func cume_distStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_CallCount
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		p.nTotal++
	}
}
func cume_distInvFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_CallCount
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, int32(24)))
	p.nStep++
}
func cume_distValueFunc(pCtx *struct_sqlite3_context) {
	var p *struct_CallCount
	p = (*struct_CallCount)(sqlite3_aggregate_context(pCtx, 0))
	if p != nil {
		var r float64 = float64(p.nStep) / float64(p.nTotal)
		sqlite3_result_double(pCtx, r)
	}
}

type struct_NtileCtx struct {
	nTotal int64
	nParam int64
	iRow   int64
}

func ntileStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_NtileCtx
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = nArg
		return 0
	}()
	p = (*struct_NtileCtx)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil {
		if p.nTotal == int64(0) {
			p.nParam = sqlite3_value_int64(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(0)*8)))
			if p.nParam <= int64(0) {
				sqlite3_result_error(pCtx, (*int8)(unsafe.Pointer(&[45]int8{'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 'o', 'f', ' ', 'n', 't', 'i', 'l', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'p', 'o', 's', 'i', 't', 'i', 'v', 'e', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), -1)
			}
		}
		p.nTotal++
	}
}
func ntileInvFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_NtileCtx
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	p = (*struct_NtileCtx)(sqlite3_aggregate_context(pCtx, int32(24)))
	p.iRow++
}
func ntileValueFunc(pCtx *struct_sqlite3_context) {
	var p *struct_NtileCtx
	p = (*struct_NtileCtx)(sqlite3_aggregate_context(pCtx, int32(24)))
	if p != nil && p.nParam > int64(0) {
		var nSize int32 = int32(p.nTotal / p.nParam)
		if nSize == 0 {
			sqlite3_result_int64(pCtx, p.iRow+int64(1))
		} else {
			var nLarge int64 = p.nTotal - p.nParam*int64(nSize)
			var iSmall int64 = nLarge * int64(nSize+1)
			var iRow int64 = p.iRow
			func() int {
				_ = 0
				return 0
			}()
			if iRow < iSmall {
				sqlite3_result_int64(pCtx, int64(1)+iRow/int64(nSize+1))
			} else {
				sqlite3_result_int64(pCtx, int64(1)+nLarge+(iRow-iSmall)/int64(nSize))
			}
		}
	}
}

type struct_LastValueCtx struct {
	pVal *struct_sqlite3_value
	nVal int32
}

func last_valueStepFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_LastValueCtx
	func() int {
		_ = nArg
		return 0
	}()
	p = (*struct_LastValueCtx)(sqlite3_aggregate_context(pCtx, int32(12)))
	if p != nil {
		sqlite3_value_free(p.pVal)
		p.pVal = sqlite3_value_dup(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(apArg)) + uintptr(0)*8)))
		if uintptr(unsafe.Pointer(p.pVal)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3_result_error_nomem(pCtx)
		} else {
			p.nVal++
		}
	}
}
func last_valueInvFunc(pCtx *struct_sqlite3_context, nArg int32, apArg **struct_sqlite3_value) {
	var p *struct_LastValueCtx
	func() int {
		_ = nArg
		return 0
	}()
	func() int {
		_ = apArg
		return 0
	}()
	p = (*struct_LastValueCtx)(sqlite3_aggregate_context(pCtx, int32(12)))
	if p != nil {
		p.nVal--
		if p.nVal == 0 {
			sqlite3_value_free(p.pVal)
			p.pVal = (*struct_sqlite3_value)(nil)
		}
	}
}
func last_valueValueFunc(pCtx *struct_sqlite3_context) {
	var p *struct_LastValueCtx
	p = (*struct_LastValueCtx)(sqlite3_aggregate_context(pCtx, 0))
	if p != nil && p.pVal != nil {
		sqlite3_result_value(pCtx, p.pVal)
	}
}
func last_valueFinalizeFunc(pCtx *struct_sqlite3_context) {
	var p *struct_LastValueCtx
	p = (*struct_LastValueCtx)(sqlite3_aggregate_context(pCtx, int32(12)))
	if p != nil && p.pVal != nil {
		sqlite3_result_value(pCtx, p.pVal)
		sqlite3_value_free(p.pVal)
		p.pVal = (*struct_sqlite3_value)(nil)
	}
}

var row_numberName [11]int8 = [11]int8{'r', 'o', 'w', '_', 'n', 'u', 'm', 'b', 'e', 'r', '\x00'}
var dense_rankName [11]int8 = [11]int8{'d', 'e', 'n', 's', 'e', '_', 'r', 'a', 'n', 'k', '\x00'}
var rankName [5]int8 = [5]int8{'r', 'a', 'n', 'k', '\x00'}
var percent_rankName [13]int8 = [13]int8{'p', 'e', 'r', 'c', 'e', 'n', 't', '_', 'r', 'a', 'n', 'k', '\x00'}
var cume_distName [10]int8 = [10]int8{'c', 'u', 'm', 'e', '_', 'd', 'i', 's', 't', '\x00'}
var ntileName [6]int8 = [6]int8{'n', 't', 'i', 'l', 'e', '\x00'}
var last_valueName [11]int8 = [11]int8{'l', 'a', 's', 't', '_', 'v', 'a', 'l', 'u', 'e', '\x00'}
var nth_valueName [10]int8 = [10]int8{'n', 't', 'h', '_', 'v', 'a', 'l', 'u', 'e', '\x00'}
var first_valueName [12]int8 = [12]int8{'f', 'i', 'r', 's', 't', '_', 'v', 'a', 'l', 'u', 'e', '\x00'}
var leadName [5]int8 = [5]int8{'l', 'e', 'a', 'd', '\x00'}
var lagName [4]int8 = [4]int8{'l', 'a', 'g', '\x00'}

func noopStepFunc(p *struct_sqlite3_context, n int32, a **struct_sqlite3_value) {
	func() int {
		_ = p
		return 0
	}()
	func() int {
		_ = n
		return 0
	}()
	func() int {
		_ = a
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
}
func noopValueFunc(p *struct_sqlite3_context) {
	func() int {
		_ = p
		return 0
	}()
}
func sqlite3WindowFunctions() {
	var aWindowFuncs [15]struct_FuncDef = [15]struct_FuncDef{struct_FuncDef{int8(0), uint32(8388608 | 1 | 65536 | 0), nil, nil, row_numberStepFunc, row_numberValueFunc, row_numberValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&row_numberName)), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 65536 | 0), nil, nil, dense_rankStepFunc, dense_rankValueFunc, dense_rankValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&dense_rankName)), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 65536 | 0), nil, nil, rankStepFunc, rankValueFunc, rankValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&rankName)), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 65536 | 0), nil, nil, percent_rankStepFunc, percent_rankValueFunc, percent_rankValueFunc, percent_rankInvFunc, (*int8)(unsafe.Pointer(&percent_rankName)), _cgoa_9{nil}}, struct_FuncDef{int8(0), uint32(8388608 | 1 | 65536 | 0), nil, nil, cume_distStepFunc, cume_distValueFunc, cume_distValueFunc, cume_distInvFunc, (*int8)(unsafe.Pointer(&cume_distName)), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 65536 | 0), nil, nil, ntileStepFunc, ntileValueFunc, ntileValueFunc, ntileInvFunc, (*int8)(unsafe.Pointer(&ntileName)), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 65536 | 0), nil, nil, last_valueStepFunc, last_valueFinalizeFunc, last_valueValueFunc, last_valueInvFunc, (*int8)(unsafe.Pointer(&last_valueName)), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 65536 | 0), nil, nil, nth_valueStepFunc, nth_valueFinalizeFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&nth_valueName)), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 65536 | 0), nil, nil, first_valueStepFunc, first_valueFinalizeFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&first_valueName)), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 65536 | 0), nil, nil, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&leadName)), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 65536 | 0), nil, nil, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&leadName)), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 1 | 65536 | 0), nil, nil, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&leadName)), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 65536 | 0), nil, nil, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&lagName)), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 65536 | 0), nil, nil, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&lagName)), _cgoa_9{nil}}, struct_FuncDef{int8(3), uint32(8388608 | 1 | 65536 | 0), nil, nil, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, (*int8)(unsafe.Pointer(&lagName)), _cgoa_9{nil}}}
	sqlite3InsertBuiltinFuncs((*struct_FuncDef)(unsafe.Pointer(&aWindowFuncs)), int32(1080/72))
}
func windowFind(pParse *struct_Parse, pList *struct_Window, zName *int8) *struct_Window {
	var p *struct_Window
	for p = pList; p != nil; p = p.pNextWin {
		if sqlite3StrICmp(p.zName, zName) == 0 {
			break
		}
	}
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[19]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ':', ' ', '%', 's', '\x00'})), zName)
	}
	return p
}
func sqlite3WindowUpdate(pParse *struct_Parse, pList *struct_Window, pWin *struct_Window, pFunc *struct_FuncDef) {
	if pWin.zName != nil && int32(pWin.eFrmType) == 0 {
		var p *struct_Window = windowFind(pParse, pList, pWin.zName)
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		pWin.pPartition = sqlite3ExprListDup(pParse.db, p.pPartition, 0)
		pWin.pOrderBy = sqlite3ExprListDup(pParse.db, p.pOrderBy, 0)
		pWin.pStart = sqlite3ExprDup(pParse.db, p.pStart, 0)
		pWin.pEnd = sqlite3ExprDup(pParse.db, p.pEnd, 0)
		pWin.eStart = p.eStart
		pWin.eEnd = p.eEnd
		pWin.eFrmType = p.eFrmType
		pWin.eExclude = p.eExclude
	} else {
		sqlite3WindowChain(pParse, pWin, pList)
	}
	if int32(pWin.eFrmType) == 89 && (pWin.pStart != nil || pWin.pEnd != nil) && (uintptr(unsafe.Pointer(pWin.pOrderBy)) == uintptr(unsafe.Pointer(nil)) || pWin.pOrderBy.nExpr != 1) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[71]int8{'R', 'A', 'N', 'G', 'E', ' ', 'w', 'i', 't', 'h', ' ', 'o', 'f', 'f', 's', 'e', 't', ' ', 'P', 'R', 'E', 'C', 'E', 'D', 'I', 'N', 'G', '/', 'F', 'O', 'L', 'L', 'O', 'W', 'I', 'N', 'G', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'o', 'n', 'e', ' ', 'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', ' ', 'e', 'x', 'p', 'r', 'e', 's', 's', 'i', 'o', 'n', '\x00'})))
	} else if pFunc.funcFlags&uint32(65536) != 0 {
		var db *struct_sqlite3 = pParse.db
		if pWin.pFilter != nil {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[63]int8{'F', 'I', 'L', 'T', 'E', 'R', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'm', 'a', 'y', ' ', 'o', 'n', 'l', 'y', ' ', 'b', 'e', ' ', 'u', 's', 'e', 'd', ' ', 'w', 'i', 't', 'h', ' ', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', 's', '\x00'})))
		} else {
			type struct_WindowUpdate struct {
				zFunc    *int8
				eFrmType int32
				eStart   int32
				eEnd     int32
			}
			var aUp [8]struct_WindowUpdate = [8]struct_WindowUpdate{struct_WindowUpdate{(*int8)(unsafe.Pointer(&row_numberName)), 76, 90, 85}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&dense_rankName)), 89, 90, 85}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&rankName)), 89, 90, 85}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&percent_rankName)), 92, 85, 90}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&cume_distName)), 92, 86, 90}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&ntileName)), 76, 85, 90}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&leadName)), 76, 90, 90}, struct_WindowUpdate{(*int8)(unsafe.Pointer(&lagName)), 76, 90, 85}}
			var i int32
			for i = int32(0); i < int32(188/20); i++ {
				if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*(*struct_WindowUpdate)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WindowUpdate)(unsafe.Pointer(&aUp)))) + uintptr(i)*20))).zFunc)) {
					sqlite3ExprDelete(db, pWin.pStart)
					sqlite3ExprDelete(db, pWin.pEnd)
					pWin.pEnd = func() (_cgo_ret *struct_Expr) {
						_cgo_addr := &pWin.pStart
						*_cgo_addr = (*struct_Expr)(nil)
						return *_cgo_addr
					}()
					pWin.eFrmType = uint8((*(*struct_WindowUpdate)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WindowUpdate)(unsafe.Pointer(&aUp)))) + uintptr(i)*20))).eFrmType)
					pWin.eStart = uint8((*(*struct_WindowUpdate)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WindowUpdate)(unsafe.Pointer(&aUp)))) + uintptr(i)*20))).eStart)
					pWin.eEnd = uint8((*(*struct_WindowUpdate)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_WindowUpdate)(unsafe.Pointer(&aUp)))) + uintptr(i)*20))).eEnd)
					pWin.eExclude = uint8(0)
					if int32(pWin.eStart) == 86 {
						pWin.pStart = sqlite3Expr(db, 155, (*int8)(unsafe.Pointer(&[2]int8{'1', '\x00'})))
					}
					break
				}
			}
		}
	}
	pWin.pFunc = pFunc
}

type WindowRewrite = struct_WindowRewrite
type struct_WindowRewrite struct {
	pWin       *struct_Window
	pSrc       *struct_SrcList
	pSub       *struct_ExprList
	pTab       *struct_Table
	pSubSelect *struct_Select
}

func selectWindowRewriteExprCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	var p *struct_WindowRewrite = *(**struct_WindowRewrite)(unsafe.Pointer(&pWalker.u))
	var pParse *struct_Parse = pWalker.pParse
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if p.pSubSelect != nil {
		if int32(pExpr.op) != 167 {
			return int32(0)
		} else {
			var nSrc int32 = p.pSrc.nSrc
			var i int32
			for i = int32(0); i < nSrc; i++ {
				if pExpr.iTable == (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(i)*112))).iCursor {
					break
				}
			}
			if i == nSrc {
				return int32(0)
			}
		}
	}
	switch int32(pExpr.op) {
	case 172:
		if !(pExpr.flags&uint32(16777216) != uint32(0)) {
			break
		} else {
			var pWin *struct_Window
			for pWin = p.pWin; pWin != nil; pWin = pWin.pNextWin {
				if uintptr(unsafe.Pointer(*(**struct_Window)(unsafe.Pointer(&pExpr.y)))) == uintptr(unsafe.Pointer(pWin)) {
					func() int {
						_ = 0
						return 0
					}()
					return int32(1)
				}
			}
		}
	case 168:
		fallthrough
	case 167:
		{
			var iCol int32 = -1
			if pParse.db.mallocFailed != 0 {
				return int32(2)
			}
			if p.pSub != nil {
				var i int32
				for i = int32(0); i < p.pSub.nExpr; i++ {
					if 0 == sqlite3ExprCompare(nil, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&p.pSub.a)))) + uintptr(i)*28))).pExpr, pExpr, -1) {
						iCol = i
						break
					}
				}
			}
			if iCol < 0 {
				var pDup *struct_Expr = sqlite3ExprDup(pParse.db, pExpr, 0)
				if pDup != nil && int32(pDup.op) == 168 {
					pDup.op = uint8(172)
				}
				p.pSub = sqlite3ExprListAppend(pParse, p.pSub, pDup)
			}
			if p.pSub != nil {
				var f int32 = int32(pExpr.flags & uint32(256))
				func() int {
					_ = 0
					return 0
				}()
				pExpr.flags |= uint32(134217728)
				sqlite3ExprDelete(pParse.db, pExpr)
				pExpr.flags &= uint32(4160749567)
				__builtin___memset_chk(unsafe.Pointer(pExpr), 0, 72, __builtin_object_size(unsafe.Pointer(pExpr), 0))
				pExpr.op = uint8(167)
				pExpr.iColumn = int16(func() int32 {
					if iCol < 0 {
						return p.pSub.nExpr - 1
					} else {
						return iCol
					}
				}())
				pExpr.iTable = p.pWin.iEphCsr
				pExpr.y.pTab = p.pTab
				pExpr.flags = uint32(f)
			}
			if pParse.db.mallocFailed != 0 {
				return int32(2)
			}
			break
		}
	default:
		break
	}
	return int32(0)
}
func selectWindowRewriteSelectCb(pWalker *struct_Walker, pSelect *struct_Select) int32 {
	var p *struct_WindowRewrite = *(**struct_WindowRewrite)(unsafe.Pointer(&pWalker.u))
	var pSave *struct_Select = p.pSubSelect
	if uintptr(unsafe.Pointer(pSave)) == uintptr(unsafe.Pointer(pSelect)) {
		return int32(0)
	} else {
		p.pSubSelect = pSelect
		sqlite3WalkSelect(pWalker, pSelect)
		p.pSubSelect = pSave
	}
	return int32(1)
}
func selectWindowRewriteEList(pParse *struct_Parse, pWin *struct_Window, pSrc *struct_SrcList, pEList *struct_ExprList, pTab *struct_Table, ppSub **struct_ExprList) {
	var sWalker struct_Walker
	var sRewrite struct_WindowRewrite
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memset_chk(unsafe.Pointer(&sWalker), 0, 48, __builtin_object_size(unsafe.Pointer(&sWalker), 0))
	__builtin___memset_chk(unsafe.Pointer(&sRewrite), 0, 40, __builtin_object_size(unsafe.Pointer(&sRewrite), 0))
	sRewrite.pSub = *ppSub
	sRewrite.pWin = pWin
	sRewrite.pSrc = pSrc
	sRewrite.pTab = pTab
	sWalker.pParse = pParse
	sWalker.xExprCallback = selectWindowRewriteExprCb
	sWalker.xSelectCallback = selectWindowRewriteSelectCb
	*(**struct_WindowRewrite)(unsafe.Pointer(&sWalker.u)) = &sRewrite
	func() int {
		_ = sqlite3WalkExprList(&sWalker, pEList)
		return 0
	}()
	*ppSub = sRewrite.pSub
}
func exprListAppendList(pParse *struct_Parse, pList *struct_ExprList, pAppend *struct_ExprList, bIntToNull int32) *struct_ExprList {
	if pAppend != nil {
		var i int32
		var nInit int32 = func() int32 {
			if pList != nil {
				return pList.nExpr
			} else {
				return 0
			}
		}()
		for i = int32(0); i < pAppend.nExpr; i++ {
			var db *struct_sqlite3 = pParse.db
			var pDup *struct_Expr = sqlite3ExprDup(db, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pAppend.a)))) + uintptr(i)*28))).pExpr, 0)
			func() int {
				_ = 0
				return 0
			}()
			if db.mallocFailed != 0 {
				sqlite3ExprDelete(db, pDup)
				break
			}
			if bIntToNull != 0 {
				var iDummy int32
				var pSub *struct_Expr
				pSub = sqlite3ExprSkipCollateAndLikely(pDup)
				if sqlite3ExprIsInteger(pSub, &iDummy) != 0 {
					pSub.op = uint8(121)
					pSub.flags &= uint32(3489659903)
					pSub.u.zToken = (*int8)(nil)
				}
			}
			pList = sqlite3ExprListAppend(pParse, pList, pDup)
			if pList != nil {
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(nInit+i)*28))).sortFlags = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pAppend.a)))) + uintptr(i)*28))).sortFlags
			}
		}
	}
	return pList
}
func sqlite3WindowExtraAggFuncDepth(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 168 && int32(pExpr.op2) >= pWalker.walkerDepth {
		pExpr.op2++
	}
	return int32(0)
}
func disallowAggregatesInOrderByCb(pWalker *struct_Walker, pExpr *struct_Expr) int32 {
	if int32(pExpr.op) == 168 && uintptr(unsafe.Pointer(pExpr.pAggInfo)) == uintptr(unsafe.Pointer(nil)) {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3ErrorMsg(pWalker.pParse, (*int8)(unsafe.Pointer(&[26]int8{'m', 'i', 's', 'u', 's', 'e', ' ', 'o', 'f', ' ', 'a', 'g', 'g', 'r', 'e', 'g', 'a', 't', 'e', ':', ' ', '%', 's', '(', ')', '\x00'})), pExpr.u.zToken)
	}
	return int32(0)
}
func sqlite3WindowRewrite(pParse *struct_Parse, p *struct_Select) int32 {
	var rc int32 = 0
	if p.pWin != nil && uintptr(unsafe.Pointer(p.pPrior)) == uintptr(unsafe.Pointer(nil)) && p.selFlags&uint32(1048576) == uint32(0) && !(int32(pParse.eParseMode) >= 2) {
		var v *struct_Vdbe = sqlite3GetVdbe(pParse)
		var db *struct_sqlite3 = pParse.db
		var pSub *struct_Select = nil
		var pSrc *struct_SrcList = p.pSrc
		var pWhere *struct_Expr = p.pWhere
		var pGroupBy *struct_ExprList = p.pGroupBy
		var pHaving *struct_Expr = p.pHaving
		var pSort *struct_ExprList = nil
		var pSublist *struct_ExprList = nil
		var pMWin *struct_Window = p.pWin
		var pWin *struct_Window
		var pTab *struct_Table
		var w struct_Walker
		var selFlags uint32 = p.selFlags
		pTab = (*struct_Table)(sqlite3DbMallocZero(db, uint64(104)))
		if uintptr(unsafe.Pointer(pTab)) == uintptr(unsafe.Pointer(nil)) {
			return sqlite3ErrorToParser(db, 7)
		}
		sqlite3AggInfoPersistWalkerInit(&w, pParse)
		sqlite3WalkSelect(&w, p)
		if p.selFlags&uint32(8) == uint32(0) {
			w.xExprCallback = disallowAggregatesInOrderByCb
			w.xSelectCallback = (func(*struct_Walker, *struct_Select) int32)(nil)
			sqlite3WalkExprList(&w, p.pOrderBy)
		}
		p.pSrc = (*struct_SrcList)(nil)
		p.pWhere = (*struct_Expr)(nil)
		p.pGroupBy = (*struct_ExprList)(nil)
		p.pHaving = (*struct_Expr)(nil)
		p.selFlags &= uint32(4294967287)
		p.selFlags |= uint32(1048576)
		pSort = exprListAppendList(pParse, nil, pMWin.pPartition, 1)
		pSort = exprListAppendList(pParse, pSort, pMWin.pOrderBy, 1)
		if pSort != nil && p.pOrderBy != nil && p.pOrderBy.nExpr <= pSort.nExpr {
			var nSave int32 = pSort.nExpr
			pSort.nExpr = p.pOrderBy.nExpr
			if sqlite3ExprListCompare(pSort, p.pOrderBy, -1) == 0 {
				sqlite3ExprListDelete(db, p.pOrderBy)
				p.pOrderBy = (*struct_ExprList)(nil)
			}
			pSort.nExpr = nSave
		}
		pMWin.iEphCsr = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		pParse.nTab += int32(3)
		selectWindowRewriteEList(pParse, pMWin, pSrc, p.pEList, pTab, &pSublist)
		selectWindowRewriteEList(pParse, pMWin, pSrc, p.pOrderBy, pTab, &pSublist)
		pMWin.nBufferCol = func() int32 {
			if pSublist != nil {
				return pSublist.nExpr
			} else {
				return 0
			}
		}()
		pSublist = exprListAppendList(pParse, pSublist, pMWin.pPartition, 0)
		pSublist = exprListAppendList(pParse, pSublist, pMWin.pOrderBy, 0)
		for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
			var pArgs *struct_ExprList
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			pArgs = pWin.pOwner.x.pList
			if pWin.pFunc.funcFlags&uint32(1048576) != 0 {
				selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist)
				pWin.iArgCol = func() int32 {
					if pSublist != nil {
						return pSublist.nExpr
					} else {
						return 0
					}
				}()
				pWin.bExprArgs = uint8(1)
			} else {
				pWin.iArgCol = func() int32 {
					if pSublist != nil {
						return pSublist.nExpr
					} else {
						return 0
					}
				}()
				pSublist = exprListAppendList(pParse, pSublist, pArgs, 0)
			}
			if pWin.pFilter != nil {
				var pFilter *struct_Expr = sqlite3ExprDup(db, pWin.pFilter, 0)
				pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter)
			}
			pWin.regAccum = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			pWin.regResult = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nMem
				*_cgo_addr++
				return *_cgo_addr
			}()
			sqlite3VdbeAddOp2(v, 74, 0, pWin.regAccum)
		}
		if uintptr(unsafe.Pointer(pSublist)) == uintptr(unsafe.Pointer(nil)) {
			pSublist = sqlite3ExprListAppend(pParse, nil, sqlite3Expr(db, 155, (*int8)(unsafe.Pointer(&[2]int8{'0', '\x00'}))))
		}
		pSub = sqlite3SelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, uint32(0), nil)
		p.pSrc = sqlite3SrcListAppend(pParse, nil, nil, nil)
		func() int {
			_ = 0
			return 0
		}()
		if p.pSrc != nil {
			var pTab2 *struct_Table
			(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pSelect = pSub
			sqlite3SrcListAssignCursors(pParse, p.pSrc)
			pSub.selFlags |= uint32(64 | 134217728)
			pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, int8(64))
			pSub.selFlags |= selFlags & uint32(8)
			if uintptr(unsafe.Pointer(pTab2)) == uintptr(unsafe.Pointer(nil)) {
				rc = int32(7)
			} else {
				__builtin___memcpy_chk(unsafe.Pointer(pTab), unsafe.Pointer(pTab2), 104, __builtin_object_size(unsafe.Pointer(pTab), 0))
				pTab.tabFlags |= uint32(16384)
				(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pTab = pTab
				pTab = pTab2
				__builtin___memset_chk(unsafe.Pointer(&w), 0, 48, __builtin_object_size(unsafe.Pointer(&w), 0))
				w.xExprCallback = sqlite3WindowExtraAggFuncDepth
				w.xSelectCallback = sqlite3WalkerDepthIncrease
				w.xSelectCallback2 = sqlite3WalkerDepthDecrease
				sqlite3WalkSelect(&w, pSub)
			}
		} else {
			sqlite3SelectDelete(db, pSub)
		}
		if db.mallocFailed != 0 {
			rc = int32(7)
		}
		sqlite3ParserAddCleanup(pParse, sqlite3DbFree, unsafe.Pointer(pTab))
	}
	func() int {
		_ = 0
		return 0
	}()
	return rc
}
func sqlite3WindowUnlinkFromSelect(p *struct_Window) {
	if p.ppThis != nil {
		*p.ppThis = p.pNextWin
		if p.pNextWin != nil {
			p.pNextWin.ppThis = p.ppThis
		}
		p.ppThis = (**struct_Window)(nil)
	}
}
func sqlite3WindowDelete(db *struct_sqlite3, p *struct_Window) {
	if p != nil {
		sqlite3WindowUnlinkFromSelect(p)
		sqlite3ExprDelete(db, p.pFilter)
		sqlite3ExprListDelete(db, p.pPartition)
		sqlite3ExprListDelete(db, p.pOrderBy)
		sqlite3ExprDelete(db, p.pEnd)
		sqlite3ExprDelete(db, p.pStart)
		sqlite3DbFree(db, unsafe.Pointer(p.zName))
		sqlite3DbFree(db, unsafe.Pointer(p.zBase))
		sqlite3DbFree(db, unsafe.Pointer(p))
	}
}
func sqlite3WindowListDelete(db *struct_sqlite3, p *struct_Window) {
	for p != nil {
		var pNext *struct_Window = p.pNextWin
		sqlite3WindowDelete(db, p)
		p = pNext
	}
}
func sqlite3WindowOffsetExpr(pParse *struct_Parse, pExpr *struct_Expr) *struct_Expr {
	if 0 == sqlite3ExprIsConstant(pExpr) {
		if int32(pParse.eParseMode) >= 2 {
			sqlite3RenameExprUnmap(pParse, pExpr)
		}
		sqlite3ExprDelete(pParse.db, pExpr)
		pExpr = sqlite3ExprAlloc(pParse.db, 121, nil, 0)
	}
	return pExpr
}
func sqlite3WindowAlloc(pParse *struct_Parse, eType int32, eStart int32, pStart *struct_Expr, eEnd int32, pEnd *struct_Expr, eExclude uint8) *struct_Window {
	var pWin *struct_Window = nil
	var bImplicitFrame int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if eType == 0 {
		bImplicitFrame = int32(1)
		eType = int32(89)
	}
	if eStart == 85 && eEnd == 88 || eStart == 86 && (eEnd == 88 || eEnd == 85) {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[32]int8{'u', 'n', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'r', 'a', 'm', 'e', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', '\x00'})))
		goto windowAllocErr
	}
	pWin = (*struct_Window)(sqlite3DbMallocZero(pParse.db, uint64(141)))
	if uintptr(unsafe.Pointer(pWin)) == uintptr(unsafe.Pointer(nil)) {
		goto windowAllocErr
	}
	pWin.eFrmType = uint8(eType)
	pWin.eStart = uint8(eStart)
	pWin.eEnd = uint8(eEnd)
	if int32(eExclude) == 0 && pParse.db.dbOptFlags&uint32(2) != uint32(0) {
		eExclude = uint8(66)
	}
	pWin.eExclude = eExclude
	pWin.bImplicitFrame = uint8(bImplicitFrame)
	pWin.pEnd = sqlite3WindowOffsetExpr(pParse, pEnd)
	pWin.pStart = sqlite3WindowOffsetExpr(pParse, pStart)
	return pWin
windowAllocErr:
	sqlite3ExprDelete(pParse.db, pEnd)
	sqlite3ExprDelete(pParse.db, pStart)
	return (*struct_Window)(nil)
}
func sqlite3WindowAssemble(pParse *struct_Parse, pWin *struct_Window, pPartition *struct_ExprList, pOrderBy *struct_ExprList, pBase *struct_Token) *struct_Window {
	if pWin != nil {
		pWin.pPartition = pPartition
		pWin.pOrderBy = pOrderBy
		if pBase != nil {
			pWin.zBase = sqlite3DbStrNDup(pParse.db, pBase.z, uint64(pBase.n))
		}
	} else {
		sqlite3ExprListDelete(pParse.db, pPartition)
		sqlite3ExprListDelete(pParse.db, pOrderBy)
	}
	return pWin
}
func sqlite3WindowChain(pParse *struct_Parse, pWin *struct_Window, pList *struct_Window) {
	if pWin.zBase != nil {
		var db *struct_sqlite3 = pParse.db
		var pExist *struct_Window = windowFind(pParse, pList, pWin.zBase)
		if pExist != nil {
			var zErr *int8 = nil
			if pWin.pPartition != nil {
				zErr = (*int8)(unsafe.Pointer(&[17]int8{'P', 'A', 'R', 'T', 'I', 'T', 'I', 'O', 'N', ' ', 'c', 'l', 'a', 'u', 's', 'e', '\x00'}))
			} else if pExist.pOrderBy != nil && pWin.pOrderBy != nil {
				zErr = (*int8)(unsafe.Pointer(&[16]int8{'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', ' ', 'c', 'l', 'a', 'u', 's', 'e', '\x00'}))
			} else if int32(pExist.bImplicitFrame) == 0 {
				zErr = (*int8)(unsafe.Pointer(&[20]int8{'f', 'r', 'a', 'm', 'e', ' ', 's', 'p', 'e', 'c', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', '\x00'}))
			}
			if zErr != nil {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[33]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'v', 'e', 'r', 'r', 'i', 'd', 'e', ' ', '%', 's', ' ', 'o', 'f', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ':', ' ', '%', 's', '\x00'})), zErr, pWin.zBase)
			} else {
				pWin.pPartition = sqlite3ExprListDup(db, pExist.pPartition, 0)
				if pExist.pOrderBy != nil {
					func() int {
						_ = 0
						return 0
					}()
					pWin.pOrderBy = sqlite3ExprListDup(db, pExist.pOrderBy, 0)
				}
				sqlite3DbFree(db, unsafe.Pointer(pWin.zBase))
				pWin.zBase = (*int8)(nil)
			}
		}
	}
}
func sqlite3WindowAttach(pParse *struct_Parse, p *struct_Expr, pWin *struct_Window) {
	if p != nil {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		*(**struct_Window)(unsafe.Pointer(&p.y)) = pWin
		p.flags |= uint32(16777216)
		pWin.pOwner = p
		if p.flags&uint32(2) != 0 && int32(pWin.eFrmType) != 166 {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[47]int8{'D', 'I', 'S', 'T', 'I', 'N', 'C', 'T', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 's', 'u', 'p', 'p', 'o', 'r', 't', 'e', 'd', ' ', 'f', 'o', 'r', ' ', 'w', 'i', 'n', 'd', 'o', 'w', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', 's', '\x00'})))
		}
	} else {
		sqlite3WindowDelete(pParse.db, pWin)
	}
}
func sqlite3WindowLink(pSel *struct_Select, pWin *struct_Window) {
	if pSel != nil {
		if nil == pSel.pWin || 0 == sqlite3WindowCompare(nil, pSel.pWin, pWin, 0) {
			pWin.pNextWin = pSel.pWin
			if pSel.pWin != nil {
				pSel.pWin.ppThis = &pWin.pNextWin
			}
			pSel.pWin = pWin
			pWin.ppThis = &pSel.pWin
		} else if sqlite3ExprListCompare(pWin.pPartition, pSel.pWin.pPartition, -1) != 0 {
			pSel.selFlags |= uint32(33554432)
		}
	}
}
func sqlite3WindowCompare(pParse *struct_Parse, p1 *struct_Window, p2 *struct_Window, bFilter int32) int32 {
	var res int32
	if uintptr(unsafe.Pointer(p1)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(p2)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	if int32(p1.eFrmType) != int32(p2.eFrmType) {
		return int32(1)
	}
	if int32(p1.eStart) != int32(p2.eStart) {
		return int32(1)
	}
	if int32(p1.eEnd) != int32(p2.eEnd) {
		return int32(1)
	}
	if int32(p1.eExclude) != int32(p2.eExclude) {
		return int32(1)
	}
	if sqlite3ExprCompare(pParse, p1.pStart, p2.pStart, -1) != 0 {
		return int32(1)
	}
	if sqlite3ExprCompare(pParse, p1.pEnd, p2.pEnd, -1) != 0 {
		return int32(1)
	}
	if func() (_cgo_ret int32) {
		_cgo_addr := &res
		*_cgo_addr = sqlite3ExprListCompare(p1.pPartition, p2.pPartition, -1)
		return *_cgo_addr
	}() != 0 {
		return res
	}
	if func() (_cgo_ret int32) {
		_cgo_addr := &res
		*_cgo_addr = sqlite3ExprListCompare(p1.pOrderBy, p2.pOrderBy, -1)
		return *_cgo_addr
	}() != 0 {
		return res
	}
	if bFilter != 0 {
		if func() (_cgo_ret int32) {
			_cgo_addr := &res
			*_cgo_addr = sqlite3ExprCompare(pParse, p1.pFilter, p2.pFilter, -1)
			return *_cgo_addr
		}() != 0 {
			return res
		}
	}
	return int32(0)
}
func sqlite3WindowCodeInit(pParse *struct_Parse, pSelect *struct_Select) {
	var nEphExpr int32 = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&pSelect.pSrc.a)))) + uintptr(0)*112))).pSelect.pEList.nExpr
	var pMWin *struct_Window = pSelect.pWin
	var pWin *struct_Window
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	sqlite3VdbeAddOp2(v, 116, pMWin.iEphCsr, nEphExpr)
	sqlite3VdbeAddOp2(v, 113, pMWin.iEphCsr+1, pMWin.iEphCsr)
	sqlite3VdbeAddOp2(v, 113, pMWin.iEphCsr+2, pMWin.iEphCsr)
	sqlite3VdbeAddOp2(v, 113, pMWin.iEphCsr+3, pMWin.iEphCsr)
	if pMWin.pPartition != nil {
		var nExpr int32 = pMWin.pPartition.nExpr
		pMWin.regPart = pParse.nMem + 1
		pParse.nMem += nExpr
		sqlite3VdbeAddOp3(v, 74, 0, pMWin.regPart, pMWin.regPart+nExpr-1)
	}
	pMWin.regOne = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	sqlite3VdbeAddOp2(v, 71, 1, pMWin.regOne)
	if pMWin.eExclude != 0 {
		pMWin.regStartRowid = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		pMWin.regEndRowid = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		pMWin.csrApp = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nTab
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()
		sqlite3VdbeAddOp2(v, 71, 1, pMWin.regStartRowid)
		sqlite3VdbeAddOp2(v, 71, 0, pMWin.regEndRowid)
		sqlite3VdbeAddOp2(v, 113, pMWin.csrApp, pMWin.iEphCsr)
		return
	}
	for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
		var p *struct_FuncDef = pWin.pFunc
		if p.funcFlags&uint32(4096) != 0 && int32(pWin.eStart) != 90 {
			var pList *struct_ExprList
			var pKeyInfo *struct_KeyInfo
			func() int {
				_ = 0
				return 0
			}()
			pList = pWin.pOwner.x.pList
			pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0)
			pWin.csrApp = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			pWin.regApp = pParse.nMem + 1
			pParse.nMem += int32(3)
			if pKeyInfo != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pWin.pFunc.zName)) + uintptr(1)))) == 'i' {
				func() int {
					_ = 0
					return 0
				}()
				*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pKeyInfo.aSortFlags)) + uintptr(0))) = uint8(1)
			}
			sqlite3VdbeAddOp2(v, 116, pWin.csrApp, 2)
			sqlite3VdbeAppendP4(v, unsafe.Pointer(pKeyInfo), -9)
			sqlite3VdbeAddOp2(v, 71, 0, pWin.regApp+1)
		} else if uintptr(unsafe.Pointer(p.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&nth_valueName)))) || uintptr(unsafe.Pointer(p.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&first_valueName)))) {
			pWin.regApp = pParse.nMem + 1
			pWin.csrApp = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			pParse.nMem += int32(2)
			sqlite3VdbeAddOp2(v, 113, pWin.csrApp, pMWin.iEphCsr)
		} else if uintptr(unsafe.Pointer(p.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&leadName)))) || uintptr(unsafe.Pointer(p.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&lagName)))) {
			pWin.csrApp = func() (_cgo_ret int32) {
				_cgo_addr := &pParse.nTab
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()
			sqlite3VdbeAddOp2(v, 113, pWin.csrApp, pMWin.iEphCsr)
		}
	}
}
func windowCheckValue(pParse *struct_Parse, reg int32, eCond int32) {
	var azErr [5]*int8 = [5]*int8{(*int8)(unsafe.Pointer(&[53]int8{'f', 'r', 'a', 'm', 'e', ' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 'o', 'f', 'f', 's', 'e', 't', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'n', 'o', 'n', '-', 'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[51]int8{'f', 'r', 'a', 'm', 'e', ' ', 'e', 'n', 'd', 'i', 'n', 'g', ' ', 'o', 'f', 'f', 's', 'e', 't', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'n', 'o', 'n', '-', 'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[56]int8{'s', 'e', 'c', 'o', 'n', 'd', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', ' ', 't', 'o', ' ', 'n', 't', 'h', '_', 'v', 'a', 'l', 'u', 'e', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'p', 'o', 's', 'i', 't', 'i', 'v', 'e', ' ', 'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[52]int8{'f', 'r', 'a', 'm', 'e', ' ', 's', 't', 'a', 'r', 't', 'i', 'n', 'g', ' ', 'o', 'f', 'f', 's', 'e', 't', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'n', 'o', 'n', '-', 'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[50]int8{'f', 'r', 'a', 'm', 'e', ' ', 'e', 'n', 'd', 'i', 'n', 'g', ' ', 'o', 'f', 'f', 's', 'e', 't', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'a', ' ', 'n', 'o', 'n', '-', 'n', 'e', 'g', 'a', 't', 'i', 'v', 'e', ' ', 'n', 'u', 'm', 'b', 'e', 'r', '\x00'}))}
	var aOp [5]int32 = [5]int32{57, 57, 54, 57, 57}
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var regZero int32 = sqlite3GetTempReg(pParse)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3VdbeAddOp2(v, 71, 0, regZero)
	if eCond >= 3 {
		var regString int32 = sqlite3GetTempReg(pParse)
		sqlite3VdbeAddOp4(v, 117, 0, regString, 0, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), -1)
		sqlite3VdbeAddOp3(v, 57, regString, sqlite3VdbeCurrentAddr(v)+2, reg)
		sqlite3VdbeChangeP5(v, uint16(67|16))
		func() int {
			_ = 0
			return 0
		}()
	} else {
		sqlite3VdbeAddOp2(v, 15, reg, sqlite3VdbeCurrentAddr(v)+2)
		func() int {
			_ = 0
			return 0
		}()
	}
	sqlite3VdbeAddOp3(v, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aOp)))) + uintptr(eCond)*4)), regZero, sqlite3VdbeCurrentAddr(v)+2, reg)
	sqlite3VdbeChangeP5(v, uint16(67))
	sqlite3MayAbort(pParse)
	sqlite3VdbeAddOp2(v, 70, 1, 2)
	sqlite3VdbeAppendP4(v, unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&azErr)))) + uintptr(eCond)*8))), -1)
	sqlite3ReleaseTempReg(pParse, regZero)
}
func windowArgCount(pWin *struct_Window) int32 {
	var pList *struct_ExprList
	func() int {
		_ = 0
		return 0
	}()
	pList = pWin.pOwner.x.pList
	return func() int32 {
		if pList != nil {
			return pList.nExpr
		} else {
			return 0
		}
	}()
}

type WindowCodeArg = struct_WindowCodeArg
type WindowCsrAndReg = struct_WindowCsrAndReg
type struct_WindowCsrAndReg struct {
	csr int32
	reg int32
}
type struct_WindowCodeArg struct {
	pParse    *struct_Parse
	pMWin     *struct_Window
	pVdbe     *struct_Vdbe
	addrGosub int32
	regGosub  int32
	regArg    int32
	eDelete   int32
	regRowid  int32
	start     struct_WindowCsrAndReg
	current   struct_WindowCsrAndReg
	end       struct_WindowCsrAndReg
}

func windowReadPeerValues(p *struct_WindowCodeArg, csr int32, reg int32) {
	var pMWin *struct_Window = p.pMWin
	var pOrderBy *struct_ExprList = pMWin.pOrderBy
	if pOrderBy != nil {
		var v *struct_Vdbe = sqlite3GetVdbe(p.pParse)
		var pPart *struct_ExprList = pMWin.pPartition
		var iColOff int32 = pMWin.nBufferCol + func() int32 {
			if pPart != nil {
				return pPart.nExpr
			} else {
				return 0
			}
		}()
		var i int32
		for i = int32(0); i < pOrderBy.nExpr; i++ {
			sqlite3VdbeAddOp3(v, 93, csr, iColOff+i, reg+i)
		}
	}
}
func windowAggStep(p *struct_WindowCodeArg, pMWin *struct_Window, csr int32, bInverse int32, reg int32) {
	var pParse *struct_Parse = p.pParse
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var pWin *struct_Window
	for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
		var pFunc *struct_FuncDef = pWin.pFunc
		var regArg int32
		var nArg int32 = func() int32 {
			if int32(pWin.bExprArgs) != 0 {
				return 0
			} else {
				return windowArgCount(pWin)
			}
		}()
		var i int32
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		for i = int32(0); i < nArg; i++ {
			if i != 1 || uintptr(unsafe.Pointer(pFunc.zName)) != uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&nth_valueName)))) {
				sqlite3VdbeAddOp3(v, 93, csr, pWin.iArgCol+i, reg+i)
			} else {
				sqlite3VdbeAddOp3(v, 93, pMWin.iEphCsr, pWin.iArgCol+i, reg+i)
			}
		}
		regArg = reg
		if pMWin.regStartRowid == 0 && pFunc.funcFlags&uint32(4096) != 0 && int32(pWin.eStart) != 90 {
			var addrIsNull int32 = sqlite3VdbeAddOp1(v, 50, regArg)
			if bInverse == 0 {
				sqlite3VdbeAddOp2(v, 85, pWin.regApp+1, 1)
				sqlite3VdbeAddOp2(v, 80, regArg, pWin.regApp)
				sqlite3VdbeAddOp3(v, 96, pWin.regApp, 2, pWin.regApp+2)
				sqlite3VdbeAddOp2(v, 137, pWin.csrApp, pWin.regApp+2)
			} else {
				sqlite3VdbeAddOp4Int(v, 25, pWin.csrApp, 0, regArg, 1)
				sqlite3VdbeAddOp1(v, 129, pWin.csrApp)
				sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2)
			}
			sqlite3VdbeJumpHere(v, addrIsNull)
		} else if pWin.regApp != 0 {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 85, pWin.regApp+1-bInverse, 1)
		} else if uintptr(unsafe.Pointer(pFunc.xSFunc)) != uintptr(unsafe.Pointer(noopStepFunc)) {
			var addrIf int32 = 0
			if pWin.pFilter != nil {
				var regTmp int32
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				regTmp = sqlite3GetTempReg(pParse)
				sqlite3VdbeAddOp3(v, 93, csr, pWin.iArgCol+nArg, regTmp)
				addrIf = sqlite3VdbeAddOp3(v, 20, regTmp, 0, 1)
				sqlite3ReleaseTempReg(pParse, regTmp)
			}
			if pWin.bExprArgs != 0 {
				var iOp int32 = sqlite3VdbeCurrentAddr(v)
				var iEnd int32
				func() int {
					_ = 0
					return 0
				}()
				nArg = pWin.pOwner.x.pList.nExpr
				regArg = sqlite3GetTempRange(pParse, nArg)
				sqlite3ExprCodeExprList(pParse, pWin.pOwner.x.pList, regArg, 0, uint8(0))
				for iEnd = sqlite3VdbeCurrentAddr(v); iOp < iEnd; iOp++ {
					var pOp *struct_VdbeOp = sqlite3VdbeGetOp(v, iOp)
					if int32(pOp.opcode) == 93 && pOp.p1 == pWin.iEphCsr {
						pOp.p1 = csr
					}
				}
			}
			if pFunc.funcFlags&uint32(32) != 0 {
				var pColl *struct_CollSeq
				func() int {
					_ = 0
					return 0
				}()
				func() int {
					_ = 0
					return 0
				}()
				pColl = sqlite3ExprNNCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pWin.pOwner.x.pList.a)))) + uintptr(0)*28))).pExpr)
				sqlite3VdbeAddOp4(v, 84, 0, 0, 0, (*int8)(unsafe.Pointer(pColl)), -2)
			}
			sqlite3VdbeAddOp3(v, func() int32 {
				if bInverse != 0 {
					return 160
				} else {
					return 161
				}
			}(), bInverse, regArg, pWin.regAccum)
			sqlite3VdbeAppendP4(v, unsafe.Pointer(pFunc), -8)
			sqlite3VdbeChangeP5(v, uint16(uint8(nArg)))
			if pWin.bExprArgs != 0 {
				sqlite3ReleaseTempRange(pParse, regArg, nArg)
			}
			if addrIf != 0 {
				sqlite3VdbeJumpHere(v, addrIf)
			}
		}
	}
}
func windowAggFinal(p *struct_WindowCodeArg, bFin int32) {
	var pParse *struct_Parse = p.pParse
	var pMWin *struct_Window = p.pMWin
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var pWin *struct_Window
	for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
		if pMWin.regStartRowid == 0 && pWin.pFunc.funcFlags&uint32(4096) != 0 && int32(pWin.eStart) != 90 {
			sqlite3VdbeAddOp2(v, 74, 0, pWin.regResult)
			sqlite3VdbeAddOp1(v, 34, pWin.csrApp)
			sqlite3VdbeAddOp3(v, 93, pWin.csrApp, 0, pWin.regResult)
			sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2)
		} else if pWin.regApp != 0 {
			func() int {
				_ = 0
				return 0
			}()
		} else {
			var nArg int32 = windowArgCount(pWin)
			if bFin != 0 {
				sqlite3VdbeAddOp2(v, 164, pWin.regAccum, nArg)
				sqlite3VdbeAppendP4(v, unsafe.Pointer(pWin.pFunc), -8)
				sqlite3VdbeAddOp2(v, 79, pWin.regAccum, pWin.regResult)
				sqlite3VdbeAddOp2(v, 74, 0, pWin.regAccum)
			} else {
				sqlite3VdbeAddOp3(v, 163, pWin.regAccum, nArg, pWin.regResult)
				sqlite3VdbeAppendP4(v, unsafe.Pointer(pWin.pFunc), -8)
			}
		}
	}
}
func windowFullScan(p *struct_WindowCodeArg) {
	var pWin *struct_Window
	var pParse *struct_Parse = p.pParse
	var pMWin *struct_Window = p.pMWin
	var v *struct_Vdbe = p.pVdbe
	var regCRowid int32 = 0
	var regCPeer int32 = 0
	var regRowid int32 = 0
	var regPeer int32 = 0
	var nPeer int32
	var lblNext int32
	var lblBrk int32
	var addrNext int32
	var csr int32
	func() int {
		_ = 0
		return 0
	}()
	csr = pMWin.csrApp
	nPeer = func() int32 {
		if pMWin.pOrderBy != nil {
			return pMWin.pOrderBy.nExpr
		} else {
			return 0
		}
	}()
	lblNext = sqlite3VdbeMakeLabel(pParse)
	lblBrk = sqlite3VdbeMakeLabel(pParse)
	regCRowid = sqlite3GetTempReg(pParse)
	regRowid = sqlite3GetTempReg(pParse)
	if nPeer != 0 {
		regCPeer = sqlite3GetTempRange(pParse, nPeer)
		regPeer = sqlite3GetTempRange(pParse, nPeer)
	}
	sqlite3VdbeAddOp2(v, 134, pMWin.iEphCsr, regCRowid)
	windowReadPeerValues(p, pMWin.iEphCsr, regCPeer)
	for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
		sqlite3VdbeAddOp2(v, 74, 0, pWin.regAccum)
	}
	sqlite3VdbeAddOp3(v, 25, csr, lblBrk, pMWin.regStartRowid)
	addrNext = sqlite3VdbeCurrentAddr(v)
	sqlite3VdbeAddOp2(v, 134, csr, regRowid)
	sqlite3VdbeAddOp3(v, 54, pMWin.regEndRowid, lblBrk, regRowid)
	if int32(pMWin.eExclude) == 85 {
		sqlite3VdbeAddOp3(v, 53, regCRowid, lblNext, regRowid)
	} else if int32(pMWin.eExclude) != 66 {
		var addr int32
		var addrEq int32 = 0
		var pKeyInfo *struct_KeyInfo = nil
		if pMWin.pOrderBy != nil {
			pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin.pOrderBy, 0, 0)
		}
		if int32(pMWin.eExclude) == 94 {
			addrEq = sqlite3VdbeAddOp3(v, 53, regCRowid, 0, regRowid)
		}
		if pKeyInfo != nil {
			windowReadPeerValues(p, csr, regPeer)
			sqlite3VdbeAddOp3(v, 89, regPeer, regCPeer, nPeer)
			sqlite3VdbeAppendP4(v, unsafe.Pointer(pKeyInfo), -9)
			addr = sqlite3VdbeCurrentAddr(v) + 1
			sqlite3VdbeAddOp3(v, 16, addr, lblNext, addr)
		} else {
			sqlite3VdbeAddOp2(v, 11, 0, lblNext)
		}
		if addrEq != 0 {
			sqlite3VdbeJumpHere(v, addrEq)
		}
	}
	windowAggStep(p, pMWin, csr, 0, p.regArg)
	sqlite3VdbeResolveLabel(v, lblNext)
	sqlite3VdbeAddOp2(v, 5, csr, addrNext)
	sqlite3VdbeJumpHere(v, addrNext-1)
	sqlite3VdbeJumpHere(v, addrNext+1)
	sqlite3ReleaseTempReg(pParse, regRowid)
	sqlite3ReleaseTempReg(pParse, regCRowid)
	if nPeer != 0 {
		sqlite3ReleaseTempRange(pParse, regPeer, nPeer)
		sqlite3ReleaseTempRange(pParse, regCPeer, nPeer)
	}
	windowAggFinal(p, 1)
}
func windowReturnOneRow(p *struct_WindowCodeArg) {
	var pMWin *struct_Window = p.pMWin
	var v *struct_Vdbe = p.pVdbe
	if pMWin.regStartRowid != 0 {
		windowFullScan(p)
	} else {
		var pParse *struct_Parse = p.pParse
		var pWin *struct_Window
		for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
			var pFunc *struct_FuncDef = pWin.pFunc
			func() int {
				_ = 0
				return 0
			}()
			if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&nth_valueName)))) || uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&first_valueName)))) {
				var csr int32 = pWin.csrApp
				var lbl int32 = sqlite3VdbeMakeLabel(pParse)
				var tmpReg int32 = sqlite3GetTempReg(pParse)
				sqlite3VdbeAddOp2(v, 74, 0, pWin.regResult)
				if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&nth_valueName)))) {
					sqlite3VdbeAddOp3(v, 93, pMWin.iEphCsr, pWin.iArgCol+1, tmpReg)
					windowCheckValue(pParse, tmpReg, 2)
				} else {
					sqlite3VdbeAddOp2(v, 71, 1, tmpReg)
				}
				sqlite3VdbeAddOp3(v, 106, tmpReg, pWin.regApp, tmpReg)
				sqlite3VdbeAddOp3(v, 54, pWin.regApp+1, lbl, tmpReg)
				sqlite3VdbeAddOp3(v, 32, csr, 0, tmpReg)
				sqlite3VdbeAddOp3(v, 93, csr, pWin.iArgCol, pWin.regResult)
				sqlite3VdbeResolveLabel(v, lbl)
				sqlite3ReleaseTempReg(pParse, tmpReg)
			} else if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&leadName)))) || uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&lagName)))) {
				var nArg int32 = pWin.pOwner.x.pList.nExpr
				var csr int32 = pWin.csrApp
				var lbl int32 = sqlite3VdbeMakeLabel(pParse)
				var tmpReg int32 = sqlite3GetTempReg(pParse)
				var iEph int32 = pMWin.iEphCsr
				if nArg < 3 {
					sqlite3VdbeAddOp2(v, 74, 0, pWin.regResult)
				} else {
					sqlite3VdbeAddOp3(v, 93, iEph, pWin.iArgCol+2, pWin.regResult)
				}
				sqlite3VdbeAddOp2(v, 134, iEph, tmpReg)
				if nArg < 2 {
					var val int32 = func() int32 {
						if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&leadName)))) {
							return 1
						} else {
							return -1
						}
					}()
					sqlite3VdbeAddOp2(v, 85, tmpReg, val)
				} else {
					var op int32 = func() int32 {
						if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&leadName)))) {
							return 106
						} else {
							return 107
						}
					}()
					var tmpReg2 int32 = sqlite3GetTempReg(pParse)
					sqlite3VdbeAddOp3(v, 93, iEph, pWin.iArgCol+1, tmpReg2)
					sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg)
					sqlite3ReleaseTempReg(pParse, tmpReg2)
				}
				sqlite3VdbeAddOp3(v, 32, csr, lbl, tmpReg)
				sqlite3VdbeAddOp3(v, 93, csr, pWin.iArgCol, pWin.regResult)
				sqlite3VdbeResolveLabel(v, lbl)
				sqlite3ReleaseTempReg(pParse, tmpReg)
			}
		}
	}
	sqlite3VdbeAddOp2(v, 12, p.regGosub, p.addrGosub)
}
func windowInitAccum(pParse *struct_Parse, pMWin *struct_Window) int32 {
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var regArg int32
	var nArg int32 = 0
	var pWin *struct_Window
	for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
		var pFunc *struct_FuncDef = pWin.pFunc
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp2(v, 74, 0, pWin.regAccum)
		nArg = func() int32 {
			if nArg > windowArgCount(pWin) {
				return nArg
			} else {
				return windowArgCount(pWin)
			}
		}()
		if pMWin.regStartRowid == 0 {
			if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&nth_valueName)))) || uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&first_valueName)))) {
				sqlite3VdbeAddOp2(v, 71, 0, pWin.regApp)
				sqlite3VdbeAddOp2(v, 71, 0, pWin.regApp+1)
			}
			if pFunc.funcFlags&uint32(4096) != 0 && pWin.csrApp != 0 {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3VdbeAddOp1(v, 145, pWin.csrApp)
				sqlite3VdbeAddOp2(v, 71, 0, pWin.regApp+1)
			}
		}
	}
	regArg = pParse.nMem + 1
	pParse.nMem += nArg
	return regArg
}
func windowCacheFrame(pMWin *struct_Window) int32 {
	var pWin *struct_Window
	if pMWin.regStartRowid != 0 {
		return int32(1)
	}
	for pWin = pMWin; pWin != nil; pWin = pWin.pNextWin {
		var pFunc *struct_FuncDef = pWin.pFunc
		if uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&nth_valueName)))) || uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&first_valueName)))) || uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&leadName)))) || uintptr(unsafe.Pointer(pFunc.zName)) == uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&lagName)))) {
			return int32(1)
		}
	}
	return int32(0)
}
func windowIfNewPeer(pParse *struct_Parse, pOrderBy *struct_ExprList, regNew int32, regOld int32, addr int32) {
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	if pOrderBy != nil {
		var nVal int32 = pOrderBy.nExpr
		var pKeyInfo *struct_KeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0)
		sqlite3VdbeAddOp3(v, 89, regOld, regNew, nVal)
		sqlite3VdbeAppendP4(v, unsafe.Pointer(pKeyInfo), -9)
		sqlite3VdbeAddOp3(v, 16, sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1)
		sqlite3VdbeAddOp3(v, 79, regNew, regOld, nVal-1)
	} else {
		sqlite3VdbeAddOp2(v, 11, 0, addr)
	}
}
func windowCodeRangeTest(p *struct_WindowCodeArg, op int32, csr1 int32, regVal int32, csr2 int32, lbl int32) {
	var pParse *struct_Parse = p.pParse
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var pOrderBy *struct_ExprList = p.pMWin.pOrderBy
	var reg1 int32 = sqlite3GetTempReg(pParse)
	var reg2 int32 = sqlite3GetTempReg(pParse)
	var regString int32 = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	var arith int32 = 106
	var addrGe int32
	var addrDone int32 = sqlite3VdbeMakeLabel(pParse)
	var pColl *struct_CollSeq
	windowReadPeerValues(p, csr1, reg1)
	windowReadPeerValues(p, csr2, reg2)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(0)*28))).sortFlags)&1 != 0 {
		switch op {
		case 57:
			op = int32(55)
			break
		case 54:
			op = int32(56)
			break
		default:
			func() int {
				_ = 0
				return 0
			}()
			op = int32(57)
			break
		}
		arith = int32(107)
	}
	if int32((*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(0)*28))).sortFlags)&2 != 0 {
		var addr int32 = sqlite3VdbeAddOp1(v, 51, reg1)
		switch op {
		case 57:
			sqlite3VdbeAddOp2(v, 11, 0, lbl)
			break
		case 54:
			sqlite3VdbeAddOp2(v, 51, reg2, lbl)
			break
		case 55:
			sqlite3VdbeAddOp2(v, 50, reg2, lbl)
			break
		default:
			func() int {
				_ = 0
				return 0
			}()
			break
		}
		sqlite3VdbeAddOp2(v, 11, 0, addrDone)
		sqlite3VdbeJumpHere(v, addr)
		sqlite3VdbeAddOp2(v, 50, reg2, lbl)
		if op == 54 || op == 57 {
			sqlite3VdbeChangeP2(v, -1, addrDone)
		}
	}
	sqlite3VdbeAddOp4(v, 117, 0, regString, 0, (*int8)(unsafe.Pointer(&[1]int8{'\x00'})), -1)
	addrGe = sqlite3VdbeAddOp3(v, 57, regString, 0, reg1)
	if op == 57 && arith == 106 || op == 55 && arith == 107 {
		sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1)
	}
	sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1)
	sqlite3VdbeJumpHere(v, addrGe)
	sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1)
	pColl = sqlite3ExprNNCollSeq(pParse, (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pOrderBy.a)))) + uintptr(0)*28))).pExpr)
	sqlite3VdbeAppendP4(v, unsafe.Pointer(pColl), -2)
	sqlite3VdbeChangeP5(v, uint16(128))
	sqlite3VdbeResolveLabel(v, addrDone)
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ReleaseTempReg(pParse, reg1)
	sqlite3ReleaseTempReg(pParse, reg2)
}
func windowCodeOp(p *struct_WindowCodeArg, op int32, regCountdown int32, jumpOnEof int32) int32 {
	var csr int32
	var reg int32
	var pParse *struct_Parse = p.pParse
	var pMWin *struct_Window = p.pMWin
	var ret int32 = 0
	var v *struct_Vdbe = p.pVdbe
	var addrContinue int32 = 0
	var bPeer int32 = func() int32 {
		if int32(pMWin.eFrmType) != 76 {
			return 1
		} else {
			return 0
		}
	}()
	var lblDone int32 = sqlite3VdbeMakeLabel(pParse)
	var addrNextRange int32 = 0
	if op == 2 && int32(pMWin.eStart) == 90 {
		func() int {
			_ = 0
			return 0
		}()
		return int32(0)
	}
	if regCountdown > 0 {
		if int32(pMWin.eFrmType) == 89 {
			addrNextRange = sqlite3VdbeCurrentAddr(v)
			func() int {
				_ = 0
				return 0
			}()
			if op == 2 {
				if int32(pMWin.eStart) == 86 {
					windowCodeRangeTest(p, 55, p.current.csr, regCountdown, p.start.csr, lblDone)
				} else {
					windowCodeRangeTest(p, 57, p.start.csr, regCountdown, p.current.csr, lblDone)
				}
			} else {
				windowCodeRangeTest(p, 54, p.end.csr, regCountdown, p.current.csr, lblDone)
			}
		} else {
			sqlite3VdbeAddOp3(v, 49, regCountdown, lblDone, 1)
		}
	}
	if op == 1 && pMWin.regStartRowid == 0 {
		windowAggFinal(p, 0)
	}
	addrContinue = sqlite3VdbeCurrentAddr(v)
	if int32(pMWin.eStart) == int32(pMWin.eEnd) && regCountdown != 0 && int32(pMWin.eFrmType) == 89 {
		var regRowid1 int32 = sqlite3GetTempReg(pParse)
		var regRowid2 int32 = sqlite3GetTempReg(pParse)
		if op == 2 {
			sqlite3VdbeAddOp2(v, 134, p.start.csr, regRowid1)
			sqlite3VdbeAddOp2(v, 134, p.end.csr, regRowid2)
			sqlite3VdbeAddOp3(v, 57, regRowid2, lblDone, regRowid1)
		} else if p.regRowid != 0 {
			sqlite3VdbeAddOp2(v, 134, p.end.csr, regRowid1)
			sqlite3VdbeAddOp3(v, 57, p.regRowid, lblDone, regRowid1)
		}
		sqlite3ReleaseTempReg(pParse, regRowid1)
		sqlite3ReleaseTempReg(pParse, regRowid2)
		func() int {
			_ = 0
			return 0
		}()
	}
	switch op {
	case 1:
		csr = p.current.csr
		reg = p.current.reg
		windowReturnOneRow(p)
		break
	case 2:
		csr = p.start.csr
		reg = p.start.reg
		if pMWin.regStartRowid != 0 {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 85, pMWin.regStartRowid, 1)
		} else {
			windowAggStep(p, pMWin, csr, 1, p.regArg)
		}
		break
	default:
		func() int {
			_ = 0
			return 0
		}()
		csr = p.end.csr
		reg = p.end.reg
		if pMWin.regStartRowid != 0 {
			func() int {
				_ = 0
				return 0
			}()
			sqlite3VdbeAddOp2(v, 85, pMWin.regEndRowid, 1)
		} else {
			windowAggStep(p, pMWin, csr, 0, p.regArg)
		}
		break
	}
	if op == p.eDelete {
		sqlite3VdbeAddOp1(v, 129, csr)
		sqlite3VdbeChangeP5(v, uint16(2))
	}
	if jumpOnEof != 0 {
		sqlite3VdbeAddOp2(v, 5, csr, sqlite3VdbeCurrentAddr(v)+2)
		ret = sqlite3VdbeAddOp0(v, 11)
	} else {
		sqlite3VdbeAddOp2(v, 5, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer)
		if bPeer != 0 {
			sqlite3VdbeAddOp2(v, 11, 0, lblDone)
		}
	}
	if bPeer != 0 {
		var nReg int32 = func() int32 {
			if pMWin.pOrderBy != nil {
				return pMWin.pOrderBy.nExpr
			} else {
				return 0
			}
		}()
		var regTmp int32 = func() int32 {
			if nReg != 0 {
				return sqlite3GetTempRange(pParse, nReg)
			} else {
				return 0
			}
		}()
		windowReadPeerValues(p, csr, regTmp)
		windowIfNewPeer(pParse, pMWin.pOrderBy, regTmp, reg, addrContinue)
		sqlite3ReleaseTempRange(pParse, regTmp, nReg)
	}
	if addrNextRange != 0 {
		sqlite3VdbeAddOp2(v, 11, 0, addrNextRange)
	}
	sqlite3VdbeResolveLabel(v, lblDone)
	return ret
}
func sqlite3WindowDup(db *struct_sqlite3, pOwner *struct_Expr, p *struct_Window) *struct_Window {
	var pNew *struct_Window = nil
	if p != nil {
		pNew = (*struct_Window)(sqlite3DbMallocZero(db, uint64(141)))
		if pNew != nil {
			pNew.zName = sqlite3DbStrDup(db, p.zName)
			pNew.zBase = sqlite3DbStrDup(db, p.zBase)
			pNew.pFilter = sqlite3ExprDup(db, p.pFilter, 0)
			pNew.pFunc = p.pFunc
			pNew.pPartition = sqlite3ExprListDup(db, p.pPartition, 0)
			pNew.pOrderBy = sqlite3ExprListDup(db, p.pOrderBy, 0)
			pNew.eFrmType = p.eFrmType
			pNew.eEnd = p.eEnd
			pNew.eStart = p.eStart
			pNew.eExclude = p.eExclude
			pNew.regResult = p.regResult
			pNew.regAccum = p.regAccum
			pNew.iArgCol = p.iArgCol
			pNew.iEphCsr = p.iEphCsr
			pNew.bExprArgs = p.bExprArgs
			pNew.pStart = sqlite3ExprDup(db, p.pStart, 0)
			pNew.pEnd = sqlite3ExprDup(db, p.pEnd, 0)
			pNew.pOwner = pOwner
			pNew.bImplicitFrame = p.bImplicitFrame
		}
	}
	return pNew
}
func sqlite3WindowListDup(db *struct_sqlite3, p *struct_Window) *struct_Window {
	var pWin *struct_Window
	var pRet *struct_Window = nil
	var pp **struct_Window = &pRet
	for pWin = p; pWin != nil; pWin = pWin.pNextWin {
		*pp = sqlite3WindowDup(db, nil, pWin)
		if uintptr(unsafe.Pointer(*pp)) == uintptr(unsafe.Pointer(nil)) {
			break
		}
		pp = &(*pp).pNextWin
	}
	return pRet
}
func windowExprGtZero(pParse *struct_Parse, pExpr *struct_Expr) int32 {
	var ret int32 = 0
	var db *struct_sqlite3 = pParse.db
	var pVal *struct_sqlite3_value = nil
	sqlite3ValueFromExpr(db, pExpr, db.enc, uint8(67), &pVal)
	if pVal != nil && sqlite3_value_int(pVal) > 0 {
		ret = int32(1)
	}
	sqlite3ValueFree(pVal)
	return ret
}
func sqlite3WindowCodeStep(pParse *struct_Parse, p *struct_Select, pWInfo *struct_WhereInfo, regGosub int32, addrGosub int32) {
	var pMWin *struct_Window = p.pWin
	var pOrderBy *struct_ExprList = pMWin.pOrderBy
	var v *struct_Vdbe = sqlite3GetVdbe(pParse)
	var csrWrite int32
	var csrInput int32 = (*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).iCursor
	var nInput int32 = int32((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&p.pSrc.a)))) + uintptr(0)*112))).pTab.nCol)
	var iInput int32
	var addrNe int32
	var addrGosubFlush int32 = 0
	var addrInteger int32 = 0
	var addrEmpty int32
	var regNew int32
	var regRecord int32
	var regNewPeer int32 = 0
	var regPeer int32 = 0
	var regFlushPart int32 = 0
	var s struct_WindowCodeArg
	var lblWhereEnd int32
	var regStart int32 = 0
	var regEnd int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	lblWhereEnd = sqlite3VdbeMakeLabel(pParse)
	__builtin___memset_chk(unsafe.Pointer(&s), 0, 68, __builtin_object_size(unsafe.Pointer(&s), 0))
	s.pParse = pParse
	s.pMWin = pMWin
	s.pVdbe = v
	s.regGosub = regGosub
	s.addrGosub = addrGosub
	s.current.csr = pMWin.iEphCsr
	csrWrite = s.current.csr + 1
	s.start.csr = s.current.csr + 2
	s.end.csr = s.current.csr + 3
	switch int32(pMWin.eStart) {
	case 86:
		if int32(pMWin.eFrmType) != 89 && windowExprGtZero(pParse, pMWin.pStart) != 0 {
			s.eDelete = int32(1)
		}
		break
	case 90:
		if windowCacheFrame(pMWin) == 0 {
			if int32(pMWin.eEnd) == 88 {
				if int32(pMWin.eFrmType) != 89 && windowExprGtZero(pParse, pMWin.pEnd) != 0 {
					s.eDelete = int32(3)
				}
			} else {
				s.eDelete = int32(1)
			}
		}
		break
	default:
		s.eDelete = int32(2)
		break
	}
	regNew = pParse.nMem + 1
	pParse.nMem += nInput
	regRecord = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	s.regRowid = func() (_cgo_ret int32) {
		_cgo_addr := &pParse.nMem
		*_cgo_addr++
		return *_cgo_addr
	}()
	if int32(pMWin.eStart) == 88 || int32(pMWin.eStart) == 86 {
		regStart = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
	}
	if int32(pMWin.eEnd) == 88 || int32(pMWin.eEnd) == 86 {
		regEnd = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
	}
	if int32(pMWin.eFrmType) != 76 {
		var nPeer int32 = func() int32 {
			if pOrderBy != nil {
				return pOrderBy.nExpr
			} else {
				return 0
			}
		}()
		regNewPeer = regNew + pMWin.nBufferCol
		if pMWin.pPartition != nil {
			regNewPeer += pMWin.pPartition.nExpr
		}
		regPeer = pParse.nMem + 1
		pParse.nMem += nPeer
		s.start.reg = pParse.nMem + 1
		pParse.nMem += nPeer
		s.current.reg = pParse.nMem + 1
		pParse.nMem += nPeer
		s.end.reg = pParse.nMem + 1
		pParse.nMem += nPeer
	}
	for iInput = int32(0); iInput < nInput; iInput++ {
		sqlite3VdbeAddOp3(v, 93, csrInput, iInput, regNew+iInput)
	}
	sqlite3VdbeAddOp3(v, 96, regNew, nInput, regRecord)
	if pMWin.pPartition != nil {
		var addr int32
		var pPart *struct_ExprList = pMWin.pPartition
		var nPart int32 = pPart.nExpr
		var regNewPart int32 = regNew + pMWin.nBufferCol
		var pKeyInfo *struct_KeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0)
		regFlushPart = func() (_cgo_ret int32) {
			_cgo_addr := &pParse.nMem
			*_cgo_addr++
			return *_cgo_addr
		}()
		addr = sqlite3VdbeAddOp3(v, 89, regNewPart, pMWin.regPart, nPart)
		sqlite3VdbeAppendP4(v, unsafe.Pointer(pKeyInfo), -9)
		sqlite3VdbeAddOp3(v, 16, addr+2, addr+4, addr+2)
		addrGosubFlush = sqlite3VdbeAddOp1(v, 12, regFlushPart)
		sqlite3VdbeAddOp3(v, 79, regNewPart, pMWin.regPart, nPart-1)
	}
	sqlite3VdbeAddOp2(v, 126, csrWrite, s.regRowid)
	sqlite3VdbeAddOp3(v, 127, csrWrite, regRecord, s.regRowid)
	addrNe = sqlite3VdbeAddOp3(v, 52, pMWin.regOne, 0, s.regRowid)
	s.regArg = windowInitAccum(pParse, pMWin)
	if regStart != 0 {
		sqlite3ExprCode(pParse, pMWin.pStart, regStart)
		windowCheckValue(pParse, regStart, 0+func() int32 {
			if int32(pMWin.eFrmType) == 89 {
				return 3
			} else {
				return 0
			}
		}())
	}
	if regEnd != 0 {
		sqlite3ExprCode(pParse, pMWin.pEnd, regEnd)
		windowCheckValue(pParse, regEnd, 1+func() int32 {
			if int32(pMWin.eFrmType) == 89 {
				return 3
			} else {
				return 0
			}
		}())
	}
	if int32(pMWin.eFrmType) != 89 && int32(pMWin.eStart) == int32(pMWin.eEnd) && regStart != 0 {
		var op int32 = func() int32 {
			if int32(pMWin.eStart) == 86 {
				return 57
			} else {
				return 55
			}
		}()
		var addrGe int32 = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd)
		windowAggFinal(&s, 0)
		sqlite3VdbeAddOp2(v, 38, s.current.csr, 1)
		windowReturnOneRow(&s)
		sqlite3VdbeAddOp1(v, 145, s.current.csr)
		sqlite3VdbeAddOp2(v, 11, 0, lblWhereEnd)
		sqlite3VdbeJumpHere(v, addrGe)
	}
	if int32(pMWin.eStart) == 86 && int32(pMWin.eFrmType) != 89 && regEnd != 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3VdbeAddOp3(v, 107, regStart, regEnd, regStart)
	}
	if int32(pMWin.eStart) != 90 {
		sqlite3VdbeAddOp2(v, 38, s.start.csr, 1)
	}
	sqlite3VdbeAddOp2(v, 38, s.current.csr, 1)
	sqlite3VdbeAddOp2(v, 38, s.end.csr, 1)
	if regPeer != 0 && pOrderBy != nil {
		sqlite3VdbeAddOp3(v, 79, regNewPeer, regPeer, pOrderBy.nExpr-1)
		sqlite3VdbeAddOp3(v, 79, regPeer, s.start.reg, pOrderBy.nExpr-1)
		sqlite3VdbeAddOp3(v, 79, regPeer, s.current.reg, pOrderBy.nExpr-1)
		sqlite3VdbeAddOp3(v, 79, regPeer, s.end.reg, pOrderBy.nExpr-1)
	}
	sqlite3VdbeAddOp2(v, 11, 0, lblWhereEnd)
	sqlite3VdbeJumpHere(v, addrNe)
	if regPeer != 0 {
		windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd)
	}
	if int32(pMWin.eStart) == 86 {
		windowCodeOp(&s, 3, 0, 0)
		if int32(pMWin.eEnd) != 90 {
			if int32(pMWin.eFrmType) == 89 {
				var lbl int32 = sqlite3VdbeMakeLabel(pParse)
				var addrNext int32 = sqlite3VdbeCurrentAddr(v)
				windowCodeRangeTest(&s, 57, s.current.csr, regEnd, s.end.csr, lbl)
				windowCodeOp(&s, 2, regStart, 0)
				windowCodeOp(&s, 1, 0, 0)
				sqlite3VdbeAddOp2(v, 11, 0, addrNext)
				sqlite3VdbeResolveLabel(v, lbl)
			} else {
				windowCodeOp(&s, 1, regEnd, 0)
				windowCodeOp(&s, 2, regStart, 0)
			}
		}
	} else if int32(pMWin.eEnd) == 88 {
		var bRPS int32 = func() int32 {
			if int32(pMWin.eStart) == 88 && int32(pMWin.eFrmType) == 89 {
				return 1
			} else {
				return 0
			}
		}()
		windowCodeOp(&s, 3, regEnd, 0)
		if bRPS != 0 {
			windowCodeOp(&s, 2, regStart, 0)
		}
		windowCodeOp(&s, 1, 0, 0)
		if !(bRPS != 0) {
			windowCodeOp(&s, 2, regStart, 0)
		}
	} else {
		var addr int32 = 0
		windowCodeOp(&s, 3, 0, 0)
		if int32(pMWin.eEnd) != 90 {
			if int32(pMWin.eFrmType) == 89 {
				var lbl int32 = 0
				addr = sqlite3VdbeCurrentAddr(v)
				if regEnd != 0 {
					lbl = sqlite3VdbeMakeLabel(pParse)
					windowCodeRangeTest(&s, 57, s.current.csr, regEnd, s.end.csr, lbl)
				}
				windowCodeOp(&s, 1, 0, 0)
				windowCodeOp(&s, 2, regStart, 0)
				if regEnd != 0 {
					sqlite3VdbeAddOp2(v, 11, 0, addr)
					sqlite3VdbeResolveLabel(v, lbl)
				}
			} else {
				if regEnd != 0 {
					addr = sqlite3VdbeAddOp3(v, 49, regEnd, 0, 1)
				}
				windowCodeOp(&s, 1, 0, 0)
				windowCodeOp(&s, 2, regStart, 0)
				if regEnd != 0 {
					sqlite3VdbeJumpHere(v, addr)
				}
			}
		}
	}
	sqlite3VdbeResolveLabel(v, lblWhereEnd)
	sqlite3WhereEnd(pWInfo)
	if pMWin.pPartition != nil {
		addrInteger = sqlite3VdbeAddOp2(v, 71, 0, regFlushPart)
		sqlite3VdbeJumpHere(v, addrGosubFlush)
	}
	s.regRowid = int32(0)
	addrEmpty = sqlite3VdbeAddOp1(v, 38, csrWrite)
	if int32(pMWin.eEnd) == 88 {
		var bRPS int32 = func() int32 {
			if int32(pMWin.eStart) == 88 && int32(pMWin.eFrmType) == 89 {
				return 1
			} else {
				return 0
			}
		}()
		windowCodeOp(&s, 3, regEnd, 0)
		if bRPS != 0 {
			windowCodeOp(&s, 2, regStart, 0)
		}
		windowCodeOp(&s, 1, 0, 0)
	} else if int32(pMWin.eStart) == 86 {
		var addrStart int32
		var addrBreak1 int32
		var addrBreak2 int32
		var addrBreak3 int32
		windowCodeOp(&s, 3, 0, 0)
		if int32(pMWin.eFrmType) == 89 {
			addrStart = sqlite3VdbeCurrentAddr(v)
			addrBreak2 = windowCodeOp(&s, 2, regStart, 1)
			addrBreak1 = windowCodeOp(&s, 1, 0, 1)
		} else if int32(pMWin.eEnd) == 90 {
			addrStart = sqlite3VdbeCurrentAddr(v)
			addrBreak1 = windowCodeOp(&s, 1, regStart, 1)
			addrBreak2 = windowCodeOp(&s, 2, 0, 1)
		} else {
			func() int {
				_ = 0
				return 0
			}()
			addrStart = sqlite3VdbeCurrentAddr(v)
			addrBreak1 = windowCodeOp(&s, 1, regEnd, 1)
			addrBreak2 = windowCodeOp(&s, 2, regStart, 1)
		}
		sqlite3VdbeAddOp2(v, 11, 0, addrStart)
		sqlite3VdbeJumpHere(v, addrBreak2)
		addrStart = sqlite3VdbeCurrentAddr(v)
		addrBreak3 = windowCodeOp(&s, 1, 0, 1)
		sqlite3VdbeAddOp2(v, 11, 0, addrStart)
		sqlite3VdbeJumpHere(v, addrBreak1)
		sqlite3VdbeJumpHere(v, addrBreak3)
	} else {
		var addrBreak int32
		var addrStart int32
		windowCodeOp(&s, 3, 0, 0)
		addrStart = sqlite3VdbeCurrentAddr(v)
		addrBreak = windowCodeOp(&s, 1, 0, 1)
		windowCodeOp(&s, 2, regStart, 0)
		sqlite3VdbeAddOp2(v, 11, 0, addrStart)
		sqlite3VdbeJumpHere(v, addrBreak)
	}
	sqlite3VdbeJumpHere(v, addrEmpty)
	sqlite3VdbeAddOp1(v, 145, s.current.csr)
	if pMWin.pPartition != nil {
		if pMWin.regStartRowid != 0 {
			sqlite3VdbeAddOp2(v, 71, 1, pMWin.regStartRowid)
			sqlite3VdbeAddOp2(v, 71, 0, pMWin.regEndRowid)
		}
		sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v))
		sqlite3VdbeAddOp1(v, 67, regFlushPart)
	}
}

type struct_TrigEvent struct {
	a int32
	b *struct_IdList
}
type struct_FrameBound struct {
	eType int32
	pExpr *struct_Expr
}

func disableLookaside(pParse *struct_Parse) {
	var db *struct_sqlite3 = pParse.db
	pParse.disableLookaside++
	db.lookaside.bDisable++
	db.lookaside.sz = uint16(0)
}
func parserDoubleLinkSelect(pParse *struct_Parse, p *struct_Select) {
	func() int {
		_ = 0
		return 0
	}()
	if p.pPrior != nil {
		var pNext *struct_Select = nil
		var pLoop *struct_Select = p
		var mxSelect int32
		var cnt int32 = 1
		for 1 != 0 {
			pLoop.pNext = pNext
			pLoop.selFlags |= uint32(256)
			pNext = pLoop
			pLoop = pLoop.pPrior
			if uintptr(unsafe.Pointer(pLoop)) == uintptr(unsafe.Pointer(nil)) {
				break
			}
			cnt++
			if pLoop.pOrderBy != nil || pLoop.pLimit != nil {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[42]int8{'%', 's', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 's', 'h', 'o', 'u', 'l', 'd', ' ', 'c', 'o', 'm', 'e', ' ', 'a', 'f', 't', 'e', 'r', ' ', '%', 's', ' ', 'n', 'o', 't', ' ', 'b', 'e', 'f', 'o', 'r', 'e', '\x00'})), func() *int8 {
					if uintptr(unsafe.Pointer(pLoop.pOrderBy)) != uintptr(unsafe.Pointer(nil)) {
						return (*int8)(unsafe.Pointer(&[9]int8{'O', 'R', 'D', 'E', 'R', ' ', 'B', 'Y', '\x00'}))
					} else {
						return (*int8)(unsafe.Pointer(&[6]int8{'L', 'I', 'M', 'I', 'T', '\x00'}))
					}
				}(), sqlite3SelectOpName(int32(pNext.op)))
				break
			}
		}
		if p.selFlags&uint32(1024) == uint32(0) && func() (_cgo_ret int32) {
			_cgo_addr := &mxSelect
			*_cgo_addr = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&pParse.db.aLimit)))) + uintptr(4)*4))
			return *_cgo_addr
		}() > 0 && cnt > mxSelect {
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[34]int8{'t', 'o', 'o', ' ', 'm', 'a', 'n', 'y', ' ', 't', 'e', 'r', 'm', 's', ' ', 'i', 'n', ' ', 'c', 'o', 'm', 'p', 'o', 'u', 'n', 'd', ' ', 'S', 'E', 'L', 'E', 'C', 'T', '\x00'})))
		}
	}
}
func attachWithToSelect(pParse *struct_Parse, pSelect *struct_Select, pWith *struct_With) *struct_Select {
	if pSelect != nil {
		pSelect.pWith = pWith
		parserDoubleLinkSelect(pParse, pSelect)
	} else {
		sqlite3WithDelete(pParse.db, pWith)
	}
	return pSelect
}
func tokenExpr(pParse *struct_Parse, op int32, t struct_Token) *struct_Expr {
	var p *struct_Expr = (*struct_Expr)(sqlite3DbMallocRawNN(pParse.db, uint64(72+uint(t.n)+uint(1))))
	if p != nil {
		p.op = uint8(op)
		p.affExpr = int8(0)
		p.flags = uint32(8388608)
		p.iAgg = int16(-1)
		p.pLeft = func() (_cgo_ret *struct_Expr) {
			_cgo_addr := &p.pRight
			*_cgo_addr = (*struct_Expr)(nil)
			return *_cgo_addr
		}()
		p.pAggInfo = (*struct_AggInfo)(nil)
		__builtin___memset_chk(unsafe.Pointer(&p.x), 0, 8, __builtin_object_size(unsafe.Pointer(&p.x), 0))
		__builtin___memset_chk(unsafe.Pointer(&p.y), 0, 8, __builtin_object_size(unsafe.Pointer(&p.y), 0))
		p.op2 = uint8(0)
		p.iTable = int32(0)
		p.iColumn = int16(0)
		p.u.zToken = (*int8)(unsafe.Pointer(&*(*struct_Expr)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*72))))
		__builtin___memcpy_chk(unsafe.Pointer(p.u.zToken), unsafe.Pointer(t.z), uint(t.n), __builtin_object_size(unsafe.Pointer(p.u.zToken), 0))
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.u.zToken)) + uintptr(t.n))) = int8(0)
		*(*int32)(unsafe.Pointer(&p.w)) = int32(uintptr(unsafe.Pointer(t.z)) - uintptr(unsafe.Pointer(pParse.zTail)))
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.u.zToken)) + uintptr(0))))))))&128 != 0 {
			sqlite3DequoteExpr(p)
		}
		p.nHeight = int32(1)
		if int32(pParse.eParseMode) >= 2 {
			return (*struct_Expr)(sqlite3RenameTokenMap(pParse, unsafe.Pointer(p), &t))
		}
	}
	return p
}
func binaryToUnaryIfNull(pParse *struct_Parse, pY *struct_Expr, pA *struct_Expr, op int32) {
	var db *struct_sqlite3 = pParse.db
	if pA != nil && pY != nil && int32(pY.op) == 121 && !(int32(pParse.eParseMode) >= 2) {
		pA.op = uint8(op)
		sqlite3ExprDelete(db, pA.pRight)
		pA.pRight = (*struct_Expr)(nil)
	}
}
func parserAddExprIdListTerm(pParse *struct_Parse, pPrior *struct_ExprList, pIdToken *struct_Token, hasCollate int32, sortOrder int32) *struct_ExprList {
	var p *struct_ExprList = sqlite3ExprListAppend(pParse, pPrior, nil)
	if (hasCollate != 0 || sortOrder != -1) && int32(pParse.db.init.busy) == 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[38]int8{'s', 'y', 'n', 't', 'a', 'x', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'a', 'f', 't', 'e', 'r', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ' ', 'n', 'a', 'm', 'e', ' ', '"', '%', '.', '*', 's', '"', '\x00'})), pIdToken.n, pIdToken.z)
	}
	sqlite3ExprListSetName(pParse, p, pIdToken, 1)
	return p
}

type _cgoa_89 struct {
	value int32
	mask  int32
}
type _cgoa_88 struct {
	yy180 struct_TrigEvent
}

var yy_action [2070]uint16 = [2070]uint16{uint16(566), uint16(1307), uint16(566), uint16(1286), uint16(201), uint16(201), uint16(566), uint16(116), uint16(112), uint16(222), uint16(566), uint16(1307), uint16(377), uint16(566), uint16(116), uint16(112), uint16(222), uint16(397), uint16(408), uint16(409), uint16(1260), uint16(378), uint16(1269), uint16(41), uint16(41), uint16(41), uint16(41), uint16(1412), uint16(1517), uint16(71), uint16(71), uint16(967), uint16(1258), uint16(41), uint16(41), uint16(491), uint16(71), uint16(71), uint16(272), uint16(968), uint16(298), uint16(476), uint16(298), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(543), uint16(409), uint16(1234), uint16(1), uint16(1), uint16(573), uint16(2), uint16(1238), uint16(548), uint16(116), uint16(112), uint16(222), uint16(309), uint16(480), uint16(142), uint16(548), uint16(1272), uint16(524), uint16(116), uint16(112), uint16(222), uint16(1320), uint16(417), uint16(523), uint16(547), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(424), uint16(116), uint16(112), uint16(222), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(277), uint16(277), uint16(277), uint16(277), uint16(560), uint16(560), uint16(560), uint16(1558), uint16(376), uint16(1560), uint16(1186), uint16(375), uint16(1157), uint16(563), uint16(1157), uint16(563), uint16(409), uint16(1558), uint16(537), uint16(252), uint16(219), uint16(1553), uint16(99), uint16(141), uint16(449), uint16(6), uint16(365), uint16(233), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(138), uint16(289), uint16(1186), uint16(1546), uint16(448), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(125), uint16(1186), uint16(1187), uint16(1188), uint16(144), uint16(465), uint16(334), uint16(566), uint16(150), uint16(127), uint16(444), uint16(122), uint16(122), uint16(122), uint16(122), uint16(115), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(454), uint16(419), uint16(13), uint16(13), uint16(215), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(422), uint16(308), uint16(557), uint16(1186), uint16(1187), uint16(1188), uint16(441), uint16(440), uint16(409), uint16(1271), uint16(122), uint16(122), uint16(122), uint16(122), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1543), uint16(98), uint16(1033), uint16(1033), uint16(1045), uint16(1048), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(566), uint16(406), uint16(405), uint16(1186), uint16(566), uint16(409), uint16(1217), uint16(319), uint16(1217), uint16(80), uint16(81), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(70), uint16(70), uint16(1186), uint16(1604), uint16(71), uint16(71), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1037), uint16(210), uint16(1186), uint16(365), uint16(1186), uint16(1187), uint16(1188), uint16(245), uint16(548), uint16(399), uint16(504), uint16(501), uint16(500), uint16(108), uint16(558), uint16(138), uint16(4), uint16(516), uint16(933), uint16(433), uint16(499), uint16(217), uint16(514), uint16(522), uint16(352), uint16(879), uint16(1186), uint16(1187), uint16(1188), uint16(383), uint16(561), uint16(566), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(277), uint16(277), uint16(16), uint16(16), uint16(1598), uint16(441), uint16(440), uint16(153), uint16(409), uint16(445), uint16(13), uint16(13), uint16(1279), uint16(563), uint16(1214), uint16(1186), uint16(1187), uint16(1188), uint16(1003), uint16(1216), uint16(264), uint16(555), uint16(1574), uint16(186), uint16(566), uint16(427), uint16(138), uint16(1215), uint16(308), uint16(557), uint16(472), uint16(138), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(55), uint16(55), uint16(413), uint16(1023), uint16(507), uint16(1217), uint16(1186), uint16(1217), uint16(474), uint16(106), uint16(106), uint16(1312), uint16(1312), uint16(1186), uint16(171), uint16(566), uint16(384), uint16(107), uint16(380), uint16(445), uint16(568), uint16(567), uint16(430), uint16(1543), uint16(1013), uint16(332), uint16(549), uint16(565), uint16(263), uint16(280), uint16(360), uint16(510), uint16(355), uint16(509), uint16(250), uint16(491), uint16(308), uint16(557), uint16(71), uint16(71), uint16(351), uint16(308), uint16(557), uint16(374), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(277), uint16(277), uint16(1186), uint16(1187), uint16(1188), uint16(1152), uint16(566), uint16(528), uint16(409), uint16(1186), uint16(1187), uint16(1188), uint16(348), uint16(563), uint16(548), uint16(1260), uint16(533), uint16(517), uint16(1152), uint16(1516), uint16(317), uint16(1152), uint16(285), uint16(550), uint16(485), uint16(569), uint16(566), uint16(569), uint16(482), uint16(51), uint16(51), uint16(207), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(171), uint16(1412), uint16(13), uint16(13), uint16(409), uint16(277), uint16(277), uint16(1186), uint16(505), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(429), uint16(563), uint16(518), uint16(220), uint16(515), uint16(1552), uint16(365), uint16(546), uint16(1186), uint16(6), uint16(532), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(145), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(245), uint16(566), uint16(474), uint16(504), uint16(501), uint16(500), uint16(566), uint16(1481), uint16(1186), uint16(1187), uint16(1188), uint16(1310), uint16(1310), uint16(499), uint16(1186), uint16(149), uint16(425), uint16(1186), uint16(480), uint16(409), uint16(274), uint16(365), uint16(952), uint16(872), uint16(56), uint16(56), uint16(1186), uint16(1187), uint16(1188), uint16(71), uint16(71), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(409), uint16(541), uint16(1552), uint16(83), uint16(865), uint16(98), uint16(6), uint16(928), uint16(529), uint16(848), uint16(543), uint16(151), uint16(927), uint16(1186), uint16(1187), uint16(1188), uint16(1186), uint16(1187), uint16(1188), uint16(290), uint16(1543), uint16(187), uint16(1633), uint16(395), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(566), uint16(954), uint16(566), uint16(453), uint16(953), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1152), uint16(221), uint16(1186), uint16(331), uint16(453), uint16(452), uint16(13), uint16(13), uint16(13), uint16(13), uint16(1003), uint16(365), uint16(463), uint16(1152), uint16(193), uint16(409), uint16(1152), uint16(382), uint16(1543), uint16(1170), uint16(32), uint16(297), uint16(474), uint16(195), uint16(1527), uint16(5), uint16(952), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(409), uint16(1067), uint16(419), uint16(1186), uint16(1024), uint16(1186), uint16(1187), uint16(1188), uint16(1186), uint16(419), uint16(332), uint16(460), uint16(320), uint16(544), uint16(1545), uint16(442), uint16(442), uint16(442), uint16(566), uint16(3), uint16(117), uint16(113), uint16(444), uint16(453), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(1473), uint16(566), uint16(15), uint16(15), uint16(293), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1186), uint16(566), uint16(1486), uint16(1412), uint16(1186), uint16(1187), uint16(1188), uint16(13), uint16(13), uint16(1186), uint16(1187), uint16(1188), uint16(1544), uint16(271), uint16(271), uint16(409), uint16(286), uint16(308), uint16(557), uint16(1008), uint16(1486), uint16(1488), uint16(196), uint16(288), uint16(71), uint16(71), uint16(563), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(409), uint16(201), uint16(1087), uint16(1186), uint16(1187), uint16(1188), uint16(1324), uint16(304), uint16(1529), uint16(388), uint16(278), uint16(278), uint16(450), uint16(564), uint16(402), uint16(922), uint16(922), uint16(566), uint16(563), uint16(566), uint16(426), uint16(491), uint16(480), uint16(563), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(1486), uint16(71), uint16(71), uint16(13), uint16(13), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(566), uint16(545), uint16(566), uint16(1577), uint16(573), uint16(2), uint16(1238), uint16(1092), uint16(1092), uint16(488), uint16(1480), uint16(309), uint16(1525), uint16(142), uint16(324), uint16(409), uint16(836), uint16(837), uint16(838), uint16(312), uint16(1320), uint16(305), uint16(363), uint16(43), uint16(43), uint16(57), uint16(57), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(12), uint16(277), uint16(277), uint16(566), uint16(1152), uint16(409), uint16(572), uint16(428), uint16(1238), uint16(465), uint16(334), uint16(296), uint16(474), uint16(309), uint16(563), uint16(142), uint16(249), uint16(1152), uint16(308), uint16(557), uint16(1152), uint16(321), uint16(1320), uint16(323), uint16(491), uint16(455), uint16(71), uint16(71), uint16(233), uint16(283), uint16(101), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1108), uint16(277), uint16(277), uint16(1412), uint16(448), uint16(394), uint16(1230), uint16(439), uint16(277), uint16(277), uint16(248), uint16(247), uint16(246), uint16(1319), uint16(563), uint16(1109), uint16(313), uint16(198), uint16(294), uint16(491), uint16(1318), uint16(563), uint16(464), uint16(566), uint16(1427), uint16(394), uint16(1130), uint16(1023), uint16(233), uint16(414), uint16(1110), uint16(295), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1014), uint16(104), uint16(71), uint16(71), uint16(1013), uint16(322), uint16(496), uint16(908), uint16(566), uint16(277), uint16(277), uint16(277), uint16(277), uint16(1108), uint16(1261), uint16(415), uint16(448), uint16(909), uint16(361), uint16(1571), uint16(1315), uint16(409), uint16(563), uint16(952), uint16(563), uint16(9), uint16(202), uint16(255), uint16(1109), uint16(316), uint16(487), uint16(44), uint16(44), uint16(249), uint16(559), uint16(415), uint16(1013), uint16(1013), uint16(1015), uint16(443), uint16(1231), uint16(409), uint16(1603), uint16(1110), uint16(897), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(1231), uint16(409), uint16(1207), uint16(215), uint16(554), uint16(123), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(1131), uint16(1631), uint16(470), uint16(1631), uint16(255), uint16(123), uint16(111), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(1131), uint16(1632), uint16(414), uint16(1632), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(221), uint16(209), uint16(351), uint16(1207), uint16(1207), uint16(147), uint16(1426), uint16(491), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(1256), uint16(539), uint16(519), uint16(888), uint16(551), uint16(952), uint16(12), uint16(566), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(538), uint16(566), uint16(860), uint16(1129), uint16(361), uint16(1571), uint16(346), uint16(1356), uint16(409), uint16(1163), uint16(58), uint16(58), uint16(339), uint16(1355), uint16(508), uint16(277), uint16(277), uint16(277), uint16(277), uint16(277), uint16(277), uint16(1207), uint16(889), uint16(1129), uint16(59), uint16(59), uint16(459), uint16(363), uint16(563), uint16(566), uint16(563), uint16(96), uint16(563), uint16(124), uint16(114), uint16(1210), uint16(1210), uint16(1044), uint16(1047), uint16(1036), uint16(1036), uint16(121), uint16(121), uint16(122), uint16(122), uint16(122), uint16(122), uint16(566), uint16(1412), uint16(566), uint16(281), uint16(1186), uint16(60), uint16(60), uint16(110), uint16(392), uint16(392), uint16(391), uint16(266), uint16(389), uint16(860), uint16(1163), uint16(845), uint16(566), uint16(481), uint16(566), uint16(436), uint16(341), uint16(1152), uint16(344), uint16(61), uint16(61), uint16(62), uint16(62), uint16(967), uint16(227), uint16(1550), uint16(315), uint16(431), uint16(540), uint16(6), uint16(1152), uint16(968), uint16(566), uint16(1152), uint16(314), uint16(45), uint16(45), uint16(46), uint16(46), uint16(512), uint16(120), uint16(120), uint16(120), uint16(120), uint16(119), uint16(119), uint16(118), uint16(118), uint16(118), uint16(117), uint16(113), uint16(444), uint16(416), uint16(173), uint16(1532), uint16(47), uint16(47), uint16(1186), uint16(1187), uint16(1188), uint16(108), uint16(558), uint16(325), uint16(4), uint16(229), uint16(1551), uint16(928), uint16(566), uint16(437), uint16(6), uint16(566), uint16(927), uint16(164), uint16(566), uint16(1290), uint16(137), uint16(1190), uint16(561), uint16(566), uint16(1549), uint16(566), uint16(1089), uint16(566), uint16(6), uint16(566), uint16(1089), uint16(531), uint16(566), uint16(868), uint16(8), uint16(49), uint16(49), uint16(228), uint16(50), uint16(50), uint16(566), uint16(63), uint16(63), uint16(566), uint16(457), uint16(445), uint16(64), uint16(64), uint16(65), uint16(65), uint16(14), uint16(14), uint16(66), uint16(66), uint16(407), uint16(129), uint16(129), uint16(555), uint16(566), uint16(458), uint16(566), uint16(1505), uint16(486), uint16(67), uint16(67), uint16(566), uint16(52), uint16(52), uint16(546), uint16(407), uint16(467), uint16(535), uint16(410), uint16(226), uint16(1023), uint16(566), uint16(534), uint16(308), uint16(557), uint16(1190), uint16(407), uint16(68), uint16(68), uint16(69), uint16(69), uint16(566), uint16(1023), uint16(566), uint16(53), uint16(53), uint16(868), uint16(1014), uint16(106), uint16(106), uint16(525), uint16(1013), uint16(566), uint16(1504), uint16(159), uint16(159), uint16(107), uint16(451), uint16(445), uint16(568), uint16(567), uint16(471), uint16(307), uint16(1013), uint16(160), uint16(160), uint16(76), uint16(76), uint16(566), uint16(1548), uint16(466), uint16(407), uint16(407), uint16(6), uint16(1225), uint16(54), uint16(54), uint16(478), uint16(276), uint16(219), uint16(566), uint16(887), uint16(886), uint16(1013), uint16(1013), uint16(1015), uint16(84), uint16(206), uint16(1206), uint16(230), uint16(282), uint16(72), uint16(72), uint16(329), uint16(483), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(1576), uint16(1174), uint16(447), uint16(130), uint16(130), uint16(281), uint16(148), uint16(105), uint16(38), uint16(103), uint16(392), uint16(392), uint16(391), uint16(266), uint16(389), uint16(566), uint16(1126), uint16(845), uint16(396), uint16(566), uint16(108), uint16(558), uint16(566), uint16(4), uint16(311), uint16(566), uint16(30), uint16(17), uint16(566), uint16(279), uint16(227), uint16(566), uint16(315), uint16(108), uint16(558), uint16(468), uint16(4), uint16(561), uint16(73), uint16(73), uint16(314), uint16(566), uint16(157), uint16(157), uint16(566), uint16(131), uint16(131), uint16(526), uint16(132), uint16(132), uint16(561), uint16(128), uint16(128), uint16(566), uint16(158), uint16(158), uint16(566), uint16(31), uint16(291), uint16(566), uint16(445), uint16(330), uint16(521), uint16(98), uint16(152), uint16(152), uint16(420), uint16(136), uint16(136), uint16(1005), uint16(229), uint16(254), uint16(555), uint16(445), uint16(479), uint16(336), uint16(135), uint16(135), uint16(164), uint16(133), uint16(133), uint16(137), uint16(134), uint16(134), uint16(875), uint16(555), uint16(535), uint16(566), uint16(473), uint16(566), uint16(254), uint16(536), uint16(475), uint16(335), uint16(254), uint16(98), uint16(894), uint16(895), uint16(228), uint16(535), uint16(566), uint16(1023), uint16(566), uint16(1074), uint16(534), uint16(210), uint16(232), uint16(106), uint16(106), uint16(1352), uint16(75), uint16(75), uint16(77), uint16(77), uint16(1023), uint16(107), uint16(340), uint16(445), uint16(568), uint16(567), uint16(106), uint16(106), uint16(1013), uint16(74), uint16(74), uint16(42), uint16(42), uint16(566), uint16(107), uint16(343), uint16(445), uint16(568), uint16(567), uint16(410), uint16(497), uint16(1013), uint16(251), uint16(359), uint16(308), uint16(557), uint16(1135), uint16(349), uint16(875), uint16(98), uint16(1070), uint16(345), uint16(251), uint16(358), uint16(1591), uint16(347), uint16(48), uint16(48), uint16(1017), uint16(1303), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(1289), uint16(1287), uint16(1074), uint16(451), uint16(961), uint16(925), uint16(254), uint16(110), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(1174), uint16(447), uint16(970), uint16(971), uint16(281), uint16(108), uint16(558), uint16(1288), uint16(4), uint16(392), uint16(392), uint16(391), uint16(266), uint16(389), uint16(1343), uint16(1086), uint16(845), uint16(1086), uint16(1085), uint16(858), uint16(1085), uint16(146), uint16(561), uint16(926), uint16(354), uint16(110), uint16(303), uint16(364), uint16(553), uint16(227), uint16(1364), uint16(315), uint16(108), uint16(558), uint16(1411), uint16(4), uint16(1339), uint16(492), uint16(1017), uint16(314), uint16(1350), uint16(1565), uint16(552), uint16(1417), uint16(1268), uint16(445), uint16(204), uint16(1259), uint16(1247), uint16(561), uint16(1246), uint16(1248), uint16(1584), uint16(269), uint16(1336), uint16(367), uint16(369), uint16(555), uint16(371), uint16(11), uint16(212), uint16(393), uint16(225), uint16(1393), uint16(284), uint16(1398), uint16(456), uint16(287), uint16(327), uint16(229), uint16(328), uint16(292), uint16(445), uint16(1386), uint16(216), uint16(333), uint16(1403), uint16(164), uint16(477), uint16(373), uint16(137), uint16(1402), uint16(400), uint16(502), uint16(555), uint16(1286), uint16(1023), uint16(357), uint16(1477), uint16(199), uint16(1587), uint16(211), uint16(106), uint16(106), uint16(932), uint16(1476), uint16(1225), uint16(228), uint16(556), uint16(175), uint16(107), uint16(200), uint16(445), uint16(568), uint16(567), uint16(258), uint16(387), uint16(1013), uint16(1524), uint16(1522), uint16(223), uint16(1222), uint16(418), uint16(1023), uint16(83), uint16(208), uint16(79), uint16(82), uint16(184), uint16(106), uint16(106), uint16(1482), uint16(169), uint16(177), uint16(461), uint16(179), uint16(462), uint16(107), uint16(1399), uint16(445), uint16(568), uint16(567), uint16(410), uint16(180), uint16(1013), uint16(495), uint16(181), uint16(308), uint16(557), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(182), uint16(35), uint16(235), uint16(100), uint16(558), uint16(398), uint16(4), uint16(96), uint16(1405), uint16(1404), uint16(36), uint16(484), uint16(469), uint16(1407), uint16(188), uint16(401), uint16(1471), uint16(451), uint16(89), uint16(1493), uint16(561), uint16(239), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(490), uint16(338), uint16(270), uint16(241), uint16(192), uint16(342), uint16(493), uint16(242), uint16(403), uint16(1249), uint16(243), uint16(511), uint16(432), uint16(1297), uint16(1306), uint16(91), uint16(445), uint16(1305), uint16(1304), uint16(879), uint16(217), uint16(434), uint16(435), uint16(1570), uint16(1276), uint16(1602), uint16(520), uint16(1601), uint16(555), uint16(301), uint16(527), uint16(404), uint16(1275), uint16(302), uint16(356), uint16(1274), uint16(1600), uint16(95), uint16(1347), uint16(366), uint16(1296), uint16(362), uint16(1348), uint16(368), uint16(256), uint16(257), uint16(1556), uint16(1555), uint16(438), uint16(1346), uint16(370), uint16(126), uint16(1345), uint16(10), uint16(1371), uint16(546), uint16(381), uint16(1023), uint16(102), uint16(1457), uint16(97), uint16(530), uint16(34), uint16(106), uint16(106), uint16(570), uint16(1180), uint16(372), uint16(265), uint16(1329), uint16(379), uint16(107), uint16(203), uint16(445), uint16(568), uint16(567), uint16(1328), uint16(385), uint16(1013), uint16(1370), uint16(386), uint16(267), uint16(268), uint16(571), uint16(1244), uint16(161), uint16(1239), uint16(162), uint16(1509), uint16(1510), uint16(1508), uint16(143), uint16(1507), uint16(299), uint16(832), uint16(213), uint16(214), uint16(78), uint16(446), uint16(205), uint16(310), uint16(306), uint16(163), uint16(224), uint16(1084), uint16(140), uint16(1082), uint16(318), uint16(165), uint16(176), uint16(1013), uint16(1013), uint16(1015), uint16(1016), uint16(27), uint16(178), uint16(1206), uint16(231), uint16(911), uint16(234), uint16(326), uint16(1098), uint16(183), uint16(421), uint16(166), uint16(167), uint16(411), uint16(185), uint16(85), uint16(423), uint16(412), uint16(86), uint16(174), uint16(87), uint16(168), uint16(88), uint16(1101), uint16(236), uint16(1097), uint16(237), uint16(154), uint16(18), uint16(238), uint16(254), uint16(337), uint16(1219), uint16(489), uint16(1090), uint16(240), uint16(190), uint16(37), uint16(847), uint16(189), uint16(494), uint16(358), uint16(244), uint16(350), uint16(506), uint16(191), uint16(877), uint16(90), uint16(498), uint16(19), uint16(20), uint16(503), uint16(92), uint16(353), uint16(890), uint16(300), uint16(170), uint16(155), uint16(93), uint16(513), uint16(94), uint16(1168), uint16(156), uint16(1050), uint16(1137), uint16(39), uint16(218), uint16(273), uint16(275), uint16(1136), uint16(960), uint16(194), uint16(955), uint16(110), uint16(1154), uint16(1158), uint16(253), uint16(7), uint16(1162), uint16(1156), uint16(21), uint16(22), uint16(1161), uint16(1142), uint16(23), uint16(24), uint16(25), uint16(33), uint16(542), uint16(26), uint16(260), uint16(197), uint16(98), uint16(1065), uint16(1051), uint16(1049), uint16(1053), uint16(1107), uint16(1054), uint16(1106), uint16(259), uint16(28), uint16(40), uint16(562), uint16(1018), uint16(859), uint16(109), uint16(29), uint16(921), uint16(390), uint16(1176), uint16(172), uint16(139), uint16(1175), uint16(1235), uint16(261), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(262), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1235), uint16(1593), uint16(1592)}
var yy_lookahead [2255]uint16 = [2255]uint16{uint16(193), uint16(223), uint16(193), uint16(225), uint16(193), uint16(193), uint16(193), uint16(274), uint16(275), uint16(276), uint16(193), uint16(233), uint16(219), uint16(193), uint16(274), uint16(275), uint16(276), uint16(206), uint16(206), uint16(19), uint16(193), uint16(219), uint16(216), uint16(216), uint16(217), uint16(216), uint16(217), uint16(193), uint16(295), uint16(216), uint16(217), uint16(31), uint16(205), uint16(216), uint16(217), uint16(193), uint16(216), uint16(217), uint16(213), uint16(39), uint16(228), uint16(193), uint16(230), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(193), uint16(19), uint16(185), uint16(186), uint16(187), uint16(188), uint16(189), uint16(190), uint16(253), uint16(274), uint16(275), uint16(276), uint16(195), uint16(193), uint16(197), uint16(253), uint16(216), uint16(262), uint16(274), uint16(275), uint16(276), uint16(204), uint16(238), uint16(204), uint16(262), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(264), uint16(274), uint16(275), uint16(276), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(239), uint16(240), uint16(239), uint16(240), uint16(210), uint16(211), uint16(212), uint16(314), uint16(315), uint16(314), uint16(59), uint16(316), uint16(86), uint16(252), uint16(88), uint16(252), uint16(19), uint16(314), uint16(315), uint16(256), uint16(257), uint16(309), uint16(25), uint16(72), uint16(296), uint16(313), uint16(193), uint16(266), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(81), uint16(292), uint16(59), uint16(307), uint16(298), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(69), uint16(116), uint16(117), uint16(118), uint16(72), uint16(128), uint16(129), uint16(193), uint16(241), uint16(22), uint16(113), uint16(54), uint16(55), uint16(56), uint16(57), uint16(58), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(120), uint16(193), uint16(216), uint16(217), uint16(25), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(231), uint16(138), uint16(139), uint16(116), uint16(117), uint16(118), uint16(106), uint16(107), uint16(19), uint16(216), uint16(54), uint16(55), uint16(56), uint16(57), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(304), uint16(25), uint16(46), uint16(47), uint16(48), uint16(49), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(193), uint16(106), uint16(107), uint16(59), uint16(193), uint16(19), uint16(153), uint16(263), uint16(155), uint16(67), uint16(24), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(216), uint16(217), uint16(59), uint16(230), uint16(216), uint16(217), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(121), uint16(142), uint16(59), uint16(193), uint16(116), uint16(117), uint16(118), uint16(119), uint16(253), uint16(204), uint16(122), uint16(123), uint16(124), uint16(19), uint16(20), uint16(81), uint16(22), uint16(262), uint16(108), uint16(19), uint16(132), uint16(165), uint16(166), uint16(193), uint16(24), uint16(126), uint16(116), uint16(117), uint16(118), uint16(278), uint16(36), uint16(193), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(239), uint16(240), uint16(216), uint16(217), uint16(215), uint16(106), uint16(107), uint16(241), uint16(19), uint16(59), uint16(216), uint16(217), uint16(223), uint16(252), uint16(115), uint16(116), uint16(117), uint16(118), uint16(73), uint16(120), uint16(26), uint16(71), uint16(193), uint16(22), uint16(193), uint16(231), uint16(81), uint16(128), uint16(138), uint16(139), uint16(269), uint16(81), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(216), uint16(217), uint16(198), uint16(100), uint16(95), uint16(153), uint16(59), uint16(155), uint16(193), uint16(106), uint16(107), uint16(235), uint16(236), uint16(59), uint16(193), uint16(193), uint16(249), uint16(114), uint16(251), uint16(116), uint16(117), uint16(118), uint16(113), uint16(304), uint16(121), uint16(127), uint16(204), uint16(193), uint16(119), uint16(120), uint16(121), uint16(122), uint16(123), uint16(124), uint16(125), uint16(193), uint16(138), uint16(139), uint16(216), uint16(217), uint16(131), uint16(138), uint16(139), uint16(193), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(239), uint16(240), uint16(116), uint16(117), uint16(118), uint16(76), uint16(193), uint16(193), uint16(19), uint16(116), uint16(117), uint16(118), uint16(23), uint16(252), uint16(253), uint16(193), uint16(87), uint16(204), uint16(89), uint16(238), uint16(193), uint16(92), uint16(268), uint16(262), uint16(281), uint16(203), uint16(193), uint16(205), uint16(285), uint16(216), uint16(217), uint16(150), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(193), uint16(193), uint16(216), uint16(217), uint16(19), uint16(239), uint16(240), uint16(59), uint16(23), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(231), uint16(252), uint16(253), uint16(193), uint16(308), uint16(309), uint16(193), uint16(145), uint16(59), uint16(313), uint16(145), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(164), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(119), uint16(193), uint16(193), uint16(122), uint16(123), uint16(124), uint16(193), uint16(283), uint16(116), uint16(117), uint16(118), uint16(235), uint16(236), uint16(132), uint16(59), uint16(241), uint16(264), uint16(59), uint16(193), uint16(19), uint16(23), uint16(193), uint16(25), uint16(23), uint16(216), uint16(217), uint16(116), uint16(117), uint16(118), uint16(216), uint16(217), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(19), uint16(308), uint16(309), uint16(151), uint16(23), uint16(25), uint16(313), uint16(135), uint16(253), uint16(21), uint16(193), uint16(241), uint16(140), uint16(116), uint16(117), uint16(118), uint16(116), uint16(117), uint16(118), uint16(268), uint16(304), uint16(22), uint16(301), uint16(302), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(193), uint16(143), uint16(193), uint16(193), uint16(143), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(76), uint16(118), uint16(59), uint16(292), uint16(211), uint16(212), uint16(216), uint16(217), uint16(216), uint16(217), uint16(73), uint16(193), uint16(80), uint16(89), uint16(25), uint16(19), uint16(92), uint16(193), uint16(304), uint16(23), uint16(22), uint16(231), uint16(193), uint16(231), uint16(193), uint16(22), uint16(143), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(19), uint16(123), uint16(193), uint16(59), uint16(23), uint16(116), uint16(117), uint16(118), uint16(59), uint16(193), uint16(127), uint16(128), uint16(129), uint16(306), uint16(307), uint16(210), uint16(211), uint16(212), uint16(193), uint16(22), uint16(111), uint16(112), uint16(113), uint16(284), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(161), uint16(193), uint16(216), uint16(217), uint16(268), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(59), uint16(193), uint16(193), uint16(193), uint16(116), uint16(117), uint16(118), uint16(216), uint16(217), uint16(116), uint16(117), uint16(118), uint16(304), uint16(239), uint16(240), uint16(19), uint16(263), uint16(138), uint16(139), uint16(23), uint16(211), uint16(212), uint16(231), uint16(263), uint16(216), uint16(217), uint16(252), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(19), uint16(193), uint16(11), uint16(116), uint16(117), uint16(118), uint16(240), uint16(253), uint16(193), uint16(201), uint16(239), uint16(240), uint16(193), uint16(134), uint16(206), uint16(136), uint16(137), uint16(193), uint16(252), uint16(193), uint16(264), uint16(193), uint16(193), uint16(252), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(284), uint16(216), uint16(217), uint16(216), uint16(217), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(193), uint16(231), uint16(193), uint16(187), uint16(188), uint16(189), uint16(190), uint16(127), uint16(128), uint16(129), uint16(238), uint16(195), uint16(193), uint16(197), uint16(16), uint16(19), uint16(7), uint16(8), uint16(9), uint16(193), uint16(204), uint16(253), uint16(193), uint16(216), uint16(217), uint16(216), uint16(217), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(213), uint16(239), uint16(240), uint16(193), uint16(76), uint16(19), uint16(188), uint16(232), uint16(190), uint16(128), uint16(129), uint16(292), uint16(193), uint16(195), uint16(252), uint16(197), uint16(46), uint16(89), uint16(138), uint16(139), uint16(92), uint16(77), uint16(204), uint16(79), uint16(193), uint16(269), uint16(216), uint16(217), uint16(266), uint16(204), uint16(159), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(12), uint16(239), uint16(240), uint16(193), uint16(298), uint16(22), uint16(23), uint16(253), uint16(239), uint16(240), uint16(127), uint16(128), uint16(129), uint16(238), uint16(252), uint16(27), uint16(193), uint16(286), uint16(204), uint16(193), uint16(204), uint16(252), uint16(291), uint16(193), uint16(273), uint16(22), uint16(23), uint16(100), uint16(266), uint16(115), uint16(42), uint16(268), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(117), uint16(159), uint16(216), uint16(217), uint16(121), uint16(161), uint16(19), uint16(63), uint16(193), uint16(239), uint16(240), uint16(239), uint16(240), uint16(12), uint16(208), uint16(209), uint16(298), uint16(73), uint16(311), uint16(312), uint16(238), uint16(19), uint16(252), uint16(25), uint16(252), uint16(22), uint16(24), uint16(24), uint16(27), uint16(193), uint16(264), uint16(216), uint16(217), uint16(46), uint16(208), uint16(209), uint16(153), uint16(154), uint16(155), uint16(253), uint16(101), uint16(19), uint16(23), uint16(42), uint16(25), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(101), uint16(19), uint16(59), uint16(25), uint16(63), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(22), uint16(23), uint16(115), uint16(25), uint16(24), uint16(43), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(22), uint16(23), uint16(115), uint16(25), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(118), uint16(150), uint16(131), uint16(59), uint16(117), uint16(22), uint16(273), uint16(193), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(204), uint16(66), uint16(204), uint16(35), uint16(204), uint16(143), uint16(213), uint16(193), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(85), uint16(193), uint16(59), uint16(101), uint16(311), uint16(312), uint16(16), uint16(193), uint16(19), uint16(94), uint16(216), uint16(217), uint16(238), uint16(193), uint16(66), uint16(239), uint16(240), uint16(239), uint16(240), uint16(239), uint16(240), uint16(117), uint16(74), uint16(101), uint16(216), uint16(217), uint16(193), uint16(193), uint16(252), uint16(193), uint16(252), uint16(149), uint16(252), uint16(44), uint16(45), uint16(46), uint16(47), uint16(48), uint16(49), uint16(50), uint16(51), uint16(52), uint16(53), uint16(54), uint16(55), uint16(56), uint16(57), uint16(193), uint16(193), uint16(193), uint16(5), uint16(59), uint16(216), uint16(217), uint16(25), uint16(10), uint16(11), uint16(12), uint16(13), uint16(14), uint16(117), uint16(146), uint16(17), uint16(193), uint16(291), uint16(193), uint16(232), uint16(77), uint16(76), uint16(79), uint16(216), uint16(217), uint16(216), uint16(217), uint16(31), uint16(30), uint16(309), uint16(32), uint16(130), uint16(87), uint16(313), uint16(89), uint16(39), uint16(193), uint16(92), uint16(40), uint16(216), uint16(217), uint16(216), uint16(217), uint16(108), uint16(102), uint16(103), uint16(104), uint16(105), uint16(106), uint16(107), uint16(108), uint16(109), uint16(110), uint16(111), uint16(112), uint16(113), uint16(299), uint16(300), uint16(193), uint16(216), uint16(217), uint16(116), uint16(117), uint16(118), uint16(19), uint16(20), uint16(193), uint16(22), uint16(70), uint16(309), uint16(135), uint16(193), uint16(264), uint16(313), uint16(193), uint16(140), uint16(78), uint16(193), uint16(226), uint16(81), uint16(59), uint16(36), uint16(193), uint16(309), uint16(193), uint16(29), uint16(193), uint16(313), uint16(193), uint16(33), uint16(145), uint16(193), uint16(59), uint16(48), uint16(216), uint16(217), uint16(98), uint16(216), uint16(217), uint16(193), uint16(216), uint16(217), uint16(193), uint16(244), uint16(59), uint16(216), uint16(217), uint16(216), uint16(217), uint16(216), uint16(217), uint16(216), uint16(217), uint16(254), uint16(216), uint16(217), uint16(71), uint16(193), uint16(244), uint16(193), uint16(193), uint16(65), uint16(216), uint16(217), uint16(193), uint16(216), uint16(217), uint16(145), uint16(254), uint16(244), uint16(85), uint16(133), uint16(15), uint16(100), uint16(193), uint16(90), uint16(138), uint16(139), uint16(117), uint16(254), uint16(216), uint16(217), uint16(216), uint16(217), uint16(193), uint16(100), uint16(193), uint16(216), uint16(217), uint16(116), uint16(117), uint16(106), uint16(107), uint16(19), uint16(121), uint16(193), uint16(193), uint16(216), uint16(217), uint16(114), uint16(162), uint16(116), uint16(117), uint16(118), uint16(244), uint16(244), uint16(121), uint16(216), uint16(217), uint16(216), uint16(217), uint16(193), uint16(309), uint16(129), uint16(254), uint16(254), uint16(313), uint16(60), uint16(216), uint16(217), uint16(19), uint16(256), uint16(257), uint16(193), uint16(120), uint16(121), uint16(153), uint16(154), uint16(155), uint16(149), uint16(150), uint16(25), uint16(24), uint16(99), uint16(216), uint16(217), uint16(152), uint16(193), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(0), uint16(1), uint16(2), uint16(216), uint16(217), uint16(5), uint16(22), uint16(158), uint16(24), uint16(160), uint16(10), uint16(11), uint16(12), uint16(13), uint16(14), uint16(193), uint16(23), uint16(17), uint16(25), uint16(193), uint16(19), uint16(20), uint16(193), uint16(22), uint16(133), uint16(193), uint16(22), uint16(22), uint16(193), uint16(22), uint16(30), uint16(193), uint16(32), uint16(19), uint16(20), uint16(129), uint16(22), uint16(36), uint16(216), uint16(217), uint16(40), uint16(193), uint16(216), uint16(217), uint16(193), uint16(216), uint16(217), uint16(116), uint16(216), uint16(217), uint16(36), uint16(216), uint16(217), uint16(193), uint16(216), uint16(217), uint16(193), uint16(53), uint16(152), uint16(193), uint16(59), uint16(23), uint16(19), uint16(25), uint16(216), uint16(217), uint16(61), uint16(216), uint16(217), uint16(23), uint16(70), uint16(25), uint16(71), uint16(59), uint16(116), uint16(193), uint16(216), uint16(217), uint16(78), uint16(216), uint16(217), uint16(81), uint16(216), uint16(217), uint16(59), uint16(71), uint16(85), uint16(193), uint16(23), uint16(193), uint16(25), uint16(90), uint16(23), uint16(23), uint16(25), uint16(25), uint16(7), uint16(8), uint16(98), uint16(85), uint16(193), uint16(100), uint16(193), uint16(59), uint16(90), uint16(142), uint16(141), uint16(106), uint16(107), uint16(193), uint16(216), uint16(217), uint16(216), uint16(217), uint16(100), uint16(114), uint16(193), uint16(116), uint16(117), uint16(118), uint16(106), uint16(107), uint16(121), uint16(216), uint16(217), uint16(216), uint16(217), uint16(193), uint16(114), uint16(193), uint16(116), uint16(117), uint16(118), uint16(133), uint16(23), uint16(121), uint16(25), uint16(121), uint16(138), uint16(139), uint16(97), uint16(23), uint16(117), uint16(25), uint16(23), uint16(193), uint16(25), uint16(131), uint16(141), uint16(193), uint16(216), uint16(217), uint16(59), uint16(193), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(226), uint16(193), uint16(117), uint16(162), uint16(23), uint16(23), uint16(25), uint16(25), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(1), uint16(2), uint16(83), uint16(84), uint16(5), uint16(19), uint16(20), uint16(226), uint16(22), uint16(10), uint16(11), uint16(12), uint16(13), uint16(14), uint16(258), uint16(153), uint16(17), uint16(155), uint16(153), uint16(23), uint16(155), uint16(25), uint16(36), uint16(23), uint16(193), uint16(25), uint16(255), uint16(193), uint16(236), uint16(30), uint16(193), uint16(32), uint16(19), uint16(20), uint16(193), uint16(22), uint16(193), uint16(288), uint16(117), uint16(40), uint16(193), uint16(318), uint16(193), uint16(193), uint16(193), uint16(59), uint16(242), uint16(193), uint16(193), uint16(36), uint16(193), uint16(193), uint16(193), uint16(287), uint16(255), uint16(255), uint16(255), uint16(71), uint16(255), uint16(243), uint16(214), uint16(191), uint16(297), uint16(267), uint16(245), uint16(271), uint16(259), uint16(259), uint16(293), uint16(70), uint16(246), uint16(246), uint16(59), uint16(267), uint16(229), uint16(245), uint16(271), uint16(78), uint16(293), uint16(259), uint16(81), uint16(271), uint16(271), uint16(220), uint16(71), uint16(225), uint16(100), uint16(219), uint16(219), uint16(249), uint16(196), uint16(243), uint16(106), uint16(107), uint16(108), uint16(219), uint16(60), uint16(98), uint16(280), uint16(297), uint16(114), uint16(249), uint16(116), uint16(117), uint16(118), uint16(141), uint16(245), uint16(121), uint16(200), uint16(200), uint16(297), uint16(38), uint16(200), uint16(100), uint16(151), uint16(150), uint16(294), uint16(294), uint16(22), uint16(106), uint16(107), uint16(283), uint16(43), uint16(234), uint16(18), uint16(237), uint16(200), uint16(114), uint16(272), uint16(116), uint16(117), uint16(118), uint16(133), uint16(237), uint16(121), uint16(18), uint16(237), uint16(138), uint16(139), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(237), uint16(270), uint16(199), uint16(19), uint16(20), uint16(246), uint16(22), uint16(149), uint16(272), uint16(272), uint16(270), uint16(200), uint16(246), uint16(234), uint16(234), uint16(246), uint16(246), uint16(162), uint16(158), uint16(290), uint16(36), uint16(199), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(62), uint16(289), uint16(200), uint16(199), uint16(22), uint16(200), uint16(221), uint16(199), uint16(221), uint16(200), uint16(199), uint16(115), uint16(64), uint16(227), uint16(218), uint16(22), uint16(59), uint16(218), uint16(218), uint16(126), uint16(165), uint16(24), uint16(113), uint16(312), uint16(218), uint16(224), uint16(305), uint16(224), uint16(71), uint16(282), uint16(144), uint16(221), uint16(220), uint16(282), uint16(218), uint16(218), uint16(218), uint16(115), uint16(261), uint16(260), uint16(227), uint16(221), uint16(261), uint16(260), uint16(200), uint16(91), uint16(317), uint16(317), uint16(82), uint16(261), uint16(260), uint16(148), uint16(261), uint16(22), uint16(265), uint16(145), uint16(200), uint16(100), uint16(158), uint16(277), uint16(147), uint16(146), uint16(25), uint16(106), uint16(107), uint16(202), uint16(13), uint16(260), uint16(194), uint16(250), uint16(249), uint16(114), uint16(248), uint16(116), uint16(117), uint16(118), uint16(250), uint16(247), uint16(121), uint16(265), uint16(246), uint16(194), uint16(6), uint16(192), uint16(192), uint16(207), uint16(192), uint16(207), uint16(213), uint16(213), uint16(213), uint16(222), uint16(213), uint16(222), uint16(4), uint16(214), uint16(214), uint16(213), uint16(3), uint16(22), uint16(163), uint16(279), uint16(207), uint16(15), uint16(23), uint16(16), uint16(23), uint16(139), uint16(130), uint16(151), uint16(153), uint16(154), uint16(155), uint16(156), uint16(157), uint16(142), uint16(25), uint16(24), uint16(20), uint16(144), uint16(16), uint16(1), uint16(142), uint16(61), uint16(130), uint16(130), uint16(303), uint16(151), uint16(53), uint16(37), uint16(303), uint16(53), uint16(300), uint16(53), uint16(130), uint16(53), uint16(116), uint16(34), uint16(1), uint16(141), uint16(5), uint16(22), uint16(115), uint16(25), uint16(161), uint16(75), uint16(41), uint16(68), uint16(141), uint16(115), uint16(24), uint16(20), uint16(68), uint16(19), uint16(131), uint16(125), uint16(23), uint16(96), uint16(22), uint16(59), uint16(22), uint16(67), uint16(22), uint16(22), uint16(67), uint16(22), uint16(24), uint16(28), uint16(67), uint16(37), uint16(23), uint16(149), uint16(22), uint16(25), uint16(23), uint16(23), uint16(23), uint16(23), uint16(22), uint16(141), uint16(23), uint16(23), uint16(97), uint16(116), uint16(22), uint16(143), uint16(25), uint16(88), uint16(75), uint16(34), uint16(44), uint16(75), uint16(86), uint16(34), uint16(34), uint16(93), uint16(23), uint16(34), uint16(34), uint16(34), uint16(22), uint16(24), uint16(34), uint16(22), uint16(25), uint16(25), uint16(23), uint16(23), uint16(23), uint16(23), uint16(23), uint16(11), uint16(23), uint16(25), uint16(22), uint16(22), uint16(25), uint16(23), uint16(23), uint16(22), uint16(22), uint16(135), uint16(15), uint16(1), uint16(25), uint16(23), uint16(1), uint16(319), uint16(141), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(141), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(141), uint16(141), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319), uint16(319)}
var yy_shift_ofst [574]uint16 = [574]uint16{uint16(1648), uint16(1477), uint16(1272), uint16(322), uint16(322), uint16(262), uint16(1319), uint16(1478), uint16(1491), uint16(1662), uint16(1662), uint16(1662), uint16(317), uint16(0), uint16(0), uint16(214), uint16(1093), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(271), uint16(271), uint16(1219), uint16(1219), uint16(216), uint16(88), uint16(262), uint16(262), uint16(262), uint16(262), uint16(262), uint16(40), uint16(111), uint16(258), uint16(361), uint16(469), uint16(512), uint16(583), uint16(622), uint16(693), uint16(732), uint16(803), uint16(842), uint16(913), uint16(1073), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1093), uint16(1113), uint16(1093), uint16(1216), uint16(957), uint16(957), uint16(1635), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1777), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(1662), uint16(137), uint16(181), uint16(181), uint16(181), uint16(181), uint16(181), uint16(94), uint16(430), uint16(66), uint16(65), uint16(112), uint16(366), uint16(475), uint16(475), uint16(629), uint16(1058), uint16(475), uint16(475), uint16(125), uint16(125), uint16(475), uint16(686), uint16(686), uint16(686), uint16(660), uint16(686), uint16(57), uint16(184), uint16(184), uint16(77), uint16(77), uint16(2070), uint16(2070), uint16(328), uint16(328), uint16(328), uint16(493), uint16(373), uint16(373), uint16(373), uint16(373), uint16(1015), uint16(1015), uint16(409), uint16(366), uint16(1129), uint16(1149), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(621), uint16(621), uint16(475), uint16(852), uint16(899), uint16(899), uint16(1295), uint16(1295), uint16(406), uint16(851), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(1307), uint16(954), uint16(954), uint16(640), uint16(464), uint16(695), uint16(238), uint16(700), uint16(538), uint16(541), uint16(748), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(634), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(1175), uint16(1175), uint16(1175), uint16(475), uint16(475), uint16(475), uint16(580), uint16(475), uint16(475), uint16(475), uint16(1074), uint16(1142), uint16(475), uint16(475), uint16(1072), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(475), uint16(797), uint16(1330), uint16(740), uint16(1131), uint16(1131), uint16(1131), uint16(1131), uint16(1069), uint16(740), uint16(740), uint16(1209), uint16(167), uint16(926), uint16(1391), uint16(1038), uint16(1314), uint16(187), uint16(1408), uint16(1314), uint16(1408), uint16(1435), uint16(1109), uint16(1038), uint16(1038), uint16(1109), uint16(1038), uint16(187), uint16(1435), uint16(227), uint16(1090), uint16(941), uint16(1270), uint16(1270), uint16(1270), uint16(1408), uint16(1256), uint16(1256), uint16(1326), uint16(1440), uint16(513), uint16(1461), uint16(1685), uint16(1685), uint16(1613), uint16(1613), uint16(1722), uint16(1722), uint16(1613), uint16(1612), uint16(1614), uint16(1745), uint16(1728), uint16(1755), uint16(1755), uint16(1755), uint16(1755), uint16(1613), uint16(1766), uint16(1651), uint16(1614), uint16(1614), uint16(1651), uint16(1745), uint16(1728), uint16(1651), uint16(1728), uint16(1651), uint16(1613), uint16(1766), uint16(1653), uint16(1758), uint16(1613), uint16(1766), uint16(1802), uint16(1613), uint16(1766), uint16(1613), uint16(1766), uint16(1802), uint16(1716), uint16(1716), uint16(1716), uint16(1768), uint16(1813), uint16(1813), uint16(1802), uint16(1716), uint16(1713), uint16(1716), uint16(1768), uint16(1716), uint16(1716), uint16(1675), uint16(1817), uint16(1729), uint16(1729), uint16(1802), uint16(1706), uint16(1742), uint16(1706), uint16(1742), uint16(1706), uint16(1742), uint16(1706), uint16(1742), uint16(1613), uint16(1774), uint16(1774), uint16(1786), uint16(1786), uint16(1723), uint16(1730), uint16(1851), uint16(1613), uint16(1720), uint16(1723), uint16(1733), uint16(1735), uint16(1651), uint16(1857), uint16(1873), uint16(1873), uint16(1896), uint16(1896), uint16(1896), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(2070), uint16(207), uint16(915), uint16(1010), uint16(1030), uint16(1217), uint16(910), uint16(1170), uint16(1470), uint16(1368), uint16(1481), uint16(1442), uint16(1318), uint16(1383), uint16(1515), uint16(1482), uint16(1523), uint16(1542), uint16(1546), uint16(1547), uint16(1588), uint16(1595), uint16(1502), uint16(1338), uint16(1566), uint16(1493), uint16(1520), uint16(1521), uint16(1598), uint16(1617), uint16(1568), uint16(1618), uint16(1511), uint16(1514), uint16(1645), uint16(1649), uint16(1570), uint16(1484), uint16(1910), uint16(1915), uint16(1897), uint16(1757), uint16(1908), uint16(1909), uint16(1901), uint16(1903), uint16(1788), uint16(1778), uint16(1798), uint16(1911), uint16(1911), uint16(1913), uint16(1793), uint16(1918), uint16(1795), uint16(1924), uint16(1940), uint16(1800), uint16(1814), uint16(1911), uint16(1815), uint16(1882), uint16(1912), uint16(1911), uint16(1796), uint16(1895), uint16(1898), uint16(1900), uint16(1902), uint16(1824), uint16(1840), uint16(1923), uint16(1818), uint16(1957), uint16(1955), uint16(1939), uint16(1847), uint16(1803), uint16(1899), uint16(1938), uint16(1904), uint16(1890), uint16(1925), uint16(1827), uint16(1854), uint16(1946), uint16(1951), uint16(1954), uint16(1843), uint16(1850), uint16(1956), uint16(1914), uint16(1958), uint16(1960), uint16(1953), uint16(1961), uint16(1917), uint16(1920), uint16(1962), uint16(1881), uint16(1959), uint16(1963), uint16(1921), uint16(1952), uint16(1967), uint16(1842), uint16(1970), uint16(1971), uint16(1972), uint16(1973), uint16(1968), uint16(1974), uint16(1976), uint16(1905), uint16(1858), uint16(1977), uint16(1978), uint16(1887), uint16(1975), uint16(1982), uint16(1862), uint16(1981), uint16(1979), uint16(1980), uint16(1983), uint16(1984), uint16(1919), uint16(1933), uint16(1926), uint16(1966), uint16(1936), uint16(1922), uint16(1985), uint16(1993), uint16(1998), uint16(1997), uint16(1999), uint16(2000), uint16(1988), uint16(2003), uint16(1981), uint16(2004), uint16(2005), uint16(2006), uint16(2007), uint16(2008), uint16(2009), uint16(2001), uint16(2020), uint16(2012), uint16(2013), uint16(2014), uint16(2015), uint16(2017), uint16(2018), uint16(2011), uint16(1906), uint16(1907), uint16(1916), uint16(1927), uint16(1928), uint16(2019), uint16(2022), uint16(2027), uint16(2042), uint16(2045)}
var yy_reduce_ofst [409]int16 = [409]int16{int16(-125), int16(733), int16(789), int16(241), int16(293), int16(-123), int16(-193), int16(-191), int16(-183), int16(-187), int16(-180), int16(83), int16(133), int16(-207), int16(-198), int16(-267), int16(-175), int16(-6), int16(166), int16(313), int16(487), int16(396), int16(489), int16(598), int16(615), int16(685), int16(687), int16(79), int16(781), int16(857), int16(490), int16(616), int16(240), int16(334), int16(-188), int16(796), int16(841), int16(843), int16(1003), int16(1005), int16(1007), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(158), int16(203), int16(391), int16(576), int16(724), int16(726), int16(886), int16(1021), int16(1035), int16(1063), int16(1081), int16(1083), int16(1097), int16(1099), int16(1117), int16(1152), int16(1155), int16(1158), int16(1163), int16(1165), int16(1167), int16(1169), int16(1172), int16(1180), int16(1183), int16(1198), int16(1200), int16(1205), int16(1215), int16(1225), int16(1227), int16(1236), int16(1252), int16(1264), int16(1299), int16(1303), int16(1306), int16(1309), int16(1312), int16(1315), int16(1325), int16(1328), int16(1337), int16(1340), int16(1343), int16(1371), int16(1373), int16(1384), int16(1386), int16(1411), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-260), int16(-53), int16(138), int16(302), int16(-158), int16(357), int16(223), int16(-222), int16(411), int16(458), int16(-92), int16(556), int16(669), int16(581), int16(632), int16(581), int16(-260), int16(632), int16(758), int16(778), int16(920), int16(-260), int16(-260), int16(-260), int16(-260), int16(161), int16(161), int16(161), int16(307), int16(234), int16(392), int16(526), int16(790), int16(195), int16(359), int16(-174), int16(-173), int16(362), int16(362), int16(-189), int16(16), int16(560), int16(567), int16(261), int16(689), int16(802), int16(853), int16(-122), int16(-166), int16(408), int16(335), int16(617), int16(690), int16(837), int16(1001), int16(746), int16(1061), int16(515), int16(1082), int16(994), int16(1034), int16(-135), int16(1000), int16(1048), int16(1137), int16(877), int16(897), int16(186), int16(627), int16(1031), int16(1133), int16(1148), int16(1159), int16(1194), int16(1199), int16(1195), int16(-194), int16(-142), int16(18), int16(-152), int16(68), int16(201), int16(253), int16(269), int16(294), int16(354), int16(521), int16(528), int16(676), int16(680), int16(736), int16(743), int16(850), int16(907), int16(1041), int16(1047), int16(1060), int16(727), int16(1139), int16(1147), int16(1201), int16(1237), int16(1278), int16(1359), int16(1393), int16(1400), int16(1413), int16(1429), int16(1433), int16(1437), int16(1126), int16(1410), int16(1430), int16(1444), int16(1480), int16(1483), int16(1405), int16(1486), int16(1490), int16(1492), int16(1420), int16(1372), int16(1496), int16(1498), int16(1441), int16(1499), int16(253), int16(1500), int16(1503), int16(1504), int16(1506), int16(1507), int16(1508), int16(1398), int16(1415), int16(1453), int16(1448), int16(1449), int16(1450), int16(1452), int16(1405), int16(1453), int16(1453), int16(1465), int16(1495), int16(1519), int16(1414), int16(1443), int16(1445), int16(1468), int16(1456), int16(1455), int16(1457), int16(1424), int16(1473), int16(1454), int16(1459), int16(1474), int16(1460), int16(1479), int16(1434), int16(1512), int16(1494), int16(1509), int16(1517), int16(1518), int16(1525), int16(1469), int16(1489), int16(1501), int16(1467), int16(1510), int16(1497), int16(1543), int16(1451), int16(1462), int16(1557), int16(1558), int16(1471), int16(1472), int16(1561), int16(1487), int16(1505), int16(1524), int16(1538), int16(1537), int16(1545), int16(1548), int16(1556), int16(1575), int16(1596), int16(1552), int16(1529), int16(1530), int16(1559), int16(1533), int16(1572), int16(1562), int16(1573), int16(1563), int16(1604), int16(1615), int16(1522), int16(1532), int16(1622), int16(1624), int16(1605), int16(1625), int16(1628), int16(1629), int16(1631), int16(1607), int16(1616), int16(1619), int16(1620), int16(1606), int16(1621), int16(1623), int16(1630), int16(1626), int16(1632), int16(1636), int16(1633), int16(1637), int16(1638), int16(1531), int16(1541), int16(1567), int16(1571), int16(1640), int16(1597), int16(1599), int16(1601), int16(1603), int16(1608), int16(1610), int16(1611), int16(1627), int16(1664), int16(1549), int16(1550), int16(1609), int16(1634), int16(1639), int16(1641), int16(1602), int16(1676), int16(1642), int16(1646), int16(1644), int16(1650), int16(1654), int16(1683), int16(1694), int16(1707), int16(1711), int16(1712), int16(1714), int16(1643), int16(1647), int16(1652), int16(1698), int16(1695), int16(1696), int16(1697), int16(1699), int16(1700), int16(1689), int16(1691), int16(1701), int16(1702), int16(1704), int16(1715)}
var yy_default [574]uint16 = [574]uint16{uint16(1637), uint16(1637), uint16(1637), uint16(1466), uint16(1233), uint16(1344), uint16(1233), uint16(1233), uint16(1233), uint16(1466), uint16(1466), uint16(1466), uint16(1233), uint16(1374), uint16(1374), uint16(1519), uint16(1266), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1465), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1554), uint16(1554), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1383), uint16(1233), uint16(1390), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1467), uint16(1468), uint16(1233), uint16(1233), uint16(1233), uint16(1518), uint16(1520), uint16(1483), uint16(1397), uint16(1396), uint16(1395), uint16(1394), uint16(1501), uint16(1361), uint16(1388), uint16(1381), uint16(1385), uint16(1461), uint16(1462), uint16(1460), uint16(1464), uint16(1468), uint16(1467), uint16(1233), uint16(1384), uint16(1431), uint16(1445), uint16(1430), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1439), uint16(1444), uint16(1451), uint16(1443), uint16(1440), uint16(1433), uint16(1432), uint16(1434), uint16(1435), uint16(1233), uint16(1233), uint16(1257), uint16(1233), uint16(1233), uint16(1254), uint16(1308), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1538), uint16(1537), uint16(1233), uint16(1436), uint16(1233), uint16(1266), uint16(1425), uint16(1424), uint16(1448), uint16(1437), uint16(1447), uint16(1446), uint16(1526), uint16(1590), uint16(1589), uint16(1484), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1554), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1554), uint16(1554), uint16(1233), uint16(1266), uint16(1554), uint16(1554), uint16(1262), uint16(1262), uint16(1368), uint16(1233), uint16(1533), uint16(1335), uint16(1335), uint16(1335), uint16(1335), uint16(1344), uint16(1335), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1523), uint16(1521), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1340), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1583), uint16(1233), uint16(1496), uint16(1322), uint16(1340), uint16(1340), uint16(1340), uint16(1340), uint16(1342), uint16(1323), uint16(1321), uint16(1334), uint16(1267), uint16(1240), uint16(1629), uint16(1400), uint16(1389), uint16(1341), uint16(1363), uint16(1389), uint16(1363), uint16(1626), uint16(1387), uint16(1400), uint16(1400), uint16(1387), uint16(1400), uint16(1341), uint16(1626), uint16(1283), uint16(1606), uint16(1278), uint16(1374), uint16(1374), uint16(1374), uint16(1363), uint16(1368), uint16(1368), uint16(1463), uint16(1341), uint16(1334), uint16(1233), uint16(1629), uint16(1629), uint16(1349), uint16(1349), uint16(1628), uint16(1628), uint16(1349), uint16(1484), uint16(1613), uint16(1409), uint16(1311), uint16(1317), uint16(1317), uint16(1317), uint16(1317), uint16(1349), uint16(1251), uint16(1387), uint16(1613), uint16(1613), uint16(1387), uint16(1409), uint16(1311), uint16(1387), uint16(1311), uint16(1387), uint16(1349), uint16(1251), uint16(1500), uint16(1623), uint16(1349), uint16(1251), uint16(1474), uint16(1349), uint16(1251), uint16(1349), uint16(1251), uint16(1474), uint16(1309), uint16(1309), uint16(1309), uint16(1298), uint16(1233), uint16(1233), uint16(1474), uint16(1309), uint16(1283), uint16(1309), uint16(1298), uint16(1309), uint16(1309), uint16(1572), uint16(1233), uint16(1478), uint16(1478), uint16(1474), uint16(1367), uint16(1362), uint16(1367), uint16(1362), uint16(1367), uint16(1362), uint16(1367), uint16(1362), uint16(1349), uint16(1564), uint16(1564), uint16(1377), uint16(1377), uint16(1382), uint16(1368), uint16(1469), uint16(1349), uint16(1233), uint16(1382), uint16(1380), uint16(1378), uint16(1387), uint16(1301), uint16(1586), uint16(1586), uint16(1582), uint16(1582), uint16(1582), uint16(1634), uint16(1634), uint16(1533), uint16(1599), uint16(1266), uint16(1266), uint16(1266), uint16(1266), uint16(1599), uint16(1285), uint16(1285), uint16(1267), uint16(1267), uint16(1266), uint16(1599), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1594), uint16(1233), uint16(1528), uint16(1485), uint16(1353), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1539), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1414), uint16(1233), uint16(1236), uint16(1530), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1391), uint16(1392), uint16(1354), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1406), uint16(1233), uint16(1233), uint16(1233), uint16(1401), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1625), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1499), uint16(1498), uint16(1233), uint16(1233), uint16(1351), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1281), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1379), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1569), uint16(1369), uint16(1233), uint16(1233), uint16(1616), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1233), uint16(1610), uint16(1325), uint16(1416), uint16(1233), uint16(1415), uint16(1419), uint16(1255), uint16(1233), uint16(1245), uint16(1233), uint16(1233)}
var yyFallback [185]uint16 = [185]uint16{uint16(0), uint16(0), uint16(59), uint16(59), uint16(59), uint16(59), uint16(0), uint16(59), uint16(59), uint16(59), uint16(0), uint16(59), uint16(59), uint16(59), uint16(59), uint16(0), uint16(0), uint16(0), uint16(59), uint16(0), uint16(0), uint16(59), uint16(0), uint16(0), uint16(0), uint16(0), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(0), uint16(0), uint16(0), uint16(59), uint16(59), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(59), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0), uint16(0)}

type struct_yyStackEntry struct {
	stateno uint16
	major   uint16
	minor   _cgoa_88
}
type yyStackEntry = struct_yyStackEntry
type struct_yyParser struct {
	yytos      *struct_yyStackEntry
	pParse     *struct_Parse
	yystack    [100]struct_yyStackEntry
	yystackEnd *struct_yyStackEntry
}
type yyParser = struct_yyParser

func sqlite3ParserInit(yypRawParser unsafe.Pointer, pParse *struct_Parse) {
	var yypParser *struct_yyParser = (*struct_yyParser)(yypRawParser)
	yypParser.pParse = pParse
	yypParser.yytos = (*struct_yyStackEntry)(unsafe.Pointer(&yypParser.yystack))
	(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_yyStackEntry)(unsafe.Pointer(&yypParser.yystack)))) + uintptr(0)*24))).stateno = uint16(0)
	(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_yyStackEntry)(unsafe.Pointer(&yypParser.yystack)))) + uintptr(0)*24))).major = uint16(0)
	yypParser.yystackEnd = &*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_yyStackEntry)(unsafe.Pointer(&yypParser.yystack)))) + uintptr(100-1)*24))
}
func yy_destructor(yypParser *struct_yyParser, yymajor uint16, yypminor *_cgoa_88) {
	var pParse *struct_Parse = yypParser.pParse
	switch int32(yymajor) {
	case 204:
		fallthrough
	case 239:
		fallthrough
	case 240:
		fallthrough
	case 252:
		{
			sqlite3SelectDelete(pParse.db, *(**struct_Select)(unsafe.Pointer(yypminor)))
		}
		break
	case 216:
		fallthrough
	case 217:
		fallthrough
	case 246:
		fallthrough
	case 248:
		fallthrough
	case 260:
		fallthrough
	case 267:
		fallthrough
	case 278:
		fallthrough
	case 280:
		fallthrough
	case 283:
		fallthrough
	case 290:
		fallthrough
	case 295:
		fallthrough
	case 311:
		{
			sqlite3ExprDelete(pParse.db, *(**struct_Expr)(unsafe.Pointer(yypminor)))
		}
		break
	case 221:
		fallthrough
	case 231:
		fallthrough
	case 232:
		fallthrough
	case 244:
		fallthrough
	case 247:
		fallthrough
	case 249:
		fallthrough
	case 253:
		fallthrough
	case 254:
		fallthrough
	case 262:
		fallthrough
	case 268:
		fallthrough
	case 277:
		fallthrough
	case 279:
		fallthrough
	case 310:
		{
			sqlite3ExprListDelete(pParse.db, *(**struct_ExprList)(unsafe.Pointer(yypminor)))
		}
		break
	case 238:
		fallthrough
	case 245:
		fallthrough
	case 256:
		fallthrough
	case 257:
		fallthrough
	case 263:
		{
			sqlite3SrcListDelete(pParse.db, *(**struct_SrcList)(unsafe.Pointer(yypminor)))
		}
		break
	case 241:
		{
			sqlite3WithDelete(pParse.db, *(**struct_With)(unsafe.Pointer(yypminor)))
		}
		break
	case 251:
		fallthrough
	case 306:
		{
			sqlite3WindowListDelete(pParse.db, *(**struct_Window)(unsafe.Pointer(yypminor)))
		}
		break
	case 261:
		fallthrough
	case 264:
		fallthrough
	case 270:
		{
			sqlite3IdListDelete(pParse.db, *(**struct_IdList)(unsafe.Pointer(yypminor)))
		}
		break
	case 273:
		fallthrough
	case 307:
		fallthrough
	case 308:
		fallthrough
	case 309:
		fallthrough
	case 312:
		{
			sqlite3WindowDelete(pParse.db, *(**struct_Window)(unsafe.Pointer(yypminor)))
		}
		break
	case 286:
		fallthrough
	case 291:
		{
			sqlite3DeleteTriggerStep(pParse.db, *(**struct_TriggerStep)(unsafe.Pointer(yypminor)))
		}
		break
	case 288:
		{
			sqlite3IdListDelete(pParse.db, yypminor.yy180.b)
		}
		break
	case 314:
		fallthrough
	case 315:
		fallthrough
	case 316:
		{
			sqlite3ExprDelete(pParse.db, (*(*struct_FrameBound)(unsafe.Pointer(yypminor))).pExpr)
		}
		break
	default:
		break
	}
}
func yy_pop_parser_stack(pParser *struct_yyParser) {
	var yytos *struct_yyStackEntry
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	yytos = func() (_cgo_ret *struct_yyStackEntry) {
		_cgo_addr := &pParser.yytos
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr)) -= 24
		return
	}()
	yy_destructor(pParser, yytos.major, &yytos.minor)
}
func sqlite3ParserFinalize(p unsafe.Pointer) {
	var pParser *struct_yyParser = (*struct_yyParser)(p)
	for uintptr(unsafe.Pointer(pParser.yytos)) > uintptr(unsafe.Pointer((*struct_yyStackEntry)(unsafe.Pointer(&pParser.yystack)))) {
		yy_pop_parser_stack(pParser)
	}
}
func yy_find_shift_action(iLookAhead uint16, stateno uint16) uint16 {
	var i int32
	if int32(stateno) > 573 {
		return stateno
	}
	func() int {
		_ = 0
		return 0
	}()
	for {
		i = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_shift_ofst)))) + uintptr(stateno)*2)))
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		i += int32(iLookAhead)
		func() int {
			_ = 0
			return 0
		}()
		if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_lookahead)))) + uintptr(i)*2))) != int32(iLookAhead) {
			var iFallback uint16
			func() int {
				_ = 0
				return 0
			}()
			iFallback = *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yyFallback)))) + uintptr(iLookAhead)*2))
			if int32(iFallback) != 0 {
				func() int {
					_ = 0
					return 0
				}()
				iLookAhead = iFallback
				continue
			}
			{
				var j int32 = i - int32(iLookAhead) + 101
				func() int {
					_ = 0
					return 0
				}()
				if int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_lookahead)))) + uintptr(j)*2))) == 101 && int32(iLookAhead) > 0 {
					return *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_action)))) + uintptr(j)*2))
				}
			}
			return *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_default)))) + uintptr(stateno)*2))
		} else {
			func() int {
				_ = 0
				return 0
			}()
			return *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_action)))) + uintptr(i)*2))
		}
		if false {
			break
		}
	}
}
func yy_find_reduce_action(stateno uint16, iLookAhead uint16) uint16 {
	var i int32
	func() int {
		_ = 0
		return 0
	}()
	i = int32(*(*int16)(unsafe.Pointer(uintptr(unsafe.Pointer((*int16)(unsafe.Pointer(&yy_reduce_ofst)))) + uintptr(stateno)*2)))
	func() int {
		_ = 0
		return 0
	}()
	i += int32(iLookAhead)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	return *(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yy_action)))) + uintptr(i)*2))
}
func yyStackOverflow(yypParser *struct_yyParser) {
	var pParse *struct_Parse = yypParser.pParse
	for uintptr(unsafe.Pointer(yypParser.yytos)) > uintptr(unsafe.Pointer((*struct_yyStackEntry)(unsafe.Pointer(&yypParser.yystack)))) {
		yy_pop_parser_stack(yypParser)
	}
	sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[22]int8{'p', 'a', 'r', 's', 'e', 'r', ' ', 's', 't', 'a', 'c', 'k', ' ', 'o', 'v', 'e', 'r', 'f', 'l', 'o', 'w', '\x00'})))
	yypParser.pParse = pParse
}
func yy_shift(yypParser *struct_yyParser, yyNewState uint16, yyMajor uint16, yyMinor struct_Token) {
	var yytos *struct_yyStackEntry
	*(*uintptr)(unsafe.Pointer(&yypParser.yytos)) += 24
	if uintptr(unsafe.Pointer(yypParser.yytos)) > uintptr(unsafe.Pointer(yypParser.yystackEnd)) {
		*(*uintptr)(unsafe.Pointer(&yypParser.yytos)) -= 24
		yyStackOverflow(yypParser)
		return
	}
	if int32(yyNewState) > 573 {
		yyNewState += uint16(1236 - 831)
	}
	yytos = yypParser.yytos
	yytos.stateno = yyNewState
	yytos.major = yyMajor
	*(*struct_Token)(unsafe.Pointer(&yytos.minor)) = yyMinor
}

var yyRuleInfoLhs [402]uint16 = [402]uint16{uint16(189), uint16(189), uint16(188), uint16(190), uint16(191), uint16(191), uint16(191), uint16(191), uint16(190), uint16(190), uint16(190), uint16(190), uint16(190), uint16(195), uint16(197), uint16(199), uint16(199), uint16(198), uint16(198), uint16(196), uint16(196), uint16(203), uint16(203), uint16(205), uint16(205), uint16(206), uint16(208), uint16(208), uint16(208), uint16(209), uint16(213), uint16(214), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(215), uint16(224), uint16(224), uint16(220), uint16(220), uint16(222), uint16(222), uint16(225), uint16(225), uint16(225), uint16(225), uint16(226), uint16(226), uint16(226), uint16(226), uint16(226), uint16(223), uint16(223), uint16(227), uint16(227), uint16(227), uint16(202), uint16(229), uint16(230), uint16(230), uint16(230), uint16(230), uint16(230), uint16(233), uint16(218), uint16(218), uint16(234), uint16(234), uint16(235), uint16(235), uint16(190), uint16(237), uint16(237), uint16(190), uint16(190), uint16(190), uint16(204), uint16(204), uint16(204), uint16(239), uint16(242), uint16(242), uint16(242), uint16(240), uint16(240), uint16(252), uint16(252), uint16(243), uint16(243), uint16(243), uint16(254), uint16(244), uint16(244), uint16(244), uint16(255), uint16(255), uint16(245), uint16(245), uint16(257), uint16(257), uint16(256), uint16(256), uint16(256), uint16(256), uint16(200), uint16(200), uint16(238), uint16(238), uint16(263), uint16(263), uint16(263), uint16(263), uint16(258), uint16(258), uint16(258), uint16(258), uint16(260), uint16(260), uint16(259), uint16(259), uint16(259), uint16(261), uint16(261), uint16(249), uint16(249), uint16(231), uint16(231), uint16(219), uint16(219), uint16(219), uint16(265), uint16(265), uint16(265), uint16(247), uint16(247), uint16(248), uint16(248), uint16(250), uint16(250), uint16(250), uint16(250), uint16(190), uint16(246), uint16(246), uint16(267), uint16(267), uint16(267), uint16(267), uint16(190), uint16(268), uint16(268), uint16(268), uint16(268), uint16(190), uint16(190), uint16(271), uint16(271), uint16(271), uint16(271), uint16(271), uint16(271), uint16(272), uint16(269), uint16(269), uint16(270), uint16(270), uint16(264), uint16(264), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(216), uint16(216), uint16(216), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(216), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(274), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(275), uint16(275), uint16(217), uint16(276), uint16(276), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(217), uint16(279), uint16(279), uint16(280), uint16(280), uint16(278), uint16(278), uint16(262), uint16(253), uint16(253), uint16(277), uint16(277), uint16(190), uint16(281), uint16(281), uint16(221), uint16(221), uint16(232), uint16(232), uint16(282), uint16(282), uint16(190), uint16(190), uint16(190), uint16(283), uint16(283), uint16(190), uint16(190), uint16(190), uint16(190), uint16(190), uint16(211), uint16(212), uint16(190), uint16(285), uint16(287), uint16(287), uint16(287), uint16(288), uint16(288), uint16(288), uint16(290), uint16(290), uint16(286), uint16(286), uint16(292), uint16(293), uint16(293), uint16(291), uint16(291), uint16(291), uint16(291), uint16(217), uint16(217), uint16(236), uint16(236), uint16(236), uint16(190), uint16(190), uint16(190), uint16(295), uint16(295), uint16(190), uint16(190), uint16(190), uint16(190), uint16(190), uint16(190), uint16(190), uint16(296), uint16(190), uint16(190), uint16(190), uint16(298), uint16(300), uint16(301), uint16(301), uint16(302), uint16(266), uint16(266), uint16(305), uint16(305), uint16(305), uint16(304), uint16(241), uint16(241), uint16(306), uint16(306), uint16(307), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(308), uint16(309), uint16(309), uint16(309), uint16(313), uint16(315), uint16(315), uint16(316), uint16(316), uint16(314), uint16(314), uint16(317), uint16(317), uint16(318), uint16(318), uint16(318), uint16(251), uint16(273), uint16(273), uint16(273), uint16(312), uint16(312), uint16(311), uint16(185), uint16(186), uint16(186), uint16(187), uint16(187), uint16(187), uint16(192), uint16(192), uint16(192), uint16(194), uint16(194), uint16(190), uint16(203), uint16(201), uint16(201), uint16(193), uint16(193), uint16(193), uint16(208), uint16(209), uint16(210), uint16(210), uint16(207), uint16(207), uint16(215), uint16(215), uint16(215), uint16(202), uint16(228), uint16(228), uint16(229), uint16(233), uint16(235), uint16(239), uint16(240), uint16(254), uint16(255), uint16(272), uint16(217), uint16(274), uint16(262), uint16(284), uint16(284), uint16(284), uint16(284), uint16(284), uint16(211), uint16(289), uint16(289), uint16(292), uint16(293), uint16(294), uint16(294), uint16(297), uint16(297), uint16(299), uint16(299), uint16(300), uint16(303), uint16(303), uint16(303), uint16(266)}
var yyRuleInfoNRhs [402]int8 = [402]int8{int8(-1), int8(-3), int8(-1), int8(-3), int8(0), int8(-1), int8(-1), int8(-1), int8(-2), int8(-2), int8(-2), int8(-3), int8(-5), int8(-6), int8(-1), int8(0), int8(-3), int8(-1), int8(0), int8(-5), int8(-2), int8(0), int8(-3), int8(-2), int8(-1), int8(-2), int8(0), int8(-4), int8(-6), int8(-2), int8(0), int8(0), int8(-2), int8(-3), int8(-4), int8(-4), int8(-4), int8(-3), int8(-3), int8(-5), int8(-2), int8(-4), int8(-4), int8(-1), int8(-2), int8(-3), int8(-4), int8(0), int8(-1), int8(0), int8(-2), int8(-2), int8(-3), int8(-3), int8(-3), int8(-2), int8(-2), int8(-1), int8(-1), int8(-2), int8(-3), int8(-2), int8(0), int8(-2), int8(-2), int8(0), int8(-1), int8(-2), int8(-7), int8(-5), int8(-5), int8(-10), int8(0), int8(0), int8(-3), int8(0), int8(-2), int8(-1), int8(-1), int8(-4), int8(-2), int8(0), int8(-9), int8(-4), int8(-1), int8(-3), int8(-4), int8(-1), int8(-3), int8(-1), int8(-2), int8(-1), int8(-9), int8(-10), int8(-4), int8(-5), int8(-1), int8(-1), int8(0), int8(0), int8(-5), int8(-3), int8(-5), int8(-2), int8(0), int8(0), int8(-2), int8(-2), int8(0), int8(-7), int8(-9), int8(-7), int8(-7), int8(0), int8(-2), int8(-1), int8(-3), int8(-1), int8(-3), int8(-5), int8(-3), int8(-1), int8(-2), int8(-3), int8(-4), int8(-2), int8(0), int8(0), int8(-3), int8(-2), int8(-4), int8(0), int8(0), int8(-3), int8(-5), int8(-3), int8(-1), int8(-1), int8(0), int8(-2), int8(-2), int8(0), int8(0), int8(-3), int8(0), int8(-2), int8(0), int8(-2), int8(-4), int8(-4), int8(-6), int8(0), int8(-2), int8(0), int8(-2), int8(-2), int8(-4), int8(-9), int8(-5), int8(-7), int8(-3), int8(-5), int8(-7), int8(-8), int8(0), int8(-2), int8(-12), int8(-9), int8(-5), int8(-8), int8(-2), int8(-2), int8(-1), int8(0), int8(-3), int8(-3), int8(-1), int8(-3), int8(-1), int8(-1), int8(-3), int8(-5), int8(-1), int8(-1), int8(-1), int8(-1), int8(-3), int8(-6), int8(-5), int8(-4), int8(-6), int8(-5), int8(-1), int8(-5), int8(-3), int8(-3), int8(-3), int8(-3), int8(-3), int8(-3), int8(-3), int8(-3), int8(-2), int8(-3), int8(-5), int8(-2), int8(-3), int8(-3), int8(-4), int8(-2), int8(-2), int8(-2), int8(-3), int8(-1), int8(-2), int8(-5), int8(-1), int8(-2), int8(-5), int8(-3), int8(-5), int8(-5), int8(-4), int8(-5), int8(-5), int8(-4), int8(-2), int8(0), int8(-1), int8(0), int8(0), int8(-3), int8(-1), int8(0), int8(-3), int8(-12), int8(-1), int8(0), int8(0), int8(-3), int8(-5), int8(-3), int8(0), int8(-2), int8(-4), int8(-2), int8(-3), int8(-2), int8(0), int8(-3), int8(-5), int8(-6), int8(-5), int8(-6), int8(-2), int8(-2), int8(-5), int8(-11), int8(-1), int8(-2), int8(0), int8(-1), int8(-1), int8(-3), int8(0), int8(-2), int8(-3), int8(-2), int8(-3), int8(-3), int8(-2), int8(-9), int8(-8), int8(-6), int8(-3), int8(-4), int8(-6), int8(-1), int8(-1), int8(-1), int8(-4), int8(-6), int8(-3), int8(0), int8(-2), int8(-1), int8(-3), int8(-1), int8(-3), int8(-6), int8(-7), int8(-6), int8(-1), int8(-8), int8(-1), int8(-4), int8(-8), int8(0), int8(-1), int8(-3), int8(-1), int8(-2), int8(-3), int8(-1), int8(-2), int8(-3), int8(-6), int8(-1), int8(-3), int8(-1), int8(-3), int8(-5), int8(-5), int8(-6), int8(-4), int8(-5), int8(-1), int8(-2), int8(0), int8(-3), int8(-6), int8(-1), int8(-1), int8(-2), int8(-1), int8(-2), int8(-2), int8(-2), int8(0), int8(-2), int8(-2), int8(-2), int8(-1), int8(-2), int8(-2), int8(-1), int8(-1), int8(-4), int8(-2), int8(-5), int8(-1), int8(-2), int8(-1), int8(-1), int8(-2), int8(-3), int8(0), int8(-1), int8(-2), int8(-1), int8(0), int8(-2), int8(-1), int8(-4), int8(-2), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-2), int8(0), int8(-2), int8(-4), int8(-2), int8(-2), int8(-3), int8(-1), int8(0), int8(-1), int8(-1), int8(-1), int8(-1), int8(-2), int8(-1), int8(0), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(-1), int8(0), int8(-3), int8(-1), int8(0), int8(-1), int8(0), int8(0), int8(-1), int8(-1), int8(-3), int8(-2), int8(0), int8(-4), int8(-2), int8(0)}

func yy_reduce(yypParser *struct_yyParser, yyruleno uint32, yyLookahead int32, yyLookaheadToken struct_Token, pParse *struct_Parse) uint16 {
	var yylhsminor_cgo2 _cgoa_88
	var yygoto int32
	var yyact uint16
	var yymsp *struct_yyStackEntry
	var yysize int32
	func() int {
		_ = yyLookahead
		return 0
	}()
	func() int {
		_ = yyLookaheadToken
		return 0
	}()
	yymsp = yypParser.yytos
	_cgo_nm, _cgo_tag := true, yyruleno
	goto _cgol_1
	yylhsminor_cgo2 = struct {
		yy180 struct_TrigEvent
	}{}
_cgol_1:
	if _cgo_nm && _cgo_tag != uint32(0) {
		goto _cgol_3
	}
	_cgo_nm = false
	{
		pParse.explain = uint8(1)
	}
	goto _cgol_4
_cgol_3:
	if _cgo_nm && _cgo_tag != uint32(1) {
		goto _cgol_5
	}
	_cgo_nm = false
	{
		pParse.explain = uint8(2)
	}
	goto _cgol_4
_cgol_5:
	if _cgo_nm && _cgo_tag != uint32(2) {
		goto _cgol_6
	}
	_cgo_nm = false
	{
		sqlite3FinishCoding(pParse)
	}
	goto _cgol_4
_cgol_6:
	if _cgo_nm && _cgo_tag != uint32(3) {
		goto _cgol_7
	}
	_cgo_nm = false
	{
		sqlite3BeginTransaction(pParse, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_7:
	if _cgo_nm && _cgo_tag != uint32(4) {
		goto _cgol_8
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(7)
	}
	goto _cgol_4
_cgol_8:
	if _cgo_nm && _cgo_tag != uint32(5) {
		goto _cgol_9
	}
	_cgo_nm = false
_cgol_9:
	if _cgo_nm && _cgo_tag != uint32(6) {
		goto _cgol_10
	}
	_cgo_nm = false
_cgol_10:
	if _cgo_nm && _cgo_tag != uint32(7) {
		goto _cgol_11
	}
	_cgo_nm = false
_cgol_11:
	if _cgo_nm && _cgo_tag != uint32(321) {
		goto _cgol_12
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major)
	}
	goto _cgol_4
_cgol_12:
	if _cgo_nm && _cgo_tag != uint32(8) {
		goto _cgol_13
	}
	_cgo_nm = false
_cgol_13:
	if _cgo_nm && _cgo_tag != uint32(9) {
		goto _cgol_14
	}
	_cgo_nm = false
	{
		sqlite3EndTransaction(pParse, int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).major))
	}
	goto _cgol_4
_cgol_14:
	if _cgo_nm && _cgo_tag != uint32(10) {
		goto _cgol_15
	}
	_cgo_nm = false
	{
		sqlite3Savepoint(pParse, 0, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_15:
	if _cgo_nm && _cgo_tag != uint32(11) {
		goto _cgol_16
	}
	_cgo_nm = false
	{
		sqlite3Savepoint(pParse, 1, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_16:
	if _cgo_nm && _cgo_tag != uint32(12) {
		goto _cgol_17
	}
	_cgo_nm = false
	{
		sqlite3Savepoint(pParse, 2, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_17:
	if _cgo_nm && _cgo_tag != uint32(13) {
		goto _cgol_18
	}
	_cgo_nm = false
	{
		sqlite3StartTable(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), 0, 0, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
	}
	goto _cgol_4
_cgol_18:
	if _cgo_nm && _cgo_tag != uint32(14) {
		goto _cgol_19
	}
	_cgo_nm = false
	{
		disableLookaside(pParse)
	}
	goto _cgol_4
_cgol_19:
	if _cgo_nm && _cgo_tag != uint32(15) {
		goto _cgol_20
	}
	_cgo_nm = false
_cgol_20:
	if _cgo_nm && _cgo_tag != uint32(18) {
		goto _cgol_21
	}
	_cgo_nm = false
_cgol_21:
	if _cgo_nm && _cgo_tag != uint32(47) {
		goto _cgol_22
	}
	_cgo_nm = false
_cgol_22:
	if _cgo_nm && _cgo_tag != uint32(62) {
		goto _cgol_23
	}
	_cgo_nm = false
_cgol_23:
	if _cgo_nm && _cgo_tag != uint32(72) {
		goto _cgol_24
	}
	_cgo_nm = false
_cgol_24:
	if _cgo_nm && _cgo_tag != uint32(81) {
		goto _cgol_25
	}
	_cgo_nm = false
_cgol_25:
	if _cgo_nm && _cgo_tag != uint32(98) {
		goto _cgol_26
	}
	_cgo_nm = false
_cgol_26:
	if _cgo_nm && _cgo_tag != uint32(242) {
		goto _cgol_27
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_27:
	if _cgo_nm && _cgo_tag != uint32(16) {
		goto _cgol_28
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_28:
	if _cgo_nm && _cgo_tag != uint32(17) {
		goto _cgol_29
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = func() int32 {
			if int32(pParse.db.init.busy) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
	goto _cgol_4
_cgol_29:
	if _cgo_nm && _cgo_tag != uint32(19) {
		goto _cgol_30
	}
	_cgo_nm = false
	{
		sqlite3EndTable(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_30:
	if _cgo_nm && _cgo_tag != uint32(20) {
		goto _cgol_31
	}
	_cgo_nm = false
	{
		sqlite3EndTable(pParse, nil, nil, uint32(0), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		sqlite3SelectDelete(pParse.db, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_31:
	if _cgo_nm && _cgo_tag != uint32(21) {
		goto _cgol_32
	}
	_cgo_nm = false
	{
		*(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = uint32(0)
	}
	goto _cgol_4
_cgol_32:
	if _cgo_nm && _cgo_tag != uint32(22) {
		goto _cgol_33
	}
	_cgo_nm = false
	{
		*(*uint32)(unsafe.Pointer(&yylhsminor_cgo2)) = *(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) | *(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	*(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(*uint32)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_33:
	if _cgo_nm && _cgo_tag != uint32(23) {
		goto _cgol_34
	}
	_cgo_nm = false
	{
		if (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n == uint32(5) && sqlite3_strnicmp((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z, (*int8)(unsafe.Pointer(&[6]int8{'r', 'o', 'w', 'i', 'd', '\x00'})), 5) == 0 {
			*(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = uint32(128 | 512)
		} else {
			*(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = uint32(0)
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'o', 'p', 't', 'i', 'o', 'n', ':', ' ', '%', '.', '*', 's', '\x00'})), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)
		}
	}
	goto _cgol_4
_cgol_34:
	if _cgo_nm && _cgo_tag != uint32(24) {
		goto _cgol_35
	}
	_cgo_nm = false
	{
		if (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n == uint32(6) && sqlite3_strnicmp((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z, (*int8)(unsafe.Pointer(&[7]int8{'s', 't', 'r', 'i', 'c', 't', '\x00'})), 6) == 0 {
			*(*uint32)(unsafe.Pointer(&yylhsminor_cgo2)) = uint32(65536)
		} else {
			*(*uint32)(unsafe.Pointer(&yylhsminor_cgo2)) = uint32(0)
			sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[27]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'o', 'p', 't', 'i', 'o', 'n', ':', ' ', '%', '.', '*', 's', '\x00'})), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)
		}
	}
	*(*uint32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(*uint32)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_35:
	if _cgo_nm && _cgo_tag != uint32(25) {
		goto _cgol_36
	}
	_cgo_nm = false
	{
		sqlite3AddColumn(pParse, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_36:
	if _cgo_nm && _cgo_tag != uint32(26) {
		goto _cgol_37
	}
	_cgo_nm = false
_cgol_37:
	if _cgo_nm && _cgo_tag != uint32(65) {
		goto _cgol_38
	}
	_cgo_nm = false
_cgol_38:
	if _cgo_nm && _cgo_tag != uint32(104) {
		goto _cgol_39
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor))).n = uint32(0)
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor))).z = (*int8)(nil)
	}
	goto _cgol_4
_cgol_39:
	if _cgo_nm && _cgo_tag != uint32(27) {
		goto _cgol_40
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).n = uint32(int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)) + uintptr((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n))))) - uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).z))))
	}
	goto _cgol_4
_cgol_40:
	if _cgo_nm && _cgo_tag != uint32(28) {
		goto _cgol_41
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor))).n = uint32(int32(uintptr(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)) + uintptr((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n))))) - uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor))).z))))
	}
	goto _cgol_4
_cgol_41:
	if _cgo_nm && _cgo_tag != uint32(29) {
		goto _cgol_42
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n = (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n + uint32(int32(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z))-uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z))))
	}
	goto _cgol_4
_cgol_42:
	if _cgo_nm && _cgo_tag != uint32(30) {
		goto _cgol_43
	}
	_cgo_nm = false
	{
		func() int {
			_ = 0
			return 0
		}()
		*(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = yyLookaheadToken.z
	}
	goto _cgol_4
_cgol_43:
	if _cgo_nm && _cgo_tag != uint32(31) {
		goto _cgol_44
	}
	_cgo_nm = false
	{
		func() int {
			_ = 0
			return 0
		}()
		*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = yyLookaheadToken
	}
	goto _cgol_4
_cgol_44:
	if _cgo_nm && _cgo_tag != uint32(32) {
		goto _cgol_45
	}
	_cgo_nm = false
_cgol_45:
	if _cgo_nm && _cgo_tag != uint32(67) {
		goto _cgol_46
	}
	_cgo_nm = false
	{
		pParse.constraintName = *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_46:
	if _cgo_nm && _cgo_tag != uint32(33) {
		goto _cgol_47
	}
	_cgo_nm = false
	{
		sqlite3AddDefaultValue(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z)) + uintptr((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n))))
	}
	goto _cgol_4
_cgol_47:
	if _cgo_nm && _cgo_tag != uint32(34) {
		goto _cgol_48
	}
	_cgo_nm = false
	{
		sqlite3AddDefaultValue(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).z))+uintptr(1))), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)
	}
	goto _cgol_4
_cgol_48:
	if _cgo_nm && _cgo_tag != uint32(35) {
		goto _cgol_49
	}
	_cgo_nm = false
	{
		sqlite3AddDefaultValue(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).z, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z)) + uintptr((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n))))
	}
	goto _cgol_4
_cgol_49:
	if _cgo_nm && _cgo_tag != uint32(36) {
		goto _cgol_50
	}
	_cgo_nm = false
	{
		var p *struct_Expr = sqlite3PExpr(pParse, 173, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
		sqlite3AddDefaultValue(pParse, p, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).z, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z)) + uintptr((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n))))
	}
	goto _cgol_4
_cgol_50:
	if _cgo_nm && _cgo_tag != uint32(37) {
		goto _cgol_51
	}
	_cgo_nm = false
	{
		var p *struct_Expr = tokenExpr(pParse, 117, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		if p != nil {
			sqlite3ExprIdToTrueFalse(p)
		}
		sqlite3AddDefaultValue(pParse, p, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z))+uintptr((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n))))
	}
	goto _cgol_4
_cgol_51:
	if _cgo_nm && _cgo_tag != uint32(38) {
		goto _cgol_52
	}
	_cgo_nm = false
	{
		sqlite3AddNotNull(pParse, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_52:
	if _cgo_nm && _cgo_tag != uint32(39) {
		goto _cgol_53
	}
	_cgo_nm = false
	{
		sqlite3AddPrimaryKey(pParse, nil, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
	}
	goto _cgol_4
_cgol_53:
	if _cgo_nm && _cgo_tag != uint32(40) {
		goto _cgol_54
	}
	_cgo_nm = false
	{
		sqlite3CreateIndex(pParse, nil, nil, nil, nil, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, nil, 0, 0, uint8(1))
	}
	goto _cgol_4
_cgol_54:
	if _cgo_nm && _cgo_tag != uint32(41) {
		goto _cgol_55
	}
	_cgo_nm = false
	{
		sqlite3AddCheckConstraint(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).z, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)
	}
	goto _cgol_4
_cgol_55:
	if _cgo_nm && _cgo_tag != uint32(42) {
		goto _cgol_56
	}
	_cgo_nm = false
	{
		sqlite3CreateForeignKey(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_56:
	if _cgo_nm && _cgo_tag != uint32(43) {
		goto _cgol_57
	}
	_cgo_nm = false
	{
		sqlite3DeferForeignKey(pParse, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_57:
	if _cgo_nm && _cgo_tag != uint32(44) {
		goto _cgol_58
	}
	_cgo_nm = false
	{
		sqlite3AddCollateType(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_58:
	if _cgo_nm && _cgo_tag != uint32(45) {
		goto _cgol_59
	}
	_cgo_nm = false
	{
		sqlite3AddGenerated(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_59:
	if _cgo_nm && _cgo_tag != uint32(46) {
		goto _cgol_60
	}
	_cgo_nm = false
	{
		sqlite3AddGenerated(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_60:
	if _cgo_nm && _cgo_tag != uint32(48) {
		goto _cgol_61
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_61:
	if _cgo_nm && _cgo_tag != uint32(49) {
		goto _cgol_62
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(0 * 257)
	}
	goto _cgol_4
_cgol_62:
	if _cgo_nm && _cgo_tag != uint32(50) {
		goto _cgol_63
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) & ^(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).mask | (*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).value
	}
	goto _cgol_4
_cgol_63:
	if _cgo_nm && _cgo_tag != uint32(51) {
		goto _cgol_64
	}
	_cgo_nm = false
	{
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).value = int32(0)
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).mask = int32(0)
	}
	goto _cgol_4
_cgol_64:
	if _cgo_nm && _cgo_tag != uint32(52) {
		goto _cgol_65
	}
	_cgo_nm = false
	{
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).value = int32(0)
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).mask = int32(0)
	}
	goto _cgol_4
_cgol_65:
	if _cgo_nm && _cgo_tag != uint32(53) {
		goto _cgol_66
	}
	_cgo_nm = false
	{
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).value = *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).mask = int32(255)
	}
	goto _cgol_4
_cgol_66:
	if _cgo_nm && _cgo_tag != uint32(54) {
		goto _cgol_67
	}
	_cgo_nm = false
	{
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).value = *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) << 8
		(*(*_cgoa_89)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).mask = int32(65280)
	}
	goto _cgol_4
_cgol_67:
	if _cgo_nm && _cgo_tag != uint32(55) {
		goto _cgol_68
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(8)
	}
	goto _cgol_4
_cgol_68:
	if _cgo_nm && _cgo_tag != uint32(56) {
		goto _cgol_69
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(9)
	}
	goto _cgol_4
_cgol_69:
	if _cgo_nm && _cgo_tag != uint32(57) {
		goto _cgol_70
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(10)
	}
	goto _cgol_4
_cgol_70:
	if _cgo_nm && _cgo_tag != uint32(58) {
		goto _cgol_71
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(7)
	}
	goto _cgol_4
_cgol_71:
	if _cgo_nm && _cgo_tag != uint32(59) {
		goto _cgol_72
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_72:
	if _cgo_nm && _cgo_tag != uint32(60) {
		goto _cgol_73
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_73:
	if _cgo_nm && _cgo_tag != uint32(61) {
		goto _cgol_74
	}
	_cgo_nm = false
_cgol_74:
	if _cgo_nm && _cgo_tag != uint32(76) {
		goto _cgol_75
	}
	_cgo_nm = false
_cgol_75:
	if _cgo_nm && _cgo_tag != uint32(171) {
		goto _cgol_76
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_76:
	if _cgo_nm && _cgo_tag != uint32(63) {
		goto _cgol_77
	}
	_cgo_nm = false
_cgol_77:
	if _cgo_nm && _cgo_tag != uint32(80) {
		goto _cgol_78
	}
	_cgo_nm = false
_cgol_78:
	if _cgo_nm && _cgo_tag != uint32(214) {
		goto _cgol_79
	}
	_cgo_nm = false
_cgol_79:
	if _cgo_nm && _cgo_tag != uint32(217) {
		goto _cgol_80
	}
	_cgo_nm = false
_cgol_80:
	if _cgo_nm && _cgo_tag != uint32(243) {
		goto _cgol_81
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_81:
	if _cgo_nm && _cgo_tag != uint32(64) {
		goto _cgol_82
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_82:
	if _cgo_nm && _cgo_tag != uint32(66) {
		goto _cgol_83
	}
	_cgo_nm = false
	{
		pParse.constraintName.n = uint32(0)
	}
	goto _cgol_4
_cgol_83:
	if _cgo_nm && _cgo_tag != uint32(68) {
		goto _cgol_84
	}
	_cgo_nm = false
	{
		sqlite3AddPrimaryKey(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), 0)
	}
	goto _cgol_4
_cgol_84:
	if _cgo_nm && _cgo_tag != uint32(69) {
		goto _cgol_85
	}
	_cgo_nm = false
	{
		sqlite3CreateIndex(pParse, nil, nil, nil, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, nil, 0, 0, uint8(1))
	}
	goto _cgol_4
_cgol_85:
	if _cgo_nm && _cgo_tag != uint32(70) {
		goto _cgol_86
	}
	_cgo_nm = false
	{
		sqlite3AddCheckConstraint(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).z, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z)
	}
	goto _cgol_4
_cgol_86:
	if _cgo_nm && _cgo_tag != uint32(71) {
		goto _cgol_87
	}
	_cgo_nm = false
	{
		sqlite3CreateForeignKey(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		sqlite3DeferForeignKey(pParse, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_87:
	if _cgo_nm && _cgo_tag != uint32(73) {
		goto _cgol_88
	}
	_cgo_nm = false
_cgol_88:
	if _cgo_nm && _cgo_tag != uint32(75) {
		goto _cgol_89
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(11)
	}
	goto _cgol_4
_cgol_89:
	if _cgo_nm && _cgo_tag != uint32(74) {
		goto _cgol_90
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_90:
	if _cgo_nm && _cgo_tag != uint32(77) {
		goto _cgol_91
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(4)
	}
	goto _cgol_4
_cgol_91:
	if _cgo_nm && _cgo_tag != uint32(78) {
		goto _cgol_92
	}
	_cgo_nm = false
_cgol_92:
	if _cgo_nm && _cgo_tag != uint32(172) {
		goto _cgol_93
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(5)
	}
	goto _cgol_4
_cgol_93:
	if _cgo_nm && _cgo_tag != uint32(79) {
		goto _cgol_94
	}
	_cgo_nm = false
	{
		sqlite3DropTable(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 0, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_94:
	if _cgo_nm && _cgo_tag != uint32(82) {
		goto _cgol_95
	}
	_cgo_nm = false
	{
		sqlite3CreateView(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)))
	}
	goto _cgol_4
_cgol_95:
	if _cgo_nm && _cgo_tag != uint32(83) {
		goto _cgol_96
	}
	_cgo_nm = false
	{
		sqlite3DropTable(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 1, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_96:
	if _cgo_nm && _cgo_tag != uint32(84) {
		goto _cgol_97
	}
	_cgo_nm = false
	{
		var dest struct_SelectDest = struct_SelectDest{uint8(9), 0, 0, 0, 0, nil, nil}
		sqlite3Select(pParse, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), &dest)
		sqlite3SelectDelete(pParse.db, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_97:
	if _cgo_nm && _cgo_tag != uint32(85) {
		goto _cgol_98
	}
	_cgo_nm = false
	{
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = attachWithToSelect(pParse, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_With)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_98:
	if _cgo_nm && _cgo_tag != uint32(86) {
		goto _cgol_99
	}
	_cgo_nm = false
	{
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = attachWithToSelect(pParse, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_With)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_99:
	if _cgo_nm && _cgo_tag != uint32(87) {
		goto _cgol_100
	}
	_cgo_nm = false
	{
		var p *struct_Select = *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		if p != nil {
			parserDoubleLinkSelect(pParse, p)
		}
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = p
	}
	goto _cgol_4
_cgol_100:
	if _cgo_nm && _cgo_tag != uint32(88) {
		goto _cgol_101
	}
	_cgo_nm = false
	{
		var pRhs *struct_Select = *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		var pLhs *struct_Select = *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))
		if pRhs != nil && pRhs.pPrior != nil {
			var pFrom *struct_SrcList
			var x struct_Token
			x.n = uint32(0)
			parserDoubleLinkSelect(pParse, pRhs)
			pFrom = sqlite3SrcListAppendFromTerm(pParse, nil, nil, nil, &x, pRhs, nil, nil)
			pRhs = sqlite3SelectNew(pParse, nil, pFrom, nil, nil, nil, nil, uint32(0), nil)
		}
		if pRhs != nil {
			pRhs.op = uint8(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
			pRhs.pPrior = pLhs
			if pLhs != nil {
				pLhs.selFlags &= uint32(4294966271)
			}
			pRhs.selFlags &= uint32(4294966271)
			if *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) != 135 {
				pParse.hasCompound = uint8(1)
			}
		} else {
			sqlite3SelectDelete(pParse.db, pLhs)
		}
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = pRhs
	}
	goto _cgol_4
_cgol_101:
	if _cgo_nm && _cgo_tag != uint32(89) {
		goto _cgol_102
	}
	_cgo_nm = false
_cgol_102:
	if _cgo_nm && _cgo_tag != uint32(91) {
		goto _cgol_103
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major)
	}
	goto _cgol_4
_cgol_103:
	if _cgo_nm && _cgo_tag != uint32(90) {
		goto _cgol_104
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(135)
	}
	goto _cgol_4
_cgol_104:
	if _cgo_nm && _cgo_tag != uint32(92) {
		goto _cgol_105
	}
	_cgo_nm = false
	{
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)) = sqlite3SelectNew(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), uint32(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor))), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_105:
	if _cgo_nm && _cgo_tag != uint32(93) {
		goto _cgol_106
	}
	_cgo_nm = false
	{
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -9)*24))).minor)) = sqlite3SelectNew(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)), *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), uint32(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor))), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		if *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -9)*24))).minor)) != nil {
			(*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -9)*24))).minor))).pWinDefn = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))
		} else {
			sqlite3WindowListDelete(pParse.db, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_106:
	if _cgo_nm && _cgo_tag != uint32(94) {
		goto _cgol_107
	}
	_cgo_nm = false
	{
		*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3SelectNew(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil, nil, nil, nil, nil, uint32(512), nil)
	}
	goto _cgol_4
_cgol_107:
	if _cgo_nm && _cgo_tag != uint32(95) {
		goto _cgol_108
	}
	_cgo_nm = false
	{
		var pRight *struct_Select
		var pLeft *struct_Select = *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))
		pRight = sqlite3SelectNew(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil, nil, nil, nil, nil, uint32(512|1024), nil)
		if pLeft != nil {
			pLeft.selFlags &= uint32(4294966271)
		}
		if pRight != nil {
			pRight.op = uint8(135)
			pRight.pPrior = pLeft
			*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = pRight
		} else {
			*(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = pLeft
		}
	}
	goto _cgol_4
_cgol_108:
	if _cgo_nm && _cgo_tag != uint32(96) {
		goto _cgol_109
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_109:
	if _cgo_nm && _cgo_tag != uint32(97) {
		goto _cgol_110
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(2)
	}
	goto _cgol_4
_cgol_110:
	if _cgo_nm && _cgo_tag != uint32(99) {
		goto _cgol_111
	}
	_cgo_nm = false
_cgol_111:
	if _cgo_nm && _cgo_tag != uint32(132) {
		goto _cgol_112
	}
	_cgo_nm = false
_cgol_112:
	if _cgo_nm && _cgo_tag != uint32(142) {
		goto _cgol_113
	}
	_cgo_nm = false
_cgol_113:
	if _cgo_nm && _cgo_tag != uint32(230) {
		goto _cgol_114
	}
	_cgo_nm = false
_cgol_114:
	if _cgo_nm && _cgo_tag != uint32(233) {
		goto _cgol_115
	}
	_cgo_nm = false
_cgol_115:
	if _cgo_nm && _cgo_tag != uint32(238) {
		goto _cgol_116
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = (*struct_ExprList)(nil)
	}
	goto _cgol_4
_cgol_116:
	if _cgo_nm && _cgo_tag != uint32(100) {
		goto _cgol_117
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		if (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n > uint32(0) {
			sqlite3ExprListSetName(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 1)
		}
		sqlite3ExprListSetSpan(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_117:
	if _cgo_nm && _cgo_tag != uint32(101) {
		goto _cgol_118
	}
	_cgo_nm = false
	{
		var p *struct_Expr = sqlite3Expr(pParse.db, 180, nil)
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), p)
	}
	goto _cgol_4
_cgol_118:
	if _cgo_nm && _cgo_tag != uint32(102) {
		goto _cgol_119
	}
	_cgo_nm = false
	{
		var pRight *struct_Expr = sqlite3PExpr(pParse, 180, nil, nil)
		var pLeft *struct_Expr = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		var pDot *struct_Expr = sqlite3PExpr(pParse, 141, pLeft, pRight)
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), pDot)
	}
	goto _cgol_4
_cgol_119:
	if _cgo_nm && _cgo_tag != uint32(103) {
		goto _cgol_120
	}
	_cgo_nm = false
_cgol_120:
	if _cgo_nm && _cgo_tag != uint32(114) {
		goto _cgol_121
	}
	_cgo_nm = false
_cgol_121:
	if _cgo_nm && _cgo_tag != uint32(254) {
		goto _cgol_122
	}
	_cgo_nm = false
_cgol_122:
	if _cgo_nm && _cgo_tag != uint32(255) {
		goto _cgol_123
	}
	_cgo_nm = false
	{
		*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_123:
	if _cgo_nm && _cgo_tag != uint32(105) {
		goto _cgol_124
	}
	_cgo_nm = false
_cgol_124:
	if _cgo_nm && _cgo_tag != uint32(108) {
		goto _cgol_125
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = (*struct_SrcList)(nil)
	}
	goto _cgol_4
_cgol_125:
	if _cgo_nm && _cgo_tag != uint32(106) {
		goto _cgol_126
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		sqlite3SrcListShiftJoinType(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_126:
	if _cgo_nm && _cgo_tag != uint32(107) {
		goto _cgol_127
	}
	_cgo_nm = false
	{
		if *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) != nil && (*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).nSrc > 0 {
			(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).a)))) + uintptr((*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).nSrc-1)*112))).fg.jointype = uint8(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_127:
	if _cgo_nm && _cgo_tag != uint32(109) {
		goto _cgol_128
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) = sqlite3SrcListAppendFromTerm(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		sqlite3SrcListIndexedBy(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
	}
	goto _cgol_4
_cgol_128:
	if _cgo_nm && _cgo_tag != uint32(110) {
		goto _cgol_129
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)) = sqlite3SrcListAppendFromTerm(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		sqlite3SrcListFuncArgs(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
	}
	goto _cgol_4
_cgol_129:
	if _cgo_nm && _cgo_tag != uint32(111) {
		goto _cgol_130
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) = sqlite3SrcListAppendFromTerm(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), nil, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_130:
	if _cgo_nm && _cgo_tag != uint32(112) {
		goto _cgol_131
	}
	_cgo_nm = false
	{
		if uintptr(unsafe.Pointer(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)))) == uintptr(unsafe.Pointer(nil)) && (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).n == uint32(0) && uintptr(unsafe.Pointer(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(*(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))) == uintptr(unsafe.Pointer(nil)) {
			*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) = *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))
		} else if (*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).nSrc == 1 {
			*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) = sqlite3SrcListAppendFromTerm(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), nil, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
			if *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) != nil {
				var pNew *struct_SrcItem = &*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor))).a)))) + uintptr((*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor))).nSrc-1)*112))
				var pOld *struct_SrcItem = (*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).a))
				pNew.zName = pOld.zName
				pNew.zDatabase = pOld.zDatabase
				pNew.pSelect = pOld.pSelect
				if pOld.fg.Xbf_0>>2&1 != 0 {
					*(**struct_ExprList)(unsafe.Pointer(&pNew.u1)) = *(**struct_ExprList)(unsafe.Pointer(&pOld.u1))
					*(**struct_ExprList)(unsafe.Pointer(&pOld.u1)) = (*struct_ExprList)(nil)
					{
						_autoGo_100 := &pOld.fg.Xbf_0
						*_autoGo_100 = *_autoGo_100&^4 | uint32(0)&1<<2
					}
					{
						_autoGo_101 := &pNew.fg.Xbf_0
						*_autoGo_101 = *_autoGo_101&^4 | uint32(1)&1<<2
					}
				}
				pOld.zName = func() (_cgo_ret *int8) {
					_cgo_addr := &pOld.zDatabase
					*_cgo_addr = (*int8)(nil)
					return *_cgo_addr
				}()
				pOld.pSelect = (*struct_Select)(nil)
			}
			sqlite3SrcListDelete(pParse.db, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
		} else {
			var pSubquery *struct_Select
			sqlite3SrcListShiftJoinType(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
			pSubquery = sqlite3SelectNew(pParse, nil, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil, nil, nil, nil, uint32(2048), nil)
			*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) = sqlite3SrcListAppendFromTerm(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), nil, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), pSubquery, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_131:
	if _cgo_nm && _cgo_tag != uint32(113) {
		goto _cgol_132
	}
	_cgo_nm = false
_cgol_132:
	if _cgo_nm && _cgo_tag != uint32(127) {
		goto _cgol_133
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor))).z = (*int8)(nil)
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor))).n = uint32(0)
	}
	goto _cgol_4
_cgol_133:
	if _cgo_nm && _cgo_tag != uint32(115) {
		goto _cgol_134
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
		if int32(pParse.eParseMode) >= 2 && *(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2)) != nil {
			sqlite3RenameTokenMap(pParse, unsafe.Pointer((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2))).a)))) + uintptr(0)*112))).zName), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_134:
	if _cgo_nm && _cgo_tag != uint32(116) {
		goto _cgol_135
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		if int32(pParse.eParseMode) >= 2 && *(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2)) != nil {
			sqlite3RenameTokenMap(pParse, unsafe.Pointer((*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2))).a)))) + uintptr(0)*112))).zName), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_SrcList)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_135:
	if _cgo_nm && _cgo_tag != uint32(117) {
		goto _cgol_136
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_136:
	if _cgo_nm && _cgo_tag != uint32(118) {
		goto _cgol_137
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_137:
	if _cgo_nm && _cgo_tag != uint32(119) {
		goto _cgol_138
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		if *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) != nil {
			(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).a)))) + uintptr(0)*112))).zAlias = sqlite3NameFromToken(pParse.db, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_138:
	if _cgo_nm && _cgo_tag != uint32(120) {
		goto _cgol_139
	}
	_cgo_nm = false
	{
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), nil)
		if *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) != nil {
			(*(*struct_SrcItem)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_SrcItem)(unsafe.Pointer(&(*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).a)))) + uintptr(0)*112))).zAlias = sqlite3NameFromToken(pParse.db, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_139:
	if _cgo_nm && _cgo_tag != uint32(121) {
		goto _cgol_140
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_140:
	if _cgo_nm && _cgo_tag != uint32(122) {
		goto _cgol_141
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = sqlite3JoinType(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil, nil)
	}
	goto _cgol_4
_cgol_141:
	if _cgo_nm && _cgo_tag != uint32(123) {
		goto _cgol_142
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3JoinType(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_142:
	if _cgo_nm && _cgo_tag != uint32(124) {
		goto _cgol_143
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3JoinType(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_143:
	if _cgo_nm && _cgo_tag != uint32(125) {
		goto _cgol_144
	}
	_cgo_nm = false
_cgol_144:
	if _cgo_nm && _cgo_tag != uint32(145) {
		goto _cgol_145
	}
	_cgo_nm = false
_cgol_145:
	if _cgo_nm && _cgo_tag != uint32(152) {
		goto _cgol_146
	}
	_cgo_nm = false
_cgol_146:
	if _cgo_nm && _cgo_tag != uint32(154) {
		goto _cgol_147
	}
	_cgo_nm = false
_cgol_147:
	if _cgo_nm && _cgo_tag != uint32(226) {
		goto _cgol_148
	}
	_cgo_nm = false
_cgol_148:
	if _cgo_nm && _cgo_tag != uint32(247) {
		goto _cgol_149
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_149:
	if _cgo_nm && _cgo_tag != uint32(126) {
		goto _cgol_150
	}
	_cgo_nm = false
_cgol_150:
	if _cgo_nm && _cgo_tag != uint32(144) {
		goto _cgol_151
	}
	_cgo_nm = false
_cgol_151:
	if _cgo_nm && _cgo_tag != uint32(146) {
		goto _cgol_152
	}
	_cgo_nm = false
_cgol_152:
	if _cgo_nm && _cgo_tag != uint32(151) {
		goto _cgol_153
	}
	_cgo_nm = false
_cgol_153:
	if _cgo_nm && _cgo_tag != uint32(153) {
		goto _cgol_154
	}
	_cgo_nm = false
_cgol_154:
	if _cgo_nm && _cgo_tag != uint32(227) {
		goto _cgol_155
	}
	_cgo_nm = false
_cgol_155:
	if _cgo_nm && _cgo_tag != uint32(229) {
		goto _cgol_156
	}
	_cgo_nm = false
_cgol_156:
	if _cgo_nm && _cgo_tag != uint32(248) {
		goto _cgol_157
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = (*struct_Expr)(nil)
	}
	goto _cgol_4
_cgol_157:
	if _cgo_nm && _cgo_tag != uint32(128) {
		goto _cgol_158
	}
	_cgo_nm = false
	{
		*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_158:
	if _cgo_nm && _cgo_tag != uint32(129) {
		goto _cgol_159
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z = (*int8)(nil)
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n = uint32(1)
	}
	goto _cgol_4
_cgol_159:
	if _cgo_nm && _cgo_tag != uint32(130) {
		goto _cgol_160
	}
	_cgo_nm = false
	{
		*(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_160:
	if _cgo_nm && _cgo_tag != uint32(131) {
		goto _cgol_161
	}
	_cgo_nm = false
_cgol_161:
	if _cgo_nm && _cgo_tag != uint32(173) {
		goto _cgol_162
	}
	_cgo_nm = false
	{
		*(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = (*struct_IdList)(nil)
	}
	goto _cgol_4
_cgol_162:
	if _cgo_nm && _cgo_tag != uint32(133) {
		goto _cgol_163
	}
	_cgo_nm = false
_cgol_163:
	if _cgo_nm && _cgo_tag != uint32(143) {
		goto _cgol_164
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_164:
	if _cgo_nm && _cgo_tag != uint32(134) {
		goto _cgol_165
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		sqlite3ExprListSetSortOrder(*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_165:
	if _cgo_nm && _cgo_tag != uint32(135) {
		goto _cgol_166
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		sqlite3ExprListSetSortOrder(*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_166:
	if _cgo_nm && _cgo_tag != uint32(136) {
		goto _cgol_167
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_167:
	if _cgo_nm && _cgo_tag != uint32(137) {
		goto _cgol_168
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_168:
	if _cgo_nm && _cgo_tag != uint32(138) {
		goto _cgol_169
	}
	_cgo_nm = false
_cgol_169:
	if _cgo_nm && _cgo_tag != uint32(141) {
		goto _cgol_170
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(-1)
	}
	goto _cgol_4
_cgol_170:
	if _cgo_nm && _cgo_tag != uint32(139) {
		goto _cgol_171
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_171:
	if _cgo_nm && _cgo_tag != uint32(140) {
		goto _cgol_172
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_172:
	if _cgo_nm && _cgo_tag != uint32(147) {
		goto _cgol_173
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = sqlite3PExpr(pParse, 148, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_173:
	if _cgo_nm && _cgo_tag != uint32(148) {
		goto _cgol_174
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3PExpr(pParse, 148, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_174:
	if _cgo_nm && _cgo_tag != uint32(149) {
		goto _cgol_175
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3PExpr(pParse, 148, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
	}
	goto _cgol_4
_cgol_175:
	if _cgo_nm && _cgo_tag != uint32(150) {
		goto _cgol_176
	}
	_cgo_nm = false
	{
		sqlite3SrcListIndexedBy(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		sqlite3DeleteFrom(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, nil)
	}
	goto _cgol_4
_cgol_176:
	if _cgo_nm && _cgo_tag != uint32(155) {
		goto _cgol_177
	}
	_cgo_nm = false
	{
		sqlite3AddReturning(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = (*struct_Expr)(nil)
	}
	goto _cgol_4
_cgol_177:
	if _cgo_nm && _cgo_tag != uint32(156) {
		goto _cgol_178
	}
	_cgo_nm = false
	{
		sqlite3AddReturning(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))
	}
	goto _cgol_4
_cgol_178:
	if _cgo_nm && _cgo_tag != uint32(157) {
		goto _cgol_179
	}
	_cgo_nm = false
	{
		sqlite3SrcListIndexedBy(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
		sqlite3ExprListCheckLength(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), (*int8)(unsafe.Pointer(&[9]int8{'s', 'e', 't', ' ', 'l', 'i', 's', 't', '\x00'})))
		*(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = sqlite3SrcListAppendList(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		sqlite3Update(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), nil, nil, nil)
	}
	goto _cgol_4
_cgol_179:
	if _cgo_nm && _cgo_tag != uint32(158) {
		goto _cgol_180
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		sqlite3ExprListSetName(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), 1)
	}
	goto _cgol_4
_cgol_180:
	if _cgo_nm && _cgo_tag != uint32(159) {
		goto _cgol_181
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)) = sqlite3ExprListAppendVector(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_181:
	if _cgo_nm && _cgo_tag != uint32(160) {
		goto _cgol_182
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		sqlite3ExprListSetName(pParse, *(**struct_ExprList)(unsafe.Pointer(&yylhsminor_cgo2)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), 1)
	}
	*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_ExprList)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_182:
	if _cgo_nm && _cgo_tag != uint32(161) {
		goto _cgol_183
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppendVector(pParse, nil, *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_183:
	if _cgo_nm && _cgo_tag != uint32(162) {
		goto _cgol_184
	}
	_cgo_nm = false
	{
		sqlite3Insert(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_184:
	if _cgo_nm && _cgo_tag != uint32(163) {
		goto _cgol_185
	}
	_cgo_nm = false
	{
		sqlite3Insert(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil, *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_185:
	if _cgo_nm && _cgo_tag != uint32(164) {
		goto _cgol_186
	}
	_cgo_nm = false
	{
		*(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = (*struct_Upsert)(nil)
	}
	goto _cgol_4
_cgol_186:
	if _cgo_nm && _cgo_tag != uint32(165) {
		goto _cgol_187
	}
	_cgo_nm = false
	{
		*(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = (*struct_Upsert)(nil)
		sqlite3AddReturning(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_187:
	if _cgo_nm && _cgo_tag != uint32(166) {
		goto _cgol_188
	}
	_cgo_nm = false
	{
		*(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -11)*24))).minor)) = sqlite3UpsertNew(pParse.db, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_188:
	if _cgo_nm && _cgo_tag != uint32(167) {
		goto _cgol_189
	}
	_cgo_nm = false
	{
		*(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)) = sqlite3UpsertNew(pParse.db, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), nil, nil, *(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_189:
	if _cgo_nm && _cgo_tag != uint32(168) {
		goto _cgol_190
	}
	_cgo_nm = false
	{
		*(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3UpsertNew(pParse.db, nil, nil, nil, nil, nil)
	}
	goto _cgol_4
_cgol_190:
	if _cgo_nm && _cgo_tag != uint32(169) {
		goto _cgol_191
	}
	_cgo_nm = false
	{
		*(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)) = sqlite3UpsertNew(pParse.db, nil, nil, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_191:
	if _cgo_nm && _cgo_tag != uint32(170) {
		goto _cgol_192
	}
	_cgo_nm = false
	{
		sqlite3AddReturning(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_192:
	if _cgo_nm && _cgo_tag != uint32(174) {
		goto _cgol_193
	}
	_cgo_nm = false
	{
		*(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_193:
	if _cgo_nm && _cgo_tag != uint32(175) {
		goto _cgol_194
	}
	_cgo_nm = false
	{
		*(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3IdListAppend(pParse, *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_194:
	if _cgo_nm && _cgo_tag != uint32(176) {
		goto _cgol_195
	}
	_cgo_nm = false
	{
		*(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = sqlite3IdListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_195:
	if _cgo_nm && _cgo_tag != uint32(177) {
		goto _cgol_196
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_196:
	if _cgo_nm && _cgo_tag != uint32(178) {
		goto _cgol_197
	}
	_cgo_nm = false
_cgol_197:
	if _cgo_nm && _cgo_tag != uint32(179) {
		goto _cgol_198
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_198:
	if _cgo_nm && _cgo_tag != uint32(180) {
		goto _cgol_199
	}
	_cgo_nm = false
	{
		var temp1 *struct_Expr = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		var temp2 *struct_Expr = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3PExpr(pParse, 141, temp1, temp2)
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_199:
	if _cgo_nm && _cgo_tag != uint32(181) {
		goto _cgol_200
	}
	_cgo_nm = false
	{
		var temp1 *struct_Expr = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
		var temp2 *struct_Expr = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		var temp3 *struct_Expr = tokenExpr(pParse, 59, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		var temp4 *struct_Expr = sqlite3PExpr(pParse, 141, temp2, temp3)
		if int32(pParse.eParseMode) >= 2 {
			sqlite3RenameTokenRemap(pParse, nil, unsafe.Pointer(temp1))
		}
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3PExpr(pParse, 141, temp1, temp4)
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_200:
	if _cgo_nm && _cgo_tag != uint32(182) {
		goto _cgol_201
	}
	_cgo_nm = false
_cgol_201:
	if _cgo_nm && _cgo_tag != uint32(183) {
		goto _cgol_202
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = tokenExpr(pParse, int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major), *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_202:
	if _cgo_nm && _cgo_tag != uint32(184) {
		goto _cgol_203
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprAlloc(pParse.db, 155, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 1)
		if *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) != nil {
			*(*int32)(unsafe.Pointer(&(*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))).w)) = int32(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)) - uintptr(unsafe.Pointer(pParse.zTail)))
		}
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_203:
	if _cgo_nm && _cgo_tag != uint32(185) {
		goto _cgol_204
	}
	_cgo_nm = false
	{
		if !(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)) + uintptr(0)))) == '#' && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z)) + uintptr(1))))))))&4 != 0) {
			var n uint32 = (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = tokenExpr(pParse, 156, *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
			sqlite3ExprAssignVarNumber(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), n)
		} else {
			var t struct_Token = *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
			func() int {
				_ = 0
				return 0
			}()
			if int32(pParse.nested) == 0 {
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[24]int8{'n', 'e', 'a', 'r', ' ', '"', '%', 'T', '"', ':', ' ', 's', 'y', 'n', 't', 'a', 'x', ' ', 'e', 'r', 'r', 'o', 'r', '\x00'})), &t)
				*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = (*struct_Expr)(nil)
			} else {
				*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = sqlite3PExpr(pParse, 176, nil, nil)
				if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) != nil {
					sqlite3GetInt32(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(t.z)) + uintptr(1))), &(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).iTable)
				}
			}
		}
	}
	goto _cgol_4
_cgol_204:
	if _cgo_nm && _cgo_tag != uint32(186) {
		goto _cgol_205
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3ExprAddCollateToken(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 1)
	}
	goto _cgol_4
_cgol_205:
	if _cgo_nm && _cgo_tag != uint32(187) {
		goto _cgol_206
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = sqlite3ExprAlloc(pParse.db, 36, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), 1)
		sqlite3ExprAttachSubtrees(pParse.db, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_206:
	if _cgo_nm && _cgo_tag != uint32(188) {
		goto _cgol_207
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprFunction(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_207:
	if _cgo_nm && _cgo_tag != uint32(189) {
		goto _cgol_208
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprFunction(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), 0)
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_208:
	if _cgo_nm && _cgo_tag != uint32(190) {
		goto _cgol_209
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprFunction(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)))
		sqlite3WindowAttach(pParse, *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)), *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_209:
	if _cgo_nm && _cgo_tag != uint32(191) {
		goto _cgol_210
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprFunction(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), 0)
		sqlite3WindowAttach(pParse, *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)), *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_210:
	if _cgo_nm && _cgo_tag != uint32(192) {
		goto _cgol_211
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprFunction(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 0)
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_211:
	if _cgo_nm && _cgo_tag != uint32(193) {
		goto _cgol_212
	}
	_cgo_nm = false
	{
		var pList *struct_ExprList = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 177, nil, nil)
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).x.pList = pList
			if pList.nExpr != 0 {
				(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).flags |= (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&pList.a)))) + uintptr(0)*28))).pExpr.flags & uint32(256|2097152|4)
			}
		} else {
			sqlite3ExprListDelete(pParse.db, pList)
		}
	}
	goto _cgol_4
_cgol_212:
	if _cgo_nm && _cgo_tag != uint32(194) {
		goto _cgol_213
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3ExprAnd(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_213:
	if _cgo_nm && _cgo_tag != uint32(195) {
		goto _cgol_214
	}
	_cgo_nm = false
_cgol_214:
	if _cgo_nm && _cgo_tag != uint32(196) {
		goto _cgol_215
	}
	_cgo_nm = false
_cgol_215:
	if _cgo_nm && _cgo_tag != uint32(197) {
		goto _cgol_216
	}
	_cgo_nm = false
_cgol_216:
	if _cgo_nm && _cgo_tag != uint32(198) {
		goto _cgol_217
	}
	_cgo_nm = false
_cgol_217:
	if _cgo_nm && _cgo_tag != uint32(199) {
		goto _cgol_218
	}
	_cgo_nm = false
_cgol_218:
	if _cgo_nm && _cgo_tag != uint32(200) {
		goto _cgol_219
	}
	_cgo_nm = false
_cgol_219:
	if _cgo_nm && _cgo_tag != uint32(201) {
		goto _cgol_220
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3PExpr(pParse, int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).major), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_220:
	if _cgo_nm && _cgo_tag != uint32(202) {
		goto _cgol_221
	}
	_cgo_nm = false
	{
		*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n |= uint32(2147483648)
	}
	goto _cgol_4
_cgol_221:
	if _cgo_nm && _cgo_tag != uint32(203) {
		goto _cgol_222
	}
	_cgo_nm = false
	{
		var pList *struct_ExprList
		var bNot int32 = int32((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n & 2147483648)
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n &= uint32(2147483647)
		pList = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		pList = sqlite3ExprListAppend(pParse, pList, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3ExprFunction(pParse, pList, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), 0)
		if bNot != 0 {
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3PExpr(pParse, 19, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), nil)
		}
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).flags |= uint32(128)
		}
	}
	goto _cgol_4
_cgol_222:
	if _cgo_nm && _cgo_tag != uint32(204) {
		goto _cgol_223
	}
	_cgo_nm = false
	{
		var pList *struct_ExprList
		var bNot int32 = int32((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).n & 2147483648)
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).n &= uint32(2147483647)
		pList = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		pList = sqlite3ExprListAppend(pParse, pList, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
		pList = sqlite3ExprListAppend(pParse, pList, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprFunction(pParse, pList, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), 0)
		if bNot != 0 {
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 19, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		}
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).flags |= uint32(128)
		}
	}
	goto _cgol_4
_cgol_223:
	if _cgo_nm && _cgo_tag != uint32(205) {
		goto _cgol_224
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = sqlite3PExpr(pParse, int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_224:
	if _cgo_nm && _cgo_tag != uint32(206) {
		goto _cgol_225
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3PExpr(pParse, 51, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_225:
	if _cgo_nm && _cgo_tag != uint32(207) {
		goto _cgol_226
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3PExpr(pParse, 45, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		binaryToUnaryIfNull(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), 50)
	}
	goto _cgol_4
_cgol_226:
	if _cgo_nm && _cgo_tag != uint32(208) {
		goto _cgol_227
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3PExpr(pParse, 171, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		binaryToUnaryIfNull(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), 51)
	}
	goto _cgol_4
_cgol_227:
	if _cgo_nm && _cgo_tag != uint32(209) {
		goto _cgol_228
	}
	_cgo_nm = false
_cgol_228:
	if _cgo_nm && _cgo_tag != uint32(210) {
		goto _cgol_229
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = sqlite3PExpr(pParse, int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).major), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_229:
	if _cgo_nm && _cgo_tag != uint32(211) {
		goto _cgol_230
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = sqlite3PExpr(pParse, func() int32 {
			if int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).major) == 106 {
				return 174
			} else {
				return 173
			}
		}(), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_230:
	if _cgo_nm && _cgo_tag != uint32(212) {
		goto _cgol_231
	}
	_cgo_nm = false
	{
		var pList *struct_ExprList = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		pList = sqlite3ExprListAppend(pParse, pList, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3ExprFunction(pParse, pList, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), 0)
	}
	*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_231:
	if _cgo_nm && _cgo_tag != uint32(213) {
		goto _cgol_232
	}
	_cgo_nm = false
_cgol_232:
	if _cgo_nm && _cgo_tag != uint32(216) {
		goto _cgol_233
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_233:
	if _cgo_nm && _cgo_tag != uint32(215) {
		goto _cgol_234
	}
	_cgo_nm = false
	{
		var pList *struct_ExprList = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		pList = sqlite3ExprListAppend(pParse, pList, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 48, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).x.pList = pList
		} else {
			sqlite3ExprListDelete(pParse.db, pList)
		}
		if *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) != 0 {
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 19, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		}
	}
	goto _cgol_4
_cgol_234:
	if _cgo_nm && _cgo_tag != uint32(218) {
		goto _cgol_235
	}
	_cgo_nm = false
	{
		if uintptr(unsafe.Pointer(*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))) == uintptr(unsafe.Pointer(nil)) {
			sqlite3ExprUnmapAndDelete(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3Expr(pParse.db, 155, func() *int8 {
				if *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) != 0 {
					return (*int8)(unsafe.Pointer(&[2]int8{'1', '\x00'}))
				} else {
					return (*int8)(unsafe.Pointer(&[2]int8{'0', '\x00'}))
				}
			}())
		} else {
			var pRHS *struct_Expr = (*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).a)))) + uintptr(0)*28))).pExpr
			if (*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).nExpr == 1 && sqlite3ExprIsConstant(pRHS) != 0 && int32((*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).op) != 177 {
				(*(*struct_ExprList_item)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_ExprList_item)(unsafe.Pointer(&(*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).a)))) + uintptr(0)*28))).pExpr = (*struct_Expr)(nil)
				sqlite3ExprListDelete(pParse.db, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
				pRHS = sqlite3PExpr(pParse, 174, pRHS, nil)
				*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 53, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), pRHS)
			} else {
				*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 49, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
				if uintptr(unsafe.Pointer(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))) == uintptr(unsafe.Pointer(nil)) {
					sqlite3ExprListDelete(pParse.db, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
				} else if int32((*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).pLeft.op) == 177 {
					var nExpr int32 = (*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).pLeft.x.pList.nExpr
					var pSelectRHS *struct_Select = sqlite3ExprListToValues(pParse, nExpr, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
					if pSelectRHS != nil {
						parserDoubleLinkSelect(pParse, pSelectRHS)
						sqlite3PExprAddSelect(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), pSelectRHS)
					}
				} else {
					(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).x.pList = *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
					sqlite3ExprSetHeightAndFlags(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
				}
			}
			if *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) != 0 {
				*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 19, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
			}
		}
	}
	goto _cgol_4
_cgol_235:
	if _cgo_nm && _cgo_tag != uint32(219) {
		goto _cgol_236
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3PExpr(pParse, 138, nil, nil)
		sqlite3PExprAddSelect(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_236:
	if _cgo_nm && _cgo_tag != uint32(220) {
		goto _cgol_237
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 49, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		sqlite3PExprAddSelect(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		if *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) != 0 {
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 19, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		}
	}
	goto _cgol_4
_cgol_237:
	if _cgo_nm && _cgo_tag != uint32(221) {
		goto _cgol_238
	}
	_cgo_nm = false
	{
		var pSrc *struct_SrcList = sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		var pSelect *struct_Select = sqlite3SelectNew(pParse, nil, pSrc, nil, nil, nil, nil, uint32(0), nil)
		if *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) != nil {
			sqlite3SrcListFuncArgs(pParse, func() *struct_SrcList {
				if pSelect != nil {
					return pSrc
				} else {
					return nil
				}
			}(), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 49, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		sqlite3PExprAddSelect(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), pSelect)
		if *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) != 0 {
			*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 19, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil)
		}
	}
	goto _cgol_4
_cgol_238:
	if _cgo_nm && _cgo_tag != uint32(222) {
		goto _cgol_239
	}
	_cgo_nm = false
	{
		var p *struct_Expr
		p = func() (_cgo_ret *struct_Expr) {
			_cgo_addr := &*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))
			*_cgo_addr = sqlite3PExpr(pParse, 20, nil, nil)
			return *_cgo_addr
		}()
		sqlite3PExprAddSelect(pParse, p, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_239:
	if _cgo_nm && _cgo_tag != uint32(223) {
		goto _cgol_240
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3PExpr(pParse, 157, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), nil)
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).x.pList = func() *struct_ExprList {
				if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) != nil {
					return sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
				} else {
					return *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))
				}
			}()
			sqlite3ExprSetHeightAndFlags(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
		} else {
			sqlite3ExprListDelete(pParse.db, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
			sqlite3ExprDelete(pParse.db, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_240:
	if _cgo_nm && _cgo_tag != uint32(224) {
		goto _cgol_241
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_241:
	if _cgo_nm && _cgo_tag != uint32(225) {
		goto _cgol_242
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_242:
	if _cgo_nm && _cgo_tag != uint32(228) {
		goto _cgol_243
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_243:
	if _cgo_nm && _cgo_tag != uint32(231) {
		goto _cgol_244
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3ExprListAppend(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_244:
	if _cgo_nm && _cgo_tag != uint32(232) {
		goto _cgol_245
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = sqlite3ExprListAppend(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_245:
	if _cgo_nm && _cgo_tag != uint32(234) {
		goto _cgol_246
	}
	_cgo_nm = false
_cgol_246:
	if _cgo_nm && _cgo_tag != uint32(239) {
		goto _cgol_247
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_247:
	if _cgo_nm && _cgo_tag != uint32(235) {
		goto _cgol_248
	}
	_cgo_nm = false
	{
		sqlite3CreateIndex(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), sqlite3SrcListAppend(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), nil), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -10)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -11)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 0, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)), uint8(0))
		if int32(pParse.eParseMode) >= 2 && pParse.pNewIndex != nil {
			sqlite3RenameTokenMap(pParse, unsafe.Pointer(pParse.pNewIndex.zName), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_248:
	if _cgo_nm && _cgo_tag != uint32(236) {
		goto _cgol_249
	}
	_cgo_nm = false
_cgol_249:
	if _cgo_nm && _cgo_tag != uint32(278) {
		goto _cgol_250
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(2)
	}
	goto _cgol_4
_cgol_250:
	if _cgo_nm && _cgo_tag != uint32(237) {
		goto _cgol_251
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(0)
	}
	goto _cgol_4
_cgol_251:
	if _cgo_nm && _cgo_tag != uint32(240) {
		goto _cgol_252
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = parserAddExprIdListTerm(pParse, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_252:
	if _cgo_nm && _cgo_tag != uint32(241) {
		goto _cgol_253
	}
	_cgo_nm = false
	{
		*(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = parserAddExprIdListTerm(pParse, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_253:
	if _cgo_nm && _cgo_tag != uint32(244) {
		goto _cgol_254
	}
	_cgo_nm = false
	{
		sqlite3DropIndex(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_254:
	if _cgo_nm && _cgo_tag != uint32(245) {
		goto _cgol_255
	}
	_cgo_nm = false
	{
		sqlite3Vacuum(pParse, nil, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_255:
	if _cgo_nm && _cgo_tag != uint32(246) {
		goto _cgol_256
	}
	_cgo_nm = false
	{
		sqlite3Vacuum(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_256:
	if _cgo_nm && _cgo_tag != uint32(249) {
		goto _cgol_257
	}
	_cgo_nm = false
	{
		sqlite3Pragma(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, 0)
	}
	goto _cgol_4
_cgol_257:
	if _cgo_nm && _cgo_tag != uint32(250) {
		goto _cgol_258
	}
	_cgo_nm = false
	{
		sqlite3Pragma(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 0)
	}
	goto _cgol_4
_cgol_258:
	if _cgo_nm && _cgo_tag != uint32(251) {
		goto _cgol_259
	}
	_cgo_nm = false
	{
		sqlite3Pragma(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), 0)
	}
	goto _cgol_4
_cgol_259:
	if _cgo_nm && _cgo_tag != uint32(252) {
		goto _cgol_260
	}
	_cgo_nm = false
	{
		sqlite3Pragma(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), 1)
	}
	goto _cgol_4
_cgol_260:
	if _cgo_nm && _cgo_tag != uint32(253) {
		goto _cgol_261
	}
	_cgo_nm = false
	{
		sqlite3Pragma(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), 1)
	}
	goto _cgol_4
_cgol_261:
	if _cgo_nm && _cgo_tag != uint32(256) {
		goto _cgol_262
	}
	_cgo_nm = false
	{
		var all struct_Token
		all.z = (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).z
		all.n = uint32(int32(uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z))-uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).z)))) + (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n
		sqlite3FinishTrigger(pParse, *(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &all)
	}
	goto _cgol_4
_cgol_262:
	if _cgo_nm && _cgo_tag != uint32(257) {
		goto _cgol_263
	}
	_cgo_nm = false
	{
		sqlite3BeginTrigger(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), (*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor.yy180.a, (*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor.yy180.b, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -10)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)))
		*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -10)*24))).minor)) = func() struct_Token {
			if (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor))).n == uint32(0) {
				return *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor))
			} else {
				return *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor))
			}
		}()
	}
	goto _cgol_4
_cgol_263:
	if _cgo_nm && _cgo_tag != uint32(258) {
		goto _cgol_264
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major)
	}
	goto _cgol_4
_cgol_264:
	if _cgo_nm && _cgo_tag != uint32(259) {
		goto _cgol_265
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = int32(65)
	}
	goto _cgol_4
_cgol_265:
	if _cgo_nm && _cgo_tag != uint32(260) {
		goto _cgol_266
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = int32(33)
	}
	goto _cgol_4
_cgol_266:
	if _cgo_nm && _cgo_tag != uint32(261) {
		goto _cgol_267
	}
	_cgo_nm = false
_cgol_267:
	if _cgo_nm && _cgo_tag != uint32(262) {
		goto _cgol_268
	}
	_cgo_nm = false
	{
		(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor.yy180.a = int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major)
		(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor.yy180.b = (*struct_IdList)(nil)
	}
	goto _cgol_4
_cgol_268:
	if _cgo_nm && _cgo_tag != uint32(263) {
		goto _cgol_269
	}
	_cgo_nm = false
	{
		(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor.yy180.a = int32(129)
		(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor.yy180.b = *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_269:
	if _cgo_nm && _cgo_tag != uint32(264) {
		goto _cgol_270
	}
	_cgo_nm = false
_cgol_270:
	if _cgo_nm && _cgo_tag != uint32(283) {
		goto _cgol_271
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = (*struct_Expr)(nil)
	}
	goto _cgol_4
_cgol_271:
	if _cgo_nm && _cgo_tag != uint32(265) {
		goto _cgol_272
	}
	_cgo_nm = false
_cgol_272:
	if _cgo_nm && _cgo_tag != uint32(284) {
		goto _cgol_273
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_273:
	if _cgo_nm && _cgo_tag != uint32(266) {
		goto _cgol_274
	}
	_cgo_nm = false
	{
		func() int {
			_ = 0
			return 0
		}()
		(*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).pLast.pNext = *(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
		(*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))).pLast = *(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_274:
	if _cgo_nm && _cgo_tag != uint32(267) {
		goto _cgol_275
	}
	_cgo_nm = false
	{
		func() int {
			_ = 0
			return 0
		}()
		(*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).pLast = *(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_275:
	if _cgo_nm && _cgo_tag != uint32(268) {
		goto _cgol_276
	}
	_cgo_nm = false
	{
		*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[95]int8{'q', 'u', 'a', 'l', 'i', 'f', 'i', 'e', 'd', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'n', 'a', 'm', 'e', 's', ' ', 'a', 'r', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'I', 'N', 'S', 'E', 'R', 'T', ',', ' ', 'U', 'P', 'D', 'A', 'T', 'E', ',', ' ', 'a', 'n', 'd', ' ', 'D', 'E', 'L', 'E', 'T', 'E', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', 's', '\x00'})))
	}
	goto _cgol_4
_cgol_276:
	if _cgo_nm && _cgo_tag != uint32(269) {
		goto _cgol_277
	}
	_cgo_nm = false
	{
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[84]int8{'t', 'h', 'e', ' ', 'I', 'N', 'D', 'E', 'X', 'E', 'D', ' ', 'B', 'Y', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'U', 'P', 'D', 'A', 'T', 'E', ' ', 'o', 'r', ' ', 'D', 'E', 'L', 'E', 'T', 'E', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', 's', '\x00'})))
	}
	goto _cgol_4
_cgol_277:
	if _cgo_nm && _cgo_tag != uint32(270) {
		goto _cgol_278
	}
	_cgo_nm = false
	{
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[85]int8{'t', 'h', 'e', ' ', 'N', 'O', 'T', ' ', 'I', 'N', 'D', 'E', 'X', 'E', 'D', ' ', 'c', 'l', 'a', 'u', 's', 'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ' ', 'o', 'n', ' ', 'U', 'P', 'D', 'A', 'T', 'E', ' ', 'o', 'r', ' ', 'D', 'E', 'L', 'E', 'T', 'E', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'w', 'i', 't', 'h', 'i', 'n', ' ', 't', 'r', 'i', 'g', 'g', 'e', 'r', 's', '\x00'})))
	}
	goto _cgol_4
_cgol_278:
	if _cgo_nm && _cgo_tag != uint32(271) {
		goto _cgol_279
	}
	_cgo_nm = false
	{
		*(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3TriggerUpdateStep(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor)), *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), uint8(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor))), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor))).z, *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -8)*24))).minor)) = *(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_279:
	if _cgo_nm && _cgo_tag != uint32(272) {
		goto _cgol_280
	}
	_cgo_nm = false
	{
		*(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3TriggerInsertStep(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_IdList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), uint8(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -6)*24))).minor))), *(**struct_Upsert)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)), *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -7)*24))).minor)) = *(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_280:
	if _cgo_nm && _cgo_tag != uint32(273) {
		goto _cgol_281
	}
	_cgo_nm = false
	{
		*(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3TriggerDeleteStep(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor))).z, *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = *(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_281:
	if _cgo_nm && _cgo_tag != uint32(274) {
		goto _cgol_282
	}
	_cgo_nm = false
	{
		*(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3TriggerSelectStep(pParse.db, *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**int8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_TriggerStep)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_TriggerStep)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_282:
	if _cgo_nm && _cgo_tag != uint32(275) {
		goto _cgol_283
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3PExpr(pParse, 71, nil, nil)
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).affExpr = int8(4)
		}
	}
	goto _cgol_4
_cgol_283:
	if _cgo_nm && _cgo_tag != uint32(276) {
		goto _cgol_284
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = sqlite3ExprAlloc(pParse.db, 71, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), 1)
		if *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) != nil {
			(*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor))).affExpr = int8(*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)))
		}
	}
	goto _cgol_4
_cgol_284:
	if _cgo_nm && _cgo_tag != uint32(277) {
		goto _cgol_285
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(1)
	}
	goto _cgol_4
_cgol_285:
	if _cgo_nm && _cgo_tag != uint32(279) {
		goto _cgol_286
	}
	_cgo_nm = false
	{
		*(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = int32(3)
	}
	goto _cgol_4
_cgol_286:
	if _cgo_nm && _cgo_tag != uint32(280) {
		goto _cgol_287
	}
	_cgo_nm = false
	{
		sqlite3DropTrigger(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_287:
	if _cgo_nm && _cgo_tag != uint32(281) {
		goto _cgol_288
	}
	_cgo_nm = false
	{
		sqlite3Attach(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_288:
	if _cgo_nm && _cgo_tag != uint32(282) {
		goto _cgol_289
	}
	_cgo_nm = false
	{
		sqlite3Detach(pParse, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_289:
	if _cgo_nm && _cgo_tag != uint32(285) {
		goto _cgol_290
	}
	_cgo_nm = false
	{
		sqlite3Reindex(pParse, nil, nil)
	}
	goto _cgol_4
_cgol_290:
	if _cgo_nm && _cgo_tag != uint32(286) {
		goto _cgol_291
	}
	_cgo_nm = false
	{
		sqlite3Reindex(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_291:
	if _cgo_nm && _cgo_tag != uint32(287) {
		goto _cgol_292
	}
	_cgo_nm = false
	{
		sqlite3Analyze(pParse, nil, nil)
	}
	goto _cgol_4
_cgol_292:
	if _cgo_nm && _cgo_tag != uint32(288) {
		goto _cgol_293
	}
	_cgo_nm = false
	{
		sqlite3Analyze(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_293:
	if _cgo_nm && _cgo_tag != uint32(289) {
		goto _cgol_294
	}
	_cgo_nm = false
	{
		sqlite3AlterRenameTable(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_294:
	if _cgo_nm && _cgo_tag != uint32(290) {
		goto _cgol_295
	}
	_cgo_nm = false
	{
		(*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).n = uint32(int32(uintptr(unsafe.Pointer(pParse.sLastToken.z))-uintptr(unsafe.Pointer((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).z)))) + pParse.sLastToken.n
		sqlite3AlterFinishAddColumn(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	goto _cgol_4
_cgol_295:
	if _cgo_nm && _cgo_tag != uint32(291) {
		goto _cgol_296
	}
	_cgo_nm = false
	{
		sqlite3AlterDropColumn(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_296:
	if _cgo_nm && _cgo_tag != uint32(292) {
		goto _cgol_297
	}
	_cgo_nm = false
	{
		disableLookaside(pParse)
		sqlite3AlterBeginAddColumn(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_297:
	if _cgo_nm && _cgo_tag != uint32(293) {
		goto _cgol_298
	}
	_cgo_nm = false
	{
		sqlite3AlterRenameColumn(pParse, *(**struct_SrcList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_298:
	if _cgo_nm && _cgo_tag != uint32(294) {
		goto _cgol_299
	}
	_cgo_nm = false
	{
		sqlite3VtabFinishParse(pParse, nil)
	}
	goto _cgol_4
_cgol_299:
	if _cgo_nm && _cgo_tag != uint32(295) {
		goto _cgol_300
	}
	_cgo_nm = false
	{
		sqlite3VtabFinishParse(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_300:
	if _cgo_nm && _cgo_tag != uint32(296) {
		goto _cgol_301
	}
	_cgo_nm = false
	{
		sqlite3VtabBeginParse(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
	}
	goto _cgol_4
_cgol_301:
	if _cgo_nm && _cgo_tag != uint32(297) {
		goto _cgol_302
	}
	_cgo_nm = false
	{
		sqlite3VtabArgInit(pParse)
	}
	goto _cgol_4
_cgol_302:
	if _cgo_nm && _cgo_tag != uint32(298) {
		goto _cgol_303
	}
	_cgo_nm = false
_cgol_303:
	if _cgo_nm && _cgo_tag != uint32(299) {
		goto _cgol_304
	}
	_cgo_nm = false
_cgol_304:
	if _cgo_nm && _cgo_tag != uint32(300) {
		goto _cgol_305
	}
	_cgo_nm = false
	{
		sqlite3VtabArgExtend(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_305:
	if _cgo_nm && _cgo_tag != uint32(301) {
		goto _cgol_306
	}
	_cgo_nm = false
_cgol_306:
	if _cgo_nm && _cgo_tag != uint32(302) {
		goto _cgol_307
	}
	_cgo_nm = false
	{
		sqlite3WithPush(pParse, *(**struct_With)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), uint8(1))
	}
	goto _cgol_4
_cgol_307:
	if _cgo_nm && _cgo_tag != uint32(303) {
		goto _cgol_308
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = uint8(1)
	}
	goto _cgol_4
_cgol_308:
	if _cgo_nm && _cgo_tag != uint32(304) {
		goto _cgol_309
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = uint8(0)
	}
	goto _cgol_4
_cgol_309:
	if _cgo_nm && _cgo_tag != uint32(305) {
		goto _cgol_310
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = uint8(2)
	}
	goto _cgol_4
_cgol_310:
	if _cgo_nm && _cgo_tag != uint32(306) {
		goto _cgol_311
	}
	_cgo_nm = false
	{
		*(**struct_Cte)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = sqlite3CteNew(pParse, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)), *(**struct_Select)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), *(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)))
	}
	goto _cgol_4
_cgol_311:
	if _cgo_nm && _cgo_tag != uint32(307) {
		goto _cgol_312
	}
	_cgo_nm = false
	{
		*(**struct_With)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = sqlite3WithAdd(pParse, nil, *(**struct_Cte)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_312:
	if _cgo_nm && _cgo_tag != uint32(308) {
		goto _cgol_313
	}
	_cgo_nm = false
	{
		*(**struct_With)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = sqlite3WithAdd(pParse, *(**struct_With)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_Cte)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	goto _cgol_4
_cgol_313:
	if _cgo_nm && _cgo_tag != uint32(309) {
		goto _cgol_314
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_314:
	if _cgo_nm && _cgo_tag != uint32(310) {
		goto _cgol_315
	}
	_cgo_nm = false
	{
		func() int {
			_ = 0
			return 0
		}()
		sqlite3WindowChain(pParse, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)))
		(*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).pNextWin = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor))
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_315:
	if _cgo_nm && _cgo_tag != uint32(311) {
		goto _cgol_316
	}
	_cgo_nm = false
	{
		if *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) != nil {
			(*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).zName = sqlite3DbStrNDup(pParse.db, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).z, uint64((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor))).n))
		}
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_316:
	if _cgo_nm && _cgo_tag != uint32(312) {
		goto _cgol_317
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = sqlite3WindowAssemble(pParse, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_317:
	if _cgo_nm && _cgo_tag != uint32(313) {
		goto _cgol_318
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3WindowAssemble(pParse, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_318:
	if _cgo_nm && _cgo_tag != uint32(314) {
		goto _cgol_319
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = sqlite3WindowAssemble(pParse, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), nil)
	}
	goto _cgol_4
_cgol_319:
	if _cgo_nm && _cgo_tag != uint32(315) {
		goto _cgol_320
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3WindowAssemble(pParse, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, *(**struct_ExprList)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)), &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_320:
	if _cgo_nm && _cgo_tag != uint32(316) {
		goto _cgol_321
	}
	_cgo_nm = false
_cgol_321:
	if _cgo_nm && _cgo_tag != uint32(335) {
		goto _cgol_322
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_322:
	if _cgo_nm && _cgo_tag != uint32(317) {
		goto _cgol_323
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3WindowAssemble(pParse, *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)), nil, nil, &*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_323:
	if _cgo_nm && _cgo_tag != uint32(318) {
		goto _cgol_324
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = sqlite3WindowAlloc(pParse, 0, 90, nil, 85, nil, uint8(0))
	}
	goto _cgol_4
_cgol_324:
	if _cgo_nm && _cgo_tag != uint32(319) {
		goto _cgol_325
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3WindowAlloc(pParse, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)), (*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).eType, (*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).pExpr, 85, nil, *(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -2)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_325:
	if _cgo_nm && _cgo_tag != uint32(320) {
		goto _cgol_326
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = sqlite3WindowAlloc(pParse, *(*int32)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)), (*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).eType, (*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor))).pExpr, (*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).eType, (*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).pExpr, *(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -5)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_326:
	if _cgo_nm && _cgo_tag != uint32(322) {
		goto _cgol_327
	}
	_cgo_nm = false
_cgol_327:
	if _cgo_nm && _cgo_tag != uint32(324) {
		goto _cgol_328
	}
	_cgo_nm = false
	{
		*(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2)) = *(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_328:
	if _cgo_nm && _cgo_tag != uint32(323) {
		goto _cgol_329
	}
	_cgo_nm = false
_cgol_329:
	if _cgo_nm && _cgo_tag != uint32(325) {
		goto _cgol_330
	}
	_cgo_nm = false
_cgol_330:
	if _cgo_nm && _cgo_tag != uint32(327) {
		goto _cgol_331
	}
	_cgo_nm = false
	{
		(*(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))).eType = int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).major)
		(*(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))).pExpr = (*struct_Expr)(nil)
	}
	*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_331:
	if _cgo_nm && _cgo_tag != uint32(326) {
		goto _cgol_332
	}
	_cgo_nm = false
	{
		(*(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))).eType = int32((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major)
		(*(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))).pExpr = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	*(*struct_FrameBound)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*struct_FrameBound)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_332:
	if _cgo_nm && _cgo_tag != uint32(328) {
		goto _cgol_333
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(1)*24))).minor)) = uint8(0)
	}
	goto _cgol_4
_cgol_333:
	if _cgo_nm && _cgo_tag != uint32(329) {
		goto _cgol_334
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_334:
	if _cgo_nm && _cgo_tag != uint32(330) {
		goto _cgol_335
	}
	_cgo_nm = false
_cgol_335:
	if _cgo_nm && _cgo_tag != uint32(331) {
		goto _cgol_336
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = uint8((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).major)
	}
	goto _cgol_4
_cgol_336:
	if _cgo_nm && _cgo_tag != uint32(332) {
		goto _cgol_337
	}
	_cgo_nm = false
	{
		*(*uint8)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = uint8((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).major)
	}
	goto _cgol_4
_cgol_337:
	if _cgo_nm && _cgo_tag != uint32(333) {
		goto _cgol_338
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	goto _cgol_4
_cgol_338:
	if _cgo_nm && _cgo_tag != uint32(334) {
		goto _cgol_339
	}
	_cgo_nm = false
	{
		if *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) != nil {
			(*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).pFilter = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
		} else {
			sqlite3ExprDelete(pParse.db, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)))
		}
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_339:
	if _cgo_nm && _cgo_tag != uint32(336) {
		goto _cgol_340
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) = (*struct_Window)(sqlite3DbMallocZero(pParse.db, uint64(141)))
		if *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2)) != nil {
			(*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))).eFrmType = uint8(166)
			(*(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))).pFilter = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))
		} else {
			sqlite3ExprDelete(pParse.db, *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)))
		}
	}
	*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&yylhsminor_cgo2))
	goto _cgol_4
_cgol_340:
	if _cgo_nm && _cgo_tag != uint32(337) {
		goto _cgol_341
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -3)*24))).minor)) = *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
		func() int {
			_ = 0
			return 0
		}()
	}
	goto _cgol_4
_cgol_341:
	if _cgo_nm && _cgo_tag != uint32(338) {
		goto _cgol_342
	}
	_cgo_nm = false
	{
		*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) = (*struct_Window)(sqlite3DbMallocZero(pParse.db, uint64(141)))
		if *(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor)) != nil {
			(*(**struct_Window)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))).zName = sqlite3DbStrNDup(pParse.db, (*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).z, uint64((*(*struct_Token)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(0)*24))).minor))).n))
		}
	}
	goto _cgol_4
_cgol_342:
	if _cgo_nm && _cgo_tag != uint32(339) {
		goto _cgol_343
	}
	_cgo_nm = false
	{
		*(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -4)*24))).minor)) = *(**struct_Expr)(unsafe.Pointer(&(*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) - uintptr(- -1)*24))).minor))
	}
	goto _cgol_4
_cgol_344:
	_cgo_nm = false
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	goto _cgol_4
	goto _cgol_4
_cgol_343:
	goto _cgol_344
_cgol_4:
	func() int {
		_ = 0
		return 0
	}()
	yygoto = int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yyRuleInfoLhs)))) + uintptr(yyruleno)*2)))
	yysize = int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&yyRuleInfoNRhs)))) + uintptr(yyruleno))))
	yyact = yy_find_reduce_action((*(*struct_yyStackEntry)(unsafe.Pointer(uintptr(unsafe.Pointer(yymsp)) + uintptr(yysize)*24))).stateno, uint16(yygoto))
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	*(*uintptr)(unsafe.Pointer(&yymsp)) += uintptr(yysize+1) * 24
	yypParser.yytos = yymsp
	yymsp.stateno = uint16(yyact)
	yymsp.major = uint16(yygoto)
	return yyact
}
func yy_syntax_error(yypParser *struct_yyParser, yymajor int32, yyminor struct_Token) {
	var pParse *struct_Parse = yypParser.pParse
	func() int {
		_ = yymajor
		return 0
	}()
	if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(yyminor.z)) + uintptr(0))) != 0 {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[24]int8{'n', 'e', 'a', 'r', ' ', '"', '%', 'T', '"', ':', ' ', 's', 'y', 'n', 't', 'a', 'x', ' ', 'e', 'r', 'r', 'o', 'r', '\x00'})), &yyminor)
	} else {
		sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[17]int8{'i', 'n', 'c', 'o', 'm', 'p', 'l', 'e', 't', 'e', ' ', 'i', 'n', 'p', 'u', 't', '\x00'})))
	}
	yypParser.pParse = pParse
}
func yy_accept(yypParser *struct_yyParser) {
	var pParse *struct_Parse = yypParser.pParse
	func() int {
		_ = 0
		return 0
	}()
	yypParser.pParse = pParse
}
func sqlite3Parser(yyp unsafe.Pointer, yymajor int32, yyminor struct_Token) {
	var yyminorunion _cgoa_88
	var yyact uint16
	var yypParser *struct_yyParser = (*struct_yyParser)(yyp)
	var pParse *struct_Parse = yypParser.pParse
	func() int {
		_ = 0
		return 0
	}()
	yyact = yypParser.yytos.stateno
	for 1 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		yyact = yy_find_shift_action(uint16(yymajor), yyact)
		if int32(yyact) >= 1236 {
			var yyruleno uint32 = uint32(int32(yyact) - 1236)
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&yyRuleInfoNRhs)))) + uintptr(yyruleno)))) == 0 {
				if uintptr(unsafe.Pointer(yypParser.yytos)) >= uintptr(unsafe.Pointer(yypParser.yystackEnd)) {
					yyStackOverflow(yypParser)
					break
				}
			}
			yyact = yy_reduce(yypParser, yyruleno, yymajor, yyminor, pParse)
		} else if int32(yyact) <= 1232 {
			yy_shift(yypParser, yyact, uint16(yymajor), yyminor)
			break
		} else if int32(yyact) == 1234 {
			*(*uintptr)(unsafe.Pointer(&yypParser.yytos)) -= 24
			yy_accept(yypParser)
			return
		} else {
			func() int {
				_ = 0
				return 0
			}()
			*(*struct_Token)(unsafe.Pointer(&yyminorunion)) = yyminor
			yy_syntax_error(yypParser, yymajor, yyminor)
			yy_destructor(yypParser, uint16(yymajor), &yyminorunion)
			break
		}
	}
	return
}
func sqlite3ParserFallback(iToken int32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&yyFallback)))) + uintptr(iToken)*2)))
}

var aiClass [256]uint8 = [256]uint8{uint8(29), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(7), uint8(7), uint8(28), uint8(7), uint8(7), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(28), uint8(7), uint8(15), uint8(8), uint8(5), uint8(4), uint8(22), uint8(24), uint8(8), uint8(17), uint8(18), uint8(21), uint8(20), uint8(23), uint8(11), uint8(26), uint8(16), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(5), uint8(19), uint8(12), uint8(14), uint8(13), uint8(6), uint8(5), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(2), uint8(2), uint8(9), uint8(28), uint8(28), uint8(28), uint8(2), uint8(8), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(2), uint8(2), uint8(28), uint8(10), uint8(28), uint8(25), uint8(28), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(30), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27)}
var zKWText [666]int8 = [666]int8{int8('R'), int8('E'), int8('I'), int8('N'), int8('D'), int8('E'), int8('X'), int8('E'), int8('D'), int8('E'), int8('S'), int8('C'), int8('A'), int8('P'), int8('E'), int8('A'), int8('C'), int8('H'), int8('E'), int8('C'), int8('K'), int8('E'), int8('Y'), int8('B'), int8('E'), int8('F'), int8('O'), int8('R'), int8('E'), int8('I'), int8('G'), int8('N'), int8('O'), int8('R'), int8('E'), int8('G'), int8('E'), int8('X'), int8('P'), int8('L'), int8('A'), int8('I'), int8('N'), int8('S'), int8('T'), int8('E'), int8('A'), int8('D'), int8('D'), int8('A'), int8('T'), int8('A'), int8('B'), int8('A'), int8('S'), int8('E'), int8('L'), int8('E'), int8('C'), int8('T'), int8('A'), int8('B'), int8('L'), int8('E'), int8('F'), int8('T'), int8('H'), int8('E'), int8('N'), int8('D'), int8('E'), int8('F'), int8('E'), int8('R'), int8('R'), int8('A'), int8('B'), int8('L'), int8('E'), int8('L'), int8('S'), int8('E'), int8('X'), int8('C'), int8('L'), int8('U'), int8('D'), int8('E'), int8('L'), int8('E'), int8('T'), int8('E'), int8('M'), int8('P'), int8('O'), int8('R'), int8('A'), int8('R'), int8('Y'), int8('I'), int8('S'), int8('N'), int8('U'), int8('L'), int8('L'), int8('S'), int8('A'), int8('V'), int8('E'), int8('P'), int8('O'), int8('I'), int8('N'), int8('T'), int8('E'), int8('R'), int8('S'), int8('E'), int8('C'), int8('T'), int8('I'), int8('E'), int8('S'), int8('N'), int8('O'), int8('T'), int8('N'), int8('U'), int8('L'), int8('L'), int8('I'), int8('K'), int8('E'), int8('X'), int8('C'), int8('E'), int8('P'), int8('T'), int8('R'), int8('A'), int8('N'), int8('S'), int8('A'), int8('C'), int8('T'), int8('I'), int8('O'), int8('N'), int8('A'), int8('T'), int8('U'), int8('R'), int8('A'), int8('L'), int8('T'), int8('E'), int8('R'), int8('A'), int8('I'), int8('S'), int8('E'), int8('X'), int8('C'), int8('L'), int8('U'), int8('S'), int8('I'), int8('V'), int8('E'), int8('X'), int8('I'), int8('S'), int8('T'), int8('S'), int8('C'), int8('O'), int8('N'), int8('S'), int8('T'), int8('R'), int8('A'), int8('I'), int8('N'), int8('T'), int8('O'), int8('F'), int8('F'), int8('S'), int8('E'), int8('T'), int8('R'), int8('I'), int8('G'), int8('G'), int8('E'), int8('R'), int8('A'), int8('N'), int8('G'), int8('E'), int8('N'), int8('E'), int8('R'), int8('A'), int8('T'), int8('E'), int8('D'), int8('E'), int8('T'), int8('A'), int8('C'), int8('H'), int8('A'), int8('V'), int8('I'), int8('N'), int8('G'), int8('L'), int8('O'), int8('B'), int8('E'), int8('G'), int8('I'), int8('N'), int8('N'), int8('E'), int8('R'), int8('E'), int8('F'), int8('E'), int8('R'), int8('E'), int8('N'), int8('C'), int8('E'), int8('S'), int8('U'), int8('N'), int8('I'), int8('Q'), int8('U'), int8('E'), int8('R'), int8('Y'), int8('W'), int8('I'), int8('T'), int8('H'), int8('O'), int8('U'), int8('T'), int8('E'), int8('R'), int8('E'), int8('L'), int8('E'), int8('A'), int8('S'), int8('E'), int8('A'), int8('T'), int8('T'), int8('A'), int8('C'), int8('H'), int8('B'), int8('E'), int8('T'), int8('W'), int8('E'), int8('E'), int8('N'), int8('O'), int8('T'), int8('H'), int8('I'), int8('N'), int8('G'), int8('R'), int8('O'), int8('U'), int8('P'), int8('S'), int8('C'), int8('A'), int8('S'), int8('C'), int8('A'), int8('D'), int8('E'), int8('F'), int8('A'), int8('U'), int8('L'), int8('T'), int8('C'), int8('A'), int8('S'), int8('E'), int8('C'), int8('O'), int8('L'), int8('L'), int8('A'), int8('T'), int8('E'), int8('C'), int8('R'), int8('E'), int8('A'), int8('T'), int8('E'), int8('C'), int8('U'), int8('R'), int8('R'), int8('E'), int8('N'), int8('T'), int8('_'), int8('D'), int8('A'), int8('T'), int8('E'), int8('I'), int8('M'), int8('M'), int8('E'), int8('D'), int8('I'), int8('A'), int8('T'), int8('E'), int8('J'), int8('O'), int8('I'), int8('N'), int8('S'), int8('E'), int8('R'), int8('T'), int8('M'), int8('A'), int8('T'), int8('C'), int8('H'), int8('P'), int8('L'), int8('A'), int8('N'), int8('A'), int8('L'), int8('Y'), int8('Z'), int8('E'), int8('P'), int8('R'), int8('A'), int8('G'), int8('M'), int8('A'), int8('T'), int8('E'), int8('R'), int8('I'), int8('A'), int8('L'), int8('I'), int8('Z'), int8('E'), int8('D'), int8('E'), int8('F'), int8('E'), int8('R'), int8('R'), int8('E'), int8('D'), int8('I'), int8('S'), int8('T'), int8('I'), int8('N'), int8('C'), int8('T'), int8('U'), int8('P'), int8('D'), int8('A'), int8('T'), int8('E'), int8('V'), int8('A'), int8('L'), int8('U'), int8('E'), int8('S'), int8('V'), int8('I'), int8('R'), int8('T'), int8('U'), int8('A'), int8('L'), int8('W'), int8('A'), int8('Y'), int8('S'), int8('W'), int8('H'), int8('E'), int8('N'), int8('W'), int8('H'), int8('E'), int8('R'), int8('E'), int8('C'), int8('U'), int8('R'), int8('S'), int8('I'), int8('V'), int8('E'), int8('A'), int8('B'), int8('O'), int8('R'), int8('T'), int8('A'), int8('F'), int8('T'), int8('E'), int8('R'), int8('E'), int8('N'), int8('A'), int8('M'), int8('E'), int8('A'), int8('N'), int8('D'), int8('R'), int8('O'), int8('P'), int8('A'), int8('R'), int8('T'), int8('I'), int8('T'), int8('I'), int8('O'), int8('N'), int8('A'), int8('U'), int8('T'), int8('O'), int8('I'), int8('N'), int8('C'), int8('R'), int8('E'), int8('M'), int8('E'), int8('N'), int8('T'), int8('C'), int8('A'), int8('S'), int8('T'), int8('C'), int8('O'), int8('L'), int8('U'), int8('M'), int8('N'), int8('C'), int8('O'), int8('M'), int8('M'), int8('I'), int8('T'), int8('C'), int8('O'), int8('N'), int8('F'), int8('L'), int8('I'), int8('C'), int8('T'), int8('C'), int8('R'), int8('O'), int8('S'), int8('S'), int8('C'), int8('U'), int8('R'), int8('R'), int8('E'), int8('N'), int8('T'), int8('_'), int8('T'), int8('I'), int8('M'), int8('E'), int8('S'), int8('T'), int8('A'), int8('M'), int8('P'), int8('R'), int8('E'), int8('C'), int8('E'), int8('D'), int8('I'), int8('N'), int8('G'), int8('F'), int8('A'), int8('I'), int8('L'), int8('A'), int8('S'), int8('T'), int8('F'), int8('I'), int8('L'), int8('T'), int8('E'), int8('R'), int8('E'), int8('P'), int8('L'), int8('A'), int8('C'), int8('E'), int8('F'), int8('I'), int8('R'), int8('S'), int8('T'), int8('F'), int8('O'), int8('L'), int8('L'), int8('O'), int8('W'), int8('I'), int8('N'), int8('G'), int8('F'), int8('R'), int8('O'), int8('M'), int8('F'), int8('U'), int8('L'), int8('L'), int8('I'), int8('M'), int8('I'), int8('T'), int8('I'), int8('F'), int8('O'), int8('R'), int8('D'), int8('E'), int8('R'), int8('E'), int8('S'), int8('T'), int8('R'), int8('I'), int8('C'), int8('T'), int8('O'), int8('T'), int8('H'), int8('E'), int8('R'), int8('S'), int8('O'), int8('V'), int8('E'), int8('R'), int8('E'), int8('T'), int8('U'), int8('R'), int8('N'), int8('I'), int8('N'), int8('G'), int8('R'), int8('I'), int8('G'), int8('H'), int8('T'), int8('R'), int8('O'), int8('L'), int8('L'), int8('B'), int8('A'), int8('C'), int8('K'), int8('R'), int8('O'), int8('W'), int8('S'), int8('U'), int8('N'), int8('B'), int8('O'), int8('U'), int8('N'), int8('D'), int8('E'), int8('D'), int8('U'), int8('N'), int8('I'), int8('O'), int8('N'), int8('U'), int8('S'), int8('I'), int8('N'), int8('G'), int8('V'), int8('A'), int8('C'), int8('U'), int8('U'), int8('M'), int8('V'), int8('I'), int8('E'), int8('W'), int8('I'), int8('N'), int8('D'), int8('O'), int8('W'), int8('B'), int8('Y'), int8('I'), int8('N'), int8('I'), int8('T'), int8('I'), int8('A'), int8('L'), int8('L'), int8('Y'), int8('P'), int8('R'), int8('I'), int8('M'), int8('A'), int8('R'), int8('Y')}
var aKWHash [127]uint8 = [127]uint8{uint8(84), uint8(92), uint8(134), uint8(82), uint8(105), uint8(29), uint8(0), uint8(0), uint8(94), uint8(0), uint8(85), uint8(72), uint8(0), uint8(53), uint8(35), uint8(86), uint8(15), uint8(0), uint8(42), uint8(97), uint8(54), uint8(89), uint8(135), uint8(19), uint8(0), uint8(0), uint8(140), uint8(0), uint8(40), uint8(129), uint8(0), uint8(22), uint8(107), uint8(0), uint8(9), uint8(0), uint8(0), uint8(123), uint8(80), uint8(0), uint8(78), uint8(6), uint8(0), uint8(65), uint8(103), uint8(147), uint8(0), uint8(136), uint8(115), uint8(0), uint8(0), uint8(48), uint8(0), uint8(90), uint8(24), uint8(0), uint8(17), uint8(0), uint8(27), uint8(70), uint8(23), uint8(26), uint8(5), uint8(60), uint8(142), uint8(110), uint8(122), uint8(0), uint8(73), uint8(91), uint8(71), uint8(145), uint8(61), uint8(120), uint8(74), uint8(0), uint8(49), uint8(0), uint8(11), uint8(41), uint8(0), uint8(113), uint8(0), uint8(0), uint8(0), uint8(109), uint8(10), uint8(111), uint8(116), uint8(125), uint8(14), uint8(50), uint8(124), uint8(0), uint8(100), uint8(0), uint8(18), uint8(121), uint8(144), uint8(56), uint8(130), uint8(139), uint8(88), uint8(83), uint8(37), uint8(30), uint8(126), uint8(0), uint8(0), uint8(108), uint8(51), uint8(131), uint8(128), uint8(0), uint8(34), uint8(0), uint8(0), uint8(132), uint8(0), uint8(98), uint8(38), uint8(39), uint8(0), uint8(20), uint8(45), uint8(117), uint8(93)}
var aKWNext [147]uint8 = [147]uint8{uint8(0), uint8(0), uint8(0), uint8(0), uint8(4), uint8(0), uint8(43), uint8(0), uint8(0), uint8(106), uint8(114), uint8(0), uint8(0), uint8(0), uint8(2), uint8(0), uint8(0), uint8(143), uint8(0), uint8(0), uint8(0), uint8(13), uint8(0), uint8(0), uint8(0), uint8(0), uint8(141), uint8(0), uint8(0), uint8(119), uint8(52), uint8(0), uint8(0), uint8(137), uint8(12), uint8(0), uint8(0), uint8(62), uint8(0), uint8(138), uint8(0), uint8(133), uint8(0), uint8(0), uint8(36), uint8(0), uint8(0), uint8(28), uint8(77), uint8(0), uint8(0), uint8(0), uint8(0), uint8(59), uint8(0), uint8(47), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(69), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(146), uint8(3), uint8(0), uint8(58), uint8(0), uint8(1), uint8(75), uint8(0), uint8(0), uint8(0), uint8(31), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(127), uint8(0), uint8(104), uint8(0), uint8(64), uint8(66), uint8(63), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(46), uint8(0), uint8(16), uint8(8), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(81), uint8(101), uint8(0), uint8(112), uint8(21), uint8(7), uint8(67), uint8(0), uint8(79), uint8(96), uint8(118), uint8(0), uint8(0), uint8(68), uint8(0), uint8(0), uint8(99), uint8(44), uint8(0), uint8(55), uint8(0), uint8(76), uint8(0), uint8(95), uint8(32), uint8(33), uint8(57), uint8(25), uint8(0), uint8(102), uint8(0), uint8(0), uint8(87)}
var aKWLen [147]uint8 = [147]uint8{uint8(7), uint8(7), uint8(5), uint8(4), uint8(6), uint8(4), uint8(5), uint8(3), uint8(6), uint8(7), uint8(3), uint8(6), uint8(6), uint8(7), uint8(7), uint8(3), uint8(8), uint8(2), uint8(6), uint8(5), uint8(4), uint8(4), uint8(3), uint8(10), uint8(4), uint8(7), uint8(6), uint8(9), uint8(4), uint8(2), uint8(6), uint8(5), uint8(9), uint8(9), uint8(4), uint8(7), uint8(3), uint8(2), uint8(4), uint8(4), uint8(6), uint8(11), uint8(6), uint8(2), uint8(7), uint8(5), uint8(5), uint8(9), uint8(6), uint8(10), uint8(4), uint8(6), uint8(2), uint8(3), uint8(7), uint8(5), uint8(9), uint8(6), uint8(6), uint8(4), uint8(5), uint8(5), uint8(10), uint8(6), uint8(5), uint8(7), uint8(4), uint8(5), uint8(7), uint8(6), uint8(7), uint8(7), uint8(6), uint8(5), uint8(7), uint8(3), uint8(7), uint8(4), uint8(7), uint8(6), uint8(12), uint8(9), uint8(4), uint8(6), uint8(5), uint8(4), uint8(7), uint8(6), uint8(12), uint8(8), uint8(8), uint8(2), uint8(6), uint8(6), uint8(7), uint8(6), uint8(4), uint8(5), uint8(9), uint8(5), uint8(5), uint8(6), uint8(3), uint8(4), uint8(9), uint8(13), uint8(2), uint8(2), uint8(4), uint8(6), uint8(6), uint8(8), uint8(5), uint8(17), uint8(12), uint8(7), uint8(9), uint8(4), uint8(4), uint8(6), uint8(7), uint8(5), uint8(9), uint8(4), uint8(4), uint8(5), uint8(2), uint8(5), uint8(8), uint8(6), uint8(4), uint8(9), uint8(5), uint8(8), uint8(4), uint8(3), uint8(9), uint8(5), uint8(5), uint8(6), uint8(4), uint8(6), uint8(2), uint8(2), uint8(9), uint8(3), uint8(7)}
var aKWOffset [147]uint16 = [147]uint16{uint16(0), uint16(2), uint16(2), uint16(8), uint16(9), uint16(14), uint16(16), uint16(20), uint16(23), uint16(25), uint16(25), uint16(29), uint16(33), uint16(36), uint16(41), uint16(46), uint16(48), uint16(53), uint16(54), uint16(59), uint16(62), uint16(65), uint16(67), uint16(69), uint16(78), uint16(81), uint16(86), uint16(90), uint16(90), uint16(94), uint16(99), uint16(101), uint16(105), uint16(111), uint16(119), uint16(123), uint16(123), uint16(123), uint16(126), uint16(129), uint16(132), uint16(137), uint16(142), uint16(146), uint16(147), uint16(152), uint16(156), uint16(160), uint16(168), uint16(174), uint16(181), uint16(184), uint16(184), uint16(187), uint16(189), uint16(195), uint16(198), uint16(206), uint16(211), uint16(216), uint16(219), uint16(222), uint16(226), uint16(236), uint16(239), uint16(244), uint16(244), uint16(248), uint16(252), uint16(259), uint16(265), uint16(271), uint16(277), uint16(277), uint16(283), uint16(284), uint16(288), uint16(295), uint16(299), uint16(306), uint16(312), uint16(324), uint16(333), uint16(335), uint16(341), uint16(346), uint16(348), uint16(355), uint16(359), uint16(370), uint16(377), uint16(378), uint16(385), uint16(391), uint16(397), uint16(402), uint16(408), uint16(412), uint16(415), uint16(424), uint16(429), uint16(433), uint16(439), uint16(441), uint16(444), uint16(453), uint16(455), uint16(457), uint16(466), uint16(470), uint16(476), uint16(482), uint16(490), uint16(495), uint16(495), uint16(495), uint16(511), uint16(520), uint16(523), uint16(527), uint16(532), uint16(539), uint16(544), uint16(553), uint16(557), uint16(560), uint16(565), uint16(567), uint16(571), uint16(579), uint16(585), uint16(588), uint16(597), uint16(602), uint16(610), uint16(610), uint16(614), uint16(623), uint16(628), uint16(633), uint16(639), uint16(642), uint16(645), uint16(648), uint16(650), uint16(655), uint16(659)}
var aKWCode [147]uint8 = [147]uint8{uint8(98), uint8(116), uint8(161), uint8(39), uint8(58), uint8(41), uint8(124), uint8(67), uint8(33), uint8(132), uint8(62), uint8(63), uint8(47), uint8(2), uint8(65), uint8(163), uint8(38), uint8(24), uint8(138), uint8(16), uint8(118), uint8(159), uint8(11), uint8(131), uint8(160), uint8(91), uint8(128), uint8(21), uint8(21), uint8(43), uint8(50), uint8(82), uint8(13), uint8(137), uint8(94), uint8(51), uint8(19), uint8(66), uint8(121), uint8(47), uint8(136), uint8(6), uint8(28), uint8(115), uint8(118), uint8(162), uint8(71), uint8(9), uint8(20), uint8(119), uint8(151), uint8(69), uint8(68), uint8(130), uint8(77), uint8(89), uint8(95), uint8(40), uint8(147), uint8(47), uint8(5), uint8(118), uint8(125), uint8(123), uint8(3), uint8(26), uint8(81), uint8(118), uint8(14), uint8(32), uint8(48), uint8(152), uint8(92), uint8(146), uint8(35), uint8(31), uint8(120), uint8(157), uint8(113), uint8(17), uint8(100), uint8(8), uint8(143), uint8(127), uint8(46), uint8(4), uint8(30), uint8(70), uint8(97), uint8(7), uint8(140), uint8(45), uint8(129), uint8(139), uint8(80), uint8(96), uint8(158), uint8(149), uint8(72), uint8(27), uint8(29), uint8(99), uint8(44), uint8(133), uint8(87), uint8(126), uint8(15), uint8(49), uint8(36), uint8(60), uint8(10), uint8(37), uint8(118), uint8(100), uint8(100), uint8(85), uint8(88), uint8(42), uint8(84), uint8(166), uint8(73), uint8(83), uint8(86), uint8(142), uint8(118), uint8(148), uint8(18), uint8(145), uint8(74), uint8(93), uint8(165), uint8(150), uint8(118), uint8(12), uint8(76), uint8(75), uint8(90), uint8(134), uint8(144), uint8(78), uint8(79), uint8(164), uint8(61), uint8(34), uint8(64), uint8(135), uint8(122)}

func keywordCode(z *int8, n int32, pType *int32) int32 {
	var i int32
	var j int32
	var zKW *int8
	if n >= 2 {
		i = (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))))))))*4 ^ int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3UpperToLower)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(n-1))))))))*3 ^ n*1) % 127
		for i = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aKWHash)))) + uintptr(i)))) - 1; i >= 0; i = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aKWNext)))) + uintptr(i)))) - 1 {
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aKWLen)))) + uintptr(i)))) != n {
				continue
			}
			zKW = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zKWText)))) + uintptr(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aKWOffset)))) + uintptr(i)*2)))))
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) & ^32 != int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zKW)) + uintptr(0)))) {
				continue
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) & ^32 != int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zKW)) + uintptr(1)))) {
				continue
			}
			j = int32(2)
			for j < n && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))) & ^32 == int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zKW)) + uintptr(j)))) {
				j++
			}
			if j < n {
				continue
			}
			*pType = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aKWCode)))) + uintptr(i))))
			break
		}
	}
	return n
}
func sqlite3KeywordCode(z *uint8, n int32) int32 {
	var id int32 = 59
	keywordCode((*int8)(unsafe.Pointer(z)), n, &id)
	return id
}
func sqlite3_keyword_name(i int32, pzName **int8, pnName *int32) int32 {
	if i < 0 || i >= 147 {
		return int32(1)
	}
	*pzName = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&zKWText)))) + uintptr(int32(*(*uint16)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint16)(unsafe.Pointer(&aKWOffset)))) + uintptr(i)*2))))))
	*pnName = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aKWLen)))) + uintptr(i))))
	return int32(0)
}
func sqlite3_keyword_count() int32 {
	return int32(147)
}
func sqlite3_keyword_check(zName *int8, nName int32) int32 {
	return func() int32 {
		if 59 != sqlite3KeywordCode((*uint8)(unsafe.Pointer(zName)), nName) {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3IsIdChar(c uint8) int32 {
	return func() int32 {
		if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(c)))))&70 != 0 {
			return 1
		} else {
			return 0
		}
	}()
}
func getToken(pz **uint8) int32 {
	var z *uint8 = *pz
	var t int32
	for {
		*(*uintptr)(unsafe.Pointer(&z)) += uintptr(sqlite3GetToken(z, &t))
		if !(t == 183) {
			break
		}
	}
	if t == 59 || t == 117 || t == 118 || t == 164 || t == 165 || sqlite3ParserFallback(t) == 59 {
		t = int32(59)
	}
	*pz = z
	return t
}
func analyzeWindowKeyword(z *uint8) int32 {
	var t int32
	t = getToken(&z)
	if t != 59 {
		return int32(59)
	}
	t = getToken(&z)
	if t != 24 {
		return int32(59)
	}
	return int32(164)
}
func analyzeOverKeyword(z *uint8, lastToken int32) int32 {
	if lastToken == 23 {
		var t int32 = getToken(&z)
		if t == 22 || t == 59 {
			return int32(165)
		}
	}
	return int32(59)
}
func analyzeFilterKeyword(z *uint8, lastToken int32) int32 {
	if lastToken == 23 && getToken(&z) == 22 {
		return int32(166)
	}
	return int32(59)
}
func sqlite3GetToken(z *uint8, tokenType *int32) int32 {
	var i int32
	var c int32
	switch int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aiClass)))) + uintptr(*z)))) {
	case 7:
		{
			for i = int32(1); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&1 != 0; i++ {
			}
			*tokenType = int32(183)
			return i
		}
	case 11:
		{
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == '-' {
				for i = int32(2); func() (_cgo_ret int32) {
					_cgo_addr := &c
					*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
					return *_cgo_addr
				}() != 0 && c != '\n'; i++ {
				}
				*tokenType = int32(183)
				return i
			} else if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == '>' {
				*tokenType = int32(112)
				return 2 + func() int32 {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(2)))) == '>' {
						return 1
					} else {
						return 0
					}
				}()
			}
			*tokenType = int32(107)
			return int32(1)
		}
	case 17:
		{
			*tokenType = int32(22)
			return int32(1)
		}
	case 18:
		{
			*tokenType = int32(23)
			return int32(1)
		}
	case 19:
		{
			*tokenType = int32(1)
			return int32(1)
		}
	case 20:
		{
			*tokenType = int32(106)
			return int32(1)
		}
	case 21:
		{
			*tokenType = int32(108)
			return int32(1)
		}
	case 16:
		{
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) != '*' || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(2)))) == 0 {
				*tokenType = int32(109)
				return int32(1)
			}
			for func() int32 {
				i = int32(3)
				return func() (_cgo_ret int32) {
					_cgo_addr := &c
					*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(2))))
					return *_cgo_addr
				}()
			}(); (c != '*' || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) != '/') && func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
				return *_cgo_addr
			}() != 0; i++ {
			}
			if c != 0 {
				i++
			}
			*tokenType = int32(183)
			return i
		}
	case 22:
		{
			*tokenType = int32(110)
			return int32(1)
		}
	case 14:
		{
			*tokenType = int32(53)
			return 1 + func() int32 {
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == '=' {
					return 1
				} else {
					return 0
				}
			}()
		}
	case 12:
		{
			if func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1))))
				return *_cgo_addr
			}() == '=' {
				*tokenType = int32(55)
				return int32(2)
			} else if c == '>' {
				*tokenType = int32(52)
				return int32(2)
			} else if c == '<' {
				*tokenType = int32(104)
				return int32(2)
			} else {
				*tokenType = int32(56)
				return int32(1)
			}
		}
	case 13:
		{
			if func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1))))
				return *_cgo_addr
			}() == '=' {
				*tokenType = int32(57)
				return int32(2)
			} else if c == '>' {
				*tokenType = int32(105)
				return int32(2)
			} else {
				*tokenType = int32(54)
				return int32(1)
			}
		}
	case 15:
		{
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) != '=' {
				*tokenType = int32(184)
				return int32(1)
			} else {
				*tokenType = int32(52)
				return int32(2)
			}
		}
	case 10:
		{
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) != '|' {
				*tokenType = int32(103)
				return int32(1)
			} else {
				*tokenType = int32(111)
				return int32(2)
			}
		}
	case 23:
		{
			*tokenType = int32(25)
			return int32(1)
		}
	case 24:
		{
			*tokenType = int32(102)
			return int32(1)
		}
	case 25:
		{
			*tokenType = int32(114)
			return int32(1)
		}
	case 8:
		{
			var delim int32 = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))))
			for i = int32(1); func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
				return *_cgo_addr
			}() != 0; i++ {
				if c == delim {
					if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))) == delim {
						i++
					} else {
						break
					}
				}
			}
			if c == '\'' {
				*tokenType = int32(117)
				return i + 1
			} else if c != 0 {
				*tokenType = int32(59)
				return i + 1
			} else {
				*tokenType = int32(184)
				return i
			}
		}
	case 26:
		{
			if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1))))))))&4 != 0) {
				*tokenType = int32(141)
				return int32(1)
			}
		}
	case 3:
		{
			*tokenType = int32(155)
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) == '0' && (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == 'x' || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == 'X') && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(2))))))))&8 != 0 {
				for i = int32(3); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&8 != 0; i++ {
				}
				return i
			}
			for i = int32(0); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&4 != 0; i++ {
			}
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == '.' {
				i++
				for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&4 != 0 {
					i++
				}
				*tokenType = int32(153)
			}
			if (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == 'e' || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) == 'E') && (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1))))))))&4 != 0 || (int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))) == '+' || int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))) == '-') && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+2))))))))&4 != 0) {
				i += int32(2)
				for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&4 != 0 {
					i++
				}
				*tokenType = int32(153)
			}
			for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&70 != 0 {
				*tokenType = int32(184)
				i++
			}
			return i
		}
	case 9:
		{
			for func() int32 {
				i = int32(1)
				return func() (_cgo_ret int32) {
					_cgo_addr := &c
					*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))))
					return *_cgo_addr
				}()
			}(); c != ']' && func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
				return *_cgo_addr
			}() != 0; i++ {
			}
			*tokenType = func() int32 {
				if c == ']' {
					return 59
				} else {
					return 184
				}
			}()
			return i
		}
	case 6:
		{
			*tokenType = int32(156)
			for i = int32(1); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&4 != 0; i++ {
			}
			return i
		}
	case 4:
		fallthrough
	case 5:
		{
			var n int32 = 0
			*tokenType = int32(156)
			for i = int32(1); func() (_cgo_ret int32) {
				_cgo_addr := &c
				*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
				return *_cgo_addr
			}() != 0; i++ {
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(c)))))&70 != 0 {
					n++
				} else if c == '(' && n > 0 {
					for {
						i++
						if !(func() (_cgo_ret int32) {
							_cgo_addr := &c
							*_cgo_addr = int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
							return *_cgo_addr
						}() != 0 && !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(c)))))&1 != 0) && c != ')') {
							break
						}
					}
					if c == ')' {
						i++
					} else {
						*tokenType = int32(184)
					}
					break
				} else if c == ':' && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+1)))) == ':' {
					i++
				} else {
					break
				}
			}
			if n == 0 {
				*tokenType = int32(184)
			}
			return i
		}
	case 1:
		{
			for i = int32(1); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&aiClass)))) + uintptr(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))) <= 2; i++ {
			}
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&70 != 0 {
				i++
				break
			}
			*tokenType = int32(59)
			return keywordCode((*int8)(unsafe.Pointer(z)), i, tokenType)
		}
	case 0:
		{
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == '\'' {
				*tokenType = int32(154)
				for i = int32(2); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&8 != 0; i++ {
				}
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) != '\'' || i%2 != 0 {
					*tokenType = int32(184)
					for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))) != '\'' {
						i++
					}
				}
				if *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))) != 0 {
					i++
				}
				return i
			}
		}
	case 2:
		fallthrough
	case 27:
		{
			i = int32(1)
			break
		}
	case 30:
		{
			if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))) == 187 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(2)))) == 191 {
				*tokenType = int32(183)
				return int32(3)
			}
			i = int32(1)
			break
		}
	case 29:
		{
			*tokenType = int32(184)
			return int32(0)
		}
	default:
		{
			*tokenType = int32(184)
			return int32(1)
		}
	}
	for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&70 != 0 {
		i++
	}
	*tokenType = int32(59)
	return i
}
func sqlite3RunParser(pParse *struct_Parse, zSql *int8) int32 {
	var nErr int32 = 0
	var pEngine unsafe.Pointer
	var n int32 = 0
	var tokenType int32
	var lastTokenParsed int32 = -1
	var db *struct_sqlite3 = pParse.db
	var mxSqlLen int32
	var pParentParse *struct_Parse = nil
	var sEngine struct_yyParser
	func() int {
		_ = 0
		return 0
	}()
	mxSqlLen = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(1)*4))
	if db.nVdbeActive == 0 {
		__atomic_store_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0, 0)
	}
	pParse.rc = int32(0)
	pParse.zTail = zSql
	pEngine = unsafe.Pointer(&sEngine)
	sqlite3ParserInit(pEngine, pParse)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	pParentParse = db.pParse
	db.pParse = pParse
	for 1 != 0 {
		n = sqlite3GetToken((*uint8)(unsafe.Pointer(zSql)), &tokenType)
		mxSqlLen -= n
		if mxSqlLen < 0 {
			pParse.rc = int32(18)
			break
		}
		if tokenType >= 164 {
			func() int {
				_ = 0
				return 0
			}()
			if __atomic_load_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0) != 0 {
				pParse.rc = int32(9)
				pParse.nErr++
				break
			}
			if tokenType == 183 {
				*(*uintptr)(unsafe.Pointer(&zSql)) += uintptr(n)
				continue
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0)))) == 0 {
				if lastTokenParsed == 1 {
					tokenType = int32(0)
				} else if lastTokenParsed == 0 {
					break
				} else {
					tokenType = int32(1)
				}
				n = int32(0)
			} else if tokenType == 164 {
				func() int {
					_ = 0
					return 0
				}()
				tokenType = analyzeWindowKeyword((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(6))))))
			} else if tokenType == 165 {
				func() int {
					_ = 0
					return 0
				}()
				tokenType = analyzeOverKeyword((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(4))))), lastTokenParsed)
			} else if tokenType == 166 {
				func() int {
					_ = 0
					return 0
				}()
				tokenType = analyzeFilterKeyword((*uint8)(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(6))))), lastTokenParsed)
			} else {
				var x struct_Token
				x.z = zSql
				x.n = uint32(n)
				sqlite3ErrorMsg(pParse, (*int8)(unsafe.Pointer(&[25]int8{'u', 'n', 'r', 'e', 'c', 'o', 'g', 'n', 'i', 'z', 'e', 'd', ' ', 't', 'o', 'k', 'e', 'n', ':', ' ', '"', '%', 'T', '"', '\x00'})), &x)
				break
			}
		}
		pParse.sLastToken.z = zSql
		pParse.sLastToken.n = uint32(n)
		sqlite3Parser(pEngine, tokenType, pParse.sLastToken)
		lastTokenParsed = tokenType
		*(*uintptr)(unsafe.Pointer(&zSql)) += uintptr(n)
		func() int {
			_ = 0
			return 0
		}()
		if pParse.rc != 0 {
			break
		}
	}
	func() int {
		_ = 0
		return 0
	}()
	sqlite3ParserFinalize(pEngine)
	if db.mallocFailed != 0 {
		pParse.rc = int32(7)
	}
	if pParse.zErrMsg != nil || pParse.rc != 0 && pParse.rc != 101 {
		if uintptr(unsafe.Pointer(pParse.zErrMsg)) == uintptr(unsafe.Pointer(nil)) {
			pParse.zErrMsg = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'})), sqlite3ErrStr(pParse.rc))
		}
		sqlite3_log(pParse.rc, (*int8)(unsafe.Pointer(&[11]int8{'%', 's', ' ', 'i', 'n', ' ', '"', '%', 's', '"', '\x00'})), pParse.zErrMsg, pParse.zTail)
		nErr++
	}
	pParse.zTail = zSql
	sqlite3_free(unsafe.Pointer(pParse.apVtabLock))
	if pParse.pNewTable != nil && !(int32(pParse.eParseMode) != 0) {
		sqlite3DeleteTable(db, pParse.pNewTable)
	}
	if pParse.pNewTrigger != nil && !(int32(pParse.eParseMode) >= 2) {
		sqlite3DeleteTrigger(db, pParse.pNewTrigger)
	}
	sqlite3DbFree(db, unsafe.Pointer(pParse.pVList))
	db.pParse = pParentParse
	func() int {
		_ = 0
		return 0
	}()
	return nErr
}
func sqlite3_complete(zSql *int8) int32 {
	var state uint8 = uint8(0)
	var token uint8
	var trans [8][8]uint8 = [8][8]uint8{[8]uint8{uint8(1), uint8(0), uint8(2), uint8(3), uint8(4), uint8(2), uint8(2), uint8(2)}, [8]uint8{uint8(1), uint8(1), uint8(2), uint8(3), uint8(4), uint8(2), uint8(2), uint8(2)}, [8]uint8{uint8(1), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2)}, [8]uint8{uint8(1), uint8(3), uint8(3), uint8(2), uint8(4), uint8(2), uint8(2), uint8(2)}, [8]uint8{uint8(1), uint8(4), uint8(2), uint8(2), uint8(2), uint8(4), uint8(5), uint8(2)}, [8]uint8{uint8(6), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5)}, [8]uint8{uint8(6), uint8(6), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(7)}, [8]uint8{uint8(1), uint8(7), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5), uint8(5)}}
	for *zSql != 0 {
		switch int32(*zSql) {
		case ';':
			{
				token = uint8(0)
				break
			}
		case ' ':
			fallthrough
		case '\r':
			fallthrough
		case '\t':
			fallthrough
		case '\n':
			fallthrough
		case '\f':
			{
				token = uint8(1)
				break
			}
		case '/':
			{
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(1)))) != '*' {
					token = uint8(2)
					break
				}
				*(*uintptr)(unsafe.Pointer(&zSql)) += uintptr(2)
				for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0)))) != 0 && (int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0)))) != '*' || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(1)))) != '/') {
					*(*uintptr)(unsafe.Pointer(&zSql))++
				}
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(0)))) == 0 {
					return int32(0)
				}
				*(*uintptr)(unsafe.Pointer(&zSql))++
				token = uint8(1)
				break
			}
		case '-':
			{
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(1)))) != '-' {
					token = uint8(2)
					break
				}
				for int32(*zSql) != 0 && int32(*zSql) != '\n' {
					*(*uintptr)(unsafe.Pointer(&zSql))++
				}
				if int32(*zSql) == 0 {
					return func() int32 {
						if int32(state) == 1 {
							return 1
						} else {
							return 0
						}
					}()
				}
				token = uint8(1)
				break
			}
		case '[':
			{
				*(*uintptr)(unsafe.Pointer(&zSql))++
				for int32(*zSql) != 0 && int32(*zSql) != ']' {
					*(*uintptr)(unsafe.Pointer(&zSql))++
				}
				if int32(*zSql) == 0 {
					return int32(0)
				}
				token = uint8(2)
				break
			}
		case '`':
			fallthrough
		case '"':
			fallthrough
		case '\'':
			{
				var c int32 = int32(*zSql)
				*(*uintptr)(unsafe.Pointer(&zSql))++
				for int32(*zSql) != 0 && int32(*zSql) != c {
					*(*uintptr)(unsafe.Pointer(&zSql))++
				}
				if int32(*zSql) == 0 {
					return int32(0)
				}
				token = uint8(2)
				break
			}
		default:
			{
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(uint8(*zSql))))))&70 != 0 {
					var nId int32
					for nId = int32(1); int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zSql)) + uintptr(nId))))))))&70 != 0; nId++ {
					}
					switch int32(*zSql) {
					case 'c':
						fallthrough
					case 'C':
						{
							if nId == 6 && sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[7]int8{'c', 'r', 'e', 'a', 't', 'e', '\x00'})), 6) == 0 {
								token = uint8(4)
							} else {
								token = uint8(2)
							}
							break
						}
					case 't':
						fallthrough
					case 'T':
						{
							if nId == 7 && sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[8]int8{'t', 'r', 'i', 'g', 'g', 'e', 'r', '\x00'})), 7) == 0 {
								token = uint8(6)
							} else if nId == 4 && sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[5]int8{'t', 'e', 'm', 'p', '\x00'})), 4) == 0 {
								token = uint8(5)
							} else if nId == 9 && sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[10]int8{'t', 'e', 'm', 'p', 'o', 'r', 'a', 'r', 'y', '\x00'})), 9) == 0 {
								token = uint8(5)
							} else {
								token = uint8(2)
							}
							break
						}
					case 'e':
						fallthrough
					case 'E':
						{
							if nId == 3 && sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[4]int8{'e', 'n', 'd', '\x00'})), 3) == 0 {
								token = uint8(7)
							} else if nId == 7 && sqlite3_strnicmp(zSql, (*int8)(unsafe.Pointer(&[8]int8{'e', 'x', 'p', 'l', 'a', 'i', 'n', '\x00'})), 7) == 0 {
								token = uint8(3)
							} else {
								token = uint8(2)
							}
							break
						}
					default:
						{
							token = uint8(2)
							break
						}
					}
					*(*uintptr)(unsafe.Pointer(&zSql)) += uintptr(nId - 1)
				} else {
					token = uint8(2)
				}
				break
			}
		}
		state = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&*(*[8]uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*[8]uint8)(unsafe.Pointer(&trans)))) + uintptr(state)*8)))))) + uintptr(token)))
		*(*uintptr)(unsafe.Pointer(&zSql))++
	}
	return func() int32 {
		if int32(state) == 1 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3_complete16(zSql unsafe.Pointer) int32 {
	var pVal *struct_sqlite3_value
	var zSql8 *int8
	var rc int32
	rc = sqlite3_initialize()
	if rc != 0 {
		return rc
	}
	pVal = sqlite3ValueNew(nil)
	sqlite3ValueSetStr(pVal, -1, zSql, uint8(2), (func(unsafe.Pointer))(0))
	zSql8 = (*int8)(sqlite3ValueText(pVal, uint8(1)))
	if zSql8 != nil {
		rc = sqlite3_complete(zSql8)
	} else {
		rc = int32(7)
	}
	sqlite3ValueFree(pVal)
	return rc & 255
}
func sqlite3TestExtInit(db *struct_sqlite3) int32 {
	func() int {
		_ = db
		return 0
	}()
	return sqlite3FaultSim(500)
}

var sqlite3BuiltinExtensions [2]func(*struct_sqlite3) int32 = [2]func(*struct_sqlite3) int32{sqlite3TestExtInit, sqlite3JsonTableFunctions}

func sqlite3_libversion() *int8 {
	return (*int8)(unsafe.Pointer(&sqlite3_version))
}
func sqlite3_libversion_number() int32 {
	return int32(3038002)
}
func sqlite3_threadsafe() int32 {
	return int32(1)
}

var sqlite3_temp_directory *int8 = nil
var sqlite3_data_directory *int8 = nil

func sqlite3_initialize() int32 {
	var pMainMtx *struct_sqlite3_mutex
	var rc int32
	func() int {
		_ = 0
		return 0
	}()
	if sqlite3Config.isInit != 0 {
		sqlite3MemoryBarrier()
		return int32(0)
	}
	rc = sqlite3MutexInit()
	if rc != 0 {
		return rc
	}
	pMainMtx = sqlite3MutexAlloc(2)
	sqlite3_mutex_enter(pMainMtx)
	sqlite3Config.isMutexInit = int32(1)
	if !(sqlite3Config.isMallocInit != 0) {
		rc = sqlite3MallocInit()
	}
	if rc == 0 {
		sqlite3Config.isMallocInit = int32(1)
		if !(sqlite3Config.pInitMutex != nil) {
			sqlite3Config.pInitMutex = sqlite3MutexAlloc(1)
			if int32(sqlite3Config.bCoreMutex) != 0 && !(sqlite3Config.pInitMutex != nil) {
				rc = int32(7)
			}
		}
	}
	if rc == 0 {
		sqlite3Config.nRefInitMutex++
	}
	sqlite3_mutex_leave(pMainMtx)
	if rc != 0 {
		return rc
	}
	sqlite3_mutex_enter(sqlite3Config.pInitMutex)
	if sqlite3Config.isInit == 0 && sqlite3Config.inProgress == 0 {
		sqlite3Config.inProgress = int32(1)
		__builtin___memset_chk(unsafe.Pointer(&sqlite3BuiltinFunctions), 0, 184, __builtin_object_size(unsafe.Pointer(&sqlite3BuiltinFunctions), 0))
		sqlite3RegisterBuiltinFunctions()
		if sqlite3Config.isPCacheInit == 0 {
			rc = sqlite3PcacheInitialize()
		}
		if rc == 0 {
			sqlite3Config.isPCacheInit = int32(1)
			rc = sqlite3OsInit()
		}
		if rc == 0 {
			rc = sqlite3MemdbInit()
		}
		if rc == 0 {
			sqlite3PCacheBufferSetup(sqlite3Config.pPage, sqlite3Config.szPage, sqlite3Config.nPage)
			sqlite3MemoryBarrier()
			sqlite3Config.isInit = int32(1)
		}
		sqlite3Config.inProgress = int32(0)
	}
	sqlite3_mutex_leave(sqlite3Config.pInitMutex)
	sqlite3_mutex_enter(pMainMtx)
	sqlite3Config.nRefInitMutex--
	if sqlite3Config.nRefInitMutex <= 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_mutex_free(sqlite3Config.pInitMutex)
		sqlite3Config.pInitMutex = (*struct_sqlite3_mutex)(nil)
	}
	sqlite3_mutex_leave(pMainMtx)
	return rc
}
func sqlite3_shutdown() int32 {
	if sqlite3Config.isInit != 0 {
		sqlite3_os_end()
		sqlite3_reset_auto_extension()
		sqlite3Config.isInit = int32(0)
	}
	if sqlite3Config.isPCacheInit != 0 {
		sqlite3PcacheShutdown()
		sqlite3Config.isPCacheInit = int32(0)
	}
	if sqlite3Config.isMallocInit != 0 {
		sqlite3MallocEnd()
		sqlite3Config.isMallocInit = int32(0)
		sqlite3_data_directory = (*int8)(nil)
		sqlite3_temp_directory = (*int8)(nil)
	}
	if sqlite3Config.isMutexInit != 0 {
		sqlite3MutexEnd()
		sqlite3Config.isMutexInit = int32(0)
	}
	return int32(0)
}
func sqlite3_config(op int32, __cgo_args ...interface {
}) int32 {
	var rc int32 = 0
	if sqlite3Config.isInit != 0 {
		return sqlite3MisuseError(168908)
	}
	switch op {
	case 1:
		{
			sqlite3Config.bCoreMutex = uint8(0)
			sqlite3Config.bFullMutex = uint8(0)
			break
		}
	case 2:
		{
			sqlite3Config.bCoreMutex = uint8(1)
			sqlite3Config.bFullMutex = uint8(0)
			break
		}
	case 3:
		{
			sqlite3Config.bCoreMutex = uint8(1)
			sqlite3Config.bFullMutex = uint8(1)
			break
		}
	case 10:
		{
			sqlite3Config.mutex = *func() (_cgo_ret *struct_sqlite3_mutex_methods) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_mutex_methods)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 11:
		{
			*func() (_cgo_ret *struct_sqlite3_mutex_methods) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_mutex_methods)
				__cgo_args = __cgo_args[1:]
				return
			}() = sqlite3Config.mutex
			break
		}
	case 4:
		{
			sqlite3Config.m = *func() (_cgo_ret *struct_sqlite3_mem_methods) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_mem_methods)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 5:
		{
			if uintptr(unsafe.Pointer(sqlite3Config.m.xMalloc)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3MemSetDefault()
			}
			*func() (_cgo_ret *struct_sqlite3_mem_methods) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_mem_methods)
				__cgo_args = __cgo_args[1:]
				return
			}() = sqlite3Config.m
			break
		}
	case 9:
		{
			sqlite3Config.bMemstat = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 27:
		{
			sqlite3Config.bSmallMalloc = uint8(func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}())
			break
		}
	case 7:
		{
			sqlite3Config.pPage = func() (_cgo_ret unsafe.Pointer) {
				_cgo_ret = __cgo_args[0].(unsafe.Pointer)
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3Config.szPage = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3Config.nPage = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 24:
		{
			*func() (_cgo_ret *int32) {
				_cgo_ret = __cgo_args[0].(*int32)
				__cgo_args = __cgo_args[1:]
				return
			}() = sqlite3HeaderSizeBtree() + sqlite3HeaderSizePcache() + sqlite3HeaderSizePcache1()
			break
		}
	case 14:
		{
			break
		}
	case 15:
		{
			rc = int32(1)
			break
		}
	case 18:
		{
			sqlite3Config.pcache2 = *func() (_cgo_ret *struct_sqlite3_pcache_methods2) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_pcache_methods2)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 19:
		{
			if uintptr(unsafe.Pointer(sqlite3Config.pcache2.xInit)) == uintptr(unsafe.Pointer(nil)) {
				sqlite3PCacheSetDefault()
			}
			*func() (_cgo_ret *struct_sqlite3_pcache_methods2) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_pcache_methods2)
				__cgo_args = __cgo_args[1:]
				return
			}() = sqlite3Config.pcache2
			break
		}
	case 13:
		{
			sqlite3Config.szLookaside = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3Config.nLookaside = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 16:
		{
			type LOGFUNC_t = func(unsafe.Pointer, int32, *int8)
			sqlite3Config.xLog = func() (_cgo_ret func(unsafe.Pointer, int32, *int8)) {
				_cgo_ret = __cgo_args[0].(func(unsafe.Pointer, int32, *int8))
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3Config.pLogArg = func() (_cgo_ret unsafe.Pointer) {
				_cgo_ret = __cgo_args[0].(unsafe.Pointer)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 17:
		{
			sqlite3Config.bOpenUri = uint8(func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}())
			break
		}
	case 20:
		{
			sqlite3Config.bUseCis = uint8(func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}())
			break
		}
	case 22:
		{
			var szMmap int64 = func() (_cgo_ret int64) {
				_cgo_ret = __cgo_args[0].(int64)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var mxMmap int64 = func() (_cgo_ret int64) {
				_cgo_ret = __cgo_args[0].(int64)
				__cgo_args = __cgo_args[1:]
				return
			}()
			if mxMmap < int64(0) || mxMmap > int64(2147418112) {
				mxMmap = int64(2147418112)
			}
			if szMmap < int64(0) {
				szMmap = int64(0)
			}
			if szMmap > mxMmap {
				szMmap = mxMmap
			}
			sqlite3Config.mxMmap = mxMmap
			sqlite3Config.szMmap = szMmap
			break
		}
	case 25:
		{
			sqlite3Config.szPma = func() (_cgo_ret uint32) {
				_cgo_ret = __cgo_args[0].(uint32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 26:
		{
			sqlite3Config.nStmtSpill = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 29:
		{
			sqlite3Config.mxMemdbSize = func() (_cgo_ret int64) {
				_cgo_ret = __cgo_args[0].(int64)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	default:
		{
			rc = int32(1)
			break
		}
	}
	return rc
}
func setupLookaside(db *struct_sqlite3, pBuf unsafe.Pointer, sz int32, cnt int32) int32 {
	var pStart unsafe.Pointer
	var szAlloc int64 = int64(sz) * int64(cnt)
	var nBig int32
	var nSm int32
	if sqlite3LookasideUsed(db, nil) > 0 {
		return int32(5)
	}
	if db.lookaside.bMalloced != 0 {
		sqlite3_free(db.lookaside.pStart)
	}
	sz = sz & ^7
	if sz <= int32(8) {
		sz = int32(0)
	}
	if cnt < 0 {
		cnt = int32(0)
	}
	if sz == 0 || cnt == 0 {
		sz = int32(0)
		pStart = unsafe.Pointer(nil)
	} else if uintptr(unsafe.Pointer(pBuf)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3BeginBenignMalloc()
		pStart = sqlite3Malloc(uint64(szAlloc))
		sqlite3EndBenignMalloc()
		if pStart != nil {
			szAlloc = int64(sqlite3MallocSize(pStart))
		}
	} else {
		pStart = pBuf
	}
	if sz >= 128*3 {
		nBig = int32(szAlloc / int64(3*128+sz))
		nSm = int32((szAlloc - int64(sz*nBig)) / int64(128))
	} else if sz >= 128*2 {
		nBig = int32(szAlloc / int64(128+sz))
		nSm = int32((szAlloc - int64(sz*nBig)) / int64(128))
	} else if sz > 0 {
		nBig = int32(szAlloc / int64(sz))
		nSm = int32(0)
	} else {
		nBig = func() (_cgo_ret int32) {
			_cgo_addr := &nSm
			*_cgo_addr = int32(0)
			return *_cgo_addr
		}()
	}
	db.lookaside.pStart = pStart
	db.lookaside.pInit = (*struct_LookasideSlot)(nil)
	db.lookaside.pFree = (*struct_LookasideSlot)(nil)
	db.lookaside.sz = uint16(sz)
	db.lookaside.szTrue = uint16(sz)
	if pStart != nil {
		var i int32
		var p *struct_LookasideSlot
		func() int {
			_ = 0
			return 0
		}()
		p = (*struct_LookasideSlot)(pStart)
		for i = int32(0); i < nBig; i++ {
			p.pNext = db.lookaside.pInit
			db.lookaside.pInit = p
			p = (*struct_LookasideSlot)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(p)))) + uintptr(sz)))))
		}
		db.lookaside.pSmallInit = (*struct_LookasideSlot)(nil)
		db.lookaside.pSmallFree = (*struct_LookasideSlot)(nil)
		db.lookaside.pMiddle = unsafe.Pointer(p)
		for i = int32(0); i < nSm; i++ {
			p.pNext = db.lookaside.pSmallInit
			db.lookaside.pSmallInit = p
			p = (*struct_LookasideSlot)(unsafe.Pointer(&*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(p)))) + uintptr(128)))))
		}
		func() int {
			_ = 0
			return 0
		}()
		db.lookaside.pEnd = unsafe.Pointer(p)
		db.lookaside.bDisable = uint32(0)
		db.lookaside.bMalloced = uint8(func() int32 {
			if uintptr(unsafe.Pointer(pBuf)) == uintptr(unsafe.Pointer(nil)) {
				return 1
			} else {
				return 0
			}
		}())
		db.lookaside.nSlot = uint32(nBig + nSm)
	} else {
		db.lookaside.pStart = unsafe.Pointer(db)
		db.lookaside.pSmallInit = (*struct_LookasideSlot)(nil)
		db.lookaside.pSmallFree = (*struct_LookasideSlot)(nil)
		db.lookaside.pMiddle = unsafe.Pointer(db)
		db.lookaside.pEnd = unsafe.Pointer(db)
		db.lookaside.bDisable = uint32(1)
		db.lookaside.sz = uint16(0)
		db.lookaside.bMalloced = uint8(0)
		db.lookaside.nSlot = uint32(0)
	}
	func() int {
		_ = 0
		return 0
	}()
	return int32(0)
}
func sqlite3_db_mutex(db *struct_sqlite3) *struct_sqlite3_mutex {
	return db.mutex
}
func sqlite3_db_release_memory(db *struct_sqlite3) int32 {
	var i int32
	sqlite3_mutex_enter(db.mutex)
	sqlite3BtreeEnterAll(db)
	for i = int32(0); i < db.nDb; i++ {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if pBt != nil {
			var pPager *struct_Pager = sqlite3BtreePager(pBt)
			sqlite3PagerShrink(pPager)
		}
	}
	sqlite3BtreeLeaveAll(db)
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3_db_cacheflush(db *struct_sqlite3) int32 {
	var i int32
	var rc int32 = 0
	var bSeenBusy int32 = 0
	sqlite3_mutex_enter(db.mutex)
	sqlite3BtreeEnterAll(db)
	for i = int32(0); rc == 0 && i < db.nDb; i++ {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if pBt != nil && sqlite3BtreeTxnState(pBt) == 2 {
			var pPager *struct_Pager = sqlite3BtreePager(pBt)
			rc = sqlite3PagerFlush(pPager)
			if rc == 5 {
				bSeenBusy = int32(1)
				rc = int32(0)
			}
		}
	}
	sqlite3BtreeLeaveAll(db)
	sqlite3_mutex_leave(db.mutex)
	return func() int32 {
		if rc == 0 && bSeenBusy != 0 {
			return 5
		} else {
			return rc
		}
	}()
}
func sqlite3_db_config(db *struct_sqlite3, op int32, __cgo_args ...interface {
}) int32 {
	var rc int32
	switch op {
	case 1000:
		{
			(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).zDbSName = func() (_cgo_ret *int8) {
				_cgo_ret = __cgo_args[0].(*int8)
				__cgo_args = __cgo_args[1:]
				return
			}()
			rc = int32(0)
			break
		}
	case 1001:
		{
			var pBuf unsafe.Pointer = func() (_cgo_ret unsafe.Pointer) {
				_cgo_ret = __cgo_args[0].(unsafe.Pointer)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var sz int32 = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var cnt int32 = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			rc = setupLookaside(db, pBuf, sz, cnt)
			break
		}
	default:
		{
			type _cgoa_90 struct {
				op   int32
				mask uint32
			}
			var aFlagOp [16]_cgoa_90 = [16]_cgoa_90{_cgoa_90{1002, uint32(16384)}, _cgoa_90{1003, uint32(262144)}, _cgoa_90{1015, 2147483648}, _cgoa_90{1004, uint32(4194304)}, _cgoa_90{1005, uint32(65536)}, _cgoa_90{1006, uint32(2048)}, _cgoa_90{1007, uint32(8388608)}, _cgoa_90{1008, uint32(16777216)}, _cgoa_90{1009, uint32(33554432)}, _cgoa_90{1010, uint32(268435456)}, _cgoa_90{1011, uint32(1 | 134217728)}, _cgoa_90{1012, uint32(67108864)}, _cgoa_90{1014, uint32(536870912)}, _cgoa_90{1013, uint32(1073741824)}, _cgoa_90{1016, uint32(2)}, _cgoa_90{1017, uint32(128)}}
			var i uint32
			rc = int32(1)
			for i = uint32(0); i < uint32(int32(128/8)); i++ {
				if (*(*_cgoa_90)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_90)(unsafe.Pointer(&aFlagOp)))) + uintptr(i)*8))).op == op {
					var onoff int32 = func() (_cgo_ret int32) {
						_cgo_ret = __cgo_args[0].(int32)
						__cgo_args = __cgo_args[1:]
						return
					}()
					var pRes *int32 = func() (_cgo_ret *int32) {
						_cgo_ret = __cgo_args[0].(*int32)
						__cgo_args = __cgo_args[1:]
						return
					}()
					var oldFlags uint64 = db.flags
					if onoff > 0 {
						db.flags |= uint64((*(*_cgoa_90)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_90)(unsafe.Pointer(&aFlagOp)))) + uintptr(i)*8))).mask)
					} else if onoff == 0 {
						db.flags &= ^uint64((*(*_cgoa_90)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_90)(unsafe.Pointer(&aFlagOp)))) + uintptr(i)*8))).mask)
					}
					if oldFlags != db.flags {
						sqlite3ExpirePreparedStatements(db, 0)
					}
					if pRes != nil {
						*pRes = func() int32 {
							if db.flags&uint64((*(*_cgoa_90)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_90)(unsafe.Pointer(&aFlagOp)))) + uintptr(i)*8))).mask) != uint64(0) {
								return 1
							} else {
								return 0
							}
						}()
					}
					rc = int32(0)
					break
				}
			}
			break
		}
	}
	return rc
}
func binCollFunc(NotUsed unsafe.Pointer, nKey1 int32, pKey1 unsafe.Pointer, nKey2 int32, pKey2 unsafe.Pointer) int32 {
	var rc int32
	var n int32
	func() int {
		_ = NotUsed
		return 0
	}()
	n = func() int32 {
		if nKey1 < nKey2 {
			return nKey1
		} else {
			return nKey2
		}
	}()
	func() int {
		_ = 0
		return 0
	}()
	rc = memcmp(pKey1, pKey2, uint(n))
	if rc == 0 {
		rc = nKey1 - nKey2
	}
	return rc
}
func rtrimCollFunc(pUser unsafe.Pointer, nKey1 int32, pKey1 unsafe.Pointer, nKey2 int32, pKey2 unsafe.Pointer) int32 {
	var pK1 *uint8 = (*uint8)(pKey1)
	var pK2 *uint8 = (*uint8)(pKey2)
	for nKey1 != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pK1)) + uintptr(nKey1-1)))) == ' ' {
		nKey1--
	}
	for nKey2 != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer(pK2)) + uintptr(nKey2-1)))) == ' ' {
		nKey2--
	}
	return binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2)
}
func sqlite3IsBinary(p *struct_CollSeq) int32 {
	func() int {
		_ = 0
		return 0
	}()
	return func() int32 {
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(p.xCmp)) == uintptr(unsafe.Pointer(binCollFunc)) {
			return 1
		} else {
			return 0
		}
	}()
}
func nocaseCollatingFunc(NotUsed unsafe.Pointer, nKey1 int32, pKey1 unsafe.Pointer, nKey2 int32, pKey2 unsafe.Pointer) int32 {
	var r int32 = sqlite3_strnicmp((*int8)(pKey1), (*int8)(pKey2), func() int32 {
		if nKey1 < nKey2 {
			return nKey1
		} else {
			return nKey2
		}
	}())
	func() int {
		_ = NotUsed
		return 0
	}()
	if 0 == r {
		r = nKey1 - nKey2
	}
	return r
}
func sqlite3_last_insert_rowid(db *struct_sqlite3) int64 {
	return db.lastRowid
}
func sqlite3_set_last_insert_rowid(db *struct_sqlite3, iRowid int64) {
	sqlite3_mutex_enter(db.mutex)
	db.lastRowid = iRowid
	sqlite3_mutex_leave(db.mutex)
}
func sqlite3_changes64(db *struct_sqlite3) int64 {
	return db.nChange
}
func sqlite3_changes(db *struct_sqlite3) int32 {
	return int32(sqlite3_changes64(db))
}
func sqlite3_total_changes64(db *struct_sqlite3) int64 {
	return db.nTotalChange
}
func sqlite3_total_changes(db *struct_sqlite3) int32 {
	return int32(sqlite3_total_changes64(db))
}
func sqlite3CloseSavepoints(db *struct_sqlite3) {
	for db.pSavepoint != nil {
		var pTmp *struct_Savepoint = db.pSavepoint
		db.pSavepoint = pTmp.pNext
		sqlite3DbFree(db, unsafe.Pointer(pTmp))
	}
	db.nSavepoint = int32(0)
	db.nStatement = int32(0)
	db.isTransactionSavepoint = uint8(0)
}
func functionDestroy(db *struct_sqlite3, p *struct_FuncDef) {
	var pDestructor *struct_FuncDestructor
	func() int {
		_ = 0
		return 0
	}()
	pDestructor = *(**struct_FuncDestructor)(unsafe.Pointer(&p.u))
	if pDestructor != nil {
		pDestructor.nRef--
		if pDestructor.nRef == 0 {
			pDestructor.xDestroy(pDestructor.pUserData)
			sqlite3DbFree(db, unsafe.Pointer(pDestructor))
		}
	}
}
func disconnectAllVtab(db *struct_sqlite3) {
	var i int32
	var p *struct_HashElem
	sqlite3BtreeEnterAll(db)
	for i = int32(0); i < db.nDb; i++ {
		var pSchema *struct_Schema = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pSchema
		if pSchema != nil {
			for p = (&pSchema.tblHash).first; p != nil; p = p.next {
				var pTab *struct_Table = (*struct_Table)(p.data)
				if int32(pTab.eTabType) == 1 {
					sqlite3VtabDisconnect(db, pTab)
				}
			}
		}
	}
	for p = (&db.aModule).first; p != nil; p = p.next {
		var pMod *struct_Module = (*struct_Module)(p.data)
		if pMod.pEpoTab != nil {
			sqlite3VtabDisconnect(db, pMod.pEpoTab)
		}
	}
	sqlite3VtabUnlockList(db)
	sqlite3BtreeLeaveAll(db)
}
func connectionIsBusy(db *struct_sqlite3) int32 {
	var j int32
	func() int {
		_ = 0
		return 0
	}()
	if db.pVdbe != nil {
		return int32(1)
	}
	for j = int32(0); j < db.nDb; j++ {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(j)*32))).pBt
		if pBt != nil && sqlite3BtreeIsInBackup(pBt) != 0 {
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3Close(db *struct_sqlite3, forceZombie int32) int32 {
	if !(db != nil) {
		return int32(0)
	}
	if !(sqlite3SafetyCheckSickOrOk(db) != 0) {
		return sqlite3MisuseError(169679)
	}
	sqlite3_mutex_enter(db.mutex)
	if int32(db.mTrace)&8 != 0 {
		(*(*func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(unsafe.Pointer(&db.trace)))(uint32(8), db.pTraceArg, unsafe.Pointer(db), nil)
	}
	disconnectAllVtab(db)
	sqlite3VtabRollback(db)
	if !(forceZombie != 0) && connectionIsBusy(db) != 0 {
		sqlite3ErrorWithMsg(db, 5, (*int8)(unsafe.Pointer(&[68]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'c', 'l', 'o', 's', 'e', ' ', 'd', 'u', 'e', ' ', 't', 'o', ' ', 'u', 'n', 'f', 'i', 'n', 'a', 'l', 'i', 'z', 'e', 'd', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', ' ', 'o', 'r', ' ', 'u', 'n', 'f', 'i', 'n', 'i', 's', 'h', 'e', 'd', ' ', 'b', 'a', 'c', 'k', 'u', 'p', 's', '\x00'})))
		sqlite3_mutex_leave(db.mutex)
		return int32(5)
	}
	db.eOpenState = uint8(167)
	sqlite3LeaveMutexAndCloseZombie(db)
	return int32(0)
}
func sqlite3_txn_state(db *struct_sqlite3, zSchema *int8) int32 {
	var iDb int32
	var nDb int32
	var iTxn int32 = -1
	sqlite3_mutex_enter(db.mutex)
	if zSchema != nil {
		nDb = func() (_cgo_ret int32) {
			_cgo_addr := &iDb
			*_cgo_addr = sqlite3FindDbName(db, zSchema)
			return *_cgo_addr
		}()
		if iDb < 0 {
			nDb--
		}
	} else {
		iDb = int32(0)
		nDb = db.nDb - 1
	}
	for ; iDb <= nDb; iDb++ {
		var pBt *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt
		var x int32 = func() int32 {
			if uintptr(unsafe.Pointer(pBt)) != uintptr(unsafe.Pointer(nil)) {
				return sqlite3BtreeTxnState(pBt)
			} else {
				return 0
			}
		}()
		if x > iTxn {
			iTxn = x
		}
	}
	sqlite3_mutex_leave(db.mutex)
	return iTxn
}
func sqlite3_close(db *struct_sqlite3) int32 {
	return sqlite3Close(db, 0)
}
func sqlite3_close_v2(db *struct_sqlite3) int32 {
	return sqlite3Close(db, 1)
}
func sqlite3LeaveMutexAndCloseZombie(db *struct_sqlite3) {
	var i *struct_HashElem
	var j int32
	if int32(db.eOpenState) != 167 || connectionIsBusy(db) != 0 {
		sqlite3_mutex_leave(db.mutex)
		return
	}
	sqlite3RollbackAll(db, 0)
	sqlite3CloseSavepoints(db)
	for j = int32(0); j < db.nDb; j++ {
		var pDb *struct_Db = &*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(j)*32))
		if pDb.pBt != nil {
			sqlite3BtreeClose(pDb.pBt)
			pDb.pBt = (*struct_Btree)(nil)
			if j != 1 {
				pDb.pSchema = (*struct_Schema)(nil)
			}
		}
	}
	if (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema != nil {
		sqlite3SchemaClear(unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema))
	}
	sqlite3VtabUnlockList(db)
	sqlite3CollapseDatabaseArray(db)
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for i = (&db.aFunc).first; i != nil; i = i.next {
		var pNext *struct_FuncDef
		var p *struct_FuncDef
		p = (*struct_FuncDef)(i.data)
		for {
			functionDestroy(db, p)
			pNext = p.pNext
			sqlite3DbFree(db, unsafe.Pointer(p))
			p = pNext
			if !(p != nil) {
				break
			}
		}
	}
	sqlite3HashClear(&db.aFunc)
	for i = (&db.aCollSeq).first; i != nil; i = i.next {
		var pColl *struct_CollSeq = (*struct_CollSeq)(i.data)
		for j = int32(0); j < 3; j++ {
			if (*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(j)*40))).xDel != nil {
				(*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(j)*40))).xDel((*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(pColl)) + uintptr(j)*40))).pUser)
			}
		}
		sqlite3DbFree(db, unsafe.Pointer(pColl))
	}
	sqlite3HashClear(&db.aCollSeq)
	for i = (&db.aModule).first; i != nil; i = i.next {
		var pMod *struct_Module = (*struct_Module)(i.data)
		sqlite3VtabEponymousTableClear(db, pMod)
		sqlite3VtabModuleUnref(db, pMod)
	}
	sqlite3HashClear(&db.aModule)
	sqlite3Error(db, 0)
	sqlite3ValueFree(db.pErr)
	sqlite3CloseExtensions(db)
	db.eOpenState = uint8(213)
	sqlite3DbFree(db, unsafe.Pointer((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema))
	if db.xAutovacDestr != nil {
		db.xAutovacDestr(db.pAutovacPagesArg)
	}
	sqlite3_mutex_leave(db.mutex)
	db.eOpenState = uint8(206)
	sqlite3_mutex_free(db.mutex)
	func() int {
		_ = 0
		return 0
	}()
	if db.lookaside.bMalloced != 0 {
		sqlite3_free(db.lookaside.pStart)
	}
	sqlite3_free(unsafe.Pointer(db))
}
func sqlite3RollbackAll(db *struct_sqlite3, tripCode int32) {
	var i int32
	var inTrans int32 = 0
	var schemaChange int32
	func() int {
		_ = 0
		return 0
	}()
	sqlite3BeginBenignMalloc()
	sqlite3BtreeEnterAll(db)
	schemaChange = func() int32 {
		if db.mDbFlags&uint32(1) != uint32(0) && int32(db.init.busy) == 0 {
			return 1
		} else {
			return 0
		}
	}()
	for i = int32(0); i < db.nDb; i++ {
		var p *struct_Btree = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt
		if p != nil {
			if sqlite3BtreeTxnState(p) == 2 {
				inTrans = int32(1)
			}
			sqlite3BtreeRollback(p, tripCode, func() int32 {
				if !(schemaChange != 0) {
					return 1
				} else {
					return 0
				}
			}())
		}
	}
	sqlite3VtabRollback(db)
	sqlite3EndBenignMalloc()
	if schemaChange != 0 {
		sqlite3ExpirePreparedStatements(db, 0)
		sqlite3ResetAllSchemasOfConnection(db)
	}
	sqlite3BtreeLeaveAll(db)
	db.nDeferredCons = int64(0)
	db.nDeferredImmCons = int64(0)
	db.flags &= ^uint64(uint64(524288) | uint64(2)<<32)
	if db.xRollbackCallback != nil && (inTrans != 0 || !(db.autoCommit != 0)) {
		db.xRollbackCallback(db.pRollbackArg)
	}
}
func sqlite3ErrStr(rc int32) *int8 {
	var aMsg [29]*int8 = [29]*int8{(*int8)(unsafe.Pointer(&[13]int8{'n', 'o', 't', ' ', 'a', 'n', ' ', 'e', 'r', 'r', 'o', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[16]int8{'S', 'Q', 'L', ' ', 'l', 'o', 'g', 'i', 'c', ' ', 'e', 'r', 'r', 'o', 'r', '\x00'})), nil, (*int8)(unsafe.Pointer(&[25]int8{'a', 'c', 'c', 'e', 's', 's', ' ', 'p', 'e', 'r', 'm', 'i', 's', 's', 'i', 'o', 'n', ' ', 'd', 'e', 'n', 'i', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'q', 'u', 'e', 'r', 'y', ' ', 'a', 'b', 'o', 'r', 't', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[19]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'i', 's', ' ', 'l', 'o', 'c', 'k', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'i', 's', ' ', 'l', 'o', 'c', 'k', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[14]int8{'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[37]int8{'a', 't', 't', 'e', 'm', 'p', 't', ' ', 't', 'o', ' ', 'w', 'r', 'i', 't', 'e', ' ', 'a', ' ', 'r', 'e', 'a', 'd', 'o', 'n', 'l', 'y', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[12]int8{'i', 'n', 't', 'e', 'r', 'r', 'u', 'p', 't', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[15]int8{'d', 'i', 's', 'k', ' ', 'I', '/', 'O', ' ', 'e', 'r', 'r', 'o', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[33]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'd', 'i', 's', 'k', ' ', 'i', 'm', 'a', 'g', 'e', ' ', 'i', 's', ' ', 'm', 'a', 'l', 'f', 'o', 'r', 'm', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[18]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'o', 'p', 'e', 'r', 'a', 't', 'i', 'o', 'n', '\x00'})), (*int8)(unsafe.Pointer(&[25]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'o', 'r', ' ', 'd', 'i', 's', 'k', ' ', 'i', 's', ' ', 'f', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[29]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'o', 'p', 'e', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'f', 'i', 'l', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[17]int8{'l', 'o', 'c', 'k', 'i', 'n', 'g', ' ', 'p', 'r', 'o', 't', 'o', 'c', 'o', 'l', '\x00'})), nil, (*int8)(unsafe.Pointer(&[28]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 's', 'c', 'h', 'e', 'm', 'a', ' ', 'h', 'a', 's', ' ', 'c', 'h', 'a', 'n', 'g', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[23]int8{'s', 't', 'r', 'i', 'n', 'g', ' ', 'o', 'r', ' ', 'b', 'l', 'o', 'b', ' ', 't', 'o', 'o', ' ', 'b', 'i', 'g', '\x00'})), (*int8)(unsafe.Pointer(&[18]int8{'c', 'o', 'n', 's', 't', 'r', 'a', 'i', 'n', 't', ' ', 'f', 'a', 'i', 'l', 'e', 'd', '\x00'})), (*int8)(unsafe.Pointer(&[18]int8{'d', 'a', 't', 'a', 't', 'y', 'p', 'e', ' ', 'm', 'i', 's', 'm', 'a', 't', 'c', 'h', '\x00'})), (*int8)(unsafe.Pointer(&[34]int8{'b', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ', 'o', 'r', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'A', 'P', 'I', ' ', 'm', 'i', 's', 'u', 's', 'e', '\x00'})), nil, (*int8)(unsafe.Pointer(&[21]int8{'a', 'u', 't', 'h', 'o', 'r', 'i', 'z', 'a', 't', 'i', 'o', 'n', ' ', 'd', 'e', 'n', 'i', 'e', 'd', '\x00'})), nil, (*int8)(unsafe.Pointer(&[26]int8{'c', 'o', 'l', 'u', 'm', 'n', ' ', 'i', 'n', 'd', 'e', 'x', ' ', 'o', 'u', 't', ' ', 'o', 'f', ' ', 'r', 'a', 'n', 'g', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[23]int8{'f', 'i', 'l', 'e', ' ', 'i', 's', ' ', 'n', 'o', 't', ' ', 'a', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[21]int8{'n', 'o', 't', 'i', 'f', 'i', 'c', 'a', 't', 'i', 'o', 'n', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[16]int8{'w', 'a', 'r', 'n', 'i', 'n', 'g', ' ', 'm', 'e', 's', 's', 'a', 'g', 'e', '\x00'}))}
	var zErr *int8 = (*int8)(unsafe.Pointer(&[14]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'e', 'r', 'r', 'o', 'r', '\x00'}))
	switch rc {
	case 4 | 2<<8:
		{
			zErr = (*int8)(unsafe.Pointer(&[22]int8{'a', 'b', 'o', 'r', 't', ' ', 'd', 'u', 'e', ' ', 't', 'o', ' ', 'R', 'O', 'L', 'L', 'B', 'A', 'C', 'K', '\x00'}))
			break
		}
	case 100:
		{
			zErr = (*int8)(unsafe.Pointer(&[22]int8{'a', 'n', 'o', 't', 'h', 'e', 'r', ' ', 'r', 'o', 'w', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', '\x00'}))
			break
		}
	case 101:
		{
			zErr = (*int8)(unsafe.Pointer(&[23]int8{'n', 'o', ' ', 'm', 'o', 'r', 'e', ' ', 'r', 'o', 'w', 's', ' ', 'a', 'v', 'a', 'i', 'l', 'a', 'b', 'l', 'e', '\x00'}))
			break
		}
	default:
		{
			rc &= int32(255)
			if rc >= 0 && rc < int32(232/8) && uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aMsg)))) + uintptr(rc)*8)))) != uintptr(unsafe.Pointer(nil)) {
				zErr = *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&aMsg)))) + uintptr(rc)*8))
			}
			break
		}
	}
	return zErr
}
func sqliteDefaultBusyCallback(ptr unsafe.Pointer, count int32) int32 {
	var db *struct_sqlite3 = (*struct_sqlite3)(ptr)
	var tmout int32 = (*struct_sqlite3)(ptr).busyTimeout
	if (count+1)*1000 > tmout {
		return int32(0)
	}
	sqlite3OsSleep(db.pVfs, 1000000)
	return int32(1)
}
func sqlite3InvokeBusyHandler(p *struct_BusyHandler) int32 {
	var rc int32
	if uintptr(unsafe.Pointer(p.xBusyHandler)) == uintptr(unsafe.Pointer(nil)) || p.nBusy < 0 {
		return int32(0)
	}
	rc = p.xBusyHandler(p.pBusyArg, p.nBusy)
	if rc == 0 {
		p.nBusy = int32(-1)
	} else {
		p.nBusy++
	}
	return rc
}
func sqlite3_busy_handler(db *struct_sqlite3, xBusy func(unsafe.Pointer, int32) int32, pArg unsafe.Pointer) int32 {
	sqlite3_mutex_enter(db.mutex)
	db.busyHandler.xBusyHandler = xBusy
	db.busyHandler.pBusyArg = pArg
	db.busyHandler.nBusy = int32(0)
	db.busyTimeout = int32(0)
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3_progress_handler(db *struct_sqlite3, nOps int32, xProgress func(unsafe.Pointer) int32, pArg unsafe.Pointer) {
	sqlite3_mutex_enter(db.mutex)
	if nOps > 0 {
		db.xProgress = xProgress
		db.nProgressOps = uint32(nOps)
		db.pProgressArg = pArg
	} else {
		db.xProgress = (func(unsafe.Pointer) int32)(nil)
		db.nProgressOps = uint32(0)
		db.pProgressArg = unsafe.Pointer(nil)
	}
	sqlite3_mutex_leave(db.mutex)
}
func sqlite3_busy_timeout(db *struct_sqlite3, ms int32) int32 {
	if ms > 0 {
		sqlite3_busy_handler(db, (func(unsafe.Pointer, int32) int32)(sqliteDefaultBusyCallback), unsafe.Pointer(db))
		db.busyTimeout = ms
	} else {
		sqlite3_busy_handler(db, nil, nil)
	}
	return int32(0)
}
func sqlite3_interrupt(db *struct_sqlite3) {
	__atomic_store_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0, 1)
}
func sqlite3CreateFunc(db *struct_sqlite3, zFunctionName *int8, nArg int32, enc int32, pUserData unsafe.Pointer, xSFunc func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xStep func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xFinal func(*struct_sqlite3_context), xValue func(*struct_sqlite3_context), xInverse func(*struct_sqlite3_context, int32, **struct_sqlite3_value), pDestructor *struct_FuncDestructor) int32 {
	var p *struct_FuncDef
	var extraFlags int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if uintptr(unsafe.Pointer(zFunctionName)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(xSFunc)) != uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(xFinal)) != uintptr(unsafe.Pointer(nil)) || func() int32 {
		if uintptr(unsafe.Pointer(xFinal)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}() != func() int32 {
		if uintptr(unsafe.Pointer(xStep)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}() || func() int32 {
		if uintptr(unsafe.Pointer(xValue)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}() != func() int32 {
		if uintptr(unsafe.Pointer(xInverse)) == uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}() || (nArg < -1 || nArg > 127) || 255 < sqlite3Strlen30(zFunctionName) {
		return sqlite3MisuseError(170308)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	extraFlags = enc & (2048 | 524288 | 1048576 | 2097152)
	enc &= int32(3 | 5)
	func() int {
		_ = 0
		return 0
	}()
	extraFlags ^= int32(2097152)
	switch enc {
	case 4:
		enc = int32(2)
		break
	case 5:
		{
			var rc int32
			rc = sqlite3CreateFunc(db, zFunctionName, nArg, 1|extraFlags^2097152, pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor)
			if rc == 0 {
				rc = sqlite3CreateFunc(db, zFunctionName, nArg, 2|extraFlags^2097152, pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor)
			}
			if rc != 0 {
				return rc
			}
			enc = int32(3)
			break
		}
	case 1:
		fallthrough
	case 2:
		fallthrough
	case 3:
		break
	default:
		enc = int32(1)
		break
	}
	p = sqlite3FindFunction(db, zFunctionName, nArg, uint8(enc), uint8(0))
	if p != nil && p.funcFlags&uint32(3) == uint32(enc) && int32(p.nArg) == nArg {
		if db.nVdbeActive != 0 {
			sqlite3ErrorWithMsg(db, 5, (*int8)(unsafe.Pointer(&[63]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'd', 'e', 'l', 'e', 't', 'e', '/', 'm', 'o', 'd', 'i', 'f', 'y', ' ', 'u', 's', 'e', 'r', '-', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', 'd', 'u', 'e', ' ', 't', 'o', ' ', 'a', 'c', 't', 'i', 'v', 'e', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', '\x00'})))
			func() int {
				_ = 0
				return 0
			}()
			return int32(5)
		} else {
			sqlite3ExpirePreparedStatements(db, 0)
		}
	} else if uintptr(unsafe.Pointer(xSFunc)) == uintptr(unsafe.Pointer(nil)) && uintptr(unsafe.Pointer(xFinal)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	p = sqlite3FindFunction(db, zFunctionName, nArg, uint8(enc), uint8(1))
	func() int {
		_ = 0
		return 0
	}()
	if !(p != nil) {
		return int32(7)
	}
	functionDestroy(db, p)
	if pDestructor != nil {
		pDestructor.nRef++
	}
	*(**struct_FuncDestructor)(unsafe.Pointer(&p.u)) = pDestructor
	p.funcFlags = p.funcFlags&uint32(3) | uint32(extraFlags)
	p.xSFunc = func() func(*struct_sqlite3_context, int32, **struct_sqlite3_value) {
		if xSFunc != nil {
			return xSFunc
		} else {
			return xStep
		}
	}()
	p.xFinalize = xFinal
	p.xValue = xValue
	p.xInverse = xInverse
	p.pUserData = pUserData
	p.nArg = int8(uint16(nArg))
	return int32(0)
}
func createFunctionApi(db *struct_sqlite3, zFunc *int8, nArg int32, enc int32, p unsafe.Pointer, xSFunc func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xStep func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xFinal func(*struct_sqlite3_context), xValue func(*struct_sqlite3_context), xInverse func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xDestroy func(unsafe.Pointer)) int32 {
	var rc int32 = 1
	var pArg *struct_FuncDestructor = nil
	sqlite3_mutex_enter(db.mutex)
	if xDestroy != nil {
		pArg = (*struct_FuncDestructor)(sqlite3Malloc(uint64(24)))
		if !(pArg != nil) {
			sqlite3OomFault(db)
			xDestroy(p)
			goto out
		}
		pArg.nRef = int32(0)
		pArg.xDestroy = xDestroy
		pArg.pUserData = p
	}
	rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, xValue, xInverse, pArg)
	if pArg != nil && pArg.nRef == 0 {
		func() int {
			_ = 0
			return 0
		}()
		xDestroy(p)
		sqlite3_free(unsafe.Pointer(pArg))
	}
out:
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_create_function(db *struct_sqlite3, zFunc *int8, nArg int32, enc int32, p unsafe.Pointer, xSFunc func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xStep func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xFinal func(*struct_sqlite3_context)) int32 {
	return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, nil, nil, nil)
}
func sqlite3_create_function_v2(db *struct_sqlite3, zFunc *int8, nArg int32, enc int32, p unsafe.Pointer, xSFunc func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xStep func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xFinal func(*struct_sqlite3_context), xDestroy func(unsafe.Pointer)) int32 {
	return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep, xFinal, nil, nil, xDestroy)
}
func sqlite3_create_window_function(db *struct_sqlite3, zFunc *int8, nArg int32, enc int32, p unsafe.Pointer, xStep func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xFinal func(*struct_sqlite3_context), xValue func(*struct_sqlite3_context), xInverse func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xDestroy func(unsafe.Pointer)) int32 {
	return createFunctionApi(db, zFunc, nArg, enc, p, nil, xStep, xFinal, xValue, xInverse, xDestroy)
}
func sqlite3_create_function16(db *struct_sqlite3, zFunctionName unsafe.Pointer, nArg int32, eTextRep int32, p unsafe.Pointer, xSFunc func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xStep func(*struct_sqlite3_context, int32, **struct_sqlite3_value), xFinal func(*struct_sqlite3_context)) int32 {
	var rc int32
	var zFunc8 *int8
	sqlite3_mutex_enter(db.mutex)
	func() int {
		_ = 0
		return 0
	}()
	zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, uint8(2))
	rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xSFunc, xStep, xFinal, nil, nil, nil)
	sqlite3DbFree(db, unsafe.Pointer(zFunc8))
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3InvalidFunction(context *struct_sqlite3_context, NotUsed int32, NotUsed2 **struct_sqlite3_value) {
	var zName *int8 = (*int8)(sqlite3_user_data(context))
	var zErr *int8
	func() int {
		func() int {
			_ = NotUsed
			return 0
		}()
		return func() int {
			_ = NotUsed2
			return 0
		}()
	}()
	zErr = sqlite3_mprintf((*int8)(unsafe.Pointer(&[51]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'u', 's', 'e', ' ', 'f', 'u', 'n', 'c', 't', 'i', 'o', 'n', ' ', '%', 's', ' ', 'i', 'n', ' ', 't', 'h', 'e', ' ', 'r', 'e', 'q', 'u', 'e', 's', 't', 'e', 'd', ' ', 'c', 'o', 'n', 't', 'e', 'x', 't', '\x00'})), zName)
	sqlite3_result_error(context, zErr, -1)
	sqlite3_free(unsafe.Pointer(zErr))
}
func sqlite3_overload_function(db *struct_sqlite3, zName *int8, nArg int32) int32 {
	var rc int32
	var zCopy *int8
	sqlite3_mutex_enter(db.mutex)
	rc = func() int32 {
		if uintptr(unsafe.Pointer(sqlite3FindFunction(db, zName, nArg, uint8(1), uint8(0)))) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	sqlite3_mutex_leave(db.mutex)
	if rc != 0 {
		return int32(0)
	}
	zCopy = sqlite3_mprintf(zName)
	if uintptr(unsafe.Pointer(zCopy)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	return sqlite3_create_function_v2(db, zName, nArg, 1, unsafe.Pointer(zCopy), sqlite3InvalidFunction, nil, nil, sqlite3_free)
}
func sqlite3_trace(db *struct_sqlite3, xTrace func(unsafe.Pointer, *int8), pArg unsafe.Pointer) unsafe.Pointer {
	var pOld unsafe.Pointer
	sqlite3_mutex_enter(db.mutex)
	pOld = db.pTraceArg
	db.mTrace = uint8(func() int32 {
		if xTrace != nil {
			return 64
		} else {
			return 0
		}
	}())
	db.trace.xLegacy = xTrace
	db.pTraceArg = pArg
	sqlite3_mutex_leave(db.mutex)
	return pOld
}
func sqlite3_trace_v2(db *struct_sqlite3, mTrace uint32, xTrace func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32, pArg unsafe.Pointer) int32 {
	sqlite3_mutex_enter(db.mutex)
	if mTrace == uint32(0) {
		xTrace = (func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(nil)
	}
	if uintptr(unsafe.Pointer(xTrace)) == uintptr(unsafe.Pointer(nil)) {
		mTrace = uint32(0)
	}
	db.mTrace = uint8(mTrace)
	*(*func(uint32, unsafe.Pointer, unsafe.Pointer, unsafe.Pointer) int32)(unsafe.Pointer(&db.trace)) = xTrace
	db.pTraceArg = pArg
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3_profile(db *struct_sqlite3, xProfile func(unsafe.Pointer, *int8, uint64), pArg unsafe.Pointer) unsafe.Pointer {
	var pOld unsafe.Pointer
	sqlite3_mutex_enter(db.mutex)
	pOld = db.pProfileArg
	db.xProfile = xProfile
	db.pProfileArg = pArg
	db.mTrace &= uint8(15)
	if db.xProfile != nil {
		db.mTrace |= uint8(128)
	}
	sqlite3_mutex_leave(db.mutex)
	return pOld
}
func sqlite3_commit_hook(db *struct_sqlite3, xCallback func(unsafe.Pointer) int32, pArg unsafe.Pointer) unsafe.Pointer {
	var pOld unsafe.Pointer
	sqlite3_mutex_enter(db.mutex)
	pOld = db.pCommitArg
	db.xCommitCallback = xCallback
	db.pCommitArg = pArg
	sqlite3_mutex_leave(db.mutex)
	return pOld
}
func sqlite3_update_hook(db *struct_sqlite3, xCallback func(unsafe.Pointer, int32, *int8, *int8, int64), pArg unsafe.Pointer) unsafe.Pointer {
	var pRet unsafe.Pointer
	sqlite3_mutex_enter(db.mutex)
	pRet = db.pUpdateArg
	db.xUpdateCallback = xCallback
	db.pUpdateArg = pArg
	sqlite3_mutex_leave(db.mutex)
	return pRet
}
func sqlite3_rollback_hook(db *struct_sqlite3, xCallback func(unsafe.Pointer), pArg unsafe.Pointer) unsafe.Pointer {
	var pRet unsafe.Pointer
	sqlite3_mutex_enter(db.mutex)
	pRet = db.pRollbackArg
	db.xRollbackCallback = xCallback
	db.pRollbackArg = pArg
	sqlite3_mutex_leave(db.mutex)
	return pRet
}
func sqlite3_autovacuum_pages(db *struct_sqlite3, xCallback func(unsafe.Pointer, *int8, uint32, uint32, uint32) uint32, pArg unsafe.Pointer, xDestructor func(unsafe.Pointer)) int32 {
	sqlite3_mutex_enter(db.mutex)
	if db.xAutovacDestr != nil {
		db.xAutovacDestr(db.pAutovacPagesArg)
	}
	db.xAutovacPages = xCallback
	db.pAutovacPagesArg = pArg
	db.xAutovacDestr = xDestructor
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3WalDefaultHook(pClientData unsafe.Pointer, db *struct_sqlite3, zDb *int8, nFrame int32) int32 {
	if nFrame >= int32(int(pClientData)) {
		sqlite3BeginBenignMalloc()
		sqlite3_wal_checkpoint(db, zDb)
		sqlite3EndBenignMalloc()
	}
	return int32(0)
}
func sqlite3_wal_autocheckpoint(db *struct_sqlite3, nFrame int32) int32 {
	if nFrame > 0 {
		sqlite3_wal_hook(db, sqlite3WalDefaultHook, unsafe.Pointer(int(nFrame)))
	} else {
		sqlite3_wal_hook(db, nil, nil)
	}
	return int32(0)
}
func sqlite3_wal_hook(db *struct_sqlite3, xCallback func(unsafe.Pointer, *struct_sqlite3, *int8, int32) int32, pArg unsafe.Pointer) unsafe.Pointer {
	var pRet unsafe.Pointer
	sqlite3_mutex_enter(db.mutex)
	pRet = db.pWalArg
	db.xWalCallback = xCallback
	db.pWalArg = pArg
	sqlite3_mutex_leave(db.mutex)
	return pRet
}
func sqlite3_wal_checkpoint_v2(db *struct_sqlite3, zDb *int8, eMode int32, pnLog *int32, pnCkpt *int32) int32 {
	var rc int32
	var iDb int32
	if pnLog != nil {
		*pnLog = int32(-1)
	}
	if pnCkpt != nil {
		*pnCkpt = int32(-1)
	}
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if eMode < 0 || eMode > 3 {
		return int32(21)
	}
	sqlite3_mutex_enter(db.mutex)
	if zDb != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zDb)) + uintptr(0)))) != 0 {
		iDb = sqlite3FindDbName(db, zDb)
	} else {
		iDb = int32(10 + 2)
	}
	if iDb < 0 {
		rc = int32(1)
		sqlite3ErrorWithMsg(db, 1, (*int8)(unsafe.Pointer(&[21]int8{'u', 'n', 'k', 'n', 'o', 'w', 'n', ' ', 'd', 'a', 't', 'a', 'b', 'a', 's', 'e', ':', ' ', '%', 's', '\x00'})), zDb)
	} else {
		db.busyHandler.nBusy = int32(0)
		rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt)
		sqlite3Error(db, rc)
	}
	rc = sqlite3ApiExit(db, rc)
	if db.nVdbeActive == 0 {
		__atomic_store_n_i32(&*(*int32)(unsafe.Pointer(&db.u1)), 0, 0)
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_wal_checkpoint(db *struct_sqlite3, zDb *int8) int32 {
	return sqlite3_wal_checkpoint_v2(db, zDb, 0, nil, nil)
}
func sqlite3Checkpoint(db *struct_sqlite3, iDb int32, eMode int32, pnLog *int32, pnCkpt *int32) int32 {
	var rc int32 = 0
	var i int32
	var bBusy int32 = 0
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	for i = int32(0); i < db.nDb && rc == 0; i++ {
		if i == iDb || iDb == 10+2 {
			rc = sqlite3BtreeCheckpoint((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(i)*32))).pBt, eMode, pnLog, pnCkpt)
			pnLog = (*int32)(nil)
			pnCkpt = (*int32)(nil)
			if rc == 5 {
				bBusy = int32(1)
				rc = int32(0)
			}
		}
	}
	return func() int32 {
		if rc == 0 && bBusy != 0 {
			return 5
		} else {
			return rc
		}
	}()
}
func sqlite3TempInMemory(db *struct_sqlite3) int32 {
	return func() int32 {
		if int32(db.temp_store) == 2 {
			return 1
		} else {
			return 0
		}
	}()
}
func sqlite3_errmsg(db *struct_sqlite3) *int8 {
	var z *int8
	if !(db != nil) {
		return sqlite3ErrStr(7)
	}
	if !(sqlite3SafetyCheckSickOrOk(db) != 0) {
		return sqlite3ErrStr(sqlite3MisuseError(171053))
	}
	sqlite3_mutex_enter(db.mutex)
	if db.mallocFailed != 0 {
		z = sqlite3ErrStr(7)
	} else {
		z = func() *int8 {
			if db.errCode != 0 {
				return (*int8)(unsafe.Pointer(sqlite3_value_text(db.pErr)))
			} else {
				return nil
			}
		}()
		func() int {
			_ = 0
			return 0
		}()
		if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
			z = sqlite3ErrStr(db.errCode)
		}
	}
	sqlite3_mutex_leave(db.mutex)
	return z
}
func sqlite3_error_offset(db *struct_sqlite3) int32 {
	var iOffset int32 = -1
	if db != nil && sqlite3SafetyCheckSickOrOk(db) != 0 && db.errCode != 0 {
		sqlite3_mutex_enter(db.mutex)
		iOffset = db.errByteOffset
		sqlite3_mutex_leave(db.mutex)
	}
	return iOffset
}
func sqlite3_errmsg16(db *struct_sqlite3) unsafe.Pointer {
	var outOfMem [14]uint16 = [14]uint16{uint16('o'), uint16('u'), uint16('t'), uint16(' '), uint16('o'), uint16('f'), uint16(' '), uint16('m'), uint16('e'), uint16('m'), uint16('o'), uint16('r'), uint16('y'), uint16(0)}
	var misuse [34]uint16 = [34]uint16{uint16('b'), uint16('a'), uint16('d'), uint16(' '), uint16('p'), uint16('a'), uint16('r'), uint16('a'), uint16('m'), uint16('e'), uint16('t'), uint16('e'), uint16('r'), uint16(' '), uint16('o'), uint16('r'), uint16(' '), uint16('o'), uint16('t'), uint16('h'), uint16('e'), uint16('r'), uint16(' '), uint16('A'), uint16('P'), uint16('I'), uint16(' '), uint16('m'), uint16('i'), uint16('s'), uint16('u'), uint16('s'), uint16('e'), uint16(0)}
	var z unsafe.Pointer
	if !(db != nil) {
		return unsafe.Pointer((*uint16)(unsafe.Pointer(&outOfMem)))
	}
	if !(sqlite3SafetyCheckSickOrOk(db) != 0) {
		return unsafe.Pointer((*uint16)(unsafe.Pointer(&misuse)))
	}
	sqlite3_mutex_enter(db.mutex)
	if db.mallocFailed != 0 {
		z = unsafe.Pointer((*uint16)(unsafe.Pointer(&outOfMem)))
	} else {
		z = sqlite3_value_text16(db.pErr)
		if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3ErrorWithMsg(db, db.errCode, sqlite3ErrStr(db.errCode))
			z = sqlite3_value_text16(db.pErr)
		}
		sqlite3OomClear(db)
	}
	sqlite3_mutex_leave(db.mutex)
	return z
}
func sqlite3_errcode(db *struct_sqlite3) int32 {
	if db != nil && !(sqlite3SafetyCheckSickOrOk(db) != 0) {
		return sqlite3MisuseError(171132)
	}
	if !(db != nil) || int32(db.mallocFailed) != 0 {
		return int32(7)
	}
	return db.errCode & db.errMask
}
func sqlite3_extended_errcode(db *struct_sqlite3) int32 {
	if db != nil && !(sqlite3SafetyCheckSickOrOk(db) != 0) {
		return sqlite3MisuseError(171141)
	}
	if !(db != nil) || int32(db.mallocFailed) != 0 {
		return int32(7)
	}
	return db.errCode
}
func sqlite3_system_errno(db *struct_sqlite3) int32 {
	return func() int32 {
		if db != nil {
			return db.iSysErrno
		} else {
			return 0
		}
	}()
}
func sqlite3_errstr(rc int32) *int8 {
	return sqlite3ErrStr(rc)
}
func createCollation(db *struct_sqlite3, zName *int8, enc uint8, pCtx unsafe.Pointer, xCompare func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32, xDel func(unsafe.Pointer)) int32 {
	var pColl *struct_CollSeq
	var enc2 int32
	func() int {
		_ = 0
		return 0
	}()
	enc2 = int32(enc)
	if enc2 == 4 || enc2 == 8 {
		enc2 = int32(2)
	}
	if enc2 < 1 || enc2 > 3 {
		return sqlite3MisuseError(171189)
	}
	pColl = sqlite3FindCollSeq(db, uint8(enc2), zName, 0)
	if pColl != nil && pColl.xCmp != nil {
		if db.nVdbeActive != 0 {
			sqlite3ErrorWithMsg(db, 5, (*int8)(unsafe.Pointer(&[68]int8{'u', 'n', 'a', 'b', 'l', 'e', ' ', 't', 'o', ' ', 'd', 'e', 'l', 'e', 't', 'e', '/', 'm', 'o', 'd', 'i', 'f', 'y', ' ', 'c', 'o', 'l', 'l', 'a', 't', 'i', 'o', 'n', ' ', 's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', ' ', 'd', 'u', 'e', ' ', 't', 'o', ' ', 'a', 'c', 't', 'i', 'v', 'e', ' ', 's', 't', 'a', 't', 'e', 'm', 'e', 'n', 't', 's', '\x00'})))
			return int32(5)
		}
		sqlite3ExpirePreparedStatements(db, 0)
		if int32(pColl.enc) & ^8 == enc2 {
			var aColl *struct_CollSeq = (*struct_CollSeq)(sqlite3HashFind(&db.aCollSeq, zName))
			var j int32
			for j = int32(0); j < 3; j++ {
				var p *struct_CollSeq = &*(*struct_CollSeq)(unsafe.Pointer(uintptr(unsafe.Pointer(aColl)) + uintptr(j)*40))
				if int32(p.enc) == int32(pColl.enc) {
					if p.xDel != nil {
						p.xDel(p.pUser)
					}
					p.xCmp = (func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32)(nil)
				}
			}
		}
	}
	pColl = sqlite3FindCollSeq(db, uint8(enc2), zName, 1)
	if uintptr(unsafe.Pointer(pColl)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	pColl.xCmp = xCompare
	pColl.pUser = pCtx
	pColl.xDel = xDel
	pColl.enc = uint8(enc2 | int32(enc)&8)
	sqlite3Error(db, 0)
	return int32(0)
}

var aHardLimit [12]int32 = [12]int32{1000000000, 1000000000, 2000, 1000, 500, 250000000, 127, 10, 50000, 32766, 1000, 8}

func sqlite3_limit(db *struct_sqlite3, limitId int32, newLimit int32) int32 {
	var oldLimit int32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if limitId < 0 || limitId >= 11+1 {
		return int32(-1)
	}
	oldLimit = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(limitId)*4))
	if newLimit >= 0 {
		if newLimit > *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aHardLimit)))) + uintptr(limitId)*4)) {
			newLimit = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aHardLimit)))) + uintptr(limitId)*4))
		} else if newLimit < 1 && limitId == 0 {
			newLimit = int32(1)
		}
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(limitId)*4)) = newLimit
	}
	return oldLimit
}
func sqlite3ParseUri(zDefaultVfs *int8, zUri *int8, pFlags *uint32, ppVfs **struct_sqlite3_vfs, pzFile **int8, pzErrMsg **int8) int32 {
	var rc int32 = 0
	var flags uint32 = *pFlags
	var zVfs *int8 = zDefaultVfs
	var zFile *int8
	var c int8
	var nUri int32 = sqlite3Strlen30(zUri)
	func() int {
		_ = 0
		return 0
	}()
	if (flags&uint32(64) != 0 || int32(sqlite3Config.bOpenUri) != 0) && nUri >= 5 && memcmp(unsafe.Pointer(zUri), unsafe.Pointer((*int8)(unsafe.Pointer(&[6]int8{'f', 'i', 'l', 'e', ':', '\x00'}))), uint(5)) == 0 {
		var zOpt *int8
		var eState int32
		var iIn int32
		var iOut int32 = 0
		var nByte uint64 = uint64(nUri + 8)
		flags |= uint32(64)
		for iIn = int32(0); iIn < nUri; iIn++ {
			nByte += func() uint64 {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))) == '&' {
					return 1
				} else {
					return 0
				}
			}()
		}
		zFile = (*int8)(sqlite3_malloc64(nByte))
		if !(zFile != nil) {
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(zFile), 0, uint(4), __builtin_object_size(unsafe.Pointer(zFile), 0))
		*(*uintptr)(unsafe.Pointer(&zFile)) += uintptr(4)
		iIn = int32(5)
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(5)))) == '/' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(6)))) == '/' {
			iIn = int32(7)
			for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))) != '/' {
				iIn++
			}
			if iIn != 7 && (iIn != 16 || memcmp(unsafe.Pointer((*int8)(unsafe.Pointer(&[10]int8{'l', 'o', 'c', 'a', 'l', 'h', 'o', 's', 't', '\x00'}))), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(7)))), uint(9)) != 0) {
				*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[28]int8{'i', 'n', 'v', 'a', 'l', 'i', 'd', ' ', 'u', 'r', 'i', ' ', 'a', 'u', 't', 'h', 'o', 'r', 'i', 't', 'y', ':', ' ', '%', '.', '*', 's', '\x00'})), iIn-7, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(7))))
				rc = int32(1)
				goto parse_uri_out
			}
		}
		eState = int32(0)
		for int32(func() (_cgo_ret int8) {
			_cgo_addr := &c
			*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))
			return *_cgo_addr
		}()) != 0 && int32(c) != '#' {
			iIn++
			if int32(c) == '%' && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn))))))))&8 != 0 && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn+1))))))))&8 != 0 {
				var octet int32 = int32(sqlite3HexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &iIn
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}())))))) << 4
				octet += int32(sqlite3HexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(func() (_cgo_ret int32) {
					_cgo_addr := &iIn
					_cgo_ret = *_cgo_addr
					*_cgo_addr++
					return
				}()))))))
				func() int {
					_ = 0
					return 0
				}()
				if octet == 0 {
					for int32(func() (_cgo_ret int8) {
						_cgo_addr := &c
						*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))
						return *_cgo_addr
					}()) != 0 && int32(c) != '#' && (eState != 0 || int32(c) != '?') && (eState != 1 || int32(c) != '=' && int32(c) != '&') && (eState != 2 || int32(c) != '&') {
						iIn++
					}
					continue
				}
				c = int8(octet)
			} else if eState == 1 && (int32(c) == '&' || int32(c) == '=') {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(iOut-1)))) == 0 {
					for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn)))) != '#' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zUri)) + uintptr(iIn-1)))) != '&' {
						iIn++
					}
					continue
				}
				if int32(c) == '&' {
					*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(func() (_cgo_ret int32) {
						_cgo_addr := &iOut
						_cgo_ret = *_cgo_addr
						*_cgo_addr++
						return
					}()))) = int8('\x00')
				} else {
					eState = int32(2)
				}
				c = int8(0)
			} else if eState == 0 && int32(c) == '?' || eState == 2 && int32(c) == '&' {
				c = int8(0)
				eState = int32(1)
			}
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &iOut
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = c
		}
		if eState == 1 {
			*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(func() (_cgo_ret int32) {
				_cgo_addr := &iOut
				_cgo_ret = *_cgo_addr
				*_cgo_addr++
				return
			}()))) = int8('\x00')
		}
		__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile))+uintptr(iOut)))), 0, uint(4), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile))+uintptr(iOut)))), 0))
		zOpt = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile)) + uintptr(sqlite3Strlen30(zFile)+1)))
		for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOpt)) + uintptr(0))) != 0 {
			var nOpt int32 = sqlite3Strlen30(zOpt)
			var zVal *int8 = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOpt)) + uintptr(nOpt+1)))
			var nVal int32 = sqlite3Strlen30(zVal)
			if nOpt == 3 && memcmp(unsafe.Pointer((*int8)(unsafe.Pointer(&[4]int8{'v', 'f', 's', '\x00'}))), unsafe.Pointer(zOpt), uint(3)) == 0 {
				zVfs = zVal
			} else {
				type struct_OpenMode struct {
					z    *int8
					mode int32
				}
				var aMode *struct_OpenMode = nil
				var zModeType *int8 = nil
				var mask int32 = 0
				var limit int32 = 0
				if nOpt == 5 && memcmp(unsafe.Pointer((*int8)(unsafe.Pointer(&[6]int8{'c', 'a', 'c', 'h', 'e', '\x00'}))), unsafe.Pointer(zOpt), uint(5)) == 0 {
					var aCacheMode [3]struct_OpenMode = [3]struct_OpenMode{struct_OpenMode{(*int8)(unsafe.Pointer(&[7]int8{'s', 'h', 'a', 'r', 'e', 'd', '\x00'})), 131072}, struct_OpenMode{(*int8)(unsafe.Pointer(&[8]int8{'p', 'r', 'i', 'v', 'a', 't', 'e', '\x00'})), 262144}, struct_OpenMode{nil, 0}}
					mask = int32(131072 | 262144)
					aMode = (*struct_OpenMode)(unsafe.Pointer(&aCacheMode))
					limit = mask
					zModeType = (*int8)(unsafe.Pointer(&[6]int8{'c', 'a', 'c', 'h', 'e', '\x00'}))
				}
				if nOpt == 4 && memcmp(unsafe.Pointer((*int8)(unsafe.Pointer(&[5]int8{'m', 'o', 'd', 'e', '\x00'}))), unsafe.Pointer(zOpt), uint(4)) == 0 {
					var aOpenMode [5]struct_OpenMode = [5]struct_OpenMode{struct_OpenMode{(*int8)(unsafe.Pointer(&[3]int8{'r', 'o', '\x00'})), 1}, struct_OpenMode{(*int8)(unsafe.Pointer(&[3]int8{'r', 'w', '\x00'})), 2}, struct_OpenMode{(*int8)(unsafe.Pointer(&[4]int8{'r', 'w', 'c', '\x00'})), 2 | 4}, struct_OpenMode{(*int8)(unsafe.Pointer(&[7]int8{'m', 'e', 'm', 'o', 'r', 'y', '\x00'})), 128}, struct_OpenMode{nil, 0}}
					mask = int32(1 | 2 | 4 | 128)
					aMode = (*struct_OpenMode)(unsafe.Pointer(&aOpenMode))
					limit = int32(uint32(mask) & flags)
					zModeType = (*int8)(unsafe.Pointer(&[7]int8{'a', 'c', 'c', 'e', 's', 's', '\x00'}))
				}
				if aMode != nil {
					var i int32
					var mode int32 = 0
					for i = int32(0); (*(*struct_OpenMode)(unsafe.Pointer(uintptr(unsafe.Pointer(aMode)) + uintptr(i)*12))).z != nil; i++ {
						var z *int8 = (*(*struct_OpenMode)(unsafe.Pointer(uintptr(unsafe.Pointer(aMode)) + uintptr(i)*12))).z
						if nVal == sqlite3Strlen30(z) && 0 == memcmp(unsafe.Pointer(zVal), unsafe.Pointer(z), uint(nVal)) {
							mode = (*(*struct_OpenMode)(unsafe.Pointer(uintptr(unsafe.Pointer(aMode)) + uintptr(i)*12))).mode
							break
						}
					}
					if mode == 0 {
						*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[20]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', '%', 's', ' ', 'm', 'o', 'd', 'e', ':', ' ', '%', 's', '\x00'})), zModeType, zVal)
						rc = int32(1)
						goto parse_uri_out
					}
					if mode & ^128 > limit {
						*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[24]int8{'%', 's', ' ', 'm', 'o', 'd', 'e', ' ', 'n', 'o', 't', ' ', 'a', 'l', 'l', 'o', 'w', 'e', 'd', ':', ' ', '%', 's', '\x00'})), zModeType, zVal)
						rc = int32(3)
						goto parse_uri_out
					}
					flags = flags&uint32(^mask) | uint32(mode)
				}
			}
			zOpt = &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zVal)) + uintptr(nVal+1)))
		}
	} else {
		zFile = (*int8)(sqlite3_malloc64(uint64(nUri + 8)))
		if !(zFile != nil) {
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(zFile), 0, uint(4), __builtin_object_size(unsafe.Pointer(zFile), 0))
		*(*uintptr)(unsafe.Pointer(&zFile)) += uintptr(4)
		if nUri != 0 {
			__builtin___memcpy_chk(unsafe.Pointer(zFile), unsafe.Pointer(zUri), uint(nUri), __builtin_object_size(unsafe.Pointer(zFile), 0))
		}
		__builtin___memset_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile))+uintptr(nUri)))), 0, uint(4), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFile))+uintptr(nUri)))), 0))
		flags &= uint32(4294967231)
	}
	*ppVfs = sqlite3_vfs_find(zVfs)
	if uintptr(unsafe.Pointer(*ppVfs)) == uintptr(unsafe.Pointer(nil)) {
		*pzErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[16]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 'v', 'f', 's', ':', ' ', '%', 's', '\x00'})), zVfs)
		rc = int32(1)
	}
parse_uri_out:
	if rc != 0 {
		sqlite3_free_filename(zFile)
		zFile = (*int8)(nil)
	}
	*pFlags = flags
	*pzFile = zFile
	return rc
}
func uriParameter(zFilename *int8, zParam *int8) *int8 {
	*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	for uintptr(unsafe.Pointer(zFilename)) != uintptr(unsafe.Pointer(nil)) && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0 {
		var x int32 = strcmp(zFilename, zParam)
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
		if x == 0 {
			return zFilename
		}
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	}
	return (*int8)(nil)
}
func openDatabase(zFilename *int8, ppDb **struct_sqlite3, flags uint32, zVfs *int8) int32 {
	var db *struct_sqlite3
	var rc int32
	var isThreadsafe int32
	var zOpen *int8 = nil
	var zErrMsg *int8 = nil
	var i int32
	*ppDb = (*struct_sqlite3)(nil)
	rc = sqlite3_initialize()
	if rc != 0 {
		return rc
	}
	if int32(sqlite3Config.bCoreMutex) == 0 {
		isThreadsafe = int32(0)
	} else if flags&uint32(32768) != 0 {
		isThreadsafe = int32(0)
	} else if flags&uint32(65536) != 0 {
		isThreadsafe = int32(1)
	} else {
		isThreadsafe = int32(sqlite3Config.bFullMutex)
	}
	if flags&uint32(262144) != 0 {
		flags &= uint32(4294836223)
	} else if sqlite3Config.sharedCacheEnabled != 0 {
		flags |= uint32(131072)
	}
	flags &= uint32(4294312167)
	db = (*struct_sqlite3)(sqlite3MallocZero(uint64(776)))
	if uintptr(unsafe.Pointer(db)) == uintptr(unsafe.Pointer(nil)) {
		goto opendb_out
	}
	if isThreadsafe != 0 {
		db.mutex = sqlite3MutexAlloc(1)
		if uintptr(unsafe.Pointer(db.mutex)) == uintptr(unsafe.Pointer(nil)) {
			sqlite3_free(unsafe.Pointer(db))
			db = (*struct_sqlite3)(nil)
			goto opendb_out
		}
		if isThreadsafe == 0 {
		}
	}
	sqlite3_mutex_enter(db.mutex)
	db.errMask = int32(func() uint32 {
		if flags&uint32(33554432) != uint32(0) {
			return 4294967295
		} else {
			return uint32(255)
		}
	}())
	db.nDb = int32(2)
	db.eOpenState = uint8(109)
	db.aDb = (*struct_Db)(unsafe.Pointer(&db.aDbStatic))
	db.lookaside.bDisable = uint32(1)
	db.lookaside.sz = uint16(0)
	func() int {
		_ = 0
		return 0
	}()
	__builtin___memcpy_chk(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit))), unsafe.Pointer((*int32)(unsafe.Pointer(&aHardLimit))), 48, __builtin_object_size(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit))), 0))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&db.aLimit)))) + uintptr(11)*4)) = int32(0)
	db.autoCommit = uint8(1)
	db.nextAutovac = int8(-1)
	db.szMmap = sqlite3Config.szMmap
	db.nextPagesize = int32(0)
	db.init.azInit = (**int8)(unsafe.Pointer(&sqlite3StdType))
	db.flags |= uint64(uint32(64|262144) | 2147483648 | uint32(32) | uint32(128) | uint32(1073741824) | uint32(536870912) | uint32(32768))
	sqlite3HashInit(&db.aCollSeq)
	sqlite3HashInit(&db.aModule)
	createCollation(db, (*int8)(unsafe.Pointer(&sqlite3StrBINARY)), uint8(1), nil, binCollFunc, nil)
	createCollation(db, (*int8)(unsafe.Pointer(&sqlite3StrBINARY)), uint8(3), nil, binCollFunc, nil)
	createCollation(db, (*int8)(unsafe.Pointer(&sqlite3StrBINARY)), uint8(2), nil, binCollFunc, nil)
	createCollation(db, (*int8)(unsafe.Pointer(&[7]int8{'N', 'O', 'C', 'A', 'S', 'E', '\x00'})), uint8(1), nil, nocaseCollatingFunc, nil)
	createCollation(db, (*int8)(unsafe.Pointer(&[6]int8{'R', 'T', 'R', 'I', 'M', '\x00'})), uint8(1), nil, rtrimCollFunc, nil)
	if db.mallocFailed != 0 {
		goto opendb_out
	}
	db.openFlags = flags
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	if 1<<(flags&uint32(7))&70 == 0 {
		rc = sqlite3MisuseError(171845)
	} else {
		rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db.pVfs, &zOpen, &zErrMsg)
	}
	if rc != 0 {
		if rc == 7 {
			sqlite3OomFault(db)
		}
		sqlite3ErrorWithMsg(db, rc, func() *int8 {
			if zErrMsg != nil {
				return (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'}))
			} else {
				return nil
			}
		}(), zErrMsg)
		sqlite3_free(unsafe.Pointer(zErrMsg))
		goto opendb_out
	}
	rc = sqlite3BtreeOpen(db.pVfs, zOpen, db, &(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt, 0, int32(flags|uint32(256)))
	if rc != 0 {
		if rc == 10|12<<8 {
			rc = int32(7)
		}
		sqlite3Error(db, rc)
		goto opendb_out
	}
	sqlite3BtreeEnter((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt)
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema = sqlite3SchemaGet(db, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt)
	if !(db.mallocFailed != 0) {
		sqlite3SetTextEncoding(db, (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.enc)
	}
	sqlite3BtreeLeave((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pBt)
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).pSchema = sqlite3SchemaGet(db, nil)
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).zDbSName = (*int8)(unsafe.Pointer(&[5]int8{'m', 'a', 'i', 'n', '\x00'}))
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).safety_level = uint8(2 + 1)
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).zDbSName = (*int8)(unsafe.Pointer(&[5]int8{'t', 'e', 'm', 'p', '\x00'}))
	(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(1)*32))).safety_level = uint8(1)
	db.eOpenState = uint8(118)
	if db.mallocFailed != 0 {
		goto opendb_out
	}
	sqlite3Error(db, 0)
	sqlite3RegisterPerConnectionBuiltinFunctions(db)
	rc = sqlite3_errcode(db)
	for i = int32(0); rc == 0 && i < int32(16/8); i++ {
		rc = (*(*func(*struct_sqlite3) int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*func(*struct_sqlite3) int32)(unsafe.Pointer(&sqlite3BuiltinExtensions)))) + uintptr(i)*8)))(db)
	}
	if rc == 0 {
		sqlite3AutoLoadExtensions(db)
		rc = sqlite3_errcode(db)
		if rc != 0 {
			goto opendb_out
		}
	}
	if rc != 0 {
		sqlite3Error(db, rc)
	}
	setupLookaside(db, nil, sqlite3Config.szLookaside, sqlite3Config.nLookaside)
	sqlite3_wal_autocheckpoint(db, 1000)
opendb_out:
	if db != nil {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_mutex_leave(db.mutex)
	}
	rc = sqlite3_errcode(db)
	func() int {
		_ = 0
		return 0
	}()
	if rc&255 == 7 {
		sqlite3_close(db)
		db = (*struct_sqlite3)(nil)
	} else if rc != 0 {
		db.eOpenState = uint8(186)
	}
	*ppDb = db
	sqlite3_free_filename(zOpen)
	return rc
}
func sqlite3_open(zFilename *int8, ppDb **struct_sqlite3) int32 {
	return openDatabase(zFilename, ppDb, uint32(2|4), nil)
}
func sqlite3_open_v2(filename *int8, ppDb **struct_sqlite3, flags int32, zVfs *int8) int32 {
	return openDatabase(filename, ppDb, uint32(flags), zVfs)
}
func sqlite3_open16(zFilename unsafe.Pointer, ppDb **struct_sqlite3) int32 {
	var zFilename8 *int8
	var pVal *struct_sqlite3_value
	var rc int32
	*ppDb = (*struct_sqlite3)(nil)
	rc = sqlite3_initialize()
	if rc != 0 {
		return rc
	}
	if uintptr(unsafe.Pointer(zFilename)) == uintptr(unsafe.Pointer(nil)) {
		zFilename = unsafe.Pointer((*int8)(unsafe.Pointer(&[3]int8{'\x00', '\x00', '\x00'})))
	}
	pVal = sqlite3ValueNew(nil)
	sqlite3ValueSetStr(pVal, -1, zFilename, uint8(2), (func(unsafe.Pointer))(0))
	zFilename8 = (*int8)(sqlite3ValueText(pVal, uint8(1)))
	if zFilename8 != nil {
		rc = openDatabase(zFilename8, ppDb, uint32(2|4), nil)
		func() int {
			_ = 0
			return 0
		}()
		if rc == 0 && !(int32((*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer((*ppDb).aDb)) + uintptr(0)*32))).pSchema.schemaFlags)&1 == 1) {
			(*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer((*ppDb).aDb)) + uintptr(0)*32))).pSchema.enc = func() (_cgo_ret uint8) {
				_cgo_addr := &(*ppDb).enc
				*_cgo_addr = uint8(2)
				return *_cgo_addr
			}()
		}
	} else {
		rc = int32(7)
	}
	sqlite3ValueFree(pVal)
	return rc & 255
}
func sqlite3_create_collation(db *struct_sqlite3, zName *int8, enc int32, pCtx unsafe.Pointer, xCompare func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32) int32 {
	return sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, nil)
}
func sqlite3_create_collation_v2(db *struct_sqlite3, zName *int8, enc int32, pCtx unsafe.Pointer, xCompare func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32, xDel func(unsafe.Pointer)) int32 {
	var rc int32
	sqlite3_mutex_enter(db.mutex)
	func() int {
		_ = 0
		return 0
	}()
	rc = createCollation(db, zName, uint8(enc), pCtx, xCompare, xDel)
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_create_collation16(db *struct_sqlite3, zName unsafe.Pointer, enc int32, pCtx unsafe.Pointer, xCompare func(unsafe.Pointer, int32, unsafe.Pointer, int32, unsafe.Pointer) int32) int32 {
	var rc int32 = 0
	var zName8 *int8
	sqlite3_mutex_enter(db.mutex)
	func() int {
		_ = 0
		return 0
	}()
	zName8 = sqlite3Utf16to8(db, zName, -1, uint8(2))
	if zName8 != nil {
		rc = createCollation(db, zName8, uint8(enc), pCtx, xCompare, nil)
		sqlite3DbFree(db, unsafe.Pointer(zName8))
	}
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_collation_needed(db *struct_sqlite3, pCollNeededArg unsafe.Pointer, xCollNeeded func(unsafe.Pointer, *struct_sqlite3, int32, *int8)) int32 {
	sqlite3_mutex_enter(db.mutex)
	db.xCollNeeded = xCollNeeded
	db.xCollNeeded16 = (func(unsafe.Pointer, *struct_sqlite3, int32, unsafe.Pointer))(nil)
	db.pCollNeededArg = pCollNeededArg
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3_collation_needed16(db *struct_sqlite3, pCollNeededArg unsafe.Pointer, xCollNeeded16 func(unsafe.Pointer, *struct_sqlite3, int32, unsafe.Pointer)) int32 {
	sqlite3_mutex_enter(db.mutex)
	db.xCollNeeded = (func(unsafe.Pointer, *struct_sqlite3, int32, *int8))(nil)
	db.xCollNeeded16 = xCollNeeded16
	db.pCollNeededArg = pCollNeededArg
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3_global_recover() int32 {
	return int32(0)
}
func sqlite3_get_autocommit(db *struct_sqlite3) int32 {
	return int32(db.autoCommit)
}
func sqlite3ReportError(iErr int32, lineno int32, zType *int8) int32 {
	sqlite3_log(iErr, (*int8)(unsafe.Pointer(&[25]int8{'%', 's', ' ', 'a', 't', ' ', 'l', 'i', 'n', 'e', ' ', '%', 'd', ' ', 'o', 'f', ' ', '[', '%', '.', '1', '0', 's', ']', '\x00'})), zType, lineno, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(sqlite3_sourceid()))+uintptr(20))))
	return iErr
}
func sqlite3CorruptError(lineno int32) int32 {
	return sqlite3ReportError(11, lineno, (*int8)(unsafe.Pointer(&[20]int8{'d', 'a', 't', 'a', 'b', 'a', 's', 'e', ' ', 'c', 'o', 'r', 'r', 'u', 'p', 't', 'i', 'o', 'n', '\x00'})))
}
func sqlite3MisuseError(lineno int32) int32 {
	return sqlite3ReportError(21, lineno, (*int8)(unsafe.Pointer(&[7]int8{'m', 'i', 's', 'u', 's', 'e', '\x00'})))
}
func sqlite3CantopenError(lineno int32) int32 {
	return sqlite3ReportError(14, lineno, (*int8)(unsafe.Pointer(&[17]int8{'c', 'a', 'n', 'n', 'o', 't', ' ', 'o', 'p', 'e', 'n', ' ', 'f', 'i', 'l', 'e', '\x00'})))
}
func sqlite3_thread_cleanup() {
}
func sqlite3_table_column_metadata(db *struct_sqlite3, zDbName *int8, zTableName *int8, zColumnName *int8, pzDataType **int8, pzCollSeq **int8, pNotNull *int32, pPrimaryKey *int32, pAutoinc *int32) int32 {
	var rc int32
	var zErrMsg *int8 = nil
	var pTab *struct_Table = nil
	var pCol *struct_Column = nil
	var iCol int32 = 0
	var zDataType *int8 = nil
	var zCollSeq *int8 = nil
	var notnull int32 = 0
	var primarykey int32 = 0
	var autoinc int32 = 0
	sqlite3_mutex_enter(db.mutex)
	sqlite3BtreeEnterAll(db)
	rc = sqlite3Init(db, &zErrMsg)
	if 0 != rc {
		goto error_out
	}
	pTab = sqlite3FindTable(db, zTableName, zDbName)
	if !(pTab != nil) || int32(pTab.eTabType) == 2 {
		pTab = (*struct_Table)(nil)
		goto error_out
	}
	if uintptr(unsafe.Pointer(zColumnName)) == uintptr(unsafe.Pointer(nil)) {
	} else {
		for iCol = int32(0); iCol < int32(pTab.nCol); iCol++ {
			pCol = &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
			if 0 == sqlite3StrICmp(pCol.zCnName, zColumnName) {
				break
			}
		}
		if iCol == int32(pTab.nCol) {
			if pTab.tabFlags&uint32(128) == uint32(0) && sqlite3IsRowid(zColumnName) != 0 {
				iCol = int32(pTab.iPKey)
				pCol = func() *struct_Column {
					if iCol >= 0 {
						return &*(*struct_Column)(unsafe.Pointer(uintptr(unsafe.Pointer(pTab.aCol)) + uintptr(iCol)*20))
					} else {
						return nil
					}
				}()
			} else {
				pTab = (*struct_Table)(nil)
				goto error_out
			}
		}
	}
	if pCol != nil {
		zDataType = sqlite3ColumnType(pCol, nil)
		zCollSeq = sqlite3ColumnColl(pCol)
		notnull = func() int32 {
			if int32(pCol.Xbf_0&15) != 0 {
				return 1
			} else {
				return 0
			}
		}()
		primarykey = func() int32 {
			if int32(pCol.colFlags)&1 != 0 {
				return 1
			} else {
				return 0
			}
		}()
		autoinc = func() int32 {
			if int32(pTab.iPKey) == iCol && pTab.tabFlags&uint32(8) != uint32(0) {
				return 1
			} else {
				return 0
			}
		}()
	} else {
		zDataType = (*int8)(unsafe.Pointer(&[8]int8{'I', 'N', 'T', 'E', 'G', 'E', 'R', '\x00'}))
		primarykey = int32(1)
	}
	if !(zCollSeq != nil) {
		zCollSeq = (*int8)(unsafe.Pointer(&sqlite3StrBINARY))
	}
error_out:
	sqlite3BtreeLeaveAll(db)
	if pzDataType != nil {
		*pzDataType = zDataType
	}
	if pzCollSeq != nil {
		*pzCollSeq = zCollSeq
	}
	if pNotNull != nil {
		*pNotNull = notnull
	}
	if pPrimaryKey != nil {
		*pPrimaryKey = primarykey
	}
	if pAutoinc != nil {
		*pAutoinc = autoinc
	}
	if 0 == rc && !(pTab != nil) {
		sqlite3DbFree(db, unsafe.Pointer(zErrMsg))
		zErrMsg = sqlite3MPrintf(db, (*int8)(unsafe.Pointer(&[28]int8{'n', 'o', ' ', 's', 'u', 'c', 'h', ' ', 't', 'a', 'b', 'l', 'e', ' ', 'c', 'o', 'l', 'u', 'm', 'n', ':', ' ', '%', 's', '.', '%', 's', '\x00'})), zTableName, zColumnName)
		rc = int32(1)
	}
	sqlite3ErrorWithMsg(db, rc, func() *int8 {
		if zErrMsg != nil {
			return (*int8)(unsafe.Pointer(&[3]int8{'%', 's', '\x00'}))
		} else {
			return nil
		}
	}(), zErrMsg)
	sqlite3DbFree(db, unsafe.Pointer(zErrMsg))
	rc = sqlite3ApiExit(db, rc)
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_sleep(ms int32) int32 {
	var pVfs *struct_sqlite3_vfs
	var rc int32
	pVfs = sqlite3_vfs_find(nil)
	if uintptr(unsafe.Pointer(pVfs)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	rc = sqlite3OsSleep(pVfs, 1000*ms) / 1000
	return rc
}
func sqlite3_extended_result_codes(db *struct_sqlite3, onoff int32) int32 {
	sqlite3_mutex_enter(db.mutex)
	db.errMask = int32(func() uint32 {
		if onoff != 0 {
			return 4294967295
		} else {
			return uint32(255)
		}
	}())
	sqlite3_mutex_leave(db.mutex)
	return int32(0)
}
func sqlite3_file_control(db *struct_sqlite3, zDbName *int8, op int32, pArg unsafe.Pointer) int32 {
	var rc int32 = 1
	var pBtree *struct_Btree
	sqlite3_mutex_enter(db.mutex)
	pBtree = sqlite3DbNameToBtree(db, zDbName)
	if pBtree != nil {
		var pPager *struct_Pager
		var fd *struct_sqlite3_file
		sqlite3BtreeEnter(pBtree)
		pPager = sqlite3BtreePager(pBtree)
		func() int {
			_ = 0
			return 0
		}()
		fd = sqlite3PagerFile(pPager)
		func() int {
			_ = 0
			return 0
		}()
		if op == 7 {
			*(**struct_sqlite3_file)(pArg) = fd
			rc = int32(0)
		} else if op == 27 {
			*(**struct_sqlite3_vfs)(pArg) = sqlite3PagerVfs(pPager)
			rc = int32(0)
		} else if op == 28 {
			*(**struct_sqlite3_file)(pArg) = sqlite3PagerJrnlFile(pPager)
			rc = int32(0)
		} else if op == 35 {
			*(*uint32)(pArg) = sqlite3PagerDataVersion(pPager)
			rc = int32(0)
		} else if op == 38 {
			var iNew int32 = *(*int32)(pArg)
			*(*int32)(pArg) = sqlite3BtreeGetRequestedReserve(pBtree)
			if iNew >= 0 && iNew <= 255 {
				sqlite3BtreeSetPageSize(pBtree, 0, iNew, 0)
			}
			rc = int32(0)
		} else {
			var nSave int32 = db.busyHandler.nBusy
			rc = sqlite3OsFileControl(fd, op, pArg)
			db.busyHandler.nBusy = nSave
		}
		sqlite3BtreeLeave(pBtree)
	}
	sqlite3_mutex_leave(db.mutex)
	return rc
}
func sqlite3_test_control(op int32, __cgo_args ...interface {
}) int32 {
	var rc int32 = 0
	switch op {
	case 5:
		{
			sqlite3PrngSaveState()
			break
		}
	case 6:
		{
			sqlite3PrngRestoreState()
			break
		}
	case 28:
		{
			var x int32 = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var y int32
			var db *struct_sqlite3 = func() (_cgo_ret *struct_sqlite3) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3)
				__cgo_args = __cgo_args[1:]
				return
			}()
			func() int {
				_ = 0
				return 0
			}()
			if db != nil && func() (_cgo_ret int32) {
				_cgo_addr := &y
				*_cgo_addr = (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(0)*32))).pSchema.schema_cookie
				return *_cgo_addr
			}() != 0 {
				x = y
			}
			sqlite3Config.iPrngSeed = uint32(x)
			sqlite3_randomness(0, nil)
			break
		}
	case 8:
		{
			var sz int32 = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var aProg *int32 = func() (_cgo_ret *int32) {
				_cgo_ret = __cgo_args[0].(*int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			rc = sqlite3BitvecBuiltinTest(sz, aProg)
			break
		}
	case 9:
		{
			type sqlite3FaultFuncType = func(int32) int32
			sqlite3Config.xTestCallback = func() (_cgo_ret func(int32) int32) {
				_cgo_ret = __cgo_args[0].(func(int32) int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			rc = sqlite3FaultSim(0)
			break
		}
	case 10:
		{
			type void_function = func()
			var xBenignBegin func()
			var xBenignEnd func()
			xBenignBegin = func() (_cgo_ret func()) {
				_cgo_ret = __cgo_args[0].(func())
				__cgo_args = __cgo_args[1:]
				return
			}()
			xBenignEnd = func() (_cgo_ret func()) {
				_cgo_ret = __cgo_args[0].(func())
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd)
			break
		}
	case 11:
		{
			rc = sqlite3PendingByte
			{
				var newVal uint32 = func() (_cgo_ret uint32) {
					_cgo_ret = __cgo_args[0].(uint32)
					__cgo_args = __cgo_args[1:]
					return
				}()
				if newVal != 0 {
					sqlite3PendingByte = int32(newVal)
				}
			}
			break
		}
	case 12:
		{
			var x int32 = 0
			func() int {
				_ = 0
				return 0
			}()
			rc = x
			break
		}
	case 13:
		{
			var x int32 = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			rc = func() int32 {
				if x != 0 {
					return x
				} else {
					return 0
				}
			}()
			break
		}
	case 22:
		{
			rc = int32(1234*100 + 1*10 + 0)
			break
		}
	case 15:
		{
			var db *struct_sqlite3 = func() (_cgo_ret *struct_sqlite3) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3)
				__cgo_args = __cgo_args[1:]
				return
			}()
			db.dbOptFlags = func() (_cgo_ret uint32) {
				_cgo_ret = __cgo_args[0].(uint32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 18:
		{
			sqlite3Config.bLocaltimeFault = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			if sqlite3Config.bLocaltimeFault == 2 {
				type sqlite3LocaltimeType = func(unsafe.Pointer, unsafe.Pointer) int32
				sqlite3Config.xAltLocaltime = func() (_cgo_ret func(unsafe.Pointer, unsafe.Pointer) int32) {
					_cgo_ret = __cgo_args[0].(func(unsafe.Pointer, unsafe.Pointer) int32)
					__cgo_args = __cgo_args[1:]
					return
				}()
			} else {
				sqlite3Config.xAltLocaltime = (func(unsafe.Pointer, unsafe.Pointer) int32)(nil)
			}
			break
		}
	case 17:
		{
			var db *struct_sqlite3 = func() (_cgo_ret *struct_sqlite3) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3)
				__cgo_args = __cgo_args[1:]
				return
			}()
			db.mDbFlags ^= uint32(32)
			break
		}
	case 20:
		{
			sqlite3Config.neverCorrupt = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 29:
		{
			sqlite3Config.bExtraSchemaChecks = uint8(func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}())
			break
		}
	case 19:
		{
			sqlite3Config.iOnceResetThreshold = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 21:
		{
			break
		}
	case 24:
		{
			var db *struct_sqlite3 = func() (_cgo_ret *struct_sqlite3) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3)
				__cgo_args = __cgo_args[1:]
				return
			}()
			db.nMaxSorterMmap = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			break
		}
	case 23:
		{
			if sqlite3Config.isInit == 0 {
				rc = int32(1)
			}
			break
		}
	case 25:
		{
			var db *struct_sqlite3 = func() (_cgo_ret *struct_sqlite3) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var iDb int32
			sqlite3_mutex_enter(db.mutex)
			iDb = sqlite3FindDbName(db, func() (_cgo_ret *int8) {
				_cgo_ret = __cgo_args[0].(*int8)
				__cgo_args = __cgo_args[1:]
				return
			}())
			if iDb >= 0 {
				db.init.iDb = uint8(iDb)
				db.init.busy = uint8(func() (_cgo_ret uint32) {
					_cgo_addr := &db.init.Xbf_0
					*_cgo_addr = uint32(func() (_cgo_ret int32) {
						_cgo_ret = __cgo_args[0].(int32)
						__cgo_args = __cgo_args[1:]
						return
					}())
					return *_cgo_addr
				}())
				db.init.newTnum = uint32(func() (_cgo_ret int32) {
					_cgo_ret = __cgo_args[0].(int32)
					__cgo_args = __cgo_args[1:]
					return
				}())
				if int32(db.init.busy) == 0 && db.init.newTnum > uint32(0) {
					sqlite3ResetAllSchemasOfConnection(db)
				}
			}
			sqlite3_mutex_leave(db.mutex)
			break
		}
	case 27:
		{
			var pCtx *struct_sqlite3_context = func() (_cgo_ret *struct_sqlite3_context) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3_context)
				__cgo_args = __cgo_args[1:]
				return
			}()
			sqlite3ResultIntReal(pCtx)
			break
		}
	case 30:
		{
			var db *struct_sqlite3 = func() (_cgo_ret *struct_sqlite3) {
				_cgo_ret = __cgo_args[0].(*struct_sqlite3)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var pn *uint64 = func() (_cgo_ret *uint64) {
				_cgo_ret = __cgo_args[0].(*uint64)
				__cgo_args = __cgo_args[1:]
				return
			}()
			*pn = uint64(0)
			func() int {
				_ = db
				return 0
			}()
			break
		}
	case 31:
		{
			var opTrace int32 = func() (_cgo_ret int32) {
				_cgo_ret = __cgo_args[0].(int32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var ptr *uint32 = func() (_cgo_ret *uint32) {
				_cgo_ret = __cgo_args[0].(*uint32)
				__cgo_args = __cgo_args[1:]
				return
			}()
			switch opTrace {
			case 0:
				*ptr = sqlite3SelectTrace
				break
			case 1:
				sqlite3SelectTrace = *ptr
				break
			case 2:
				*ptr = sqlite3WhereTrace
				break
			case 3:
				sqlite3WhereTrace = *ptr
				break
			}
			break
		}
	case 33:
		{
			var rIn float64 = func() (_cgo_ret float64) {
				_cgo_ret = __cgo_args[0].(float64)
				__cgo_args = __cgo_args[1:]
				return
			}()
			var rLogEst int16 = sqlite3LogEstFromDouble(rIn)
			var iInt uint64 = sqlite3LogEstToInt(rLogEst)
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(func() (_cgo_ret *int32) {
				_cgo_ret = __cgo_args[0].(*int32)
				__cgo_args = __cgo_args[1:]
				return
			}())) + uintptr(0)*4)) = int32(rLogEst)
			*(*uint64)(unsafe.Pointer(uintptr(unsafe.Pointer(func() (_cgo_ret *uint64) {
				_cgo_ret = __cgo_args[0].(*uint64)
				__cgo_args = __cgo_args[1:]
				return
			}())) + uintptr(0)*8)) = iInt
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(func() (_cgo_ret *int32) {
				_cgo_ret = __cgo_args[0].(*int32)
				__cgo_args = __cgo_args[1:]
				return
			}())) + uintptr(0)*4)) = int32(sqlite3LogEst(iInt))
			break
		}
	}
	return rc
}
func databaseName(zName *int8) *int8 {
	for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -1)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -2)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -3)))) != 0 || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zName)) - uintptr(- -4)))) != 0 {
		*(*uintptr)(unsafe.Pointer(&zName))--
	}
	return zName
}
func appendText(p *int8, z *int8) *int8 {
	var n uint = strlen(z)
	__builtin___memcpy_chk(unsafe.Pointer(p), unsafe.Pointer(z), n+uint(1), __builtin_object_size(unsafe.Pointer(p), 0))
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p))+uintptr(n))))) + uintptr(1)))
}
func sqlite3_create_filename(zDatabase *int8, zJournal *int8, zWal *int8, nParam int32, azParam **int8) *int8 {
	var nByte int64
	var i int32
	var pResult *int8
	var p *int8
	nByte = int64(strlen(zDatabase) + strlen(zJournal) + strlen(zWal) + uint(10))
	for i = int32(0); i < nParam*2; i++ {
		nByte += int64(uint64(strlen(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azParam)) + uintptr(i)*8))) + uint(1)))
	}
	pResult = func() (_cgo_ret *int8) {
		_cgo_addr := &p
		*_cgo_addr = (*int8)(sqlite3_malloc64(uint64(nByte)))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	__builtin___memset_chk(unsafe.Pointer(p), 0, uint(4), __builtin_object_size(unsafe.Pointer(p), 0))
	*(*uintptr)(unsafe.Pointer(&p)) += uintptr(4)
	p = appendText(p, zDatabase)
	for i = int32(0); i < nParam*2; i++ {
		p = appendText(p, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azParam)) + uintptr(i)*8)))
	}
	*func() (_cgo_ret *int8) {
		_cgo_addr := &p
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr))++
		return
	}() = int8(0)
	p = appendText(p, zJournal)
	p = appendText(p, zWal)
	*func() (_cgo_ret *int8) {
		_cgo_addr := &p
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr))++
		return
	}() = int8(0)
	*func() (_cgo_ret *int8) {
		_cgo_addr := &p
		_cgo_ret = *_cgo_addr
		*(*uintptr)(unsafe.Pointer(_cgo_addr))++
		return
	}() = int8(0)
	func() int {
		_ = 0
		return 0
	}()
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pResult)) + uintptr(4)))
}
func sqlite3_free_filename(p *int8) {
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	p = (*int8)(unsafe.Pointer(databaseName(p)))
	sqlite3_free(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) - uintptr(4)))))
}
func sqlite3_uri_parameter(zFilename *int8, zParam *int8) *int8 {
	if uintptr(unsafe.Pointer(zFilename)) == uintptr(unsafe.Pointer(nil)) || uintptr(unsafe.Pointer(zParam)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	zFilename = databaseName(zFilename)
	return uriParameter(zFilename, zParam)
}
func sqlite3_uri_key(zFilename *int8, N int32) *int8 {
	if uintptr(unsafe.Pointer(zFilename)) == uintptr(unsafe.Pointer(nil)) || N < 0 {
		return (*int8)(nil)
	}
	zFilename = databaseName(zFilename)
	*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	for zFilename != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0 && func() (_cgo_ret int32) {
		_cgo_addr := &N
		_cgo_ret = *_cgo_addr
		*_cgo_addr--
		return
	}() > 0 {
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	}
	return func() *int8 {
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0 {
			return zFilename
		} else {
			return nil
		}
	}()
}
func sqlite3_uri_boolean(zFilename *int8, zParam *int8, bDflt int32) int32 {
	var z *int8 = sqlite3_uri_parameter(zFilename, zParam)
	bDflt = func() int32 {
		if bDflt != 0 {
			return 1
		} else {
			return 0
		}
	}()
	return func() int32 {
		if z != nil {
			return int32(sqlite3GetBoolean(z, uint8(bDflt)))
		} else {
			return bDflt
		}
	}()
}
func sqlite3_uri_int64(zFilename *int8, zParam *int8, bDflt int64) int64 {
	var z *int8 = sqlite3_uri_parameter(zFilename, zParam)
	var v int64
	if z != nil && sqlite3DecOrHexToI64(z, &v) == 0 {
		bDflt = v
	}
	return bDflt
}
func sqlite3_filename_database(zFilename *int8) *int8 {
	if uintptr(unsafe.Pointer(zFilename)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	return databaseName(zFilename)
}
func sqlite3_filename_journal(zFilename *int8) *int8 {
	if uintptr(unsafe.Pointer(zFilename)) == uintptr(unsafe.Pointer(nil)) {
		return (*int8)(nil)
	}
	zFilename = databaseName(zFilename)
	*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	for zFilename != nil && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(0)))) != 0 {
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	}
	return (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zFilename)) + uintptr(1)))
}
func sqlite3_filename_wal(zFilename *int8) *int8 {
	zFilename = sqlite3_filename_journal(zFilename)
	if zFilename != nil {
		*(*uintptr)(unsafe.Pointer(&zFilename)) += uintptr(sqlite3Strlen30(zFilename) + 1)
	}
	return zFilename
}
func sqlite3DbNameToBtree(db *struct_sqlite3, zDbName *int8) *struct_Btree {
	var iDb int32 = func() int32 {
		if zDbName != nil {
			return sqlite3FindDbName(db, zDbName)
		} else {
			return 0
		}
	}()
	return func() *struct_Btree {
		if iDb < 0 {
			return nil
		} else {
			return (*(*struct_Db)(unsafe.Pointer(uintptr(unsafe.Pointer(db.aDb)) + uintptr(iDb)*32))).pBt
		}
	}()
}
func sqlite3_db_filename(db *struct_sqlite3, zDbName *int8) *int8 {
	var pBt *struct_Btree
	pBt = sqlite3DbNameToBtree(db, zDbName)
	return func() *int8 {
		if pBt != nil {
			return sqlite3BtreeGetFilename(pBt)
		} else {
			return nil
		}
	}()
}
func sqlite3_db_readonly(db *struct_sqlite3, zDbName *int8) int32 {
	var pBt *struct_Btree
	pBt = sqlite3DbNameToBtree(db, zDbName)
	return func() int32 {
		if pBt != nil {
			return sqlite3BtreeIsReadonly(pBt)
		} else {
			return -1
		}
	}()
}
func sqlite3_compileoption_used(zOptName *int8) int32 {
	var i int32
	var n int32
	var nOpt int32
	var azCompileOpt **int8
	azCompileOpt = sqlite3CompileOptions(&nOpt)
	if sqlite3_strnicmp(zOptName, (*int8)(unsafe.Pointer(&[8]int8{'S', 'Q', 'L', 'I', 'T', 'E', '_', '\x00'})), 7) == 0 {
		*(*uintptr)(unsafe.Pointer(&zOptName)) += uintptr(7)
	}
	n = sqlite3Strlen30(zOptName)
	for i = int32(0); i < nOpt; i++ {
		if sqlite3_strnicmp(zOptName, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azCompileOpt)) + uintptr(i)*8)), n) == 0 && sqlite3IsIdChar(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(*(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azCompileOpt)) + uintptr(i)*8)))) + uintptr(n))))) == 0 {
			return int32(1)
		}
	}
	return int32(0)
}
func sqlite3_compileoption_get(N int32) *int8 {
	var nOpt int32
	var azCompileOpt **int8
	azCompileOpt = sqlite3CompileOptions(&nOpt)
	if N >= 0 && N < nOpt {
		return *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer(azCompileOpt)) + uintptr(N)*8))
	}
	return (*int8)(nil)
}

var jsonIsSpace [256]int8 = [256]int8{int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(1), int8(1), int8(0), int8(0), int8(1), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(1), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0)}

type JsonString = struct_JsonString
type JsonNode = struct_JsonNode
type JsonParse = struct_JsonParse
type struct_JsonString struct {
	pCtx    *struct_sqlite3_context
	zBuf    *int8
	nAlloc  uint64
	nUsed   uint64
	bStatic uint8
	bErr    uint8
	zSpace  [100]int8
}

var jsonType [8]*int8 = [8]*int8{(*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'u', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'f', 'a', 'l', 's', 'e', '\x00'})), (*int8)(unsafe.Pointer(&[8]int8{'i', 'n', 't', 'e', 'g', 'e', 'r', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'r', 'e', 'a', 'l', '\x00'})), (*int8)(unsafe.Pointer(&[5]int8{'t', 'e', 'x', 't', '\x00'})), (*int8)(unsafe.Pointer(&[6]int8{'a', 'r', 'r', 'a', 'y', '\x00'})), (*int8)(unsafe.Pointer(&[7]int8{'o', 'b', 'j', 'e', 'c', 't', '\x00'}))}

type _cgoa_91 struct {
	zJContent *int8
}
type struct_JsonNode struct {
	eType   uint8
	jnFlags uint8
	eU      uint8
	n       uint32
	u       _cgoa_91
}
type struct_JsonParse struct {
	nNode  uint32
	nAlloc uint32
	aNode  *struct_JsonNode
	zJson  *int8
	aUp    *uint32
	oom    uint8
	nErr   uint8
	iDepth uint16
	nJson  int32
	iHold  uint32
}

func jsonZero(p *struct_JsonString) {
	p.zBuf = (*int8)(unsafe.Pointer(&p.zSpace))
	p.nAlloc = uint64(100)
	p.nUsed = uint64(0)
	p.bStatic = uint8(1)
}
func jsonInit(p *struct_JsonString, pCtx *struct_sqlite3_context) {
	p.pCtx = pCtx
	p.bErr = uint8(0)
	jsonZero(p)
}
func jsonReset(p *struct_JsonString) {
	if !(p.bStatic != 0) {
		sqlite3_free(unsafe.Pointer(p.zBuf))
	}
	jsonZero(p)
}
func jsonOom(p *struct_JsonString) {
	p.bErr = uint8(1)
	sqlite3_result_error_nomem(p.pCtx)
	jsonReset(p)
}
func jsonGrow(p *struct_JsonString, N uint32) int32 {
	var nTotal uint64 = func() uint64 {
		if uint64(N) < p.nAlloc {
			return p.nAlloc * uint64(2)
		} else {
			return p.nAlloc + uint64(N) + uint64(10)
		}
	}()
	var zNew *int8
	if p.bStatic != 0 {
		if p.bErr != 0 {
			return int32(1)
		}
		zNew = (*int8)(sqlite3_malloc64(nTotal))
		if uintptr(unsafe.Pointer(zNew)) == uintptr(unsafe.Pointer(nil)) {
			jsonOom(p)
			return int32(7)
		}
		__builtin___memcpy_chk(unsafe.Pointer(zNew), unsafe.Pointer(p.zBuf), uint(p.nUsed), __builtin_object_size(unsafe.Pointer(zNew), 0))
		p.zBuf = zNew
		p.bStatic = uint8(0)
	} else {
		zNew = (*int8)(sqlite3_realloc64(unsafe.Pointer(p.zBuf), nTotal))
		if uintptr(unsafe.Pointer(zNew)) == uintptr(unsafe.Pointer(nil)) {
			jsonOom(p)
			return int32(7)
		}
		p.zBuf = zNew
	}
	p.nAlloc = nTotal
	return int32(0)
}
func jsonAppendRaw(p *struct_JsonString, zIn *int8, N uint32) {
	if N == uint32(0) {
		return
	}
	if uint64(N)+p.nUsed >= p.nAlloc && jsonGrow(p, N) != 0 {
		return
	}
	__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf))+uintptr(p.nUsed)))), unsafe.Pointer(zIn), uint(N), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf))+uintptr(p.nUsed)))), 0))
	p.nUsed += uint64(N)
}
func jsonPrintf(N int32, p *struct_JsonString, zFormat *int8, __cgo_args ...interface {
}) {
	if p.nUsed+uint64(N) >= p.nAlloc && jsonGrow(p, uint32(N)) != 0 {
		return
	}
	sqlite3_vsnprintf(N, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf))+uintptr(p.nUsed))), zFormat, __cgo_args...)
	p.nUsed += uint64(int32(strlen((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(p.nUsed))))))
}
func jsonAppendChar(p *struct_JsonString, c int8) {
	if p.nUsed >= p.nAlloc && jsonGrow(p, uint32(1)) != 0 {
		return
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
		_cgo_addr := &p.nUsed
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()))) = c
}
func jsonAppendSeparator(p *struct_JsonString) {
	var c int8
	if p.nUsed == uint64(0) {
		return
	}
	c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(p.nUsed-uint64(1))))
	if int32(c) != '[' && int32(c) != '{' {
		jsonAppendChar(p, int8(','))
	}
}
func jsonAppendString(p *struct_JsonString, zIn *int8, N uint32) {
	var aSpecial_cgo4 [32]int8
	var i uint32
	if uintptr(unsafe.Pointer(zIn)) == uintptr(unsafe.Pointer(nil)) || uint64(N)+p.nUsed+uint64(2) >= p.nAlloc && jsonGrow(p, N+uint32(2)) != 0 {
		return
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
		_cgo_addr := &p.nUsed
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()))) = int8('"')
	for i = uint32(0); i < N; i++ {
		var c uint8 = *(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(zIn)))) + uintptr(i)))
		if !(int32(c) == '"' || int32(c) == '\\') {
			goto _cgol_2
		}
	json_simple_escape:
		if p.nUsed+uint64(N)+uint64(3)-uint64(i) > p.nAlloc && jsonGrow(p, N+uint32(3)-i) != 0 {
			return
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('\\')
		goto _cgol_1
	_cgol_2:
		if !(int32(c) <= 31) {
			goto _cgol_3
		}
		aSpecial_cgo4 = [32]int8{int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8('b'), int8('t'), int8('n'), int8(0), int8('f'), int8('r'), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0), int8(0)}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		if !(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&aSpecial_cgo4)))) + uintptr(c))) != 0) {
			goto _cgol_5
		}
		c = uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&aSpecial_cgo4)))) + uintptr(c))))
		goto json_simple_escape
	_cgol_5:
		if p.nUsed+uint64(N)+uint64(7)+uint64(i) > p.nAlloc && jsonGrow(p, N+uint32(7)-i) != 0 {
			return
		}
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('\\')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('u')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('0')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('0')
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8('0' + int32(c)>>4)
		c = uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&[17]int8{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', '\x00'})))) + uintptr(int32(c)&15))))
	_cgol_3:
		;
	_cgol_1:
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
			_cgo_addr := &p.nUsed
			_cgo_ret = *_cgo_addr
			*_cgo_addr++
			return
		}()))) = int8(c)
	}
	*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zBuf)) + uintptr(func() (_cgo_ret uint64) {
		_cgo_addr := &p.nUsed
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}()))) = int8('"')
	func() int {
		_ = 0
		return 0
	}()
}
func jsonAppendValue(p *struct_JsonString, pValue *struct_sqlite3_value) {
	switch sqlite3_value_type(pValue) {
	case 5:
		{
			jsonAppendRaw(p, (*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'})), uint32(4))
			break
		}
	case 1:
		fallthrough
	case 2:
		{
			var z *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(pValue)))
			var n uint32 = uint32(sqlite3_value_bytes(pValue))
			jsonAppendRaw(p, z, n)
			break
		}
	case 3:
		{
			var z *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(pValue)))
			var n uint32 = uint32(sqlite3_value_bytes(pValue))
			if sqlite3_value_subtype(pValue) == uint32(74) {
				jsonAppendRaw(p, z, n)
			} else {
				jsonAppendString(p, z, n)
			}
			break
		}
	default:
		{
			if int32(p.bErr) == 0 {
				sqlite3_result_error(p.pCtx, (*int8)(unsafe.Pointer(&[29]int8{'J', 'S', 'O', 'N', ' ', 'c', 'a', 'n', 'n', 'o', 't', ' ', 'h', 'o', 'l', 'd', ' ', 'B', 'L', 'O', 'B', ' ', 'v', 'a', 'l', 'u', 'e', 's', '\x00'})), -1)
				p.bErr = uint8(2)
				jsonReset(p)
			}
			break
		}
	}
}
func jsonResult(p *struct_JsonString) {
	if int32(p.bErr) == 0 {
		sqlite3_result_text64(p.pCtx, p.zBuf, p.nUsed, func() func(unsafe.Pointer) {
			if int32(p.bStatic) != 0 {
				return (func(unsafe.Pointer))(-1)
			} else {
				return sqlite3_free
			}
		}(), uint8(1))
		jsonZero(p)
	}
	func() int {
		_ = 0
		return 0
	}()
}
func jsonNodeSize(pNode *struct_JsonNode) uint32 {
	return func() uint32 {
		if int32(pNode.eType) >= 6 {
			return pNode.n + uint32(1)
		} else {
			return uint32(1)
		}
	}()
}
func jsonParseReset(pParse *struct_JsonParse) {
	sqlite3_free(unsafe.Pointer(pParse.aNode))
	pParse.aNode = (*struct_JsonNode)(nil)
	pParse.nNode = uint32(0)
	pParse.nAlloc = uint32(0)
	sqlite3_free(unsafe.Pointer(pParse.aUp))
	pParse.aUp = (*uint32)(nil)
}
func jsonParseFree(pParse *struct_JsonParse) {
	jsonParseReset(pParse)
	sqlite3_free(unsafe.Pointer(pParse))
}
func jsonRenderNode(pNode *struct_JsonNode, pOut *struct_JsonString, aReplace **struct_sqlite3_value) {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pNode.jnFlags)&(8|16) != 0 {
		if int32(pNode.jnFlags)&8 != 0 && uintptr(unsafe.Pointer(aReplace)) != uintptr(unsafe.Pointer(nil)) {
			func() int {
				_ = 0
				return 0
			}()
			jsonAppendValue(pOut, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(aReplace)) + uintptr(*(*uint32)(unsafe.Pointer(&pNode.u)))*8)))
			return
		}
		func() int {
			_ = 0
			return 0
		}()
		pNode = *(**struct_JsonNode)(unsafe.Pointer(&pNode.u))
	}
	switch int32(pNode.eType) {
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			jsonAppendRaw(pOut, (*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'})), uint32(4))
			break
		}
	case 1:
		{
			jsonAppendRaw(pOut, (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'u', 'e', '\x00'})), uint32(4))
			break
		}
	case 2:
		{
			jsonAppendRaw(pOut, (*int8)(unsafe.Pointer(&[6]int8{'f', 'a', 'l', 's', 'e', '\x00'})), uint32(5))
			break
		}
	case 5:
		{
			if int32(pNode.jnFlags)&1 != 0 {
				func() int {
					_ = 0
					return 0
				}()
				jsonAppendString(pOut, pNode.u.zJContent, pNode.n)
				break
			}
		}
	case 4:
		fallthrough
	case 3:
		{
			func() int {
				_ = 0
				return 0
			}()
			jsonAppendRaw(pOut, pNode.u.zJContent, pNode.n)
			break
		}
	case 6:
		{
			var j uint32 = uint32(1)
			jsonAppendChar(pOut, int8('['))
			for {
				for j <= pNode.n {
					if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j)*16))).jnFlags)&4 == 0 {
						jsonAppendSeparator(pOut)
						jsonRenderNode(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j)*16)), pOut, aReplace)
					}
					j += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j)*16)))
				}
				if int32(pNode.jnFlags)&32 == 0 {
					break
				}
				func() int {
					_ = 0
					return 0
				}()
				pNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(*(*uint32)(unsafe.Pointer(&pNode.u)))*16))
				j = uint32(1)
			}
			jsonAppendChar(pOut, int8(']'))
			break
		}
	case 7:
		{
			var j uint32 = uint32(1)
			jsonAppendChar(pOut, int8('{'))
			for {
				for j <= pNode.n {
					if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j+uint32(1))*16))).jnFlags)&4 == 0 {
						jsonAppendSeparator(pOut)
						jsonRenderNode(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j)*16)), pOut, aReplace)
						jsonAppendChar(pOut, int8(':'))
						jsonRenderNode(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j+uint32(1))*16)), pOut, aReplace)
					}
					j += uint32(1) + jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j+uint32(1))*16)))
				}
				if int32(pNode.jnFlags)&32 == 0 {
					break
				}
				func() int {
					_ = 0
					return 0
				}()
				pNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(*(*uint32)(unsafe.Pointer(&pNode.u)))*16))
				j = uint32(1)
			}
			jsonAppendChar(pOut, int8('}'))
			break
		}
	}
}
func jsonReturnJson(pNode *struct_JsonNode, pCtx *struct_sqlite3_context, aReplace **struct_sqlite3_value) {
	var s struct_JsonString
	jsonInit(&s, pCtx)
	jsonRenderNode(pNode, &s, aReplace)
	jsonResult(&s)
	sqlite3_result_subtype(pCtx, uint32(74))
}
func jsonHexToInt(h int32) uint8 {
	func() int {
		_ = 0
		return 0
	}()
	h += 9 * (1 & (h >> 6))
	return uint8(h & 15)
}
func jsonHexToInt4(z *int8) uint32 {
	var v uint32
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = 0
		return 0
	}()
	v = uint32(int32(jsonHexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0))))))<<12 + int32(jsonHexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1))))))<<8 + int32(jsonHexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(2))))))<<4 + int32(jsonHexToInt(int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(3)))))))
	return v
}
func jsonReturn(pNode *struct_JsonNode, pCtx *struct_sqlite3_context, aReplace **struct_sqlite3_value) {
	switch int32(pNode.eType) {
	default:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_result_null(pCtx)
			break
		}
	case 1:
		{
			sqlite3_result_int(pCtx, 1)
			break
		}
	case 2:
		{
			sqlite3_result_int(pCtx, 0)
			break
		}
	case 3:
		{
			var i int64 = int64(0)
			var z *int8
			func() int {
				_ = 0
				return 0
			}()
			z = pNode.u.zJContent
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) == '-' {
				*(*uintptr)(unsafe.Pointer(&z))++
			}
			for int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) >= '0' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) <= '9' {
				var v uint32 = uint32(int32(*func() (_cgo_ret *int8) {
					_cgo_addr := &z
					_cgo_ret = *_cgo_addr
					*(*uintptr)(unsafe.Pointer(_cgo_addr))++
					return
				}()) - '0')
				if i >= (int64(4294967295)|int64(2147483647)<<32)/int64(10) {
					if i > (int64(4294967295)|int64(2147483647)<<32)/int64(10) {
						goto int_as_real
					}
					if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) >= '0' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(0)))) <= '9' {
						goto int_as_real
					}
					if v == uint32(9) {
						goto int_as_real
					}
					if v == uint32(8) {
						if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode.u.zJContent)) + uintptr(0)))) == '-' {
							sqlite3_result_int64(pCtx, int64(-1)-(int64(4294967295)|int64(2147483647)<<32))
							goto int_done
						} else {
							goto int_as_real
						}
					}
				}
				i = i*int64(10) + int64(v)
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode.u.zJContent)) + uintptr(0)))) == '-' {
				i = -i
			}
			sqlite3_result_int64(pCtx, i)
		int_done:
			break
		int_as_real:
		}
	case 4:
		{
			var r float64
			var z *int8
			func() int {
				_ = 0
				return 0
			}()
			z = pNode.u.zJContent
			sqlite3AtoF(z, &r, sqlite3Strlen30(z), uint8(1))
			sqlite3_result_double(pCtx, r)
			break
		}
	case 5:
		{
			func() int {
				_ = 0
				return 0
			}()
			if int32(pNode.jnFlags)&2 == 0 {
				func() int {
					_ = 0
					return 0
				}()
				sqlite3_result_text(pCtx, (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode.u.zJContent))+uintptr(1))), int32(pNode.n-uint32(2)), (func(unsafe.Pointer))(-1))
			} else {
				var i uint32
				var n uint32 = pNode.n
				var z *int8
				var zOut *int8
				var j uint32
				func() int {
					_ = 0
					return 0
				}()
				z = pNode.u.zJContent
				zOut = (*int8)(sqlite3_malloc(int32(n + uint32(1))))
				if uintptr(unsafe.Pointer(zOut)) == uintptr(unsafe.Pointer(nil)) {
					sqlite3_result_error_nomem(pCtx)
					break
				}
				for func() uint32 {
					i = uint32(1)
					return func() (_cgo_ret uint32) {
						_cgo_addr := &j
						*_cgo_addr = uint32(0)
						return *_cgo_addr
					}()
				}(); i < n-uint32(1); i++ {
					var c int8 = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))
					if int32(c) != '\\' {
						*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
							_cgo_addr := &j
							_cgo_ret = *_cgo_addr
							*_cgo_addr++
							return
						}()))) = c
					} else {
						c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret uint32) {
							_cgo_addr := &i
							*_cgo_addr++
							return *_cgo_addr
						}())))
						if int32(c) == 'u' {
							var v uint32 = jsonHexToInt4((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(i))))) + uintptr(1))))
							i += uint32(4)
							if v == uint32(0) {
								break
							}
							if v <= uint32(127) {
								*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
									_cgo_addr := &j
									_cgo_ret = *_cgo_addr
									*_cgo_addr++
									return
								}()))) = int8(v)
							} else if v <= uint32(2047) {
								*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
									_cgo_addr := &j
									_cgo_ret = *_cgo_addr
									*_cgo_addr++
									return
								}()))) = int8(uint32(192) | v>>6)
								*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
									_cgo_addr := &j
									_cgo_ret = *_cgo_addr
									*_cgo_addr++
									return
								}()))) = int8(uint32(128) | v&uint32(63))
							} else {
								var vlo uint32
								if v&uint32(64512) == uint32(55296) && i < n-uint32(6) && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+uint32(1))))) == '\\' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+uint32(2))))) == 'u' && func() (_cgo_ret uint32) {
									_cgo_addr := &vlo
									*_cgo_addr = jsonHexToInt4((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(i))))) + uintptr(3))))
									return *_cgo_addr
								}()&uint32(64512) == uint32(56320) {
									v = v&uint32(1023)<<10 + vlo&uint32(1023) + uint32(65536)
									i += uint32(6)
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(240) | v>>18)
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(128) | v>>12&uint32(63))
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(128) | v>>6&uint32(63))
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(128) | v&uint32(63))
								} else {
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(224) | v>>12)
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(128) | v>>6&uint32(63))
									*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
										_cgo_addr := &j
										_cgo_ret = *_cgo_addr
										*_cgo_addr++
										return
									}()))) = int8(uint32(128) | v&uint32(63))
								}
							}
						} else {
							if int32(c) == 'b' {
								c = int8('\b')
							} else if int32(c) == 'f' {
								c = int8('\f')
							} else if int32(c) == 'n' {
								c = int8('\n')
							} else if int32(c) == 'r' {
								c = int8('\r')
							} else if int32(c) == 't' {
								c = int8('\t')
							}
							*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(func() (_cgo_ret uint32) {
								_cgo_addr := &j
								_cgo_ret = *_cgo_addr
								*_cgo_addr++
								return
							}()))) = c
						}
					}
				}
				*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zOut)) + uintptr(j))) = int8(0)
				sqlite3_result_text(pCtx, zOut, int32(j), sqlite3_free)
			}
			break
		}
	case 6:
		fallthrough
	case 7:
		{
			jsonReturnJson(pNode, pCtx, aReplace)
			break
		}
	}
}
func jsonParseAddNodeExpand(pParse *struct_JsonParse, eType uint32, n uint32, zContent *int8) int32 {
	var nNew uint32
	var pNew *struct_JsonNode
	func() int {
		_ = 0
		return 0
	}()
	if pParse.oom != 0 {
		return int32(-1)
	}
	nNew = pParse.nAlloc*uint32(2) + uint32(10)
	pNew = (*struct_JsonNode)(sqlite3_realloc64(unsafe.Pointer(pParse.aNode), uint64(16*uint(nNew))))
	if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
		pParse.oom = uint8(1)
		return int32(-1)
	}
	pParse.nAlloc = nNew
	pParse.aNode = pNew
	func() int {
		_ = 0
		return 0
	}()
	return jsonParseAddNode(pParse, eType, n, zContent)
}
func jsonParseAddNode(pParse *struct_JsonParse, eType uint32, n uint32, zContent *int8) int32 {
	var p *struct_JsonNode
	if uintptr(unsafe.Pointer(pParse.aNode)) == uintptr(unsafe.Pointer(nil)) || pParse.nNode >= pParse.nAlloc {
		return jsonParseAddNodeExpand(pParse, eType, n, zContent)
	}
	p = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(pParse.nNode)*16))
	p.eType = uint8(eType)
	p.jnFlags = uint8(0)
	p.n = n
	p.u.zJContent = zContent
	return int32(func() (_cgo_ret uint32) {
		_cgo_addr := &pParse.nNode
		_cgo_ret = *_cgo_addr
		*_cgo_addr++
		return
	}())
}
func jsonIs4Hex(z *int8) int32 {
	var i int32
	for i = int32(0); i < 4; i++ {
		if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))))&8 != 0) {
			return int32(0)
		}
	}
	return int32(1)
}
func jsonParseValue(pParse *struct_JsonParse, i uint32) int32 {
	var c int8
	var j uint32
	var iThis int32
	var x int32
	var pNode *struct_JsonNode
	var z *int8 = pParse.zJson
	for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))))) != 0 {
		i++
	}
	if int32(func() (_cgo_ret int8) {
		_cgo_addr := &c
		*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))
		return *_cgo_addr
	}()) == '{' {
		iThis = jsonParseAddNode(pParse, uint32(7), uint32(0), nil)
		if iThis < 0 {
			return int32(-1)
		}
		for j = i + uint32(1); ; j++ {
			for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j))))))) != 0 {
				j++
			}
			if int32(func() (_cgo_ret uint16) {
				_cgo_addr := &pParse.iDepth
				*_cgo_addr++
				return *_cgo_addr
			}()) > 2000 {
				return int32(-1)
			}
			x = jsonParseValue(pParse, j)
			if x < 0 {
				pParse.iDepth--
				if x == -2 && pParse.nNode == uint32(iThis)+uint32(1) {
					return int32(j + uint32(1))
				}
				return int32(-1)
			}
			if pParse.oom != 0 {
				return int32(-1)
			}
			pNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(pParse.nNode-uint32(1))*16))
			if int32(pNode.eType) != 5 {
				return int32(-1)
			}
			pNode.jnFlags |= uint8(64)
			j = uint32(x)
			for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j))))))) != 0 {
				j++
			}
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))) != ':' {
				return int32(-1)
			}
			j++
			x = jsonParseValue(pParse, j)
			pParse.iDepth--
			if x < 0 {
				return int32(-1)
			}
			j = uint32(x)
			for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j))))))) != 0 {
				j++
			}
			c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))
			if int32(c) == ',' {
				continue
			}
			if int32(c) != '}' {
				return int32(-1)
			}
			break
		}
		(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iThis)*16))).n = pParse.nNode - uint32(iThis) - uint32(1)
		return int32(j + uint32(1))
	} else if int32(c) == '[' {
		iThis = jsonParseAddNode(pParse, uint32(6), uint32(0), nil)
		if iThis < 0 {
			return int32(-1)
		}
		__builtin___memset_chk(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iThis)*16))).u), 0, 8, __builtin_object_size(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iThis)*16))).u), 0))
		for j = i + uint32(1); ; j++ {
			for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j))))))) != 0 {
				j++
			}
			if int32(func() (_cgo_ret uint16) {
				_cgo_addr := &pParse.iDepth
				*_cgo_addr++
				return *_cgo_addr
			}()) > 2000 {
				return int32(-1)
			}
			x = jsonParseValue(pParse, j)
			pParse.iDepth--
			if x < 0 {
				if x == -3 && pParse.nNode == uint32(iThis)+uint32(1) {
					return int32(j + uint32(1))
				}
				return int32(-1)
			}
			j = uint32(x)
			for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j))))))) != 0 {
				j++
			}
			c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))
			if int32(c) == ',' {
				continue
			}
			if int32(c) != ']' {
				return int32(-1)
			}
			break
		}
		(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iThis)*16))).n = pParse.nNode - uint32(iThis) - uint32(1)
		return int32(j + uint32(1))
	} else if int32(c) == '"' {
		var jnFlags uint8 = uint8(0)
		j = i + uint32(1)
		for {
			c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))
			if int32(c) & ^31 == 0 {
				return int32(-1)
			}
			if int32(c) == '\\' {
				c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(func() (_cgo_ret uint32) {
					_cgo_addr := &j
					*_cgo_addr++
					return *_cgo_addr
				}())))
				if int32(c) == '"' || int32(c) == '\\' || int32(c) == '/' || int32(c) == 'b' || int32(c) == 'f' || int32(c) == 'n' || int32(c) == 'r' || int32(c) == 't' || int32(c) == 'u' && jsonIs4Hex((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(j)))))+uintptr(1)))) != 0 {
					jnFlags = uint8(2)
				} else {
					return int32(-1)
				}
			} else if int32(c) == '"' {
				break
			}
			j++
		}
		jsonParseAddNode(pParse, uint32(5), j+uint32(1)-i, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
		if !(pParse.oom != 0) {
			(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(pParse.nNode-uint32(1))*16))).jnFlags = jnFlags
		}
		return int32(j + uint32(1))
	} else if int32(c) == 'n' && strncmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(i))), (*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'})), uint(4)) == 0 && !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+uint32(4)))))))))&6 != 0) {
		jsonParseAddNode(pParse, uint32(0), uint32(0), nil)
		return int32(i + uint32(4))
	} else if int32(c) == 't' && strncmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(i))), (*int8)(unsafe.Pointer(&[5]int8{'t', 'r', 'u', 'e', '\x00'})), uint(4)) == 0 && !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+uint32(4)))))))))&6 != 0) {
		jsonParseAddNode(pParse, uint32(1), uint32(0), nil)
		return int32(i + uint32(4))
	} else if int32(c) == 'f' && strncmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z))+uintptr(i))), (*int8)(unsafe.Pointer(&[6]int8{'f', 'a', 'l', 's', 'e', '\x00'})), uint(5)) == 0 && !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+uint32(5)))))))))&6 != 0) {
		jsonParseAddNode(pParse, uint32(2), uint32(0), nil)
		return int32(i + uint32(5))
	} else if int32(c) == '-' || int32(c) >= '0' && int32(c) <= '9' {
		var seenDP uint8 = uint8(0)
		var seenE uint8 = uint8(0)
		func() int {
			_ = 0
			return 0
		}()
		if int32(c) <= '0' {
			j = func() uint32 {
				if int32(c) == '-' {
					return i + uint32(1)
				} else {
					return i
				}
			}()
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))) == '0' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j+uint32(1))))) >= '0' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j+uint32(1))))) <= '9' {
				return int32(-1)
			}
		}
		j = i + uint32(1)
		for ; ; j++ {
			c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j)))
			if int32(c) >= '0' && int32(c) <= '9' {
				continue
			}
			if int32(c) == '.' {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j-uint32(1))))) == '-' {
					return int32(-1)
				}
				if seenDP != 0 {
					return int32(-1)
				}
				seenDP = uint8(1)
				continue
			}
			if int32(c) == 'e' || int32(c) == 'E' {
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j-uint32(1))))) < '0' {
					return int32(-1)
				}
				if seenE != 0 {
					return int32(-1)
				}
				seenDP = func() (_cgo_ret uint8) {
					_cgo_addr := &seenE
					*_cgo_addr = uint8(1)
					return *_cgo_addr
				}()
				c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j+uint32(1))))
				if int32(c) == '+' || int32(c) == '-' {
					j++
					c = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j+uint32(1))))
				}
				if int32(c) < '0' || int32(c) > '9' {
					return int32(-1)
				}
				continue
			}
			break
		}
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(j-uint32(1))))) < '0' {
			return int32(-1)
		}
		jsonParseAddNode(pParse, uint32(func() int32 {
			if int32(seenDP) != 0 {
				return 4
			} else {
				return 3
			}
		}()), j-i, &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i))))
		return int32(j)
	} else if int32(c) == '}' {
		return int32(-2)
	} else if int32(c) == ']' {
		return int32(-3)
	} else if int32(c) == 0 {
		return int32(0)
	} else {
		return int32(-1)
	}
}
func jsonParse(pParse *struct_JsonParse, pCtx *struct_sqlite3_context, zJson *int8) int32 {
	var i int32
	__builtin___memset_chk(unsafe.Pointer(pParse), 0, 44, __builtin_object_size(unsafe.Pointer(pParse), 0))
	if uintptr(unsafe.Pointer(zJson)) == uintptr(unsafe.Pointer(nil)) {
		return int32(1)
	}
	pParse.zJson = zJson
	i = jsonParseValue(pParse, uint32(0))
	if pParse.oom != 0 {
		i = int32(-1)
	}
	if i > 0 {
		func() int {
			_ = 0
			return 0
		}()
		for *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer((*int8)(unsafe.Pointer(&jsonIsSpace)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zJson)) + uintptr(i))))))) != 0 {
			i++
		}
		if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zJson)) + uintptr(i))) != 0 {
			i = int32(-1)
		}
	}
	if i <= 0 {
		if uintptr(unsafe.Pointer(pCtx)) != uintptr(unsafe.Pointer(nil)) {
			if pParse.oom != 0 {
				sqlite3_result_error_nomem(pCtx)
			} else {
				sqlite3_result_error(pCtx, (*int8)(unsafe.Pointer(&[15]int8{'m', 'a', 'l', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'J', 'S', 'O', 'N', '\x00'})), -1)
			}
		}
		jsonParseReset(pParse)
		return int32(1)
	}
	return int32(0)
}
func jsonParseFillInParentage(pParse *struct_JsonParse, i uint32, iParent uint32) {
	var pNode *struct_JsonNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(i)*16))
	var j uint32
	*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aUp)) + uintptr(i)*4)) = iParent
	switch int32(pNode.eType) {
	case 6:
		{
			for j = uint32(1); j <= pNode.n; j += jsonNodeSize((*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(j)*16))) {
				jsonParseFillInParentage(pParse, i+j, i)
			}
			break
		}
	case 7:
		{
			for j = uint32(1); j <= pNode.n; j += jsonNodeSize((*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer((*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode))+uintptr(j)*16))))+uintptr(1)*16))) + uint32(1) {
				*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aUp)) + uintptr(i+j)*4)) = i
				jsonParseFillInParentage(pParse, i+j+uint32(1), i)
			}
			break
		}
	default:
		{
			break
		}
	}
}
func jsonParseFindParents(pParse *struct_JsonParse) int32 {
	var aUp *uint32
	func() int {
		_ = 0
		return 0
	}()
	aUp = func() (_cgo_ret *uint32) {
		_cgo_addr := &pParse.aUp
		*_cgo_addr = (*uint32)(sqlite3_malloc64(uint64(4 * uint(pParse.nNode))))
		return *_cgo_addr
	}()
	if uintptr(unsafe.Pointer(aUp)) == uintptr(unsafe.Pointer(nil)) {
		pParse.oom = uint8(1)
		return int32(7)
	}
	jsonParseFillInParentage(pParse, uint32(0), uint32(0))
	return int32(0)
}
func jsonParseCached(pCtx *struct_sqlite3_context, argv **struct_sqlite3_value, pErrCtx *struct_sqlite3_context) *struct_JsonParse {
	var zJson *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	var nJson int32 = sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	var p *struct_JsonParse
	var pMatch *struct_JsonParse = nil
	var iKey int32
	var iMinKey int32 = 0
	var iMinHold uint32 = 4294967295
	var iMaxHold uint32 = uint32(0)
	if uintptr(unsafe.Pointer(zJson)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_JsonParse)(nil)
	}
	for iKey = int32(0); iKey < 4; iKey++ {
		p = (*struct_JsonParse)(sqlite3_get_auxdata(pCtx, -429938+iKey))
		if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
			iMinKey = iKey
			break
		}
		if uintptr(unsafe.Pointer(pMatch)) == uintptr(unsafe.Pointer(nil)) && p.nJson == nJson && memcmp(unsafe.Pointer(p.zJson), unsafe.Pointer(zJson), uint(nJson)) == 0 {
			p.nErr = uint8(0)
			pMatch = p
		} else if p.iHold < iMinHold {
			iMinHold = p.iHold
			iMinKey = iKey
		}
		if p.iHold > iMaxHold {
			iMaxHold = p.iHold
		}
	}
	if pMatch != nil {
		pMatch.nErr = uint8(0)
		pMatch.iHold = iMaxHold + uint32(1)
		return pMatch
	}
	p = (*struct_JsonParse)(sqlite3_malloc64(uint64(44 + uint(nJson) + uint(1))))
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		sqlite3_result_error_nomem(pCtx)
		return (*struct_JsonParse)(nil)
	}
	__builtin___memset_chk(unsafe.Pointer(p), 0, 44, __builtin_object_size(unsafe.Pointer(p), 0))
	p.zJson = (*int8)(unsafe.Pointer(&*(*struct_JsonParse)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + uintptr(1)*44))))
	__builtin___memcpy_chk(unsafe.Pointer((*int8)(unsafe.Pointer(p.zJson))), unsafe.Pointer(zJson), uint(nJson+1), __builtin_object_size(unsafe.Pointer((*int8)(unsafe.Pointer(p.zJson))), 0))
	if jsonParse(p, pErrCtx, p.zJson) != 0 {
		sqlite3_free(unsafe.Pointer(p))
		return (*struct_JsonParse)(nil)
	}
	p.nJson = nJson
	p.iHold = iMaxHold + uint32(1)
	sqlite3_set_auxdata(pCtx, -429938+iMinKey, unsafe.Pointer(p), (func(unsafe.Pointer))(jsonParseFree))
	return (*struct_JsonParse)(sqlite3_get_auxdata(pCtx, -429938+iMinKey))
}
func jsonLabelCompare(pNode *struct_JsonNode, zKey *int8, nKey uint32) int32 {
	func() int {
		_ = 0
		return 0
	}()
	if int32(pNode.jnFlags)&1 != 0 {
		if pNode.n != nKey {
			return int32(0)
		}
		return func() int32 {
			if strncmp(pNode.u.zJContent, zKey, uint(nKey)) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	} else {
		if pNode.n != nKey+uint32(2) {
			return int32(0)
		}
		return func() int32 {
			if strncmp((*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode.u.zJContent))+uintptr(1))), zKey, uint(nKey)) == 0 {
				return 1
			} else {
				return 0
			}
		}()
	}
}
func jsonLookupStep(pParse *struct_JsonParse, iRoot uint32, zPath *int8, pApnd *int32, pzErr **int8) *struct_JsonNode {
	var i uint32
	var j uint32
	var nKey uint32
	var zKey *int8
	var pRoot *struct_JsonNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) == 0 {
		return pRoot
	}
	if int32(pRoot.jnFlags)&8 != 0 {
		return (*struct_JsonNode)(nil)
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) == '.' {
		if int32(pRoot.eType) != 7 {
			return (*struct_JsonNode)(nil)
		}
		*(*uintptr)(unsafe.Pointer(&zPath))++
		if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) == '"' {
			zKey = (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(1)))
			for i = uint32(1); int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i)))) != '"'; i++ {
			}
			nKey = i - uint32(1)
			if *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i))) != 0 {
				i++
			} else {
				*pzErr = zPath
				return (*struct_JsonNode)(nil)
			}
		} else {
			zKey = zPath
			for i = uint32(0); int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i)))) != 0 && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i)))) != '.' && int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i)))) != '['; i++ {
			}
			nKey = i
		}
		if nKey == uint32(0) {
			*pzErr = zPath
			return (*struct_JsonNode)(nil)
		}
		j = uint32(1)
		for {
			for j <= pRoot.n {
				if jsonLabelCompare((*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot))+uintptr(j)*16)), zKey, nKey) != 0 {
					return jsonLookupStep(pParse, iRoot+j+uint32(1), &*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(i))), pApnd, pzErr)
				}
				j++
				j += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot)) + uintptr(j)*16)))
			}
			if int32(pRoot.jnFlags)&32 == 0 {
				break
			}
			func() int {
				_ = 0
				return 0
			}()
			iRoot += *(*uint32)(unsafe.Pointer(&pRoot.u))
			pRoot = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))
			j = uint32(1)
		}
		if pApnd != nil {
			var iStart uint32
			var iLabel uint32
			var pNode *struct_JsonNode
			iStart = uint32(jsonParseAddNode(pParse, uint32(7), uint32(2), nil))
			iLabel = uint32(jsonParseAddNode(pParse, uint32(5), nKey, zKey))
			*(*uintptr)(unsafe.Pointer(&zPath)) += uintptr(i)
			pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr)
			if pParse.oom != 0 {
				return (*struct_JsonNode)(nil)
			}
			if pNode != nil {
				pRoot = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))
				func() int {
					_ = 0
					return 0
				}()
				*(*uint32)(unsafe.Pointer(&pRoot.u)) = iStart - iRoot
				pRoot.jnFlags |= uint8(32)
				(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iLabel)*16))).jnFlags |= uint8(1)
			}
			return pNode
		}
	} else if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) == '[' {
		i = uint32(0)
		j = uint32(1)
		for int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(j))))))))&4 != 0 {
			i = i*uint32(10) + uint32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(j)))) - uint32('0')
			j++
		}
		if j < uint32(2) || int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(j)))) != ']' {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(1)))) == '#' {
				var pBase *struct_JsonNode = pRoot
				var iBase int32 = int32(iRoot)
				if int32(pRoot.eType) != 6 {
					return (*struct_JsonNode)(nil)
				}
				for {
					for j <= pBase.n {
						if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pBase)) + uintptr(j)*16))).jnFlags)&4 == 0 {
							i++
						}
						j += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pBase)) + uintptr(j)*16)))
					}
					if int32(pBase.jnFlags)&32 == 0 {
						break
					}
					func() int {
						_ = 0
						return 0
					}()
					iBase += int32(*(*uint32)(unsafe.Pointer(&pBase.u)))
					pBase = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iBase)*16))
					j = uint32(1)
				}
				j = uint32(2)
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(2)))) == '-' && int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(3))))))))&4 != 0 {
					var x uint32 = uint32(0)
					j = uint32(3)
					for {
						x = x*uint32(10) + uint32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(j)))) - uint32('0')
						j++
						if !(int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(j))))))))&4 != 0) {
							break
						}
					}
					if x > i {
						return (*struct_JsonNode)(nil)
					}
					i -= x
				}
				if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(j)))) != ']' {
					*pzErr = zPath
					return (*struct_JsonNode)(nil)
				}
			} else {
				*pzErr = zPath
				return (*struct_JsonNode)(nil)
			}
		}
		if int32(pRoot.eType) != 6 {
			return (*struct_JsonNode)(nil)
		}
		*(*uintptr)(unsafe.Pointer(&zPath)) += uintptr(j + uint32(1))
		j = uint32(1)
		for {
			for j <= pRoot.n && (i > uint32(0) || int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot)) + uintptr(j)*16))).jnFlags)&4 != 0) {
				if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot)) + uintptr(j)*16))).jnFlags)&4 == 0 {
					i--
				}
				j += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pRoot)) + uintptr(j)*16)))
			}
			if int32(pRoot.jnFlags)&32 == 0 {
				break
			}
			func() int {
				_ = 0
				return 0
			}()
			iRoot += *(*uint32)(unsafe.Pointer(&pRoot.u))
			pRoot = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))
			j = uint32(1)
		}
		if j <= pRoot.n {
			return jsonLookupStep(pParse, iRoot+j, zPath, pApnd, pzErr)
		}
		if i == uint32(0) && pApnd != nil {
			var iStart uint32
			var pNode *struct_JsonNode
			iStart = uint32(jsonParseAddNode(pParse, uint32(6), uint32(1), nil))
			pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr)
			if pParse.oom != 0 {
				return (*struct_JsonNode)(nil)
			}
			if pNode != nil {
				pRoot = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))
				func() int {
					_ = 0
					return 0
				}()
				*(*uint32)(unsafe.Pointer(&pRoot.u)) = iStart - iRoot
				pRoot.jnFlags |= uint8(32)
			}
			return pNode
		}
	} else {
		*pzErr = zPath
	}
	return (*struct_JsonNode)(nil)
}
func jsonLookupAppend(pParse *struct_JsonParse, zPath *int8, pApnd *int32, pzErr **int8) *struct_JsonNode {
	*pApnd = int32(1)
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) == 0 {
		jsonParseAddNode(pParse, uint32(0), uint32(0), nil)
		return func() *struct_JsonNode {
			if int32(pParse.oom) != 0 {
				return nil
			} else {
				return &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(pParse.nNode-uint32(1))*16))
			}
		}()
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) == '.' {
		jsonParseAddNode(pParse, uint32(7), uint32(0), nil)
	} else if strncmp(zPath, (*int8)(unsafe.Pointer(&[4]int8{'[', '0', ']', '\x00'})), uint(3)) == 0 {
		jsonParseAddNode(pParse, uint32(6), uint32(0), nil)
	} else {
		return (*struct_JsonNode)(nil)
	}
	if pParse.oom != 0 {
		return (*struct_JsonNode)(nil)
	}
	return jsonLookupStep(pParse, pParse.nNode-uint32(1), zPath, pApnd, pzErr)
}
func jsonPathSyntaxError(zErr *int8) *int8 {
	return sqlite3_mprintf((*int8)(unsafe.Pointer(&[26]int8{'J', 'S', 'O', 'N', ' ', 'p', 'a', 't', 'h', ' ', 'e', 'r', 'r', 'o', 'r', ' ', 'n', 'e', 'a', 'r', ' ', '\'', '%', 'q', '\'', '\x00'})), zErr)
}
func jsonLookup(pParse *struct_JsonParse, zPath *int8, pApnd *int32, pCtx *struct_sqlite3_context) *struct_JsonNode {
	var zErr *int8 = nil
	var pNode *struct_JsonNode = nil
	var zMsg *int8
	if uintptr(unsafe.Pointer(zPath)) == uintptr(unsafe.Pointer(nil)) {
		return (*struct_JsonNode)(nil)
	}
	if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) != '$' {
		zErr = zPath
		goto lookup_err
	}
	*(*uintptr)(unsafe.Pointer(&zPath))++
	pNode = jsonLookupStep(pParse, uint32(0), zPath, pApnd, &zErr)
	if uintptr(unsafe.Pointer(zErr)) == uintptr(unsafe.Pointer(nil)) {
		return pNode
	}
lookup_err:
	pParse.nErr++
	func() int {
		_ = 0
		return 0
	}()
	zMsg = jsonPathSyntaxError(zErr)
	if zMsg != nil {
		sqlite3_result_error(pCtx, zMsg, -1)
		sqlite3_free(unsafe.Pointer(zMsg))
	} else {
		sqlite3_result_error_nomem(pCtx)
	}
	return (*struct_JsonNode)(nil)
}
func jsonWrongNumArgs(pCtx *struct_sqlite3_context, zFuncName *int8) {
	var zMsg *int8 = sqlite3_mprintf((*int8)(unsafe.Pointer(&[43]int8{'j', 's', 'o', 'n', '_', '%', 's', '(', ')', ' ', 'n', 'e', 'e', 'd', 's', ' ', 'a', 'n', ' ', 'o', 'd', 'd', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', '\x00'})), zFuncName)
	sqlite3_result_error(pCtx, zMsg, -1)
	sqlite3_free(unsafe.Pointer(zMsg))
}
func jsonRemoveAllNulls(pNode *struct_JsonNode) {
	var i int32
	var n int32
	func() int {
		_ = 0
		return 0
	}()
	n = int32(pNode.n)
	for i = int32(2); i <= n; i += int32(jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(i)*16))) + uint32(1)) {
		switch int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(i)*16))).eType) {
		case 0:
			(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(i)*16))).jnFlags |= uint8(4)
			break
		case 7:
			jsonRemoveAllNulls(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(i)*16)))
			break
		}
	}
}
func jsonQuoteFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var jx struct_JsonString
	func() int {
		_ = argc
		return 0
	}()
	jsonInit(&jx, ctx)
	jsonAppendValue(&jx, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	jsonResult(&jx)
	sqlite3_result_subtype(ctx, uint32(74))
}
func jsonArrayFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var i int32
	var jx struct_JsonString
	jsonInit(&jx, ctx)
	jsonAppendChar(&jx, int8('['))
	for i = int32(0); i < argc; i++ {
		jsonAppendSeparator(&jx)
		jsonAppendValue(&jx, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))
	}
	jsonAppendChar(&jx, int8(']'))
	jsonResult(&jx)
	sqlite3_result_subtype(ctx, uint32(74))
}
func jsonArrayLengthFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_JsonParse
	var n int64 = int64(0)
	var i uint32
	var pNode *struct_JsonNode
	p = jsonParseCached(ctx, argv, ctx)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	if argc == 2 {
		var zPath *int8 = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
		pNode = jsonLookup(p, zPath, nil, ctx)
	} else {
		pNode = p.aNode
	}
	if uintptr(unsafe.Pointer(pNode)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if int32(pNode.eType) == 6 {
		func() int {
			_ = 0
			return 0
		}()
		for i = uint32(1); i <= pNode.n; n++ {
			i += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode)) + uintptr(i)*16)))
		}
	}
	sqlite3_result_int64(ctx, n)
}
func jsonExtractFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_JsonParse
	var pNode *struct_JsonNode
	var zPath *int8
	var flags int32 = int32(int(sqlite3_user_data(ctx)))
	var jx struct_JsonString
	if argc < 2 {
		return
	}
	p = jsonParseCached(ctx, argv, ctx)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if argc == 2 {
		zPath = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
		if uintptr(unsafe.Pointer(zPath)) == uintptr(unsafe.Pointer(nil)) {
			return
		}
		if flags&3 != 0 {
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) != '$' {
				jsonInit(&jx, ctx)
				if int32(*(*uint8)(unsafe.Pointer(uintptr(unsafe.Pointer((*uint8)(unsafe.Pointer(&sqlite3CtypeMap)))) + uintptr(uint8(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0))))))))&4 != 0 {
					jsonAppendRaw(&jx, (*int8)(unsafe.Pointer(&[3]int8{'$', '[', '\x00'})), uint32(2))
					jsonAppendRaw(&jx, zPath, uint32(int32(strlen(zPath))))
					jsonAppendRaw(&jx, (*int8)(unsafe.Pointer(&[2]int8{']', '\x00'})), uint32(2))
				} else {
					jsonAppendRaw(&jx, (*int8)(unsafe.Pointer(&[3]int8{'$', '.', '\x00'})), uint32(1+func() int32 {
						if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zPath)) + uintptr(0)))) != '[' {
							return 1
						} else {
							return 0
						}
					}()))
					jsonAppendRaw(&jx, zPath, uint32(int32(strlen(zPath))))
					jsonAppendChar(&jx, int8(0))
				}
				pNode = func() *struct_JsonNode {
					if int32(jx.bErr) != 0 {
						return nil
					} else {
						return jsonLookup(p, jx.zBuf, nil, ctx)
					}
				}()
				jsonReset(&jx)
			} else {
				pNode = jsonLookup(p, zPath, nil, ctx)
			}
			if pNode != nil {
				if flags&1 != 0 {
					jsonReturnJson(pNode, ctx, nil)
				} else {
					jsonReturn(pNode, ctx, nil)
					sqlite3_result_subtype(ctx, uint32(0))
				}
			}
		} else {
			pNode = jsonLookup(p, zPath, nil, ctx)
			if int32(p.nErr) == 0 && pNode != nil {
				jsonReturn(pNode, ctx, nil)
			}
		}
	} else {
		var i int32
		jsonInit(&jx, ctx)
		jsonAppendChar(&jx, int8('['))
		for i = int32(1); i < argc; i++ {
			zPath = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))))
			pNode = jsonLookup(p, zPath, nil, ctx)
			if p.nErr != 0 {
				break
			}
			jsonAppendSeparator(&jx)
			if pNode != nil {
				jsonRenderNode(pNode, &jx, nil)
			} else {
				jsonAppendRaw(&jx, (*int8)(unsafe.Pointer(&[5]int8{'n', 'u', 'l', 'l', '\x00'})), uint32(4))
			}
		}
		if i == argc {
			jsonAppendChar(&jx, int8(']'))
			jsonResult(&jx)
			sqlite3_result_subtype(ctx, uint32(74))
		}
		jsonReset(&jx)
	}
}
func jsonMergePatch(pParse *struct_JsonParse, iTarget uint32, pPatch *struct_JsonNode) *struct_JsonNode {
	var i uint32
	var j uint32
	var iRoot uint32
	var pTarget *struct_JsonNode
	if int32(pPatch.eType) != 7 {
		return pPatch
	}
	func() int {
		_ = 0
		return 0
	}()
	pTarget = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iTarget)*16))
	func() int {
		_ = 0
		return 0
	}()
	if int32(pTarget.eType) != 7 {
		jsonRemoveAllNulls(pPatch)
		return pPatch
	}
	iRoot = iTarget
	for i = uint32(1); i < pPatch.n; i += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i+uint32(1))*16))) + uint32(1) {
		var nKey uint32
		var zKey *int8
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		nKey = (*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i)*16))).n
		zKey = (*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i)*16))).u.zJContent
		func() int {
			_ = 0
			return 0
		}()
		for j = uint32(1); j < pTarget.n; j += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j+uint32(1))*16))) + uint32(1) {
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			func() int {
				_ = 0
				return 0
			}()
			if (*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j)*16))).n == nKey && strncmp((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j)*16))).u.zJContent, zKey, uint(nKey)) == 0 {
				if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j+uint32(1))*16))).jnFlags)&(4|16) != 0 {
					break
				}
				if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i+uint32(1))*16))).eType) == 0 {
					(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j+uint32(1))*16))).jnFlags |= uint8(4)
				} else {
					var pNew *struct_JsonNode = jsonMergePatch(pParse, iTarget+j+uint32(1), &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i+uint32(1))*16)))
					if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
						return (*struct_JsonNode)(nil)
					}
					pTarget = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iTarget)*16))
					if uintptr(unsafe.Pointer(pNew)) != uintptr(unsafe.Pointer(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j+uint32(1))*16)))) {
						func() int {
							_ = 0
							return 0
						}()
						*(**struct_JsonNode)(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j+uint32(1))*16))).u)) = pNew
						(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pTarget)) + uintptr(j+uint32(1))*16))).jnFlags |= uint8(16)
					}
				}
				break
			}
		}
		if j >= pTarget.n && int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i+uint32(1))*16))).eType) != 0 {
			var iStart int32
			var iPatch int32
			iStart = jsonParseAddNode(pParse, uint32(7), uint32(2), nil)
			jsonParseAddNode(pParse, uint32(5), nKey, zKey)
			iPatch = jsonParseAddNode(pParse, uint32(1), uint32(0), nil)
			if pParse.oom != 0 {
				return (*struct_JsonNode)(nil)
			}
			jsonRemoveAllNulls(pPatch)
			pTarget = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iTarget)*16))
			func() int {
				_ = 0
				return 0
			}()
			(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))).jnFlags |= uint8(32)
			*(*uint32)(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iRoot)*16))).u)) = uint32(iStart) - iRoot
			iRoot = uint32(iStart)
			func() int {
				_ = 0
				return 0
			}()
			(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iPatch)*16))).jnFlags |= uint8(16)
			*(**struct_JsonNode)(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pParse.aNode)) + uintptr(iPatch)*16))).u)) = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(pPatch)) + uintptr(i+uint32(1))*16))
		}
	}
	return pTarget
}
func jsonPatchFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_JsonParse
	var y struct_JsonParse
	var pResult *struct_JsonNode
	func() int {
		_ = argc
		return 0
	}()
	if jsonParse(&x, ctx, (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))) != 0 {
		return
	}
	if jsonParse(&y, ctx, (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))) != 0 {
		jsonParseReset(&x)
		return
	}
	pResult = jsonMergePatch(&x, uint32(0), y.aNode)
	func() int {
		_ = 0
		return 0
	}()
	if pResult != nil {
		jsonReturnJson(pResult, ctx, nil)
	} else {
		sqlite3_result_error_nomem(ctx)
	}
	jsonParseReset(&x)
	jsonParseReset(&y)
}
func jsonObjectFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var i int32
	var jx struct_JsonString
	var z *int8
	var n uint32
	if argc&1 != 0 {
		sqlite3_result_error(ctx, (*int8)(unsafe.Pointer(&[51]int8{'j', 's', 'o', 'n', '_', 'o', 'b', 'j', 'e', 'c', 't', '(', ')', ' ', 'r', 'e', 'q', 'u', 'i', 'r', 'e', 's', ' ', 'a', 'n', ' ', 'e', 'v', 'e', 'n', ' ', 'n', 'u', 'm', 'b', 'e', 'r', ' ', 'o', 'f', ' ', 'a', 'r', 'g', 'u', 'm', 'e', 'n', 't', 's', '\x00'})), -1)
		return
	}
	jsonInit(&jx, ctx)
	jsonAppendChar(&jx, int8('{'))
	for i = int32(0); i < argc; i += int32(2) {
		if sqlite3_value_type(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8))) != 3 {
			sqlite3_result_error(ctx, (*int8)(unsafe.Pointer(&[34]int8{'j', 's', 'o', 'n', '_', 'o', 'b', 'j', 'e', 'c', 't', '(', ')', ' ', 'l', 'a', 'b', 'e', 'l', 's', ' ', 'm', 'u', 's', 't', ' ', 'b', 'e', ' ', 'T', 'E', 'X', 'T', '\x00'})), -1)
			jsonReset(&jx)
			return
		}
		jsonAppendSeparator(&jx)
		z = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))))
		n = uint32(sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8))))
		jsonAppendString(&jx, z, n)
		jsonAppendChar(&jx, int8(':'))
		jsonAppendValue(&jx, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i+1)*8)))
	}
	jsonAppendChar(&jx, int8('}'))
	jsonResult(&jx)
	sqlite3_result_subtype(ctx, uint32(74))
}
func jsonRemoveFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_JsonParse
	var pNode *struct_JsonNode
	var zPath *int8
	var i uint32
	if argc < 1 {
		return
	}
	if jsonParse(&x, ctx, (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))) != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	for i = uint32(1); i < uint32(argc); i++ {
		zPath = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))))
		if uintptr(unsafe.Pointer(zPath)) == uintptr(unsafe.Pointer(nil)) {
			goto remove_done
		}
		pNode = jsonLookup(&x, zPath, nil, ctx)
		if x.nErr != 0 {
			goto remove_done
		}
		if pNode != nil {
			pNode.jnFlags |= uint8(4)
		}
	}
	if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(x.aNode)) + uintptr(0)*16))).jnFlags)&4 == 0 {
		jsonReturnJson(x.aNode, ctx, nil)
	}
remove_done:
	jsonParseReset(&x)
}
func jsonReplaceFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_JsonParse
	var pNode *struct_JsonNode
	var zPath *int8
	var i uint32
	if argc < 1 {
		return
	}
	if argc&1 == 0 {
		jsonWrongNumArgs(ctx, (*int8)(unsafe.Pointer(&[8]int8{'r', 'e', 'p', 'l', 'a', 'c', 'e', '\x00'})))
		return
	}
	if jsonParse(&x, ctx, (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))) != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	for i = uint32(1); i < uint32(argc); i += uint32(2) {
		zPath = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))))
		pNode = jsonLookup(&x, zPath, nil, ctx)
		if x.nErr != 0 {
			goto replace_err
		}
		if pNode != nil {
			func() int {
				_ = 0
				return 0
			}()
			pNode.jnFlags |= uint8(int32(uint8(8)))
			*(*uint32)(unsafe.Pointer(&pNode.u)) = i + uint32(1)
		}
	}
	if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(x.aNode)) + uintptr(0)*16))).jnFlags)&8 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_result_value(ctx, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(*(*uint32)(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(x.aNode)) + uintptr(0)*16))).u)))*8)))
	} else {
		jsonReturnJson(x.aNode, ctx, argv)
	}
replace_err:
	jsonParseReset(&x)
}
func jsonSetFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var x struct_JsonParse
	var pNode *struct_JsonNode
	var zPath *int8
	var i uint32
	var bApnd int32
	var bIsSet int32 = func() int32 {
		if uintptr(unsafe.Pointer(sqlite3_user_data(ctx))) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}()
	if argc < 1 {
		return
	}
	if argc&1 == 0 {
		jsonWrongNumArgs(ctx, func() *int8 {
			if bIsSet != 0 {
				return (*int8)(unsafe.Pointer(&[4]int8{'s', 'e', 't', '\x00'}))
			} else {
				return (*int8)(unsafe.Pointer(&[7]int8{'i', 'n', 's', 'e', 'r', 't', '\x00'}))
			}
		}())
		return
	}
	if jsonParse(&x, ctx, (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))) != 0 {
		return
	}
	func() int {
		_ = 0
		return 0
	}()
	for i = uint32(1); i < uint32(argc); i += uint32(2) {
		zPath = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(i)*8)))))
		bApnd = int32(0)
		pNode = jsonLookup(&x, zPath, &bApnd, ctx)
		if x.oom != 0 {
			sqlite3_result_error_nomem(ctx)
			goto jsonSetDone
		} else if x.nErr != 0 {
			goto jsonSetDone
		} else if pNode != nil && (bApnd != 0 || bIsSet != 0) {
			func() int {
				_ = 0
				return 0
			}()
			pNode.jnFlags |= uint8(int32(uint8(8)))
			*(*uint32)(unsafe.Pointer(&pNode.u)) = i + uint32(1)
		}
	}
	if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(x.aNode)) + uintptr(0)*16))).jnFlags)&8 != 0 {
		func() int {
			_ = 0
			return 0
		}()
		sqlite3_result_value(ctx, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(*(*uint32)(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(x.aNode)) + uintptr(0)*16))).u)))*8)))
	} else {
		jsonReturnJson(x.aNode, ctx, argv)
	}
jsonSetDone:
	jsonParseReset(&x)
}
func jsonTypeFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_JsonParse
	var zPath *int8
	var pNode *struct_JsonNode
	p = jsonParseCached(ctx, argv, ctx)
	if uintptr(unsafe.Pointer(p)) == uintptr(unsafe.Pointer(nil)) {
		return
	}
	if argc == 2 {
		zPath = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
		pNode = jsonLookup(p, zPath, nil, ctx)
	} else {
		pNode = p.aNode
	}
	if pNode != nil {
		sqlite3_result_text(ctx, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&jsonType)))) + uintptr(pNode.eType)*8)), -1, (func(unsafe.Pointer))(0))
	}
}
func jsonValidFunc(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var p *struct_JsonParse
	func() int {
		_ = argc
		return 0
	}()
	p = jsonParseCached(ctx, argv, nil)
	sqlite3_result_int(ctx, func() int32 {
		if uintptr(unsafe.Pointer(p)) != uintptr(unsafe.Pointer(nil)) {
			return 1
		} else {
			return 0
		}
	}())
}
func jsonArrayStep(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var pStr *struct_JsonString
	func() int {
		_ = argc
		return 0
	}()
	pStr = (*struct_JsonString)(sqlite3_aggregate_context(ctx, int32(134)))
	if pStr != nil {
		if uintptr(unsafe.Pointer(pStr.zBuf)) == uintptr(unsafe.Pointer(nil)) {
			jsonInit(pStr, ctx)
			jsonAppendChar(pStr, int8('['))
		} else if pStr.nUsed > uint64(1) {
			jsonAppendChar(pStr, int8(','))
		}
		pStr.pCtx = ctx
		jsonAppendValue(pStr, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))
	}
}
func jsonArrayCompute(ctx *struct_sqlite3_context, isFinal int32) {
	var pStr *struct_JsonString
	pStr = (*struct_JsonString)(sqlite3_aggregate_context(ctx, 0))
	if pStr != nil {
		pStr.pCtx = ctx
		jsonAppendChar(pStr, int8(']'))
		if pStr.bErr != 0 {
			if int32(pStr.bErr) == 1 {
				sqlite3_result_error_nomem(ctx)
			}
			func() int {
				_ = 0
				return 0
			}()
		} else if isFinal != 0 {
			sqlite3_result_text(ctx, pStr.zBuf, int32(pStr.nUsed), func() func(unsafe.Pointer) {
				if int32(pStr.bStatic) != 0 {
					return (func(unsafe.Pointer))(-1)
				} else {
					return sqlite3_free
				}
			}())
			pStr.bStatic = uint8(1)
		} else {
			sqlite3_result_text(ctx, pStr.zBuf, int32(pStr.nUsed), (func(unsafe.Pointer))(-1))
			pStr.nUsed--
		}
	} else {
		sqlite3_result_text(ctx, (*int8)(unsafe.Pointer(&[3]int8{'[', ']', '\x00'})), 2, (func(unsafe.Pointer))(0))
	}
	sqlite3_result_subtype(ctx, uint32(74))
}
func jsonArrayValue(ctx *struct_sqlite3_context) {
	jsonArrayCompute(ctx, 0)
}
func jsonArrayFinal(ctx *struct_sqlite3_context) {
	jsonArrayCompute(ctx, 1)
}
func jsonGroupInverse(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var i uint32
	var inStr int32 = 0
	var nNest int32 = 0
	var z *int8
	var c int8
	var pStr *struct_JsonString
	func() int {
		_ = argc
		return 0
	}()
	func() int {
		_ = argv
		return 0
	}()
	pStr = (*struct_JsonString)(sqlite3_aggregate_context(ctx, 0))
	if !(pStr != nil) {
		return
	}
	z = pStr.zBuf
	for i = uint32(1); uint64(i) < pStr.nUsed && (int32(func() (_cgo_ret int8) {
		_cgo_addr := &c
		*_cgo_addr = *(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i)))
		return *_cgo_addr
	}()) != ',' || inStr != 0 || nNest != 0); i++ {
		if int32(c) == '"' {
			inStr = func() int32 {
				if !(inStr != 0) {
					return 1
				} else {
					return 0
				}
			}()
		} else if int32(c) == '\\' {
			i++
		} else if !(inStr != 0) {
			if int32(c) == '{' || int32(c) == '[' {
				nNest++
			}
			if int32(c) == '}' || int32(c) == ']' {
				nNest--
			}
		}
	}
	if uint64(i) < pStr.nUsed {
		pStr.nUsed -= uint64(i)
		__builtin___memmove_chk(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))), unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(i+uint32(1))))), uint(pStr.nUsed)-uint(1), __builtin_object_size(unsafe.Pointer(&*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(1)))), 0))
		*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(z)) + uintptr(pStr.nUsed))) = int8(0)
	} else {
		pStr.nUsed = uint64(1)
	}
}
func jsonObjectStep(ctx *struct_sqlite3_context, argc int32, argv **struct_sqlite3_value) {
	var pStr *struct_JsonString
	var z *int8
	var n uint32
	func() int {
		_ = argc
		return 0
	}()
	pStr = (*struct_JsonString)(sqlite3_aggregate_context(ctx, int32(134)))
	if pStr != nil {
		if uintptr(unsafe.Pointer(pStr.zBuf)) == uintptr(unsafe.Pointer(nil)) {
			jsonInit(pStr, ctx)
			jsonAppendChar(pStr, int8('{'))
		} else if pStr.nUsed > uint64(1) {
			jsonAppendChar(pStr, int8(','))
		}
		pStr.pCtx = ctx
		z = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
		n = uint32(sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
		jsonAppendString(pStr, z, n)
		jsonAppendChar(pStr, int8(':'))
		jsonAppendValue(pStr, *(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))
	}
}
func jsonObjectCompute(ctx *struct_sqlite3_context, isFinal int32) {
	var pStr *struct_JsonString
	pStr = (*struct_JsonString)(sqlite3_aggregate_context(ctx, 0))
	if pStr != nil {
		jsonAppendChar(pStr, int8('}'))
		if pStr.bErr != 0 {
			if int32(pStr.bErr) == 1 {
				sqlite3_result_error_nomem(ctx)
			}
			func() int {
				_ = 0
				return 0
			}()
		} else if isFinal != 0 {
			sqlite3_result_text(ctx, pStr.zBuf, int32(pStr.nUsed), func() func(unsafe.Pointer) {
				if int32(pStr.bStatic) != 0 {
					return (func(unsafe.Pointer))(-1)
				} else {
					return sqlite3_free
				}
			}())
			pStr.bStatic = uint8(1)
		} else {
			sqlite3_result_text(ctx, pStr.zBuf, int32(pStr.nUsed), (func(unsafe.Pointer))(-1))
			pStr.nUsed--
		}
	} else {
		sqlite3_result_text(ctx, (*int8)(unsafe.Pointer(&[3]int8{'{', '}', '\x00'})), 2, (func(unsafe.Pointer))(0))
	}
	sqlite3_result_subtype(ctx, uint32(74))
}
func jsonObjectValue(ctx *struct_sqlite3_context) {
	jsonObjectCompute(ctx, 0)
}
func jsonObjectFinal(ctx *struct_sqlite3_context) {
	jsonObjectCompute(ctx, 1)
}

type JsonEachCursor = struct_JsonEachCursor
type struct_JsonEachCursor struct {
	base       struct_sqlite3_vtab_cursor
	iRowid     uint32
	iBegin     uint32
	i          uint32
	iEnd       uint32
	eType      uint8
	bRecursive uint8
	zJson      *int8
	zRoot      *int8
	sParse     struct_JsonParse
}

func jsonEachConnect(db *struct_sqlite3, pAux unsafe.Pointer, argc int32, argv **int8, ppVtab **struct_sqlite3_vtab, pzErr **int8) int32 {
	var pNew *struct_sqlite3_vtab
	var rc int32
	func() int {
		_ = pzErr
		return 0
	}()
	func() int {
		_ = argv
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	func() int {
		_ = pAux
		return 0
	}()
	rc = sqlite3_declare_vtab(db, (*int8)(unsafe.Pointer(&[83]int8{'C', 'R', 'E', 'A', 'T', 'E', ' ', 'T', 'A', 'B', 'L', 'E', ' ', 'x', '(', 'k', 'e', 'y', ',', 'v', 'a', 'l', 'u', 'e', ',', 't', 'y', 'p', 'e', ',', 'a', 't', 'o', 'm', ',', 'i', 'd', ',', 'p', 'a', 'r', 'e', 'n', 't', ',', 'f', 'u', 'l', 'l', 'k', 'e', 'y', ',', 'p', 'a', 't', 'h', ',', 'j', 's', 'o', 'n', ' ', 'H', 'I', 'D', 'D', 'E', 'N', ',', 'r', 'o', 'o', 't', ' ', 'H', 'I', 'D', 'D', 'E', 'N', ')', '\x00'})))
	if rc == 0 {
		pNew = func() (_cgo_ret *struct_sqlite3_vtab) {
			_cgo_addr := &*ppVtab
			*_cgo_addr = (*struct_sqlite3_vtab)(sqlite3_malloc(int32(24)))
			return *_cgo_addr
		}()
		if uintptr(unsafe.Pointer(pNew)) == uintptr(unsafe.Pointer(nil)) {
			return int32(7)
		}
		__builtin___memset_chk(unsafe.Pointer(pNew), 0, 24, __builtin_object_size(unsafe.Pointer(pNew), 0))
		sqlite3_vtab_config(db, 2)
	}
	return rc
}
func jsonEachDisconnect(pVtab *struct_sqlite3_vtab) int32 {
	sqlite3_free(unsafe.Pointer(pVtab))
	return int32(0)
}
func jsonEachOpenEach(p *struct_sqlite3_vtab, ppCursor **struct_sqlite3_vtab_cursor) int32 {
	var pCur *struct_JsonEachCursor
	func() int {
		_ = p
		return 0
	}()
	pCur = (*struct_JsonEachCursor)(sqlite3_malloc(int32(92)))
	if uintptr(unsafe.Pointer(pCur)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memset_chk(unsafe.Pointer(pCur), 0, 92, __builtin_object_size(unsafe.Pointer(pCur), 0))
	*ppCursor = &pCur.base
	return int32(0)
}
func jsonEachOpenTree(p *struct_sqlite3_vtab, ppCursor **struct_sqlite3_vtab_cursor) int32 {
	var rc int32 = jsonEachOpenEach(p, ppCursor)
	if rc == 0 {
		var pCur *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(*ppCursor))
		pCur.bRecursive = uint8(1)
	}
	return rc
}
func jsonEachCursorReset(p *struct_JsonEachCursor) {
	sqlite3_free(unsafe.Pointer(p.zJson))
	sqlite3_free(unsafe.Pointer(p.zRoot))
	jsonParseReset(&p.sParse)
	p.iRowid = uint32(0)
	p.i = uint32(0)
	p.iEnd = uint32(0)
	p.eType = uint8(0)
	p.zJson = (*int8)(nil)
	p.zRoot = (*int8)(nil)
}
func jsonEachClose(cur *struct_sqlite3_vtab_cursor) int32 {
	var p *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(cur))
	jsonEachCursorReset(p)
	sqlite3_free(unsafe.Pointer(cur))
	return int32(0)
}
func jsonEachEof(cur *struct_sqlite3_vtab_cursor) int32 {
	var p *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(cur))
	return func() int32 {
		if p.i >= p.iEnd {
			return 1
		} else {
			return 0
		}
	}()
}
func jsonEachNext(cur *struct_sqlite3_vtab_cursor) int32 {
	var p *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(cur))
	if p.bRecursive != 0 {
		if int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(p.i)*16))).jnFlags)&64 != 0 {
			p.i++
		}
		p.i++
		p.iRowid++
		if p.i < p.iEnd {
			var iUp uint32 = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aUp)) + uintptr(p.i)*4))
			var pUp *struct_JsonNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(iUp)*16))
			p.eType = pUp.eType
			if int32(pUp.eType) == 6 {
				func() int {
					_ = 0
					return 0
				}()
				if iUp == p.i-uint32(1) {
					*(*uint32)(unsafe.Pointer(&pUp.u)) = uint32(0)
				} else {
					*(*uint32)(unsafe.Pointer(&pUp.u))++
				}
			}
		}
	} else {
		switch int32(p.eType) {
		case 6:
			{
				p.i += jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(p.i)*16)))
				p.iRowid++
				break
			}
		case 7:
			{
				p.i += uint32(1) + jsonNodeSize(&*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(p.i+uint32(1))*16)))
				p.iRowid++
				break
			}
		default:
			{
				p.i = p.iEnd
				break
			}
		}
	}
	return int32(0)
}
func jsonEachComputePath(p *struct_JsonEachCursor, pStr *struct_JsonString, i uint32) {
	var pNode *struct_JsonNode
	var pUp *struct_JsonNode
	var iUp uint32
	if i == uint32(0) {
		jsonAppendChar(pStr, int8('$'))
		return
	}
	iUp = *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aUp)) + uintptr(i)*4))
	jsonEachComputePath(p, pStr, iUp)
	pNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(i)*16))
	pUp = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(iUp)*16))
	if int32(pUp.eType) == 6 {
		func() int {
			_ = 0
			return 0
		}()
		jsonPrintf(30, pStr, (*int8)(unsafe.Pointer(&[5]int8{'[', '%', 'd', ']', '\x00'})), *(*uint32)(unsafe.Pointer(&pUp.u)))
	} else {
		func() int {
			_ = 0
			return 0
		}()
		if int32(pNode.jnFlags)&64 == 0 {
			*(*uintptr)(unsafe.Pointer(&pNode)) -= 16
		}
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		func() int {
			_ = 0
			return 0
		}()
		jsonPrintf(int32(pNode.n+uint32(1)), pStr, (*int8)(unsafe.Pointer(&[6]int8{'.', '%', '.', '*', 's', '\x00'})), pNode.n-uint32(2), (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pNode.u.zJContent))+uintptr(1))))
	}
}
func jsonEachColumn(cur *struct_sqlite3_vtab_cursor, ctx *struct_sqlite3_context, i int32) int32 {
	var p *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(cur))
	var pThis *struct_JsonNode = &*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(p.i)*16))
	switch i {
	case 0:
		{
			if p.i == uint32(0) {
				break
			}
			if int32(p.eType) == 7 {
				jsonReturn(pThis, ctx, nil)
			} else if int32(p.eType) == 6 {
				var iKey uint32
				if p.bRecursive != 0 {
					if p.iRowid == uint32(0) {
						break
					}
					func() int {
						_ = 0
						return 0
					}()
					iKey = *(*uint32)(unsafe.Pointer(&(*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aUp)) + uintptr(p.i)*4)))*16))).u))
				} else {
					iKey = p.iRowid
				}
				sqlite3_result_int64(ctx, int64(iKey))
			}
			break
		}
	case 1:
		{
			if int32(pThis.jnFlags)&64 != 0 {
				*(*uintptr)(unsafe.Pointer(&pThis)) += 16
			}
			jsonReturn(pThis, ctx, nil)
			break
		}
	case 2:
		{
			if int32(pThis.jnFlags)&64 != 0 {
				*(*uintptr)(unsafe.Pointer(&pThis)) += 16
			}
			sqlite3_result_text(ctx, *(**int8)(unsafe.Pointer(uintptr(unsafe.Pointer((**int8)(unsafe.Pointer(&jsonType)))) + uintptr(pThis.eType)*8)), -1, (func(unsafe.Pointer))(0))
			break
		}
	case 3:
		{
			if int32(pThis.jnFlags)&64 != 0 {
				*(*uintptr)(unsafe.Pointer(&pThis)) += 16
			}
			if int32(pThis.eType) >= 6 {
				break
			}
			jsonReturn(pThis, ctx, nil)
			break
		}
	case 4:
		{
			sqlite3_result_int64(ctx, int64(p.i)+func() int64 {
				if int32(pThis.jnFlags)&64 != 0 {
					return 1
				} else {
					return 0
				}
			}())
			break
		}
	case 5:
		{
			if p.i > p.iBegin && int32(p.bRecursive) != 0 {
				sqlite3_result_int64(ctx, int64(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aUp)) + uintptr(p.i)*4))))
			}
			break
		}
	case 6:
		{
			var x struct_JsonString
			jsonInit(&x, ctx)
			if p.bRecursive != 0 {
				jsonEachComputePath(p, &x, p.i)
			} else {
				if p.zRoot != nil {
					jsonAppendRaw(&x, p.zRoot, uint32(int32(strlen(p.zRoot))))
				} else {
					jsonAppendChar(&x, int8('$'))
				}
				if int32(p.eType) == 6 {
					jsonPrintf(30, &x, (*int8)(unsafe.Pointer(&[5]int8{'[', '%', 'd', ']', '\x00'})), p.iRowid)
				} else if int32(p.eType) == 7 {
					func() int {
						_ = 0
						return 0
					}()
					jsonPrintf(int32(pThis.n), &x, (*int8)(unsafe.Pointer(&[6]int8{'.', '%', '.', '*', 's', '\x00'})), pThis.n-uint32(2), (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(pThis.u.zJContent))+uintptr(1))))
				}
			}
			jsonResult(&x)
			break
		}
	case 7:
		{
			if p.bRecursive != 0 {
				var x struct_JsonString
				jsonInit(&x, ctx)
				jsonEachComputePath(p, &x, *(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aUp)) + uintptr(p.i)*4)))
				jsonResult(&x)
				break
			}
		}
	default:
		{
			var zRoot *int8 = p.zRoot
			if uintptr(unsafe.Pointer(zRoot)) == uintptr(unsafe.Pointer(nil)) {
				zRoot = (*int8)(unsafe.Pointer(&[2]int8{'$', '\x00'}))
			}
			sqlite3_result_text(ctx, zRoot, -1, (func(unsafe.Pointer))(0))
			break
		}
	case 8:
		{
			func() int {
				_ = 0
				return 0
			}()
			sqlite3_result_text(ctx, p.sParse.zJson, -1, (func(unsafe.Pointer))(0))
			break
		}
	}
	return int32(0)
}
func jsonEachRowid(cur *struct_sqlite3_vtab_cursor, pRowid *int64) int32 {
	var p *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(cur))
	*pRowid = int64(p.iRowid)
	return int32(0)
}
func jsonEachBestIndex(tab *struct_sqlite3_vtab, pIdxInfo *struct_sqlite3_index_info) int32 {
	var i int32
	var aIdx [2]int32
	var unusableMask int32 = 0
	var idxMask int32 = 0
	var pConstraint *struct_sqlite3_index_constraint
	func() int {
		_ = 0
		return 0
	}()
	func() int {
		_ = tab
		return 0
	}()
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(0)*4)) = func() (_cgo_ret int32) {
		_cgo_addr := &*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(1)*4))
		*_cgo_addr = int32(-1)
		return *_cgo_addr
	}()
	pConstraint = pIdxInfo.aConstraint
	for i = int32(0); i < pIdxInfo.nConstraint; func() *struct_sqlite3_index_constraint {
		i++
		return func() (_cgo_ret *struct_sqlite3_index_constraint) {
			_cgo_addr := &pConstraint
			_cgo_ret = *_cgo_addr
			*(*uintptr)(unsafe.Pointer(_cgo_addr)) += 12
			return
		}()
	}() {
		var iCol int32
		var iMask int32
		if pConstraint.iColumn < 8 {
			continue
		}
		iCol = pConstraint.iColumn - 8
		func() int {
			_ = 0
			return 0
		}()
		iMask = int32(1 << iCol)
		if int32(pConstraint.usable) == 0 {
			unusableMask |= iMask
		} else if int32(pConstraint.op) == 2 {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(iCol)*4)) = i
			idxMask |= iMask
		}
	}
	if unusableMask & ^idxMask != 0 {
		return int32(19)
	}
	if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(0)*4)) < 0 {
		pIdxInfo.idxNum = int32(0)
	} else {
		pIdxInfo.estimatedCost = float64(1)
		i = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(0)*4))
		(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(i)*5))).argvIndex = int32(1)
		(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(i)*5))).omit = uint8(1)
		if *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(1)*4)) < 0 {
			pIdxInfo.idxNum = int32(1)
		} else {
			i = *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer((*int32)(unsafe.Pointer(&aIdx)))) + uintptr(1)*4))
			(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(i)*5))).argvIndex = int32(2)
			(*(*struct_sqlite3_index_constraint_usage)(unsafe.Pointer(uintptr(unsafe.Pointer(pIdxInfo.aConstraintUsage)) + uintptr(i)*5))).omit = uint8(1)
			pIdxInfo.idxNum = int32(3)
		}
	}
	return int32(0)
}
func jsonEachFilter(cur *struct_sqlite3_vtab_cursor, idxNum int32, idxStr *int8, argc int32, argv **struct_sqlite3_value) int32 {
	var p *struct_JsonEachCursor = (*struct_JsonEachCursor)(unsafe.Pointer(cur))
	var z *int8
	var zRoot *int8 = nil
	var n int64
	func() int {
		_ = idxStr
		return 0
	}()
	func() int {
		_ = argc
		return 0
	}()
	jsonEachCursorReset(p)
	if idxNum == 0 {
		return int32(0)
	}
	z = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8)))))
	if uintptr(unsafe.Pointer(z)) == uintptr(unsafe.Pointer(nil)) {
		return int32(0)
	}
	n = int64(sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(0)*8))))
	p.zJson = (*int8)(sqlite3_malloc64(uint64(n + int64(1))))
	if uintptr(unsafe.Pointer(p.zJson)) == uintptr(unsafe.Pointer(nil)) {
		return int32(7)
	}
	__builtin___memcpy_chk(unsafe.Pointer(p.zJson), unsafe.Pointer(z), uint(n)+uint(1), __builtin_object_size(unsafe.Pointer(p.zJson), 0))
	if jsonParse(&p.sParse, nil, p.zJson) != 0 {
		var rc int32 = 7
		if int32(p.sParse.oom) == 0 {
			sqlite3_free(unsafe.Pointer(cur.pVtab.zErrMsg))
			cur.pVtab.zErrMsg = sqlite3_mprintf((*int8)(unsafe.Pointer(&[15]int8{'m', 'a', 'l', 'f', 'o', 'r', 'm', 'e', 'd', ' ', 'J', 'S', 'O', 'N', '\x00'})))
			if cur.pVtab.zErrMsg != nil {
				rc = int32(1)
			}
		}
		jsonEachCursorReset(p)
		return rc
	} else if int32(p.bRecursive) != 0 && jsonParseFindParents(&p.sParse) != 0 {
		jsonEachCursorReset(p)
		return int32(7)
	} else {
		var pNode *struct_JsonNode = nil
		if idxNum == 3 {
			var zErr *int8 = nil
			zRoot = (*int8)(unsafe.Pointer(sqlite3_value_text(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8)))))
			if uintptr(unsafe.Pointer(zRoot)) == uintptr(unsafe.Pointer(nil)) {
				return int32(0)
			}
			n = int64(sqlite3_value_bytes(*(**struct_sqlite3_value)(unsafe.Pointer(uintptr(unsafe.Pointer(argv)) + uintptr(1)*8))))
			p.zRoot = (*int8)(sqlite3_malloc64(uint64(n + int64(1))))
			if uintptr(unsafe.Pointer(p.zRoot)) == uintptr(unsafe.Pointer(nil)) {
				return int32(7)
			}
			__builtin___memcpy_chk(unsafe.Pointer(p.zRoot), unsafe.Pointer(zRoot), uint(n)+uint(1), __builtin_object_size(unsafe.Pointer(p.zRoot), 0))
			if int32(*(*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(zRoot)) + uintptr(0)))) != '$' {
				zErr = zRoot
			} else {
				pNode = jsonLookupStep(&p.sParse, uint32(0), (*int8)(unsafe.Pointer(uintptr(unsafe.Pointer(p.zRoot))+uintptr(1))), nil, &zErr)
			}
			if zErr != nil {
				sqlite3_free(unsafe.Pointer(cur.pVtab.zErrMsg))
				cur.pVtab.zErrMsg = jsonPathSyntaxError(zErr)
				jsonEachCursorReset(p)
				return func() int32 {
					if cur.pVtab.zErrMsg != nil {
						return 1
					} else {
						return 7
					}
				}()
			} else if uintptr(unsafe.Pointer(pNode)) == uintptr(unsafe.Pointer(nil)) {
				return int32(0)
			}
		} else {
			pNode = p.sParse.aNode
		}
		p.iBegin = func() (_cgo_ret uint32) {
			_cgo_addr := &p.i
			*_cgo_addr = uint32(int32((uintptr(unsafe.Pointer(pNode)) - uintptr(unsafe.Pointer(p.sParse.aNode))) * 16))
			return *_cgo_addr
		}()
		p.eType = pNode.eType
		if int32(p.eType) >= 6 {
			func() int {
				_ = 0
				return 0
			}()
			*(*uint32)(unsafe.Pointer(&pNode.u)) = uint32(0)
			p.iEnd = p.i + pNode.n + uint32(1)
			if p.bRecursive != 0 {
				p.eType = (*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(*(*uint32)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aUp)) + uintptr(p.i)*4)))*16))).eType
				if p.i > uint32(0) && int32((*(*struct_JsonNode)(unsafe.Pointer(uintptr(unsafe.Pointer(p.sParse.aNode)) + uintptr(p.i-uint32(1))*16))).jnFlags)&64 != 0 {
					p.i--
				}
			} else {
				p.i++
			}
		} else {
			p.iEnd = p.i + uint32(1)
		}
	}
	return int32(0)
}

var jsonEachModule struct_sqlite3_module = struct_sqlite3_module{0, nil, jsonEachConnect, jsonEachBestIndex, jsonEachDisconnect, nil, jsonEachOpenEach, jsonEachClose, jsonEachFilter, jsonEachNext, jsonEachEof, jsonEachColumn, jsonEachRowid, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil}
var jsonTreeModule struct_sqlite3_module = struct_sqlite3_module{0, nil, jsonEachConnect, jsonEachBestIndex, jsonEachDisconnect, nil, jsonEachOpenTree, jsonEachClose, jsonEachFilter, jsonEachNext, jsonEachEof, jsonEachColumn, jsonEachRowid, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil}

func sqlite3RegisterJsonFunctions() {
	var aJsonFunc [19]struct_FuncDef = [19]struct_FuncDef{struct_FuncDef{int8(1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonRemoveFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[5]int8{'j', 's', 'o', 'n', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonArrayFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'j', 's', 'o', 'n', '_', 'a', 'r', 'r', 'a', 'y', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonArrayLengthFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[18]int8{'j', 's', 'o', 'n', '_', 'a', 'r', 'r', 'a', 'y', '_', 'l', 'e', 'n', 'g', 't', 'h', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonArrayLengthFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[18]int8{'j', 's', 'o', 'n', '_', 'a', 'r', 'r', 'a', 'y', '_', 'l', 'e', 'n', 'g', 't', 'h', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonExtractFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[13]int8{'j', 's', 'o', 'n', '_', 'e', 'x', 't', 'r', 'a', 'c', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(1)), nil, jsonExtractFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[3]int8{'-', '>', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(2)), nil, jsonExtractFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[4]int8{'-', '>', '>', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonSetFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[12]int8{'j', 's', 'o', 'n', '_', 'i', 'n', 's', 'e', 'r', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonObjectFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[12]int8{'j', 's', 'o', 'n', '_', 'o', 'b', 'j', 'e', 'c', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonPatchFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'j', 's', 'o', 'n', '_', 'p', 'a', 't', 'c', 'h', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonQuoteFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'j', 's', 'o', 'n', '_', 'q', 'u', 'o', 't', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonRemoveFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[12]int8{'j', 's', 'o', 'n', '_', 'r', 'e', 'm', 'o', 'v', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonReplaceFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[13]int8{'j', 's', 'o', 'n', '_', 'r', 'e', 'p', 'l', 'a', 'c', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(-1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(4)), nil, jsonSetFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[9]int8{'j', 's', 'o', 'n', '_', 's', 'e', 't', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonTypeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'j', 's', 'o', 'n', '_', 't', 'y', 'p', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonTypeFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[10]int8{'j', 's', 'o', 'n', '_', 't', 'y', 'p', 'e', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 2048 | 2097152 | 2048 | 1), unsafe.Pointer(int(0)), nil, jsonValidFunc, nil, nil, nil, (*int8)(unsafe.Pointer(&[11]int8{'j', 's', 'o', 'n', '_', 'v', 'a', 'l', 'i', 'd', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(1), uint32(8388608 | 1 | 0*32 | 1048576 | 1 | 2048 | 2097152), unsafe.Pointer(int(0)), nil, jsonArrayStep, jsonArrayFinal, jsonArrayValue, jsonGroupInverse, (*int8)(unsafe.Pointer(&[17]int8{'j', 's', 'o', 'n', '_', 'g', 'r', 'o', 'u', 'p', '_', 'a', 'r', 'r', 'a', 'y', '\x00'})), _cgoa_9{nil}}, struct_FuncDef{int8(2), uint32(8388608 | 1 | 0*32 | 1048576 | 1 | 2048 | 2097152), unsafe.Pointer(int(0)), nil, jsonObjectStep, jsonObjectFinal, jsonObjectValue, jsonGroupInverse, (*int8)(unsafe.Pointer(&[18]int8{'j', 's', 'o', 'n', '_', 'g', 'r', 'o', 'u', 'p', '_', 'o', 'b', 'j', 'e', 'c', 't', '\x00'})), _cgoa_9{nil}}}
	sqlite3InsertBuiltinFuncs((*struct_FuncDef)(unsafe.Pointer(&aJsonFunc)), int32(1368/72))
}
func sqlite3JsonTableFunctions(db *struct_sqlite3) int32 {
	var rc int32 = 0
	type _cgoa_92 struct {
		zName   *int8
		pModule *struct_sqlite3_module
	}
	var aMod [2]_cgoa_92 = [2]_cgoa_92{_cgoa_92{(*int8)(unsafe.Pointer(&[10]int8{'j', 's', 'o', 'n', '_', 'e', 'a', 'c', 'h', '\x00'})), &jsonEachModule}, _cgoa_92{(*int8)(unsafe.Pointer(&[10]int8{'j', 's', 'o', 'n', '_', 't', 'r', 'e', 'e', '\x00'})), &jsonTreeModule}}
	var i uint32
	for i = uint32(0); uint(i) < 32/16 && rc == 0; i++ {
		rc = sqlite3_create_module(db, (*(*_cgoa_92)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_92)(unsafe.Pointer(&aMod)))) + uintptr(i)*16))).zName, (*(*_cgoa_92)(unsafe.Pointer(uintptr(unsafe.Pointer((*_cgoa_92)(unsafe.Pointer(&aMod)))) + uintptr(i)*16))).pModule, nil)
	}
	return rc
}
func sqlite3_sourceid() *int8 {
	return (*int8)(unsafe.Pointer(&[85]int8{'2', '0', '2', '2', '-', '0', '3', '-', '2', '6', ' ', '1', '3', ':', '5', '1', ':', '1', '0', ' ', 'd', '3', '3', 'c', '7', '0', '9', 'c', 'c', '0', 'a', 'f', '6', '6', 'b', 'c', '5', 'b', '6', 'd', 'c', '6', '2', '1', '6', 'e', 'b', 'a', '9', 'f', '1', 'f', '0', 'b', '4', '0', '9', '6', '0', 'b', '9', 'a', 'e', '8', '3', '6', '9', '4', 'c', '9', '8', '6', 'f', 'b', 'f', '4', 'c', '1', 'd', '6', 'f', '0', '8', 'f', '\x00'}))
}
